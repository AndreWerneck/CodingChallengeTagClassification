,model_input,new_tags
151,"You are given a tree (a connected undirected graph without cycles) of $$$n$$$ vertices. Each of the $$$n - 1$$$ edges of the tree is colored in either black or red.You are also given an integer $$$k$$$. Consider sequences of $$$k$$$ vertices. Let's call a sequence $$$[a_1, a_2, \ldots, a_k]$$$ good if it satisfies the following criterion:  We will walk a path (possibly visiting same edge/vertex multiple times) on the tree, starting from $$$a_1$$$ and ending at $$$a_k$$$.  Start at $$$a_1$$$, then go to $$$a_2$$$ using the shortest path between $$$a_1$$$ and $$$a_2$$$, then go to $$$a_3$$$ in a similar way, and so on, until you travel the shortest path between $$$a_{k-1}$$$ and $$$a_k$$$. If you walked over at least one black edge during this process, then the sequence is good.   Consider the tree on the picture. If $$$k=3$$$ then the following sequences are good: $$$[1, 4, 7]$$$, $$$[5, 5, 3]$$$ and $$$[2, 3, 7]$$$. The following sequences are not good: $$$[1, 4, 6]$$$, $$$[5, 5, 5]$$$, $$$[3, 7, 3]$$$.There are $$$n^k$$$ sequences of vertices, count how many of them are good. Since this number can be quite large, print it modulo $$$10^9+7$$$. NoteIn the first example, all sequences ($$$4^4$$$) of length $$$4$$$ except the following are good:   $$$[1, 1, 1, 1]$$$ $$$[2, 2, 2, 2]$$$ $$$[3, 3, 3, 3]$$$ $$$[4, 4, 4, 4]$$$ In the second example, all edges are red, hence there aren't any good sequences. """"""
if num edges red <= k - 1:
    return (n choose k)

# num edges red >= k
""""""

def n_perm_k(n, k):
    return n ** k

def ways(xs, k):
    total = n_perm_k(sum(xs), k)

    for x in xs:
        total -= n_perm_k(x, k)
    
    return total

def dfs(i, graph, visited):
    stack = [i]
    count = 0
    while stack:
        current = stack.pop()
        count += 1
        visited.add(current)
        for neighbor, black in graph[current].items():
            if not black and neighbor not in visited:
                stack.append(neighbor)
    return count                

def get_forest_sizes(n, graph):
    visited = set()
    components = []
    for i in range(1, n + 1):
        if i not in visited:
            ans = dfs(i, graph, visited)
            components.append(ans)
    return components

def solve(n, k, graph, black_count):
    if black_count == 0:
        # no black
        return 0
    else:
        return ways(get_forest_sizes(n, graph), k)

n, k = map(int, input().split())
graph = { x: {} for x in range(1, n + 1) }
black_count = 0
for _ in range(1, n):
    a, b, black = map(int, input().split())
    black_count += black
    graph[a][b] = (black == 1)
    graph[b][a] = (black == 1)

print(solve(n, k, graph, black_count) % (10 ** 9 + 7))
","['dfs and similar', 'dsu', 'graphs', 'math', 'trees']"
807,"A bitstring is a string that contains only the characters 0 and 1.Koyomi Kanou is working hard towards her dream of becoming a writer. To practice, she decided to participate in the Binary Novel Writing Contest. The writing prompt for the contest consists of three bitstrings of length $$$2n$$$. A valid novel for the contest is a bitstring of length at most $$$3n$$$ that contains at least two of the three given strings as subsequences.Koyomi has just received the three prompt strings from the contest organizers. Help her write a valid novel for the contest.A string $$$a$$$ is a subsequence of a string $$$b$$$ if $$$a$$$ can be obtained from $$$b$$$ by deletion of several (possibly, zero) characters. NoteIn the first test case, the bitstrings 00 and 01 are subsequences of the output string: 010 and 010. Note that 11 is not a subsequence of the output string, but this is not required.In the second test case all three input strings are subsequences of the output string: 011001010, 011001010 and 011001010. import sys
input = lambda : sys.stdin.readline().rstrip()

write = lambda x: sys.stdout.write(x+""\n""); writef = lambda x: print(""{:.12f}"".format(x))
debug = lambda x: sys.stderr.write(x+""\n"")
YES=""Yes""; NO=""No""; pans = lambda v: print(YES if v else NO)
LI = lambda : list(map(int, input().split()))
# sys.setrecursionlimit(3*10**5+10)

t = int(input())
for _ in range(t):
    n = int(input())
    s = [list(map(int, input())) for _ in range(3)]
    index = [0,0,0]
    l = []
    for i in range(3*n):
        if max(index)==2*n:
            inds = list(range(3))
            inds.sort(key=lambda i: index[i])
            j = inds[1]
            for k in range(index[j], 2*n):
                l.append(s[j][k])
            break
        if s[0][index[0]] + s[1][index[1]] + s[2][index[2]] >= 2:
            v = 1
        else:
            v = 0
        l.append(v)
        for j in range(3):
            if s[j][index[j]]==v:
                index[j] += 1
    assert len(l)<=3*n
    write("""".join(map(str, l)))
#     break","['constructive algorithms', 'greedy', 'implementation', 'strings', 'two pointers']"
621,"For an array $$$b$$$ of $$$n$$$ integers, the extreme value of this array is the minimum number of times (possibly, zero) the following operation has to be performed to make $$$b$$$ non-decreasing:   Select an index $$$i$$$ such that $$$1 \le i \le |b|$$$, where $$$|b|$$$ is the current length of $$$b$$$.  Replace $$$b_i$$$ with two elements $$$x$$$ and $$$y$$$ such that $$$x$$$ and $$$y$$$ both are positive integers and $$$x + y = b_i$$$.  This way, the array $$$b$$$ changes and the next operation is performed on this modified array. For example, if $$$b = [2, 4, 3]$$$ and index $$$2$$$ gets selected, then the possible arrays after this operation are $$$[2, \underline{1}, \underline{3}, 3]$$$, $$$[2, \underline{2}, \underline{2}, 3]$$$, or $$$[2, \underline{3}, \underline{1}, 3]$$$. And consequently, for this array, this single operation is enough to make it non-decreasing: $$$[2, 4, 3] \rightarrow [2, \underline{2}, \underline{2}, 3]$$$.It's easy to see that every array of positive integers can be made non-decreasing this way.YouKn0wWho has an array $$$a$$$ of $$$n$$$ integers. Help him find the sum of extreme values of all nonempty subarrays of $$$a$$$ modulo $$$998\,244\,353$$$. If a subarray appears in $$$a$$$ multiple times, its extreme value should be counted the number of times it appears.An array $$$d$$$ is a subarray of an array $$$c$$$ if $$$d$$$ can be obtained from $$$c$$$ by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end. NoteLet $$$f(l, r)$$$ denote the extreme value of $$$[a_l, a_{l+1}, \ldots, a_r]$$$.In the first test case,   $$$f(1, 3) = 3$$$, because YouKn0wWho can perform the following operations on the subarray $$$[5, 4, 3]$$$ (the newly inserted elements are underlined):$$$[5, 4, 3] \rightarrow [\underline{3}, \underline{2}, 4, 3] \rightarrow [3, 2, \underline{2}, \underline{2}, 3] \rightarrow [\underline{1}, \underline{2}, 2, 2, 2, 3]$$$; $$$f(1, 2) = 1$$$, because $$$[5, 4] \rightarrow [\underline{2}, \underline{3}, 4]$$$; $$$f(2, 3) = 1$$$, because $$$[4, 3] \rightarrow [\underline{1}, \underline{3}, 3]$$$; $$$f(1, 1) = f(2, 2) = f(3, 3) = 0$$$, because they are already non-decreasing. So the total sum of extreme values of all subarrays of $$$a = 3 + 1 + 1 + 0 + 0 + 0 = 5$$$. import sys

input = sys.stdin.readline
MOD = 998244353



t=int(input())
for _ in range(t):
    n = int(input())
    A = list(map(int, input().split()))
    cnt = {}
    ans = 0

    for l in range(n - 1, -1, -1):
        cnt2 = {}
        a = A[l]
        for k, v in cnt.items():

            tmp = (a + k - 1) // k    # k: y  ; tmp : K or ceil(ar[i]/y) ;
            x = a // tmp
            if x in cnt2:
                cnt2[x] += v
            else:
                cnt2[x] = v
            ans += (tmp - 1) * (l + 1) * v
            ans %= MOD
        cnt = cnt2
        if a in cnt:
            cnt[a] += 1
        else:
            cnt[a] = 1

    print(ans)","['dp', 'greedy', 'number theory']"
3970,"Emuskald needs a fence around his farm, but he is too lazy to build it himself. So he purchased a fence-building robot.He wants the fence to be a regular polygon. The robot builds the fence along a single path, but it can only make fence corners at a single angle a.Will the robot be able to build the fence Emuskald wants? In other words, is there a regular polygon which angles are equal to a? NoteIn the first test case, it is impossible to build the fence, since there is no regular polygon with angle .In the second test case, the fence is a regular triangle, and in the last test case — a square. for _ in range(int(input())):
	print(['YES','NO'][bool(360%(180-int(input())))])","['geometry', 'implementation', 'math']"
3990,"During the break, we decided to relax and play dominoes. Our box with Domino was empty, so we decided to borrow the teacher's dominoes.The teacher responded instantly at our request. He put nm dominoes on the table as an n × 2m rectangle so that each of the n rows contained m dominoes arranged horizontally. Each half of each domino contained number (0 or 1).We were taken aback, and the teacher smiled and said: ""Consider some arrangement of dominoes in an n × 2m matrix. Let's count for each column of the matrix the sum of numbers in this column. Then among all such sums find the maximum one. Can you rearrange the dominoes in the matrix in such a way that the maximum sum will be minimum possible? Note that it is prohibited to change the orientation of the dominoes, they all need to stay horizontal, nevertheless dominoes are allowed to rotate by 180 degrees. As a reward I will give you all my dominoes"".We got even more taken aback. And while we are wondering what was going on, help us make an optimal matrix of dominoes. NoteConsider the answer for the first sample. There, the maximum sum among all columns equals 1 (the number of columns is 6, and not 3). Obviously, this maximum can't be less than 1, then such matrix is optimal.Note that the dominoes can be rotated by 180 degrees. a,b=map(int,input().split())
c=list()
x00=0
x01=0
x11=0
for i in range(a):
    c.append(list(input().split()))
    x11+=c[-1].count('11')
    x01+=c[-1].count('01')+c[-1].count('10')
x00=a*b-x11-x01
new=[[]for i in range(b)]
i=0
while x11>0:
    x11-=1
    new[i].append('11')
    i+=1
    i%=b
step=1
reverse=False
while x01>0:
    x01-=1
    if reverse:
        new[i].append('01')
    else:
        new[i].append('10')
    i+=step
    if i==-1 or i==b:
        step=-step
        i+=step
        reverse=1-reverse
for r in new:
    r+=['00']*(a-len(r))
for i in range(a):
    print(' '.join([new[k][i]for k in range(b)]))
","['constructive algorithms', 'greedy']"
1744,"You are given an array a consisting of n elements. The imbalance value of some subsegment of this array is the difference between the maximum and minimum element from this segment. The imbalance value of the array is the sum of imbalance values of all subsegments of this array.For example, the imbalance value of array [1, 4, 1] is 9, because there are 6 different subsegments of this array:   [1] (from index 1 to index 1), imbalance value is 0;  [1, 4] (from index 1 to index 2), imbalance value is 3;  [1, 4, 1] (from index 1 to index 3), imbalance value is 3;  [4] (from index 2 to index 2), imbalance value is 0;  [4, 1] (from index 2 to index 3), imbalance value is 3;  [1] (from index 3 to index 3), imbalance value is 0; You have to determine the imbalance value of the array a. nan #code_taken_from https://stoverflow.com/questions/30698441/optimal-way-to-find-sums-of-all-contiguous-sub-arrays-max-difference
def sumaaa(d):
    st = [(-1, float('inf'))]
    sum_ = 0
    for i, x in enumerate(d):
        while x > st[-1][1]:
            aa, ab = st.pop()
            aba, abb = st[-1]
            sum_ += ab * (i - aa) * (aa - aba)
        st.append((i, x))
    while len(st) > 1:
        aa, ab = st.pop()
        aba, abb = st[-1]
        sum_ += ab * (len(d) - aa) * (aa - aba)
    return sum_

def max_differences_sum(d):
    return sumaaa(d) + sumaaa([-x for x in d])
n=input();
a=map(int,raw_input().split())
print(max_differences_sum(a))

","['data structures', 'divide and conquer', 'dsu', 'sortings']"
555,"Little Petya likes permutations a lot. Recently his mom has presented him permutation q1, q2, ..., qn of length n.A permutation a of length n is a sequence of integers a1, a2, ..., an (1 ≤ ai ≤ n), all integers there are distinct. There is only one thing Petya likes more than permutations: playing with little Masha. As it turns out, Masha also has a permutation of length n. Petya decided to get the same permutation, whatever the cost may be. For that, he devised a game with the following rules:  Before the beginning of the game Petya writes permutation 1, 2, ..., n on the blackboard. After that Petya makes exactly k moves, which are described below.  During a move Petya tosses a coin. If the coin shows heads, he performs point 1, if the coin shows tails, he performs point 2.  Let's assume that the board contains permutation p1, p2, ..., pn at the given moment. Then Petya removes the written permutation p from the board and writes another one instead: pq1, pq2, ..., pqn. In other words, Petya applies permutation q (which he has got from his mother) to permutation p.  All actions are similar to point 1, except that Petya writes permutation t on the board, such that: tqi = pi for all i from 1 to n. In other words, Petya applies a permutation that is inverse to q to permutation p. We know that after the k-th move the board contained Masha's permutation s1, s2, ..., sn. Besides, we know that throughout the game process Masha's permutation never occurred on the board before the k-th move. Note that the game has exactly k moves, that is, throughout the game the coin was tossed exactly k times.Your task is to determine whether the described situation is possible or else state that Petya was mistaken somewhere. See samples and notes to them for a better understanding. NoteIn the first sample Masha's permutation coincides with the permutation that was written on the board before the beginning of the game. Consequently, that violates the condition that Masha's permutation never occurred on the board before k moves were performed.In the second sample the described situation is possible, in case if after we toss a coin, we get tails.In the third sample the possible coin tossing sequence is: heads-tails-tails.In the fourth sample the possible coin tossing sequence is: heads-heads. def Solve(x,L):
    if(x==k[0]):
        return L==S
    
    if((x,tuple(L)) in Mem):
        return False
    if(L==S):
        return False
    E=[]
    for i in range(len(L)):
        E.append(L[Q[i]-1])
    if(Solve(x+1,E)):
        return True
    E=[0]*len(L)
    for i in range(len(L)):
        E[Q[i]-1]=L[i]
    if(Solve(x+1,E)):
        return True
    Mem[(x,tuple(L))]=1
    return False
Mem={}
k=[0]
n,k[0]=map(int,input().split())

P=list(range(1,n+1))
Q=list(map(int,input().split()))
S=list(map(int,input().split()))

if(Solve(0,P)):
    print(""YES"")
else:
    print(""NO"")
","['brute force', 'combinatorics', 'implementation']"
4540,"You are given a permutation $$$p$$$ consisting of $$$n$$$ integers $$$1, 2, \dots, n$$$ (a permutation is an array where each element from $$$1$$$ to $$$n$$$ occurs exactly once).Let's call an array $$$a$$$ bipartite if the following undirected graph is bipartite:  the graph consists of $$$n$$$ vertices;  two vertices $$$i$$$ and $$$j$$$ are connected by an edge if $$$i &lt; j$$$ and $$$a_i &gt; a_j$$$. Your task is to find a bipartite array of integers $$$a$$$ of size $$$n$$$, such that $$$a_i = p_i$$$ or $$$a_i = -p_i$$$, or report that no such array exists. If there are multiple answers, print any of them. nan from math import inf
import sys

input = sys.stdin.readline
inf = 1 << 20

def sol(numbers):
    n, elems = numbers

    # dp[i, sign]
    # i: posición del elemento i-ésimo del array elems que se está analizando
    # sign: signo que se le puso al elemento (i-1)-ésimo de elems   
    dp = [[inf, inf] for _ in range(n)]
    dp[0][0] = dp[0][1] = -inf

    # cad
    cad = [[0, 0] for _ in range(n)]

    for i in range(n - 1):
        for s in range(2):
            if dp[i][s] != inf:
                x = -1 * elems[i] if s else elems[i]
                y = dp[i][s]
                if x < y:
                    x, y = y, x
                for sp in range(2):
                    z = -1 * elems[i + 1] if sp else elems[i + 1]
                    if z > x and dp[i + 1][sp] > y:
                        dp[i + 1][sp] = y
                        cad[i + 1][sp] = s
                    elif z > y and dp[i + 1][sp] > x:
                        dp[i + 1][sp] = x
                        cad[i + 1][sp] = s

    sg = -1
    for s in range(2):
        if dp[n - 1][s] != inf:
            sg = s

    if sg == -1:
        print(""NO"")
        return

    res = [0] * n
    for i in range(n - 1, -1, -1):
        res[i] = -1 * elems[i] if sg else elems[i]
        sg = cad[i][sg]

    print(""YES"")
    print(*res)

def main():
    # t: number of test cases
    t = int(input())

    # test cases
    for _ in range(t):
        n = int(input())
        numbers = (n, list(map(int, input().split("" ""))))
        sol(numbers)
    



main()","['dp', 'greedy']"
1533,"Caisa solved the problem with the sugar and now he is on the way back to home. Caisa is playing a mobile game during his path. There are (n + 1) pylons numbered from 0 to n in this game. The pylon with number 0 has zero height, the pylon with number i (i &gt; 0) has height hi. The goal of the game is to reach n-th pylon, and the only move the player can do is to jump from the current pylon (let's denote its number as k) to the next one (its number will be k + 1). When the player have made such a move, its energy increases by hk - hk + 1 (if this value is negative the player loses energy). The player must have non-negative amount of energy at any moment of the time. Initially Caisa stand at 0 pylon and has 0 energy. The game provides a special opportunity: one can pay a single dollar and increase the height of anyone pylon by one. Caisa may use that opportunity several times, but he doesn't want to spend too much money. What is the minimal amount of money he must paid to reach the goal of the game? NoteIn the first sample he can pay 4 dollars and increase the height of pylon with number 0 by 4 units. Then he can safely pass to the last pylon. import math
import sys

#imgur.com/Pkt7iIf.png

def ii(): return int(input())
def mi(): return map(int, input().split())
def li(): return list(map(int, input().split()))

n = ii()
print(max(li()))

","['brute force', 'implementation', 'math']"
1281,"Our beloved detective, Sherlock is currently trying to catch a serial killer who kills a person each day. Using his powers of deduction, he came to know that the killer has a strategy for selecting his next victim.The killer starts with two potential victims on his first day, selects one of these two, kills selected victim and replaces him with a new person. He repeats this procedure each day. This way, each day he has two potential victims to choose from. Sherlock knows the initial two potential victims. Also, he knows the murder that happened on a particular day and the new person who replaced this victim.You need to help him get all the pairs of potential victims at each day so that Sherlock can observe some pattern. NoteIn first example, the killer starts with ross and rachel.   After day 1, ross is killed and joey appears.  After day 2, rachel is killed and phoebe appears.  After day 3, phoebe is killed and monica appears.  After day 4, monica is killed and chandler appears.  now_list = raw_input().split(' ')
n = int(raw_input())
print ' '.join(now_list)
for i in xrange(n):
    x, y = raw_input().split(' ')
    now_list.remove(x)
    now_list.append(y)
    print ' '.join(now_list)
","['brute force', 'implementation', 'strings']"
179,"ZS the Coder is playing a game. There is a number displayed on the screen and there are two buttons, ' + ' (plus) and '' (square root). Initially, the number 2 is displayed on the screen. There are n + 1 levels in the game and ZS the Coder start at the level 1.When ZS the Coder is at level k, he can :  Press the ' + ' button. This increases the number on the screen by exactly k. So, if the number on the screen was x, it becomes x + k. Press the '' button. Let the number on the screen be x. After pressing this button, the number becomes . After that, ZS the Coder levels up, so his current level becomes k + 1. This button can only be pressed when x is a perfect square, i.e. x = m2 for some positive integer m. Additionally, after each move, if ZS the Coder is at level k, and the number on the screen is m, then m must be a multiple of k. Note that this condition is only checked after performing the press. For example, if ZS the Coder is at level 4 and current number is 100, he presses the '' button and the number turns into 10. Note that at this moment, 10 is not divisible by 4, but this press is still valid, because after it, ZS the Coder is at level 5, and 10 is divisible by 5.ZS the Coder needs your help in beating the game — he wants to reach level n + 1. In other words, he needs to press the '' button n times. Help him determine the number of times he should press the ' + ' button before pressing the '' button at each level. Please note that ZS the Coder wants to find just any sequence of presses allowing him to reach level n + 1, but not necessarily a sequence minimizing the number of presses. NoteIn the first sample case:On the first level, ZS the Coder pressed the ' + ' button 14 times (and the number on screen is initially 2), so the number became 2 + 14·1 = 16. Then, ZS the Coder pressed the '' button, and the number became . After that, on the second level, ZS pressed the ' + ' button 16 times, so the number becomes 4 + 16·2 = 36. Then, ZS pressed the '' button, levelling up and changing the number into .After that, on the third level, ZS pressed the ' + ' button 46 times, so the number becomes 6 + 46·3 = 144. Then, ZS pressed the '' button, levelling up and changing the number into . Note that 12 is indeed divisible by 4, so ZS the Coder can reach level 4.Also, note that pressing the ' + ' button 10 times on the third level before levelling up does not work, because the number becomes 6 + 10·3 = 36, and when the '' button is pressed, the number becomes  and ZS the Coder is at Level 4. However, 6 is not divisible by 4 now, so this is not a valid solution.In the second sample case:On the first level, ZS the Coder pressed the ' + ' button 999999999999999998 times (and the number on screen is initially 2), so the number became 2 + 999999999999999998·1 = 1018. Then, ZS the Coder pressed the '' button, and the number became . After that, on the second level, ZS pressed the ' + ' button 44500000000 times, so the number becomes 109 + 44500000000·2 = 9·1010. Then, ZS pressed the '' button, levelling up and changing the number into . Note that 300000 is a multiple of 3, so ZS the Coder can reach level 3. def main():
    n=int(input())
    print(2)
    for i in range(2,n+1):
        print(i*(i+1)**2-(i-1))

main()


'''
1=>2: 2->4     [2]
2=>3: 2->36    [17]
3=>4: 6->144   [46]
4=>5: 12->400  [97]
5=>6: 20->900  [176]
'''
","['constructive algorithms', 'math', 'number theory']"
2835,"The police department of your city has just started its journey. Initially, they don’t have any manpower. So, they started hiring new recruits in groups.Meanwhile, crimes keeps occurring within the city. One member of the police force can investigate only one crime during his/her lifetime.If there is no police officer free (isn't busy with crime) during the occurrence of a crime, it will go untreated.Given the chronological order of crime occurrences and recruit hirings, find the number of crimes which will go untreated. NoteLets consider the second example:  Firstly one person is hired.  Then crime appears, the last hired person will investigate this crime.  One more person is hired.  One more crime appears, the last hired person will investigate this crime.  Crime appears. There is no free policeman at the time, so this crime will go untreated.  One more person is hired.  One more person is hired.  One more person is hired. The answer is one, as one crime (on step 5) will go untreated. #!/usr/bin/env pypy
from __future__ import division, print_function
from collections import defaultdict, Counter, deque
from future_builtins import ascii, filter, hex, map, oct, zip
from itertools import imap as map, izip as zip, permutations, combinations, combinations_with_replacement
from __builtin__ import xrange as range
from math import ceil, factorial
from _continuation import continulet
from cStringIO import StringIO
from io import IOBase
import __pypy__
from bisect import bisect, insort, bisect_left, bisect_right
from fractions import Fraction
from functools import reduce
import string
import sys
import os
import re
inf = float('inf')
mod_ = int(1e9) + 7
mod = 998244353

def main():
	n = int(input())
	arr = list(map(int, input().split()))
	officers, crimes = 0, 0
	for ele in arr:
		if ele != -1:
			officers += ele
		else:
			if officers:
				officers -= 1
			else:
				crimes += 1
	print(crimes)


BUFSIZE = 8192
class FastI(IOBase):
	def __init__(self, file):
		self._fd = file.fileno()
		self._buffer = StringIO()
		self.newlines = 0

	def read(self):
		while True:
			b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
			if not b:
				break
			ptr = self.buffer.tell()
			self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
		self.newlines = 0
		return self.buffer.read()

	def readline(self):
		while self.newlines == 0:
			b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
			self.newlines = b.count(""\n"") + (not b)
			ptr = self._buffer.tell()
			self._buffer.seek(0, 2), self._buffer.write(
				b), self._buffer.seek(ptr)
		self.newlines -= 1
		return self._buffer.readline()
class FastO(IOBase):
	def __init__(self, file):
		self._fd = file.fileno()
		self._buffer = __pypy__.builders.StringBuilder()
		self.write = lambda s: self._buffer.append(s)

	def flush(self):
		os.write(self._fd, self._buffer.build())
		self._buffer = __pypy__.builders.StringBuilder()
def print(*args, **kwargs):
	sep, file = kwargs.pop(""sep"", "" ""), kwargs.pop(""file"", sys.stdout)
	at_start = True
	for x in args:
		if not at_start:
			file.write(sep)
		file.write(str(x))
		at_start = False
	file.write(kwargs.pop(""end"", ""\n""))
	if kwargs.pop(""flush"", False):
		file.flush()
def gcd(x, y):
	while y:
		x, y = y, x % y
	return x
sys.stdin, sys.stdout = FastI(sys.stdin), FastO(sys.stdout)
def input(): return sys.stdin.readline().rstrip(""\r\n"")
if __name__ == ""__main__"":
	def bootstrap(cont):
		call, arg = cont.switch()
		while True:
			call, arg = cont.switch(to=continulet(
				lambda _, f, args: f(*args), call, arg))
	cont = continulet(bootstrap)
	cont.switch()
	main()",['implementation']
4552,"Masha wants to open her own bakery and bake muffins in one of the n cities numbered from 1 to n. There are m bidirectional roads, each of whose connects some pair of cities.To bake muffins in her bakery, Masha needs to establish flour supply from some storage. There are only k storages, located in different cities numbered a1, a2, ..., ak.Unforunately the law of the country Masha lives in prohibits opening bakery in any of the cities which has storage located in it. She can open it only in one of another n - k cities, and, of course, flour delivery should be paid — for every kilometer of path between storage and bakery Masha should pay 1 ruble.Formally, Masha will pay x roubles, if she will open the bakery in some city b (ai ≠ b for every 1 ≤ i ≤ k) and choose a storage in some city s (s = aj for some 1 ≤ j ≤ k) and b and s are connected by some path of roads of summary length x (if there are more than one path, Masha is able to choose which of them should be used).Masha is very thrifty and rational. She is interested in a city, where she can open her bakery (and choose one of k storages and one of the paths between city with bakery and city with storage) and pay minimum possible amount of rubles for flour delivery. Please help Masha find this amount. NoteImage illustrates the first sample case. Cities with storage located in and the road representing the answer are darkened.  '''input
3 1 1
1 2 3
3
'''
n, m, k = map(int, raw_input().split())

if k == 0:
	print -1
else:
	A = [map(int, raw_input().split()) for _ in xrange(m)]
	storages = map(int, raw_input().split())
	
	mark = [True] * (n + 1)
	for i in storages: mark[i] = False

	res = 10000000000
	for u, v, l in A:
		if mark[u] != mark[v]:
			res = min(res, l)

	print res if res != 10000000000 else -1
",['graphs']
1187,"A permutation of length $$$n$$$ is an array consisting of $$$n$$$ distinct integers from $$$1$$$ to $$$n$$$ in arbitrary order. For example, $$$[2,3,1,5,4]$$$ is a permutation, but $$$[1,2,2]$$$ is not a permutation ($$$2$$$ appears twice in the array) and $$$[1,3,4]$$$ is also not a permutation ($$$n=3$$$ but there is $$$4$$$ in the array).For a positive integer $$$n$$$, we call a permutation $$$p$$$ of length $$$n$$$ good if the following condition holds for every pair $$$i$$$ and $$$j$$$ ($$$1 \le i \le j \le n$$$) —   $$$(p_i \text{ OR } p_{i+1} \text{ OR } \ldots \text{ OR } p_{j-1} \text{ OR } p_{j}) \ge j-i+1$$$, where $$$\text{OR}$$$ denotes the bitwise OR operation. In other words, a permutation $$$p$$$ is good if for every subarray of $$$p$$$, the $$$\text{OR}$$$ of all elements in it is not less than the number of elements in that subarray. Given a positive integer $$$n$$$, output any good permutation of length $$$n$$$. We can show that for the given constraints such a permutation always exists. NoteFor $$$n = 3$$$, $$$[3,1,2]$$$ is a good permutation. Some of the subarrays are listed below.   $$$3\text{ OR }1 = 3 \geq 2$$$ $$$(i = 1,j = 2)$$$  $$$3\text{ OR }1\text{ OR }2 = 3 \geq 3$$$ $$$(i = 1,j = 3)$$$  $$$1\text{ OR }2 = 3 \geq 2$$$ $$$(i = 2,j = 3)$$$  $$$1 \geq 1$$$ $$$(i = 2,j = 2)$$$ Similarly, you can verify that $$$[4,3,5,2,7,1,6]$$$ is also good. for i in range(int(input())):
    n=int(input())
    arr=[i for i in range(1,n+1)]
    print(*arr)
","['constructive algorithms', 'math']"
2602,"Piegirl got bored with binary, decimal and other integer based counting systems. Recently she discovered some interesting properties about number , in particular that q2 = q + 1, and she thinks it would make a good base for her new unique system. She called it ""golden system"". In golden system the number is a non-empty string containing 0's and 1's as digits. The decimal value of expression a0a1...an equals to .Soon Piegirl found out that this system doesn't have same properties that integer base systems do and some operations can not be performed on it. She wasn't able to come up with a fast way of comparing two numbers. She is asking for your help.Given two numbers written in golden system notation, determine which of them has larger decimal value. NoteIn the first example first number equals to , while second number is approximately 1.6180339882 + 1.618033988 + 1 ≈ 5.236, which is clearly a bigger number.In the second example numbers are equal. Each of them is  ≈ 2.618. from itertools import dropwhile, chain


def main():
    zeroes = lambda a: not a
    a, b = [list(chain([0, 0], dropwhile(zeroes, map(int, input()))))
            for _ in range(2)]

    def tofib(l):
        i = 0
        while i < len(l) - 1:
            if l[i] > 0 and l[i + 1] > 0:
                l[i] -= 1
                l[i + 1] -= 1
                l[i - 1] += 1
                i -= 3
            i += 1
        return l

    a = list(dropwhile(zeroes, tofib(a)))
    b = list(dropwhile(zeroes, tofib(b)))

    if len(a) < len(b):
        print('<')
        return
    if len(a) > len(b):
        print('>')
        return
    for i in range(len(a)):
        if a[i] < b[i]:
            print('<')
            return
        if a[i] > b[i]:
            print('>')
            return
    print('=')


if __name__ == '__main__':
    main()

","['math', 'other']"
1966,"Recently, Valery have come across an entirely new programming language. Most of all the language attracted him with template functions and procedures. Let us remind you that templates are tools of a language, designed to encode generic algorithms, without reference to some parameters (e.g., data types, buffer sizes, default values).Valery decided to examine template procedures in this language in more detail. The description of a template procedure consists of the procedure name and the list of its parameter types. The generic type T parameters can be used as parameters of template procedures.A procedure call consists of a procedure name and a list of variable parameters. Let's call a procedure suitable for this call if the following conditions are fulfilled:   its name equals to the name of the called procedure;  the number of its parameters equals to the number of parameters of the procedure call;  the types of variables in the procedure call match the corresponding types of its parameters. The variable type matches the type of a parameter if the parameter has a generic type T or the type of the variable and the parameter are the same. You are given a description of some set of template procedures. You are also given a list of variables used in the program, as well as direct procedure calls that use the described variables. For each call you need to count the number of procedures that are suitable for this call. nan n=int(raw_input())
fs=[]
for i in xrange(n):
    s=raw_input().strip()
    s=s[4:].strip()
    name=s[:s.find('(')].strip()
    lst=s[s.find('(')+1:s.find(')')].split(',')
    lst=map(lambda a:a.strip(),lst)
    fs.append((name,lst))

m=int(raw_input())
tp={}
for i in xrange(m):
    a,b=raw_input().split()
    tp[b]=a

k=int(raw_input())
for i in range(k):
    s=raw_input().strip()
    name=s[:s.find('(')].strip()
    lst=s[s.find('(')+1:s.find(')')].split(',')
    lst=map(lambda a:tp[a.strip()],lst)
    ret=0
    for a,b in fs:
        if a!=name or len(b) != len(lst):
            continue
        for i in xrange(len(b)):
            if b[i]!='T' and b[i]!=lst[i]:
                break
        else:
            ret+=1
    print ret","['binary search', 'brute force', 'implementation', 'other']"
4316,"You have $$$a$$$ coins of value $$$n$$$ and $$$b$$$ coins of value $$$1$$$. You always pay in exact change, so you want to know if there exist such $$$x$$$ and $$$y$$$ that if you take $$$x$$$ ($$$0 \le x \le a$$$) coins of value $$$n$$$ and $$$y$$$ ($$$0 \le y \le b$$$) coins of value $$$1$$$, then the total value of taken coins will be $$$S$$$.You have to answer $$$q$$$ independent test cases. nan q = int(raw_input())

for _ in range(q):
    a, b, n, S = map(int, raw_input().split())
    if b >= S:
        print ""YES""
        continue
    total = S
    need = S/n
    if need <= a:
        total -= need * n
    else:
        total -= a * n
    if b < total:
        print ""NO""
    else:
        print ""YES""

    
",['math']
586,"Happy new year! The year 2020 is also known as Year Gyeongja (경자년, gyeongja-nyeon) in Korea. Where did the name come from? Let's briefly look at the Gapja system, which is traditionally used in Korea to name the years.There are two sequences of $$$n$$$ strings $$$s_1, s_2, s_3, \ldots, s_{n}$$$ and $$$m$$$ strings $$$t_1, t_2, t_3, \ldots, t_{m}$$$. These strings contain only lowercase letters. There might be duplicates among these strings.Let's call a concatenation of strings $$$x$$$ and $$$y$$$ as the string that is obtained by writing down strings $$$x$$$ and $$$y$$$ one right after another without changing the order. For example, the concatenation of the strings ""code"" and ""forces"" is the string ""codeforces"".The year 1 has a name which is the concatenation of the two strings $$$s_1$$$ and $$$t_1$$$. When the year increases by one, we concatenate the next two strings in order from each of the respective sequences. If the string that is currently being used is at the end of its sequence, we go back to the first string in that sequence.For example, if $$$n = 3, m = 4, s = $$${""a"", ""b"", ""c""}, $$$t =$$$ {""d"", ""e"", ""f"", ""g""}, the following table denotes the resulting year names. Note that the names of the years may repeat.  You are given two sequences of strings of size $$$n$$$ and $$$m$$$ and also $$$q$$$ queries. For each query, you will be given the current year. Could you find the name corresponding to the given year, according to the Gapja system? NoteThe first example denotes the actual names used in the Gapja system. These strings usually are either a number or the name of some animal. n,m=map(int,input().split())
S=list(map(str,input().split()))
T=list(map(str,input().split()))
q=int(input())
for i in range (q):
    y=int(input())
    print(S[(y%n)-1]+T[(y%m)-1])","['implementation', 'strings']"
599,"You are given a palindromic string $$$s$$$ of length $$$n$$$.You have to count the number of indices $$$i$$$ $$$(1 \le i \le n)$$$ such that the string after removing $$$s_i$$$ from $$$s$$$ still remains a palindrome. For example, consider $$$s$$$ = ""aba""  If we remove $$$s_1$$$ from $$$s$$$, the string becomes ""ba"" which is not a palindrome.  If we remove $$$s_2$$$ from $$$s$$$, the string becomes ""aa"" which is a palindrome.  If we remove $$$s_3$$$ from $$$s$$$, the string becomes ""ab"" which is not a palindrome. A palindrome is a string that reads the same backward as forward. For example, ""abba"", ""a"", ""fef"" are palindromes whereas ""codeforces"", ""acd"", ""xy"" are not. NoteThe first test case is described in the statement.In the second test case, the indices $$$i$$$ that result in palindrome after removing $$$s_i$$$ are $$$3, 4, 5, 6$$$. Hence the answer is $$$4$$$. In the third test case, removal of any of the indices results in ""d"" which is a palindrome. Hence the answer is $$$2$$$. for _ in range(int(input())):
    n=int(input())
    s= input()
    c=0
    val = s[n//2]
    for i in range(n//2-1, -1, -1):
        if s[i]!=val:
            break
        c+=2
    print(c+n%2)
           ","['greedy', 'strings']"
1588,"A bracket sequence is called regular if it is possible to obtain correct arithmetic expression by inserting characters «+» and «1» into this sequence. For example, sequences «(())()», «()» and «(()(()))» are regular, while «)(», «(()» and «(()))(» are not.One day Johnny got bracket sequence. He decided to remove some of the brackets from it in order to obtain a regular bracket sequence. What is the maximum length of a regular bracket sequence which can be obtained? nan from collections import *

s, ans, l, r = input(), 0, 0, 0
arr = deque(s)
# print(arr)
for i in arr:
    if i == '(':
        l += 1
    else:
        if l > 0:
            l-=1
            ans+=2
print(ans)",['greedy']
3116,"Everybody knows that opposites attract. That is the key principle of the ""Perfect Matching"" dating agency. The ""Perfect Matching"" matchmakers have classified each registered customer by his interests and assigned to the i-th client number ti ( - 10 ≤ ti ≤ 10). Of course, one number can be assigned to any number of customers.""Perfect Matching"" wants to advertise its services and publish the number of opposite couples, that is, the couples who have opposite values of t. Each couple consists of exactly two clients. The customer can be included in a couple an arbitrary number of times. Help the agency and write the program that will find the sought number by the given sequence t1, t2, ..., tn. For example, if t = (1,  - 1, 1,  - 1), then any two elements ti and tj form a couple if i and j have different parity. Consequently, in this case the sought number equals 4.Of course, a client can't form a couple with him/herself. NoteIn the first sample the couples of opposite clients are: (1,2), (1,5) и (3,4).In the second sample any couple of clients is opposite. data = input()
cnt = int(data[0])

t = [int(i) for i in input().split()]
d = dict()
for idx in range(-10, 11):
    d[idx] = 0

for r in t:
    d[r] += 1

s = 0
for idx in range(1, 11):
    s += d[idx] * d[(-idx)]

if d[0] > 1:
    for idx in range(1, d[0]):
        s += idx

print(s)","['implementation', 'math']"
1221,"The Rebel fleet is on the run. It consists of m ships currently gathered around a single planet. Just a few seconds ago, the vastly more powerful Empire fleet has appeared in the same solar system, and the Rebels will need to escape into hyperspace. In order to spread the fleet, the captain of each ship has independently come up with the coordinate to which that ship will jump. In the obsolete navigation system used by the Rebels, this coordinate is given as the value of an arithmetic expression of the form .To plan the future of the resistance movement, Princess Heidi needs to know, for each ship, how many ships are going to end up at the same coordinate after the jump. You are her only hope! NoteIn the sample testcase, the second and the third ship will both end up at the coordinate 3.Note that this problem has only two versions – easy and hard. from collections import Counter
N = int(input())
src = [eval(input()) for i in range(N)]
ctr = Counter(src)
ans = [ctr[a] for a in src]
print(*ans)
","['math', 'other']"
4162,"Professor Dumbledore is helping Harry destroy the Horcruxes. He went to Gaunt Shack as he suspected a Horcrux to be present there. He saw Marvolo Gaunt's Ring and identified it as a Horcrux. Although he destroyed it, he is still affected by its curse. Professor Snape is helping Dumbledore remove the curse. For this, he wants to give Dumbledore exactly x drops of the potion he made. Value of x is calculated as maximum of p·ai + q·aj + r·ak for given p, q, r and array a1, a2, ... an such that 1 ≤ i ≤ j ≤ k ≤ n. Help Snape find the value of x. Do note that the value of x may be negative. NoteIn the first sample case, we can take i = j = k = 5, thus making the answer as 1·5 + 2·5 + 3·5 = 30.In second sample case, selecting i = j = 1 and k = 5 gives the answer 12. R=lambda:map(int,raw_input().split())
n,p,q,r=R()
v=sorted((p,q,r))
a=R()
b=a[:]
b[0]*=p
for i in range(1,n):
    b[i]=max(a[i]*p,b[i-1])
c=a[:]
c[0]=a[0]*q+b[0]
for i in range(1,n):
    c[i]=max(b[i]+a[i]*q,c[i-1])
b[0]=a[0]*r+c[0]
for i in range(1,n):
    b[i]=max(c[i]+a[i]*r,b[i-1])
print b[-1]","['brute force', 'data structures', 'dp']"
4346,"Little town Nsk consists of n junctions connected by m bidirectional roads. Each road connects two distinct junctions and no two roads connect the same pair of junctions. It is possible to get from any junction to any other junction by these roads. The distance between two junctions is equal to the minimum possible number of roads on a path between them.In order to improve the transportation system, the city council asks mayor to build one new road. The problem is that the mayor has just bought a wonderful new car and he really enjoys a ride from his home, located near junction s to work located near junction t. Thus, he wants to build a new road in such a way that the distance between these two junctions won't decrease. You are assigned a task to compute the number of pairs of junctions that are not connected by the road, such that if the new road between these two junctions is built the distance between s and t won't decrease. nan n,m,s,t = map(int, raw_input().split())
a=[0]*(n+1)
b=list(a)
g= [[] for i in range(n+1)]
for i in range(m):
    u,v = map(int, raw_input().split())
    g[u]+=[v]
    g[v]+=[u]

def bfs(x, a):
    q=[x]
    while q:
        c=q.pop()
        for y in g[c]:
            if not a[y]:
                a[y] = a[c]+1
                q.insert(0,y)
    a[x]=0
bfs(s,a)
bfs(t,b)
# print a,b
r=0
for i in range(1,n+1):
    for j in range(i + 1, n + 1):
        if min(a[i]+b[j]+1, a[j]+b[i]+1) >= a[t]:
            r+=1
print r-m
","['dfs and similar', 'graphs', 'shortest paths']"
877,"Once again, Boris needs the help of Anton in creating a task. This time Anton needs to solve the following problem:There are two arrays of integers $$$a$$$ and $$$b$$$ of length $$$n$$$. It turned out that array $$$a$$$ contains only elements from the set $$$\{-1, 0, 1\}$$$.Anton can perform the following sequence of operations any number of times:   Choose any pair of indexes $$$(i, j)$$$ such that $$$1 \le i &lt; j \le n$$$. It is possible to choose the same pair $$$(i, j)$$$ more than once.   Add $$$a_i$$$ to $$$a_j$$$. In other words, $$$j$$$-th element of the array becomes equal to $$$a_i + a_j$$$. For example, if you are given array $$$[1, -1, 0]$$$, you can transform it only to $$$[1, -1, -1]$$$, $$$[1, 0, 0]$$$ and $$$[1, -1, 1]$$$ by one operation.Anton wants to predict if it is possible to apply some number (zero or more) of these operations to the array $$$a$$$ so that it becomes equal to array $$$b$$$. Can you help him? NoteIn the first test-case we can choose $$$(i, j)=(2, 3)$$$ twice and after that choose $$$(i, j)=(1, 2)$$$ twice too. These operations will transform $$$[1, -1, 0] \to [1, -1, -2] \to [1, 1, -2]$$$In the second test case we can't make equal numbers on the second position.In the third test case we can choose $$$(i, j)=(1, 2)$$$ $$$41$$$ times. The same about the fourth test case.In the last lest case, it is impossible to make array $$$a$$$ equal to the array $$$b$$$. for _ in range(int(input())):
    n = int(input())
    a = list(map(int,input().split()))
    b = list(map(int,input().split()))

    if a[0]!=b[0]:
        print(""NO"")
        continue

    one = -1
    minus = -1
    for i in range(n):
        if one ==-1 and a[i] == 1:
            one = i
        # elif a[1] == 0:
        elif minus==-1 and a[i] == -1:
            minus = i
        if one!= -1 and minus !=-1:
            break  
    for i in range(1,n):
        if a[i]<b[i] and  (one==-1 or one>=i):
            print(""NO"")
            break
        if a[i]>b[i] and (minus == -1 or minus>=i):
            print(""NO"")
            break
    else:
        print(""YES"")

","['greedy', 'implementation']"
3862,"Let's call an array $$$a_1, a_2, \dots, a_m$$$ of nonnegative integer numbers good if $$$a_1 + a_2 + \dots + a_m = 2\cdot(a_1 \oplus a_2 \oplus \dots \oplus a_m)$$$, where $$$\oplus$$$ denotes the bitwise XOR operation.For example, array $$$[1, 2, 3, 6]$$$ is good, as $$$1 + 2 + 3 + 6 = 12 = 2\cdot 6 = 2\cdot (1\oplus 2 \oplus 3 \oplus 6)$$$. At the same time, array $$$[1, 2, 1, 3]$$$ isn't good, as $$$1 + 2 + 1 + 3 = 7 \neq 2\cdot 1 = 2\cdot(1\oplus 2 \oplus 1 \oplus 3)$$$.You are given an array of length $$$n$$$: $$$a_1, a_2, \dots, a_n$$$. Append at most $$$3$$$ elements to it to make it good. Appended elements don't have to be different. It can be shown that the solution always exists under the given constraints. If there are different solutions, you are allowed to output any of them. Note that you don't have to minimize the number of added elements!. So, if an array is good already you are allowed to not append elements. NoteIn the first test case of the example, the sum of all numbers is $$$12$$$, and their $$$\oplus$$$ is $$$6$$$, so the condition is already satisfied.In the second test case of the example, after adding $$$4, 4$$$, the array becomes $$$[8, 4, 4]$$$. The sum of numbers in it is $$$16$$$, $$$\oplus$$$ of numbers in it is $$$8$$$. for i in range(int(input())):
    x=int(input())
    m=list(map(int,input().split()))
    s=0
    ss=0
    for j in range(x):
        s=s^m[j]
        ss+=m[j]
    if s==0:
        print(""1"")
        print(ss)
    else:
        print(""2"")
        print(str(s)+"" ""+str(ss+s))
        
","['bitmasks', 'constructive algorithms', 'math']"
3693,"HDD hard drives group data by sectors. All files are split to fragments and each of them are written in some sector of hard drive. Note the fragments can be written in sectors in arbitrary order.One of the problems of HDD hard drives is the following: the magnetic head should move from one sector to another to read some file.Find the time need to read file split to n fragments. The i-th sector contains the fi-th fragment of the file (1 ≤ fi ≤ n). Note different sectors contains the different fragments. At the start the magnetic head is in the position that contains the first fragment. The file are reading in the following manner: at first the first fragment is read, then the magnetic head moves to the sector that contains the second fragment, then the second fragment is read and so on until the n-th fragment is read. The fragments are read in the order from the first to the n-th.It takes |a - b| time units to move the magnetic head from the sector a to the sector b. Reading a fragment takes no time. NoteIn the second example the head moves in the following way:  1-&gt;2 means movement from the sector 1 to the sector 5, i.e. it takes 4 time units  2-&gt;3 means movement from the sector 5 to the sector 2, i.e. it takes 3 time units  3-&gt;4 means movement from the sector 2 to the sector 4, i.e. it takes 2 time units  4-&gt;5 means movement from the sector 4 to the sector 3, i.e. it takes 1 time units So the answer to the second example is 4 + 3 + 2 + 1 = 10. from bisect import bisect
from itertools import permutations,combinations
n=int(input())
a=list(map(int,input().split()))

cnt=1
b = []
for x in a:
    b.append([x,cnt])
    cnt+=1
b.sort()
res = 0
for i in range(1,n):
    res+=abs(b[i][1]-b[i-1][1])
print(res)","['implementation', 'math']"
3638,"Polycarp's workday lasts exactly $$$n$$$ minutes. He loves chocolate bars and can eat one bar in one minute. Today Polycarp has $$$k$$$ bars at the beginning of the workday.In some minutes of the workday Polycarp has important things to do and in such minutes he is not able to eat a chocolate bar. In other minutes he can either eat or not eat one chocolate bar. It is guaranteed, that in the first and in the last minutes of the workday Polycarp has no important things to do and he will always eat bars in this minutes to gladden himself at the begining and at the end of the workday. Also it is guaranteed, that $$$k$$$ is strictly greater than $$$1$$$.Your task is to determine such an order of eating chocolate bars that the maximum break time between eating bars is as minimum as possible.Consider that Polycarp eats a bar in the minute $$$x$$$ and the next bar in the minute $$$y$$$ ($$$x &lt; y$$$). Then the break time is equal to $$$y - x - 1$$$ minutes. It is not necessary for Polycarp to eat all bars he has. NoteIn the first example Polycarp can not eat the chocolate bar in the second minute, so the time of the break equals to one minute.In the second example Polycarp will eat bars in the minutes $$$1$$$ and $$$8$$$ anyway, also he needs to eat the chocolate bar in the minute $$$5$$$, so that the time of the maximum break will be equal to $$$3$$$ minutes. def check(mn, n, k, s):
	cur = 0
	k -= 1
	while cur + 1 < n:
		prv = cur
		cur = min(n - 1, cur + mn)
		while s[cur] == '1':
			cur -= 1
		if prv == cur:
			return False
		k -= 1
	return k >= 0

n, k = map(int, input().split())
s = input()
L = 1
R = n - 1
while L < R:
	mid = (L + R) // 2
	if not check(mid, n, k, s):
		L = mid + 1
	else:
		R = mid
print(L - 1)","['binary search', 'greedy', 'other']"
2517,"ZS the Coder has recently found an interesting concept called the Birthday Paradox. It states that given a random set of 23 people, there is around 50% chance that some two of them share the same birthday. ZS the Coder finds this very interesting, and decides to test this with the inhabitants of Udayland.In Udayland, there are 2n days in a year. ZS the Coder wants to interview k people from Udayland, each of them has birthday in one of 2n days (each day with equal probability). He is interested in the probability of at least two of them have the birthday at the same day. ZS the Coder knows that the answer can be written as an irreducible fraction . He wants to find the values of A and B (he does not like to deal with floating point numbers). Can you help him? NoteIn the first sample case, there are 23 = 8 days in Udayland. The probability that 2 people have the same birthday among 2 people is clearly , so A = 1, B = 8.In the second sample case, there are only 21 = 2 days in Udayland, but there are 3 people, so it is guaranteed that two of them have the same birthday. Thus, the probability is 1 and A = B = 1. import math
n, k = [int(x) for x in input().split()]
if n<70 and k>2**n:
    print(1,1)
    exit(0)
mod = int(1e6)+3

def fastpow(a,b):
    t, ans = a, 1
    while b:
        if(b&1):
            ans = ans*t%mod
        t = t*t %mod
        b>>=1
    return ans

t=k-1
cnt=0
while t:
    cnt += t>>1
    t>>=1

x=0
t=fastpow(2,n)
if k<mod:
    x=1
    for i in range(1,k):
        x = x*(t-i)%mod
y=fastpow(2,n*(k-1))

inv = fastpow(2,mod-2)
inv = fastpow(inv,cnt)

x=(x*inv%mod+mod)%mod
y=(y*inv%mod+mod)%mod

x=(y-x+mod)%mod

print(x,y)","['math', 'number theory', 'probabilities']"
144,"The student council has a shared document file. Every day, some members of the student council write the sequence TMT (short for Towa Maji Tenshi) in it.However, one day, the members somehow entered the sequence into the document at the same time, creating a jumbled mess. Therefore, it is Suguru Doujima's task to figure out whether the document has malfunctioned. Specifically, he is given a string of length $$$n$$$ whose characters are all either T or M, and he wants to figure out if it is possible to partition it into some number of disjoint subsequences, all of which are equal to TMT. That is, each character of the string should belong to exactly one of the subsequences.A string $$$a$$$ is a subsequence of a string $$$b$$$ if $$$a$$$ can be obtained from $$$b$$$ by deletion of several (possibly, zero) characters. NoteIn the first test case, the string itself is already a sequence equal to TMT.In the third test case, we may partition the string into the subsequences TMTMTT. Both the bolded and the non-bolded subsequences are equal to TMT. t=int(input())
for i in range(t):
    n=int(input())
    p=input()
    p1=p[::-1]
    c=0
    r=False
    c1=p.count('T')
    c2=p.count('M')
    if n%3!=0 or c1!=c2*2 or p[0]=='M' or p[-1]=='M':
        print(""NO"")
    else:
        for j in range(n):
            if p[j]=='T':
                c+=1
            else:
                c-=1
            if c<0 or c>n//3:   
                r=True
                break
        if c==n//3 and not r:
            print(""YES"")
        else:
            print(""NO"")
                
                ",['greedy']
2086,"There is a house with $$$n$$$ flats situated on the main street of Berlatov. Vova is watching this house every night. The house can be represented as an array of $$$n$$$ integer numbers $$$a_1, a_2, \dots, a_n$$$, where $$$a_i = 1$$$ if in the $$$i$$$-th flat the light is on and $$$a_i = 0$$$ otherwise.Vova thinks that people in the $$$i$$$-th flats are disturbed and cannot sleep if and only if $$$1 &lt; i &lt; n$$$ and $$$a_{i - 1} = a_{i + 1} = 1$$$ and $$$a_i = 0$$$.Vova is concerned by the following question: what is the minimum number $$$k$$$ such that if people from exactly $$$k$$$ pairwise distinct flats will turn off the lights then nobody will be disturbed? Your task is to find this number $$$k$$$. NoteIn the first example people from flats $$$2$$$ and $$$7$$$ or $$$4$$$ and $$$7$$$ can turn off the light and nobody will be disturbed. It can be shown that there is no better answer in this example.There are no disturbed people in second and third examples. n = int(input())
a = [int(s) for s in input().split()]
c = 0
for i in range(2, n):
    if a[i - 2] - a[i - 1] == 1 and a[i] == 1:
        a[i] = 0
        c += 1
print(c)",['greedy']
1061,"The tournament «Sleepyhead-2010» in the rapid falling asleep has just finished in Berland. n best participants from the country have participated in it. The tournament consists of games, each of them is a match between two participants. n·(n - 1) / 2 games were played during the tournament, and each participant had a match with each other participant. The rules of the game are quite simple — the participant who falls asleep first wins. The secretary made a record of each game in the form «xi yi», where xi and yi are the numbers of participants. The first number in each pair is a winner (i.e. xi is a winner and yi is a loser). There is no draws.Recently researches form the «Institute Of Sleep» have found that every person is characterized by a value pj — the speed of falling asleep. The person who has lower speed wins. Every person has its own value pj, constant during the life. It is known that all participants of the tournament have distinct speeds of falling asleep. Also it was found that the secretary made records about all the games except one. You are to find the result of the missing game. nan n=int(input())
a,b,c=[0]*(n+1),[0]*(n+1), []
for _ in range(n*(n-1)//2-1):
    x,y=map(int,input().split())
    a[x]+=1
    b[y]+=1
for i in range(1,n+1):
    if a[i]+b[i] != n-1:
        c.append(i)
if a[c[0]]>a[c[1]]:
    print(c[0],c[1])
else:
    print(c[1],c[0])
","['bitmasks', 'brute force', 'dfs and similar', 'greedy']"
4273,"Vasya has n items lying in a line. The items are consecutively numbered by numbers from 1 to n in such a way that the leftmost item has number 1, the rightmost item has number n. Each item has a weight, the i-th item weights wi kilograms.Vasya needs to collect all these items, however he won't do it by himself. He uses his brand new robot. The robot has two different arms — the left one and the right one. The robot can consecutively perform the following actions:   Take the leftmost item with the left hand and spend wi · l energy units (wi is a weight of the leftmost item, l is some parameter). If the previous action was the same (left-hand), then the robot spends extra Ql energy units;  Take the rightmost item with the right hand and spend wj · r energy units (wj is a weight of the rightmost item, r is some parameter). If the previous action was the same (right-hand), then the robot spends extra Qr energy units; Naturally, Vasya wants to program the robot in a way that the robot spends as little energy as possible. He asked you to solve this problem. Your task is to find the minimum number of energy units robot spends to collect all items. NoteConsider the first sample. As l = r, we can take an item in turns: first from the left side, then from the right one and last item from the left. In total the robot spends 4·42 + 4·99 + 4·3 = 576 energy units.The second sample. The optimal solution is to take one item from the right, then one item from the left and two items from the right. In total the robot spends (2·4) + (7·1) + (2·3) + (2·2 + 9) = 34 energy units. #!/usr/bin/python3

import sys

n, l, r, ql, qr = map(int, sys.stdin.readline().strip().split())
w = [int(x) for x in sys.stdin.readline().strip().split()]

s = [0]
for i in range(0, n):
    s.append(s[-1] + w[i])

def cost(left):
    right = n - left
    diff = left - right
    bonus = 0
    if diff > 0: # left part is larger
        bonus = ql * (diff - 1)
    elif diff < 0: # right part is larger
        bonus = qr * (-diff - 1)
    return bonus + l * s[left] + r * (s[n] - s[left])

best = cost(0)
for left in range(1, n+1):
    c = cost(left)
    if c < best:
        best = c

print(best)
","['brute force', 'greedy', 'math']"
2057,"Let $$$x$$$ be an array of integers $$$x = [x_1, x_2, \dots, x_n]$$$. Let's define $$$B(x)$$$ as a minimal size of a partition of $$$x$$$ into subsegments such that all elements in each subsegment are equal. For example, $$$B([3, 3, 6, 1, 6, 6, 6]) = 4$$$ using next partition: $$$[3, 3\ |\ 6\ |\ 1\ |\ 6, 6, 6]$$$.Now you don't have any exact values of $$$x$$$, but you know that $$$x_i$$$ can be any integer value from $$$[l_i, r_i]$$$ ($$$l_i \le r_i$$$) uniformly at random. All $$$x_i$$$ are independent.Calculate expected value of $$$(B(x))^2$$$, or $$$E((B(x))^2)$$$. It's guaranteed that the expected value can be represented as rational fraction $$$\frac{P}{Q}$$$ where $$$(P, Q) = 1$$$, so print the value $$$P \cdot Q^{-1} \mod 10^9 + 7$$$. NoteLet's describe all possible values of $$$x$$$ for the first sample:   $$$[1, 1, 1]$$$: $$$B(x) = 1$$$, $$$B^2(x) = 1$$$;  $$$[1, 1, 2]$$$: $$$B(x) = 2$$$, $$$B^2(x) = 4$$$;  $$$[1, 1, 3]$$$: $$$B(x) = 2$$$, $$$B^2(x) = 4$$$;  $$$[1, 2, 1]$$$: $$$B(x) = 3$$$, $$$B^2(x) = 9$$$;  $$$[1, 2, 2]$$$: $$$B(x) = 2$$$, $$$B^2(x) = 4$$$;  $$$[1, 2, 3]$$$: $$$B(x) = 3$$$, $$$B^2(x) = 9$$$;  So $$$E = \frac{1}{6} (1 + 4 + 4 + 9 + 4 + 9) = \frac{31}{6}$$$ or $$$31 \cdot 6^{-1} = 166666673$$$.All possible values of $$$x$$$ for the second sample:   $$$[3, 4, 5]$$$: $$$B(x) = 3$$$, $$$B^2(x) = 9$$$;  $$$[3, 4, 6]$$$: $$$B(x) = 3$$$, $$$B^2(x) = 9$$$;  $$$[3, 5, 5]$$$: $$$B(x) = 2$$$, $$$B^2(x) = 4$$$;  $$$[3, 5, 6]$$$: $$$B(x) = 3$$$, $$$B^2(x) = 9$$$;  $$$[4, 4, 5]$$$: $$$B(x) = 2$$$, $$$B^2(x) = 4$$$;  $$$[4, 4, 6]$$$: $$$B(x) = 2$$$, $$$B^2(x) = 4$$$;  $$$[4, 5, 5]$$$: $$$B(x) = 2$$$, $$$B^2(x) = 4$$$;  $$$[4, 5, 6]$$$: $$$B(x) = 3$$$, $$$B^2(x) = 9$$$;  So $$$E = \frac{1}{8} (9 + 9 + 4 + 9 + 4 + 4 + 4 + 9) = \frac{52}{8}$$$ or $$$13 \cdot 2^{-1} = 500000010$$$. mod = 10 ** 9 + 7

def pow_(x, y, p) : 
    res = 1     
    x   = x % p  
      
    if x == 0: 
        return 0
  
    while y > 0: 
        if (y & 1) == 1: 
            res = (res * x) % p 
  
        y = y >> 1 
        x = (x * x) % p 
          
    return res 
    
def reverse(x, mod):
    return pow_(x, mod-2, mod)

def prob(l_arr, r_arr):
    l_, r_ = max(l_arr), min(r_arr)
   
    if l_ > r_:
        return 1
  
    p = (r_-l_+1)
    for l, r in zip(l_arr, r_arr):
        p *= reverse(r-l+1 ,mod)
        
    return (1-p) % mod

n = int(input())
L = list(map(int, input().split()))
R = list(map(int, input().split()))

EX, EX2 = 0, 0
P       = [0] * n
pre     = [0] * n

for i in range(1, n):
    P[i]   =  prob(L[i-1: i+1], R[i-1: i+1])
    pre[i] = (pre[i-1] + P[i]) % mod
    
    if i >= 2:
        pA, pB, pAB = 1-P[i-1], 1-P[i], 1-prob(L[i-2: i+1], R[i-2: i+1])
        p_          = 1 - (pA+pB-pAB)
        
        EX2  += 2 * (P[i]*pre[i-2] + p_) % mod

EX    = sum(P) % mod
EX2  += EX
ans   = (EX2 + 2*EX + 1) % mod
print(ans)","['dp', 'math', 'probabilities']"
751,"You are given a set of n points on the plane. A line containing the origin is called good, if projection of the given set to this line forms a symmetric multiset of points. Find the total number of good lines.Multiset is a set where equal elements are allowed.Multiset is called symmetric, if there is a point P on the plane such that the multiset is centrally symmetric in respect of point P. NotePicture to the first sample test: In the second sample, any line containing the origin is good. from fractions import Fraction
import time


class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def to_tuple(self):
        return (self.x, self.y)

    def __repr__(self):
        return ""Point({}, {})"".format(self.x, self.y)

    def __eq__(self, other):
        return self.to_tuple() == other.to_tuple()

    def __hash__(self):
        return hash(self.to_tuple())

    def __neg__(self):
        return Point(-self.x, -self.y)

    def __add__(self, other):
        return Point(self.x+other.x, self.y+other.y)

    def __sub__(self, other):
        return self+(-other)

    def scalar_mul(self, mu):
        return Point(mu*self.x, mu*self.y)

    def int_divide(self, den):
        return Point(self.x//den, self.y//den)


class Line:
    def __init__(self, a, b, c):
        # ax+by+c=0
        self.a = a
        self.b = b
        self.c = c

    def __repr__(self):
        return ""{}*x + {}*y + {} = 0"".format(self.a, self.b, self.c)

    @classmethod
    def between_two_points(cls, P, Q):
        return cls(P.y-Q.y, Q.x-P.x, P.x*Q.y-P.y*Q.x)

    def evaluate(self, P):
        return self.a*P.x+self.b*P.y+self.c

    def direction(self):
        if self.a == 0:
            return (0, 1)
        return (1, Fraction(self.b, self.a))


def abs_sgn(x):
    if x == 0:
        return 0, 0
    if x < 0:
        return -x, -1
    return x, 1


def solve(tuple_points):
    points = set()
    center = Point(0, 0)
    for cur in tuple_points:
        cur = Point(*cur).scalar_mul(2*n)
        center += cur
        points.add(cur)

    center = center.int_divide(n)
    dcenter = center+center

    sym_points_set = set()
    for p in points:
        sym_points_set.add(dcenter-p)
    nosym = list(points - sym_points_set)

    if len(nosym) == 0:
        print(-1)
        exit(0)

    p0 = nosym[0]
    good_lines = set()
    for p in nosym:
        m = (p+p0).int_divide(2)
        line = Line.between_two_points(m, center)
        distances = list(map(line.evaluate, nosym))

        ok = True
        mydict = {}
        for dd in distances:
            dda, sgn = abs_sgn(dd)
            if dda not in mydict:
                mydict[dda] = sgn
            else:
                mydict[dda] += sgn
        for k in mydict:
            if mydict[k] != 0:
                ok = False
                break
        if ok:
            good_lines.add(line.direction())

    return len(good_lines)


# This one is accepted on CF
if __name__ == ""__main__"":
    n = int(input())
    pts = []
    for i in range(n):
        row = input().split("" "")
        cur = (int(row[0]), int(row[1]))
        pts.append(cur)
    print(solve(pts))
",['geometry']
393,"A tournament is a directed graph without self-loops in which every pair of vertexes is connected by exactly one directed edge. That is, for any two vertexes u and v (u ≠ v) exists either an edge going from u to v, or an edge from v to u.You are given a tournament consisting of n vertexes. Your task is to find there a cycle of length three. nan from sys import stdin, stdout
input = stdin.readline
import gc
gc.disable()

def f():
    p, q, n = [0], [0], int(input())
    input()
    for i in range(1, n):
        t = input()[: i]
        if '0' in t:
            if '1' in t:
                for l, j in enumerate(p): 
                    if t[j] == '1': 
                        for r, j in enumerate(q):
                            if t[j] == '0':                             
                                if l + r == i: break
                                return str(p[l] + 1) + ' ' + str(q[r] + 1) + ' ' + str(i + 1)
                        break
                p.insert(l, i)
                q.insert(i - l, i)
            else: 
                p.append(i)
                q = [i] + q
        else: 
            p = [i] + p
            q.append(i)
    return -1
print(f())","['dfs and similar', 'graphs']"
2245,"You are given an array $$$a$$$ consisting of $$$n$$$ positive integers.Initially, you have an integer $$$x = 0$$$. During one move, you can do one of the following two operations:  Choose exactly one $$$i$$$ from $$$1$$$ to $$$n$$$ and increase $$$a_i$$$ by $$$x$$$ ($$$a_i := a_i + x$$$), then increase $$$x$$$ by $$$1$$$ ($$$x := x + 1$$$).  Just increase $$$x$$$ by $$$1$$$ ($$$x := x + 1$$$). The first operation can be applied no more than once to each $$$i$$$ from $$$1$$$ to $$$n$$$.Your task is to find the minimum number of moves required to obtain such an array that each its element is divisible by $$$k$$$ (the value $$$k$$$ is given).You have to answer $$$t$$$ independent test cases.  NoteConsider the first test case of the example:  $$$x=0$$$, $$$a = [1, 2, 1, 3]$$$. Just increase $$$x$$$;  $$$x=1$$$, $$$a = [1, 2, 1, 3]$$$. Add $$$x$$$ to the second element and increase $$$x$$$;  $$$x=2$$$, $$$a = [1, 3, 1, 3]$$$. Add $$$x$$$ to the third element and increase $$$x$$$;  $$$x=3$$$, $$$a = [1, 3, 3, 3]$$$. Add $$$x$$$ to the fourth element and increase $$$x$$$;  $$$x=4$$$, $$$a = [1, 3, 3, 6]$$$. Just increase $$$x$$$;  $$$x=5$$$, $$$a = [1, 3, 3, 6]$$$. Add $$$x$$$ to the first element and increase $$$x$$$;  $$$x=6$$$, $$$a = [6, 3, 3, 6]$$$. We obtained the required array. Note that you can't add $$$x$$$ to the same element more than once. t = int(input())
for i in range(t):
    n,k = map(int,input().split())
    A = list(map(int,input().split()))
    B = {}
    for j in A:
        if j % k not in B:
            B[j % k] = 0
        B[j % k] += 1
    max = 0
    c = k + 1
    for j in B:
        if j != 0 and (B[j] == max and j < c or B[j] > max):
            max = B[j]
            c = j
    if c == k + 1:
        print(0)
    else:
        print(max * k - c + 1)
            ","['math', 'sortings', 'two pointers']"
3742,"Alice and Bob play a game. Initially they have a string $$$s_1, s_2, \dots, s_n$$$, consisting of only characters . and X. They take alternating turns, and Alice is moving first. During each turn, the player has to select a contiguous substring consisting only of characters . and replaces each of them with X. Alice must select a substing of length $$$a$$$, and Bob must select a substring of length $$$b$$$. It is guaranteed that $$$a &gt; b$$$.For example, if $$$s =$$$ ...X.. and $$$a = 3$$$, $$$b = 2$$$, then after Alice's move string can turn only into XXXX... And if it's Bob's turn and the string $$$s =$$$ ...X.., then after Bob's move the string can turn into XX.X.., .XXX.. or ...XXX.Whoever is unable to make a move, loses. You have to determine who wins if they both play optimally.You have to answer $$$q$$$ independent queries. NoteIn the first query Alice can select substring $$$s_3 \dots s_5$$$. After that $$$s$$$ turns into XXXXX...XX...X. After that, no matter what move Bob makes, Alice can make the move (this will be her second move), but Bob can't make his second move.In the second query Alice can not win because she cannot even make one move.In the third query Alice can choose substring $$$s_2 \dots s_6$$$. After that $$$s$$$ turns into .XXXXX.X..X, and Bob can't make a move after that. import os
import sys
from atexit import register
from io import BytesIO
sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))
sys.stdout = BytesIO()
register(lambda: os.write(1, sys.stdout.getvalue()))
input = lambda: sys.stdin.readline().rstrip('\r\n')
 
q  = int(input())
for _ in range(q):
	a,b = map(int ,input().split("" ""))
	s = map(lambda x: 0 if x == ""."" else 1,input())
	lengths = []
	cnt = 0
	for i in range(len(s)):
		if s[i] == 0:
			cnt += 1
		else:
			if cnt >0:
				lengths.append(cnt)
				cnt = 0
	if cnt >0:
		lengths.append(cnt)
	lengths.sort()
	flag = True
	cnt = 0
	used = 0
	tod = 0
	for l in lengths:
		if l<b:
			continue
		elif a>l>=b:
			flag = False
			break
		elif a<=l<2*b:
			cnt += 1
		elif l>=2*b and not used:
			if l>=a:
				used = 1
				tod = l-a
			else:
				flag = False
				break
		else:
			flag = False
			break
	# print flag
	if not flag:
		print ""NO""
	else:
		if tod != 0:
			flag = False
			for i in range(tod/2+1):
				s1 = i
				s2 = tod-i
				if s1>s2:
					continue
				if a>s1>=b or s1>=2*b or a>s2>=b or s2>=2*b:
					continue
				if (cnt+used+(2*b>s1>=a)*1+(2*b>s2>=a)*1)%2 == 1:
					# print tod,cnt,used,s1,s2,(2*b>s1>=a)*1,(b>s2>=a)*1
					flag = True
					break
			# print ""tod"",flag
			if flag:
				print ""YES""
			else:
				print ""NO""

		elif (cnt+used) %2 == 0:	
			print ""NO""
		else:
			print ""YES""
",['games']
3046,"A group of tourists is going to kayak and catamaran tour. A rented lorry has arrived to the boat depot to take kayaks and catamarans to the point of departure. It's known that all kayaks are of the same size (and each of them occupies the space of 1 cubic metre), and all catamarans are of the same size, but two times bigger than kayaks (and occupy the space of 2 cubic metres).Each waterborne vehicle has a particular carrying capacity, and it should be noted that waterborne vehicles that look the same can have different carrying capacities. Knowing the truck body volume and the list of waterborne vehicles in the boat depot (for each one its type and carrying capacity are known), find out such set of vehicles that can be taken in the lorry, and that has the maximum total carrying capacity. The truck body volume of the lorry can be used effectively, that is to say you can always put into the lorry a waterborne vehicle that occupies the space not exceeding the free space left in the truck body. nan R = lambda: map(int, input().split())
n, v= R()
k,c=[],[]
for i in range(n):
    t, a= R()
    if(t==1):   k+=[[a,i+1]]
    else:   c+=[[a,i+1]]
k.sort(reverse=True)
c.sort(reverse=True)
sum=0
klen = len(k)
clen= len(c)
y= min(klen,v)
for i in range(1,y):
    k[i][0]+=k[i-1][0]
for i in range(1,clen):
    c[i][0]+=c[i-1][0]
#print(k,c)
if y>0:   ans= k[y-1][0]
else:   ans=0
#print(ans)
j= int((v-y)/2)
if clen>0:
    if j>0 and j<clen:
        ans+=c[j-1][0]
    elif j>0:
        ans+=c[clen-1][0]
        j=clen
    #print(ans,j)
    if 2*j+y == v-1 and j<clen:
        if y>1 and ans<=c[j][0]+k[y-2][0]:
            ans= c[j][0]+k[y-2][0]
            j,y =j+1, y-1
        elif y==1 and ans<=c[j][0]:
            ans=c[j][0]
            y,j=0,j+1
    #print(ans,y,j)
    while y>2 and j<clen and ans<=c[j][0]+k[y-3][0]:
        ans= c[j][0]+k[y-3][0]
        j,y =j+1, y-2
    #print(ans,j)
    if y==2 and j<clen and ans<=c[j][0]:
        ans=c[j][0]
        y,j=0,j+1
print(ans)
s=""""
for i in range(y):  s+=str(k[i][1])+"" ""
for i in range(j):  s+=str(c[i][1])+"" ""
print(s)
    ","['greedy', 'sortings']"
4280,"There are n servers in a laboratory, each of them can perform tasks. Each server has a unique id — integer from 1 to n.It is known that during the day q tasks will come, the i-th of them is characterized with three integers: ti — the moment in seconds in which the task will come, ki — the number of servers needed to perform it, and di — the time needed to perform this task in seconds. All ti are distinct.To perform the i-th task you need ki servers which are unoccupied in the second ti. After the servers begin to perform the task, each of them will be busy over the next di seconds. Thus, they will be busy in seconds ti, ti + 1, ..., ti + di - 1. For performing the task, ki servers with the smallest ids will be chosen from all the unoccupied servers. If in the second ti there are not enough unoccupied servers, the task is ignored.Write the program that determines which tasks will be performed and which will be ignored. NoteIn the first example in the second 1 the first task will come, it will be performed on the servers with ids 1, 2 and 3 (the sum of the ids equals 6) during two seconds. In the second 2 the second task will come, it will be ignored, because only the server 4 will be unoccupied at that second. In the second 3 the third task will come. By this time, servers with the ids 1, 2 and 3 will be unoccupied again, so the third task will be done on all the servers with the ids 1, 2, 3 and 4 (the sum of the ids is 10).In the second example in the second 3 the first task will come, it will be performed on the servers with ids 1 and 2 (the sum of the ids is 3) during three seconds. In the second 5 the second task will come, it will be performed on the server 3, because the first two servers will be busy performing the first task. import sys

n, q = map(int, raw_input().split())
last_busy = [0] * (n + 1)
for _ in xrange(q):
    t, k, d = map(int, raw_input().split())
    free = []
    for server in xrange(1, n + 1):
        if last_busy[server] <= t:
            free.append(server)
        if len(free) == k:
            break
    if len(free) == k:
        sys.stdout.write(str(sum(free)) + ""\n"")
        for server in free:
            last_busy[server] = t + d
    else:
       sys.stdout.write(""-1\n"")
",['implementation']
279,"You have a long stick, consisting of $$$m$$$ segments enumerated from $$$1$$$ to $$$m$$$. Each segment is $$$1$$$ centimeter long. Sadly, some segments are broken and need to be repaired.You have an infinitely long repair tape. You want to cut some pieces from the tape and use them to cover all of the broken segments. To be precise, a piece of tape of integer length $$$t$$$ placed at some position $$$s$$$ will cover segments $$$s, s+1, \ldots, s+t-1$$$.You are allowed to cover non-broken segments; it is also possible that some pieces of tape will overlap.Time is money, so you want to cut at most $$$k$$$ continuous pieces of tape to cover all the broken segments. What is the minimum total length of these pieces? NoteIn the first example, you can use a piece of length $$$11$$$ to cover the broken segments $$$20$$$ and $$$30$$$, and another piece of length $$$6$$$ to cover $$$75$$$ and $$$80$$$, for a total length of $$$17$$$.In the second example, you can use a piece of length $$$4$$$ to cover broken segments $$$1$$$, $$$2$$$ and $$$4$$$, and two pieces of length $$$1$$$ to cover broken segments $$$60$$$ and $$$87$$$. n, m, k = [int(s) for s in input().split(' ')]
pos = [int(s) for s in input().split(' ')]
segments = []
need = n - k
for i in range(n-1):
    segment = pos[i+1] - pos[i]
    if segment == 1:
        need -= 1
    else:
        segments.append(segment-1)
segments = sorted(segments)
if need <= 0:
    print(n)
else:
    print(n + sum(segments[:need]))","['greedy', 'sortings']"
410,"Little Susie, thanks to her older brother, likes to play with cars. Today she decided to set up a tournament between them. The process of a tournament is described in the next paragraph.There are n toy cars. Each pair collides. The result of a collision can be one of the following: no car turned over, one car turned over, both cars turned over. A car is good if it turned over in no collision. The results of the collisions are determined by an n × n matrix А: there is a number on the intersection of the і-th row and j-th column that describes the result of the collision of the і-th and the j-th car:    - 1: if this pair of cars never collided.  - 1 occurs only on the main diagonal of the matrix.  0: if no car turned over during the collision.  1: if only the i-th car turned over during the collision.  2: if only the j-th car turned over during the collision.  3: if both cars turned over during the collision. Susie wants to find all the good cars. She quickly determined which cars are good. Can you cope with the task? nan def isFallen(n, matrix):
	fallen = [1 for i in range(n)]
	for i in range(n):
		for j in range(n):
			if i != j:
				if matrix[i][j] == 3:
					fallen[i] = 0
				if matrix[i][j] == 1:
					fallen[i] = 0
	survived = []
	for i in range(len(fallen)):
		if fallen[i] == 1:
			survived.append(i)
	return (survived)

def plus(x):
	return str(x + 1)

a = int(raw_input())
new = []
for i in range(a):
	b = raw_input()
	new.append(map(int, b.split("" "")))
ans = isFallen(a, new)
print len(ans)
ans = map(plus, ans)
print "" "".join(ans)
",['implementation']
1978,"A long time ago, in a galaxy far far away two giant IT-corporations Pineapple and Gogol continue their fierce competition. Crucial moment is just around the corner: Gogol is ready to release it's new tablet Lastus 3000.This new device is equipped with specially designed artificial intelligence (AI). Employees of Pineapple did their best to postpone the release of Lastus 3000 as long as possible. Finally, they found out, that the name of the new artificial intelligence is similar to the name of the phone, that Pineapple released 200 years ago. As all rights on its name belong to Pineapple, they stand on changing the name of Gogol's artificial intelligence.Pineapple insists, that the name of their phone occurs in the name of AI as a substring. Because the name of technology was already printed on all devices, the Gogol's director decided to replace some characters in AI name with ""#"". As this operation is pretty expensive, you should find the minimum number of characters to replace with ""#"", such that the name of AI doesn't contain the name of the phone as a substring.Substring is a continuous subsequence of a string. NoteIn the first sample AI's name may be replaced with ""int#llect"".In the second sample Gogol can just keep things as they are.In the third sample one of the new possible names of AI may be ""s#ris#ri"". s1=input()
s2=input()

print(s1.count(s2))","['constructive algorithms', 'greedy', 'strings']"
4509,"You are given two strings $$$s$$$ and $$$t$$$ consisting of lowercase Latin letters. Also you have a string $$$z$$$ which is initially empty. You want string $$$z$$$ to be equal to string $$$t$$$. You can perform the following operation to achieve this: append any subsequence of $$$s$$$ at the end of string $$$z$$$. A subsequence is a sequence that can be derived from the given sequence by deleting zero or more elements without changing the order of the remaining elements. For example, if $$$z = ac$$$, $$$s = abcde$$$, you may turn $$$z$$$ into following strings in one operation:   $$$z = acace$$$ (if we choose subsequence $$$ace$$$);  $$$z = acbcd$$$ (if we choose subsequence $$$bcd$$$);  $$$z = acbce$$$ (if we choose subsequence $$$bce$$$). Note that after this operation string $$$s$$$ doesn't change.Calculate the minimum number of such operations to turn string $$$z$$$ into string $$$t$$$.  nan #!/usr/bin/env pypy
from __future__ import division, print_function
from collections import defaultdict, Counter, deque
from future_builtins import ascii, filter, hex, map, oct, zip
from itertools import imap as map, izip as zip, permutations, combinations, combinations_with_replacement
from __builtin__ import xrange as range
from math import ceil, factorial
from _continuation import continulet
from cStringIO import StringIO
from io import IOBase
import __pypy__
from bisect import bisect, insort, bisect_left, bisect_right
from fractions import Fraction
from functools import reduce
import sys
import os
import re
inf = float('inf')
mod_ = int(1e9) + 7
mod = 998244353


def main():
	for _ in range(int(input())):
		s = input()
		t = input()
		position = defaultdict(list)
		for i in range(len(s)):
			position[s[i]].append(i)

		ans, tind, sind = 1, 0, 0
		for tind in range(len(t)):
			if t[tind] not in position:
				print(-1)
				break
			cind = bisect_left(position[t[tind]], sind)
			if cind == len(position[t[tind]]):
				sind = position[t[tind]][0] + 1
				ans += 1
			else:
				sind = position[t[tind]][cind] + 1
		else:
			print(ans)


BUFSIZE = 8192
class FastI(IOBase):
	def __init__(self, file):
		self._fd = file.fileno()
		self._buffer = StringIO()
		self.newlines = 0

	def read(self):
		while True:
			b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
			if not b:
				break
			ptr = self.buffer.tell()
			self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
		self.newlines = 0
		return self.buffer.read()

	def readline(self):
		while self.newlines == 0:
			b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
			self.newlines = b.count(""\n"") + (not b)
			ptr = self._buffer.tell()
			self._buffer.seek(0, 2), self._buffer.write(
				b), self._buffer.seek(ptr)
		self.newlines -= 1
		return self._buffer.readline()
class FastO(IOBase):
	def __init__(self, file):
		self._fd = file.fileno()
		self._buffer = __pypy__.builders.StringBuilder()
		self.write = lambda s: self._buffer.append(s)

	def flush(self):
		os.write(self._fd, self._buffer.build())
		self._buffer = __pypy__.builders.StringBuilder()
def print(*args, **kwargs):
	sep, file = kwargs.pop(""sep"", "" ""), kwargs.pop(""file"", sys.stdout)
	at_start = True
	for x in args:
		if not at_start:
			file.write(sep)
		file.write(str(x))
		at_start = False
	file.write(kwargs.pop(""end"", ""\n""))
	if kwargs.pop(""flush"", False):
		file.flush()
def gcd(x, y):
	while y:
		x, y = y, x % y
	return x
sys.stdin, sys.stdout = FastI(sys.stdin), FastO(sys.stdout)
def input(): return sys.stdin.readline().rstrip(""\r\n"")
if __name__ == ""__main__"":
	def bootstrap(cont):
		call, arg = cont.switch()
		while True:
			call, arg = cont.switch(to=continulet(
				lambda _, f, args: f(*args), call, arg))
	cont = continulet(bootstrap)
	cont.switch()
	main()","['dp', 'greedy', 'strings']"
2078,"You are a rebel leader and you are planning to start a revolution in your country. But the evil Government found out about your plans and set your punishment in the form of correctional labor.You must paint a fence which consists of $$$10^{100}$$$ planks in two colors in the following way (suppose planks are numbered from left to right from $$$0$$$):   if the index of the plank is divisible by $$$r$$$ (such planks have indices $$$0$$$, $$$r$$$, $$$2r$$$ and so on) then you must paint it red;  if the index of the plank is divisible by $$$b$$$ (such planks have indices $$$0$$$, $$$b$$$, $$$2b$$$ and so on) then you must paint it blue;  if the index is divisible both by $$$r$$$ and $$$b$$$ you can choose the color to paint the plank;  otherwise, you don't need to paint the plank at all (and it is forbidden to spent paint on it). Furthermore, the Government added one additional restriction to make your punishment worse. Let's list all painted planks of the fence in ascending order: if there are $$$k$$$ consecutive planks with the same color in this list, then the Government will state that you failed the labor and execute you immediately. If you don't paint the fence according to the four aforementioned conditions, you will also be executed.The question is: will you be able to accomplish the labor (the time is not important) or the execution is unavoidable and you need to escape at all costs. nan def gcd(a,b):
    if(b==0):
        return a
    return gcd(b,a%b)
t=int(input())
for _ in range(t):
    r,b,k=map(int,input().split())
    mini=min(r,b)
    maxi=max(r,b)
    gg=gcd(mini,maxi)
    mini=mini//gg
    maxi=maxi//gg
    if((k-1)*mini+1<maxi):
        print(""REBEL"")
    else:
        print(""OBEY"")
    ","['greedy', 'math', 'number theory']"
1609,"Suppose you had an array $$$A$$$ of $$$n$$$ elements, each of which is $$$0$$$ or $$$1$$$.Let us define a function $$$f(k,A)$$$ which returns another array $$$B$$$, the result of sorting the first $$$k$$$ elements of $$$A$$$ in non-decreasing order. For example, $$$f(4,[0,1,1,0,0,1,0]) = [0,0,1,1,0,1,0]$$$. Note that the first $$$4$$$ elements were sorted.Now consider the arrays $$$B_1, B_2,\ldots, B_n$$$ generated by $$$f(1,A), f(2,A),\ldots,f(n,A)$$$. Let $$$C$$$ be the array obtained by taking the element-wise sum of $$$B_1, B_2,\ldots, B_n$$$.For example, let $$$A=[0,1,0,1]$$$. Then we have $$$B_1=[0,1,0,1]$$$, $$$B_2=[0,1,0,1]$$$, $$$B_3=[0,0,1,1]$$$, $$$B_4=[0,0,1,1]$$$. Then $$$C=B_1+B_2+B_3+B_4=[0,1,0,1]+[0,1,0,1]+[0,0,1,1]+[0,0,1,1]=[0,2,2,4]$$$.You are given $$$C$$$. Determine a binary array $$$A$$$ that would give $$$C$$$ when processed as above. It is guaranteed that an array $$$A$$$ exists for given $$$C$$$ in the input.  NoteHere's the explanation for the first test case. Given that $$$A=[1,1,0,1]$$$, we can construct each $$$B_i$$$:   $$$B_1=[\color{blue}{1},1,0,1]$$$;  $$$B_2=[\color{blue}{1},\color{blue}{1},0,1]$$$;  $$$B_3=[\color{blue}{0},\color{blue}{1},\color{blue}{1},1]$$$;  $$$B_4=[\color{blue}{0},\color{blue}{1},\color{blue}{1},\color{blue}{1}]$$$  And then, we can sum up each column above to get $$$C=[1+1+0+0,1+1+1+1,0+0+1+1,1+1+1+1]=[2,4,2,4]$$$. import sys

input = lambda: sys.stdin.buffer.readline().decode().strip()
for _ in range(int(input())):
    n, a = int(input()), [int(x) for x in input().split()]
    ans, ones = [], sum(a) // n
    mem = [0] * (n + 1)

    for i in reversed(range(n)):
        mem[i] += mem[i + 1]
        a[i] -= mem[i]

        if a[i] == i + 1:
            mem[i] += 1
            mem[i - ones] -= 1
            ones -= 1
            ans.append(1)
        elif a[i] == 1:
            mem[i] += 1
            mem[i - ones] -= 1
            ans.append(0)
        else:
            ans.extend([0] * (i + 1))
            break
    print(*ans[::-1])
","['constructive algorithms', 'data structures', 'greedy', 'implementation', 'math', 'two pointers']"
1769,"On the well-known testing system MathForces, a draw of $$$n$$$ rating units is arranged. The rating will be distributed according to the following algorithm: if $$$k$$$ participants take part in this event, then the $$$n$$$ rating is evenly distributed between them and rounded to the nearest lower integer, At the end of the drawing, an unused rating may remain — it is not given to any of the participants.For example, if $$$n = 5$$$ and $$$k = 3$$$, then each participant will recieve an $$$1$$$ rating unit, and also $$$2$$$ rating units will remain unused. If $$$n = 5$$$, and $$$k = 6$$$, then none of the participants will increase their rating.Vasya participates in this rating draw but does not have information on the total number of participants in this event. Therefore, he wants to know what different values of the rating increment are possible to get as a result of this draw and asks you for help.For example, if $$$n=5$$$, then the answer is equal to the sequence $$$0, 1, 2, 5$$$. Each of the sequence values (and only them) can be obtained as $$$\lfloor n/k \rfloor$$$ for some positive integer $$$k$$$ (where $$$\lfloor x \rfloor$$$ is the value of $$$x$$$ rounded down): $$$0 = \lfloor 5/7 \rfloor$$$, $$$1 = \lfloor 5/5 \rfloor$$$, $$$2 = \lfloor 5/2 \rfloor$$$, $$$5 = \lfloor 5/1 \rfloor$$$.Write a program that, for a given $$$n$$$, finds a sequence of all possible rating increments. nan from math import sqrt
from sys import stdin, stdout
for i in range(int(input())):
  n = int(input())
  s,j,l = set([0,1]), 2, sqrt(n)
  while j <= l:
    s.add(j)
    s.add(int(n//j))
    j += 1
  s.add(n)
  a,l = sorted(s), len(s)
  stdout.write('%d\n' % l)
  for j in range(l):
    stdout.write('%d ' % a[j])
  stdout.write('\n')
","['binary search', 'math', 'number theory', 'other']"
4567,"In a far away kingdom young pages help to set the table for the King. As they are terribly mischievous, one needs to keep an eye on the control whether they have set everything correctly. This time the royal chef Gerasim had the impression that the pages have played a prank again: they had poured the juice from one cup to another. Now Gerasim wants to check his hypothesis. The good thing is that chef Gerasim always pour the same number of milliliters of juice to all cups in the royal kitchen. Having thoroughly measured the juice in each cup, Gerasim asked you to write a program that will determine from which cup juice was poured to which one; otherwise, the program should determine that this time the pages set the table diligently.To simplify your task we shall consider the cups to be bottomless so that the juice never overfills a cup and pours out, however much it can be. Besides, by some strange reason in a far away kingdom one can only pour to a cup or from one cup to another an integer number of milliliters of juice. nan 


def middleCount(lis, m):
  count = 0

  for a,b in lis:
    if a == m:
      count += 1

  return count	  


n = int(raw_input())

lis = []

first = -1

allUnique = True

for i in range(n):
  l = int(raw_input())
  lis.append((l, i+1))
  
  if first == -1:
    first = l
	
  if l != first:
    allUnique = False  

lis.sort()

if allUnique:
  print ""Exemplary pages.""
elif len(lis) == 2:
  if (lis[0][0] + lis[1][0]) % 2 == 0:
    initial = (lis[0][0] + lis[1][0]) / 2
    print str(initial - lis[0][0]) + "" ml. from cup #"" + str(lis[0][1]) + "" to cup #"" + str(lis[-1][1]) + ""."" 	
  else:
    print ""Unrecoverable configuration.""  
else:
  if len(lis) == 4 and lis[1][0] != lis[-2][0]:
    print ""Unrecoverable configuration."" 
  elif middleCount(lis, lis[1][0]) == (len(lis) - 2) and (lis[1][0] - lis[0][0]) == (lis[-1][0] - lis[-2][0]):
    print str(lis[1][0] - lis[0][0]) + "" ml. from cup #"" + str(lis[0][1]) + "" to cup #"" + str(lis[-1][1]) + ""."" 
  else:
    print ""Unrecoverable configuration.""  


  ","['implementation', 'sortings']"
2932,"$$$ \def\myred#1{\color{red}{\underline{\bf{#1}}}} \def\myblue#1{\color{blue}{\overline{\bf{#1}}}} $$$ $$$\def\RED{\myred{Red}} \def\BLUE{\myblue{Blue}}$$$You are given a sequence of $$$n$$$ non-negative integers $$$a_1, a_2, \ldots, a_n$$$. Initially, all the elements of the sequence are unpainted. You can paint each number $$$\RED$$$ or $$$\BLUE$$$ (but not both), or leave it unpainted. For a color $$$c$$$, $$$\text{Count}(c)$$$ is the number of elements in the sequence painted with that color and $$$\text{Sum}(c)$$$ is the sum of the elements in the sequence painted with that color.For example, if the given sequence is $$$[2, 8, 6, 3, 1]$$$ and it is painted this way: $$$[\myblue{2}, 8, \myred{6}, \myblue{3}, 1]$$$ (where $$$6$$$ is painted red, $$$2$$$ and $$$3$$$ are painted blue, $$$1$$$ and $$$8$$$ are unpainted) then $$$\text{Sum}(\RED)=6$$$, $$$\text{Sum}(\BLUE)=2+3=5$$$, $$$\text{Count}(\RED)=1$$$, and $$$\text{Count}(\BLUE)=2$$$.Determine if it is possible to paint the sequence so that $$$\text{Sum}(\RED) &gt; \text{Sum}(\BLUE)$$$ and $$$\text{Count}(\RED) &lt; \text{Count}(\BLUE)$$$. NoteIn the first test case, there is no possible way to paint the sequence. For example, if you paint the sequence this way: $$$[\myblue{1},\myblue{2},\myred{3}]$$$ (where $$$3$$$ is painted red, $$$1$$$ and $$$2$$$ are painted blue) then $$$\text{Count}(\RED)=1 &lt; \text{Count}(\BLUE)=2$$$, but $$$\text{Sum}(\RED)=3 \ngtr \text{Sum}(\BLUE)=3$$$. So, this is not a possible way to paint the sequence.In the second test case, a possible way to paint the sequence is described in the statement. We can see that $$$\text{Sum}(\RED)=6 &gt; \text{Sum}(\BLUE)=5$$$ and $$$\text{Count}(\RED)=1 &lt; \text{Count}(\BLUE)=2$$$.In the third test case, there is no possible way to paint the sequence. For example, if you paint the sequence this way: $$$[\myred{3},\myred{5},\myblue{4}, \myblue{2}]$$$ (where $$$3$$$ and $$$5$$$ are painted red, $$$4$$$ and $$$2$$$ are painted blue) then $$$\text{Sum}(\RED) = 8 &gt; \text{Sum}(\BLUE) = 6$$$ but $$$\text{Count}(\RED) = 2 \nless \text{Count}(\BLUE) = 2$$$. So, this is not a possible way to paint the sequence.In the fourth test case, it can be proven that there is no possible way to paint the sequence satisfying sum and count constraints. def main():
    cases = read_cases()
    results = process_cases(cases)

    for r in results:
        print(r)


def read_cases():
    num_cases = int(input())
    cases = []
    for i in range(0, num_cases):
        input()
        case_string = input()
        case_el_strings = case_string.split(' ')

        case_array = list(map(int, case_el_strings))
        case_array.sort()
        cases.append(case_array)
    return cases


def process_cases(cases):
    return list(map(process_case, cases))


def process_case(case) -> str:
    output = ""no""

    indent = 1 if len(case) % 2 == 0 else 0  # ok
    red_sum = case[len(case) - 1]
    blue_sum = sum(case[0:len(case) - 1 - indent])
    # print('blue_sum', blue_sum)
    # print('red_sum', red_sum)
    if red_sum > blue_sum:
        return ""yes""
    for j in range(len(case) - 2, int(len(case) / 2), -1):
        blue_sum -= case[j - indent]
        red_sum += case[j]
        # print(""blue el"", case[j - 1], j)
        # print(""red el"", case[j], j + 1)
        # print('blue_sum', blue_sum)
        # print('red_sum', red_sum)
        if red_sum > blue_sum:
            output = ""yes""
            break
    return output


if __name__ == ""__main__"":
    main()
","['brute force', 'constructive algorithms', 'greedy', 'sortings', 'two pointers']"
1862,"When Valera has got some free time, he goes to the library to read some books. Today he's got t free minutes to read. That's why Valera took n books in the library and for each book he estimated the time he is going to need to read it. Let's number the books by integers from 1 to n. Valera needs ai minutes to read the i-th book.Valera decided to choose an arbitrary book with number i and read the books one by one, starting from this book. In other words, he will first read book number i, then book number i + 1, then book number i + 2 and so on. He continues the process until he either runs out of the free time or finishes reading the n-th book. Valera reads each book up to the end, that is, he doesn't start reading the book if he doesn't have enough free time to finish reading it. Print the maximum number of books Valera can read. nan books, free_time = map(int, input().split())
time_arr = list(map(int, input().split()))

from_index = -1
read_time, max_count = 0, 0
for i in range(books):
    if read_time + time_arr[i] <= free_time:
        read_time += time_arr[i]
    else:
        read_time += time_arr[i]
        while read_time > free_time:
            from_index += 1
            read_time -= time_arr[from_index]

    max_count = max(max_count, i - from_index)

print(max_count)","['binary search', 'brute force', 'implementation', 'two pointers']"
1743,"Pavel cooks barbecue. There are n skewers, they lay on a brazier in a row, each on one of n positions. Pavel wants each skewer to be cooked some time in every of n positions in two directions: in the one it was directed originally and in the reversed direction.Pavel has a plan: a permutation p and a sequence b1, b2, ..., bn, consisting of zeros and ones. Each second Pavel move skewer on position i to position pi, and if bi equals 1 then he reverses it. So he hope that every skewer will visit every position in both directions.Unfortunately, not every pair of permutation p and sequence b suits Pavel. What is the minimum total number of elements in the given permutation p and the given sequence b he needs to change so that every skewer will visit each of 2n placements? Note that after changing the permutation should remain a permutation as well.There is no problem for Pavel, if some skewer visits some of the placements several times before he ends to cook. In other words, a permutation p and a sequence b suit him if there is an integer k (k ≥ 2n), so that after k seconds each skewer visits each of the 2n placements.It can be shown that some suitable pair of permutation p and sequence b exists for any n. NoteIn the first example Pavel can change the permutation to 4, 3, 1, 2.In the second example Pavel can change any element of b to 1. import sys
sys.setrecursionlimit(10 ** 9)


n = int(input())
p = list(map(int, input().split()))
b = list(map(int, input().split()))

used = [False] * n
comp = 0
for i in range(n):
    if not used[i]:
        u = i
        while True:
            used[u] = True
            v = p[u] - 1
            if not used[v]:
                u = v
            else:
                break
            
        comp += 1

if comp == 1:
    ans = 0
else:
    ans = comp

ed = 0
for i in range(n):
    if b[i]:
        ed += 1

if not ed % 2:
    ans += 1
    
print(ans)","['constructive algorithms', 'dfs and similar', 'graphs']"
478,"Recently, Masha was presented with a chessboard with a height of $$$n$$$ and a width of $$$m$$$.The rows on the chessboard are numbered from $$$1$$$ to $$$n$$$ from bottom to top. The columns are numbered from $$$1$$$ to $$$m$$$ from left to right. Therefore, each cell can be specified with the coordinates $$$(x,y)$$$, where $$$x$$$ is the column number, and $$$y$$$ is the row number (do not mix up).Let us call a rectangle with coordinates $$$(a,b,c,d)$$$ a rectangle lower left point of which has coordinates $$$(a,b)$$$, and the upper right one — $$$(c,d)$$$.The chessboard is painted black and white as follows:   An example of a chessboard. Masha was very happy with the gift and, therefore, invited her friends Maxim and Denis to show off. The guys decided to make her a treat — they bought her a can of white and a can of black paint, so that if the old board deteriorates, it can be repainted. When they came to Masha, something unpleasant happened: first, Maxim went over the threshold and spilled white paint on the rectangle $$$(x_1,y_1,x_2,y_2)$$$. Then after him Denis spilled black paint on the rectangle $$$(x_3,y_3,x_4,y_4)$$$.To spill paint of color $$$color$$$ onto a certain rectangle means that all the cells that belong to the given rectangle become $$$color$$$. The cell dyeing is superimposed on each other (if at first some cell is spilled with white paint and then with black one, then its color will be black).Masha was shocked! She drove away from the guests and decided to find out how spoiled the gift was. For this, she needs to know the number of cells of white and black color. Help her find these numbers! NoteExplanation for examples:The first picture of each illustration shows how the field looked before the dyes were spilled. The second picture of each illustration shows how the field looked after Maxim spoiled white dye (the rectangle on which the dye was spilled is highlighted with red). The third picture in each illustration shows how the field looked after Denis spoiled black dye (the rectangle on which the dye was spilled is highlighted with red).In the first test, the paint on the field changed as follows:  In the second test, the paint on the field changed as follows:  In the third test, the paint on the field changed as follows:  In the fourth test, the paint on the field changed as follows:  In the fifth test, the paint on the field changed as follows:   #!/usr/bin/env python3
import sys

def rint():
    return map(int, sys.stdin.readline().split())
#lines = stdin.readlines()


def cnt_b(xx1, yy1, xx2, yy2):
    w = xx2 - xx1 + 1
    h = yy2 - yy1 + 1
    return w*h - cnt_w(xx1, yy1, xx2, yy2)


def cnt_w(xx1, yy1, xx2, yy2):
    w = xx2 - xx1 + 1
    h = yy2 - yy1 + 1
    cnt = (w*h)//2
    if w%2 and h%2:
        if xx1%2 and yy1%2 or xx1%2 == 0 and yy1%2 == 0:
            cnt+=1
    return cnt


def area(w, h):
    return w*h


def cross_rect(x1, y1, x2, y2, x3, y3, x4, y4):
    xl = max(x1, x3)
    xr = min(x2, x4)
    yl = max(y1, y3)
    yr = min(y2, y4)
    if xl <= xr and yl <= yr:
        return xl, yl, xr, yr
    else:
        return -1, -1, -1, -1


t = int(input())
for i in range(t):
    n, m = rint()
    x1, y1, x2, y2 = rint()
    x3, y3, x4, y4 = rint()
    tot_w = cnt_w(1, 1, m, n)
    wc = tot_w + cnt_b(x1, y1, x2, y2)
    wc -= cnt_w(x3, y3, x4, y4)
    xl, yl, xr, yr = cross_rect(x1, y1, x2, y2, x3, y3, x4, y4)
    if xl != -1:
        wc -= cnt_b(xl, yl, xr, yr)
    print(wc, m*n - wc)


",['implementation']
1272,"Given an array of $$$n$$$ positive integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 1000$$$). Find the maximum value of $$$i + j$$$ such that $$$a_i$$$ and $$$a_j$$$ are coprime,$$$^{\dagger}$$$ or $$$-1$$$ if no such $$$i$$$, $$$j$$$ exist.For example consider the array $$$[1, 3, 5, 2, 4, 7, 7]$$$. The maximum value of $$$i + j$$$ that can be obtained is $$$5 + 7$$$, since $$$a_5 = 4$$$ and $$$a_7 = 7$$$ are coprime.$$$^{\dagger}$$$ Two integers $$$p$$$ and $$$q$$$ are coprime if the only positive integer that is a divisor of both of them is $$$1$$$ (that is, their greatest common divisor is $$$1$$$). NoteFor the first test case, we can choose $$$i = j = 3$$$, with sum of indices equal to $$$6$$$, since $$$1$$$ and $$$1$$$ are coprime.For the second test case, we can choose $$$i = 7$$$ and $$$j = 5$$$, with sum of indices equal to $$$7 + 5 = 12$$$, since $$$7$$$ and $$$4$$$ are coprime. num = int(input())
res = []
factors = [{1}, {1, 2}, {1, 3}, {1, 2}, {1, 5}, {1, 2, 3}, {1, 7}, {1, 2}, {1, 3}, {1, 2, 5}, {1, 11}, {1, 2, 3}, {1, 13}, {1, 2, 7}, {1, 3, 5}, {1, 2}, {1, 17}, {1, 2, 3}, {1, 19}, {1, 2, 5}, {1, 3, 7}, {1, 2, 11}, {1, 23}, {1, 2, 3}, {1, 5}, {1, 2, 13}, {1, 3}, {1, 2, 7}, {1, 29}, {1, 2, 3, 5}, {1, 31}, {1, 2}, {3, 1, 11}, {1, 2, 17}, {1, 5, 7}, {1, 2, 3}, {1, 37}, {1, 2, 19}, {1, 3, 13}, {1, 2, 5}, {1, 41}, {1, 2, 3, 7}, {1, 43}, {1, 2, 11}, {1, 3, 5}, {1, 2, 23}, {1, 47}, {1, 2, 3}, {1, 7}, {1, 2, 5}, {1, 3, 17}, {1, 2, 13}, {1, 53}, {1, 2, 3}, {1, 11, 5}, {1, 2, 7}, {3, 1, 19}, {1, 2, 29}, {1, 59}, {1, 2, 3, 5}, {1, 61}, {1, 2, 31}, {1, 3, 7}, {1, 2}, {1, 5, 13}, {3, 1, 2, 11}, {1, 67}, {1, 2, 17}, {1, 3, 23}, {1, 2, 5, 7}, {1, 71}, {1, 2, 3}, {73, 1}, {1, 2, 37}, {1, 3, 5}, {1, 2, 19}, {1, 11, 7}, {1, 2, 3, 13}, {1, 79}, {1, 2, 5}, {1, 3}, {1, 2, 41}, {1, 83}, {1, 2, 3, 7}, {1, 5, 17}, {1, 2, 43}, {1, 3, 29}, {1, 2, 11}, {89, 1}, {1, 2, 3, 5}, {1, 13, 7}, {1, 2, 23}, {1, 3, 31}, {1, 2, 47}, {1, 19, 5}, {1, 2, 3}, {1, 97}, {1, 2, 7}, {3, 1, 11}, {1, 2, 5}, {1, 101}, {1, 2, 3, 17}, {1, 103}, {1, 2, 13}, {1, 3, 5, 7}, {1, 2, 53}, {1, 107}, {1, 2, 3}, {1, 109}, {1, 2, 11, 5}, {1, 3, 37}, {1, 2, 7}, {1, 113}, {3, 1, 2, 19}, {1, 5, 23}, {1, 2, 29}, {1, 3, 13}, {1, 2, 59}, {1, 17, 7}, {1, 2, 3, 5}, {1, 11}, {1, 2, 61}, {1, 3, 41}, {1, 2, 31}, {1, 5}, {1, 2, 3, 7}, {1, 127}, {1, 2}, {3, 1, 43}, {1, 2, 5, 13}, {1, 131}, {3, 1, 2, 11}, {1, 19, 7}, {1, 2, 67}, {1, 3, 5}, {1, 2, 17}, {1, 137}, {1, 2, 3, 23}, {1, 139}, {1, 2, 5, 7}, {1, 3, 47}, {1, 2, 71}, {1, 11, 13}, {1, 2, 3}, {1, 5, 29}, {73, 1, 2}, {1, 3, 7}, {1, 2, 37}, {1, 149}, {1, 2, 3, 5}, {1, 151}, {1, 2, 19}, {1, 3, 17}, {1, 2, 11, 7}, {1, 5, 31}, {1, 2, 3, 13}, {1, 157}, {1, 2, 79}, {1, 3, 53}, {1, 2, 5}, {1, 7, 23}, {1, 2, 3}, {1, 163}, {1, 2, 41}, {3, 1, 11, 5}, {1, 2, 83}, {1, 167}, {1, 2, 3, 7}, {1, 13}, {1, 2, 5, 17}, {3, 1, 19}, {1, 2, 43}, {1, 173}, {1, 2, 3, 29}, {1, 5, 7}, {1, 2, 11}, {3, 1, 59}, {89, 1, 2}, {1, 179}, {1, 2, 3, 5}, {1, 181}, {1, 2, 13, 7}, {1, 3, 61}, {1, 2, 23}, {1, 5, 37}, {1, 2, 3, 31}, {1, 11, 17}, {1, 2, 47}, {1, 3, 7}, {1, 2, 19, 5}, {1, 191}, {1, 2, 3}, {1, 193}, {1, 2, 97}, {1, 5, 3, 13}, {1, 2, 7}, {1, 197}, {3, 1, 2, 11}, {1, 199}, {1, 2, 5}, {3, 1, 67}, {1, 2, 101}, {1, 29, 7}, {1, 2, 3, 17}, {1, 5, 41}, {1, 2, 103}, {1, 3, 23}, {1, 2, 13}, {11, 1, 19}, {1, 2, 3, 5, 7}, {1, 211}, {1, 2, 53}, {1, 3, 71}, {1, 2, 107}, {1, 43, 5}, {1, 2, 3}, {1, 7, 31}, {1, 2, 109}, {73, 1, 3}, {1, 2, 11, 5}, {1, 13, 17}, {1, 2, 3, 37}, {1, 223}, {1, 2, 7}, {1, 3, 5}, {1, 2, 113}, {1, 227}, {3, 1, 2, 19}, {1, 229}, {1, 2, 5, 23}, {3, 1, 11, 7}, {1, 2, 29}, {1, 233}, {1, 2, 3, 13}, {1, 5, 47}, {1, 2, 59}, {1, 3, 79}, {1, 2, 17, 7}, {1, 239}, {1, 2, 3, 5}, {1, 241}, {1, 2, 11}, {1, 3}, {1, 2, 61}, {1, 5, 7}, {1, 2, 3, 41}, {1, 19, 13}, {1, 2, 31}, {3, 1, 83}, {1, 2, 5}, {1, 251}, {1, 2, 3, 7}, {1, 11, 23}, {1, 2, 127}, {1, 3, 5, 17}, {1, 2}, {1, 257}, {3, 1, 2, 43}, {1, 37, 7}, {1, 2, 5, 13}, {1, 3, 29}, {1, 2, 131}, {1, 263}, {3, 1, 2, 11}, {1, 5, 53}, {1, 2, 19, 7}, {89, 1, 3}, {1, 2, 67}, {1, 269}, {1, 2, 3, 5}, {1, 271}, {1, 2, 17}, {1, 3, 13, 7}, {1, 137, 2}, {1, 11, 5}, {1, 2, 3, 23}, {1, 277}, {1, 2, 139}, {1, 3, 31}, {1, 2, 5, 7}, {1, 281}, {1, 2, 3, 47}, {1, 283}, {1, 2, 71}, {3, 1, 19, 5}, {1, 2, 11, 13}, {1, 7, 41}, {1, 2, 3}, {1, 17}, {1, 2, 5, 29}, {1, 3, 97}, {73, 1, 2}, {1, 293}, {1, 2, 3, 7}, {1, 59, 5}, {1, 2, 37}, {3, 1, 11}, {1, 2, 149}, {1, 13, 23}, {1, 2, 3, 5}, {1, 43, 7}, {1, 2, 151}, {1, 3, 101}, {1, 2, 19}, {1, 5, 61}, {1, 2, 3, 17}, {1, 307}, {1, 2, 11, 7}, {1, 3, 103}, {1, 2, 5, 31}, {1, 311}, {1, 2, 3, 13}, {1, 313}, {1, 2, 157}, {1, 3, 5, 7}, {1, 2, 79}, {1, 317}, {1, 2, 3, 53}, {1, 11, 29}, {1, 2, 5}, {3, 1, 107}, {1, 2, 7, 23}, {1, 19, 17}, {1, 2, 3}, {1, 5, 13}, {1, 2, 163}, {1, 3, 109}, {1, 2, 41}, {1, 7, 47}, {1, 2, 3, 5, 11}, {1, 331}, {1, 2, 83}, {1, 3, 37}, {1, 2, 167}, {1, 67, 5}, {1, 2, 3, 7}, {337, 1}, {1, 2, 13}, {1, 3, 113}, {1, 2, 5, 17}, {1, 11, 31}, {3, 1, 2, 19}, {1, 7}, {1, 2, 43}, {1, 3, 5, 23}, {1, 2, 173}, {1, 347}, {1, 2, 3, 29}, {1, 349}, {1, 2, 5, 7}, {1, 3, 13}, {1, 2, 11}, {1, 353}, {3, 1, 2, 59}, {1, 5, 71}, {89, 1, 2}, {1, 3, 17, 7}, {1, 2, 179}, {1, 359}, {1, 2, 3, 5}, {1, 19}, {1, 2, 181}, {3, 1, 11}, {1, 2, 13, 7}, {73, 1, 5}, {1, 2, 3, 61}, {1, 367}, {1, 2, 23}, {1, 3, 41}, {1, 2, 5, 37}, {1, 53, 7}, {1, 2, 3, 31}, {1, 373}, {1, 2, 11, 17}, {1, 3, 5}, {1, 2, 47}, {1, 13, 29}, {1, 2, 3, 7}, {1, 379}, {1, 2, 19, 5}, {1, 3, 127}, {1, 2, 191}, {1, 383}, {1, 2, 3}, {1, 11, 5, 7}, {1, 2, 193}, {3, 1, 43}, {1, 2, 97}, {1, 389}, {1, 2, 3, 5, 13}, {1, 17, 23}, {1, 2, 7}, {1, 3, 131}, {1, 2, 197}, {1, 5, 79}, {3, 1, 2, 11}, {1, 397}, {1, 2, 199}, {3, 1, 19, 7}, {1, 2, 5}, {1, 401}, {3, 1, 2, 67}, {1, 13, 31}, {1, 2, 101}, {1, 3, 5}, {1, 2, 29, 7}, {1, 11, 37}, {1, 2, 3, 17}, {1, 409}, {1, 2, 5, 41}, {1, 137, 3}, {1, 2, 103}, {1, 59, 7}, {1, 2, 3, 23}, {1, 83, 5}, {1, 2, 13}, {1, 3, 139}, {11, 1, 2, 19}, {1, 419}, {1, 2, 3, 5, 7}, {1, 421}, {1, 2, 211}, {1, 3, 47}, {1, 2, 53}, {1, 5, 17}, {1, 2, 3, 71}, {1, 61, 7}, {1, 2, 107}, {3, 1, 11, 13}, {1, 2, 43, 5}, {1, 431}, {1, 2, 3}, {1, 433}, {1, 2, 7, 31}, {1, 5, 3, 29}, {1, 2, 109}, {1, 19, 23}, {73, 1, 2, 3}, {1, 439}, {1, 2, 11, 5}, {1, 3, 7}, {1, 2, 13, 17}, {1, 443}, {1, 2, 3, 37}, {89, 1, 5}, {1, 2, 223}, {1, 3, 149}, {1, 2, 7}, {1, 449}, {1, 2, 3, 5}, {1, 11, 41}, {1, 2, 113}, {1, 3, 151}, {1, 2, 227}, {1, 5, 13, 7}, {3, 1, 2, 19}, {1, 457}, {1, 2, 229}, {1, 3, 17}, {1, 2, 5, 23}, {1, 461}, {1, 2, 3, 7, 11}, {1, 463}, {1, 2, 29}, {1, 3, 5, 31}, {1, 2, 233}, {1, 467}, {1, 2, 3, 13}, {1, 67, 7}, {1, 2, 5, 47}, {1, 3, 157}, {1, 2, 59}, {11, 1, 43}, {1, 2, 3, 79}, {1, 19, 5}, {1, 2, 17, 7}, {1, 3, 53}, {1, 2, 239}, {1, 479}, {1, 2, 3, 5}, {1, 13, 37}, {1, 2, 241}, {1, 3, 7, 23}, {1, 2, 11}, {1, 5, 97}, {1, 2, 3}, {1, 487}, {1, 2, 61}, {1, 3, 163}, {1, 2, 5, 7}, {1, 491}, {1, 2, 3, 41}, {1, 29, 17}, {1, 2, 19, 13}, {3, 1, 11, 5}, {1, 2, 31}, {1, 7, 71}, {3, 1, 2, 83}, {1, 499}, {1, 2, 5}, {1, 3, 167}, {1, 2, 251}, {1, 503}, {1, 2, 3, 7}, {1, 5, 101}, {1, 2, 11, 23}, {1, 3, 13}, {1, 2, 127}, {1, 509}, {1, 2, 3, 5, 17}, {73, 1, 7}, {1, 2}, {3, 1, 19}, {1, 2, 257}, {1, 5, 103}, {3, 1, 2, 43}, {1, 11, 47}, {1, 2, 37, 7}, {1, 3, 173}, {1, 2, 5, 13}, {1, 521}, {1, 2, 3, 29}, {1, 523}, {1, 2, 131}, {1, 3, 5, 7}, {1, 2, 263}, {1, 17, 31}, {3, 1, 2, 11}, {1, 23}, {1, 2, 5, 53}, {3, 1, 59}, {1, 2, 19, 7}, {1, 13, 41}, {89, 1, 2, 3}, {1, 107, 5}, {1, 2, 67}, {1, 3, 179}, {1, 2, 269}, {1, 11, 7}, {1, 2, 3, 5}, {1, 541}, {1, 2, 271}, {1, 3, 181}, {1, 2, 17}, {1, 5, 109}, {1, 2, 3, 7, 13}, {1, 547}, {1, 137, 2}, {1, 3, 61}, {1, 2, 11, 5}, {1, 19, 29}, {1, 2, 3, 23}, {1, 7, 79}, {1, 2, 277}, {1, 5, 3, 37}, {1, 2, 139}, {1, 557}, {1, 2, 3, 31}, {1, 43, 13}, {1, 2, 5, 7}, {3, 1, 11, 17}, {1, 2, 281}, {1, 563}, {1, 2, 3, 47}, {1, 5, 113}, {1, 2, 283}, {1, 3, 7}, {1, 2, 71}, {1, 569}, {1, 2, 3, 5, 19}, {1, 571}, {1, 2, 11, 13}, {1, 3, 191}, {1, 2, 7, 41}, {1, 5, 23}, {1, 2, 3}, {577, 1}, {1, 2, 17}, {1, 3, 193}, {1, 2, 5, 29}, {1, 83, 7}, {1, 2, 3, 97}, {1, 11, 53}, {73, 1, 2}, {1, 5, 3, 13}, {1, 2, 293}, {1, 587}, {1, 2, 3, 7}, {1, 19, 31}, {1, 2, 59, 5}, {1, 3, 197}, {1, 2, 37}, {593, 1}, {3, 1, 2, 11}, {1, 5, 17, 7}, {1, 2, 149}, {1, 3, 199}, {1, 2, 13, 23}, {1, 599}, {1, 2, 3, 5}, {601, 1}, {1, 2, 43, 7}, {3, 1, 67}, {1, 2, 151}, {1, 11, 5}, {1, 2, 3, 101}, {1, 607}, {1, 2, 19}, {1, 3, 29, 7}, {1, 2, 5, 61}, {1, 13, 47}, {1, 2, 3, 17}, {1, 613}, {1, 2, 307}, {1, 3, 5, 41}, {1, 2, 11, 7}, {1, 617}, {1, 2, 3, 103}, {1, 619}, {1, 2, 5, 31}, {1, 3, 23}, {1, 2, 311}, {89, 1, 7}, {1, 2, 3, 13}, {1, 5}, {1, 2, 313}, {19, 1, 11, 3}, {1, 2, 157}, {1, 37, 17}, {1, 2, 3, 5, 7}, {1, 631}, {1, 2, 79}, {1, 3, 211}, {1, 2, 317}, {1, 5, 127}, {1, 2, 3, 53}, {1, 13, 7}, {1, 2, 11, 29}, {1, 3, 71}, {1, 2, 5}, {1, 641}, {3, 1, 2, 107}, {1, 643}, {1, 2, 7, 23}, {3, 1, 43, 5}, {1, 2, 19, 17}, {1, 647}, {1, 2, 3}, {11, 1, 59}, {1, 2, 5, 13}, {1, 3, 7, 31}, {1, 2, 163}, {1, 653}, {1, 2, 3, 109}, {1, 131, 5}, {1, 2, 41}, {73, 1, 3}, {1, 2, 7, 47}, {1, 659}, {1, 2, 3, 5, 11}, {1, 661}, {1, 2, 331}, {1, 3, 13, 17}, {1, 2, 83}, {1, 19, 5, 7}, {1, 2, 3, 37}, {1, 29, 23}, {1, 2, 167}, {1, 3, 223}, {1, 2, 67, 5}, {1, 11, 61}, {1, 2, 3, 7}, {1, 673}, {337, 1, 2}, {1, 3, 5}, {1, 2, 13}, {1, 677}, {1, 2, 3, 113}, {1, 97, 7}, {1, 2, 5, 17}, {1, 3, 227}, {1, 2, 11, 31}, {1, 683}, {3, 1, 2, 19}, {1, 137, 5}, {1, 2, 7}, {1, 3, 229}, {1, 2, 43}, {1, 13, 53}, {1, 2, 3, 5, 23}, {1, 691}, {1, 2, 173}, {3, 1, 11, 7}, {1, 2, 347}, {1, 139, 5}, {1, 2, 3, 29}, {1, 17, 41}, {1, 2, 349}, {1, 3, 233}, {1, 2, 5, 7}, {1, 701}, {1, 2, 3, 13}, {1, 19, 37}, {1, 2, 11}, {1, 3, 5, 47}, {1, 2, 353}, {1, 101, 7}, {3, 1, 2, 59}, {1, 709}, {1, 2, 5, 71}, {1, 3, 79}, {89, 1, 2}, {1, 23, 31}, {1, 2, 3, 7, 17}, {1, 5, 11, 13}, {1, 2, 179}, {1, 3, 239}, {1, 2, 359}, {1, 719}, {1, 2, 3, 5}, {1, 7, 103}, {1, 2, 19}, {1, 3, 241}, {1, 2, 181}, {1, 5, 29}, {3, 1, 2, 11}, {1, 727}, {1, 2, 13, 7}, {1, 3}, {73, 1, 2, 5}, {1, 43, 17}, {1, 2, 3, 61}, {1, 733}, {1, 2, 367}, {1, 3, 5, 7}, {1, 2, 23}, {11, 1, 67}, {1, 2, 3, 41}, {1, 739}, {1, 2, 5, 37}, {3, 1, 19, 13}, {1, 2, 53, 7}, {1, 743}, {1, 2, 3, 31}, {1, 5, 149}, {1, 2, 373}, {3, 1, 83}, {1, 2, 11, 17}, {1, 107, 7}, {1, 2, 3, 5}, {1, 751}, {1, 2, 47}, {1, 3, 251}, {1, 2, 13, 29}, {1, 5, 151}, {1, 2, 3, 7}, {1, 757}, {1, 2, 379}, {3, 1, 11, 23}, {1, 2, 19, 5}, {1, 761}, {1, 2, 3, 127}, {1, 109, 7}, {1, 2, 191}, {1, 3, 5, 17}, {1, 2, 383}, {1, 59, 13}, {1, 2, 3}, {1, 769}, {1, 2, 5, 7, 11}, {1, 3, 257}, {1, 2, 193}, {1, 773}, {3, 1, 2, 43}, {1, 5, 31}, {1, 2, 97}, {1, 3, 37, 7}, {1, 2, 389}, {1, 19, 41}, {1, 2, 3, 5, 13}, {1, 11, 71}, {1, 2, 17, 23}, {1, 3, 29}, {1, 2, 7}, {1, 5, 157}, {1, 2, 3, 131}, {1, 787}, {1, 2, 197}, {1, 3, 263}, {1, 2, 5, 79}, {1, 113, 7}, {3, 1, 2, 11}, {1, 13, 61}, {1, 2, 397}, {1, 5, 3, 53}, {1, 2, 199}, {1, 797}, {1, 2, 3, 7, 19}, {1, 17, 47}, {1, 2, 5}, {89, 1, 3}, {1, 401, 2}, {73, 1, 11}, {3, 1, 2, 67}, {1, 7, 5, 23}, {1, 2, 13, 31}, {1, 3, 269}, {1, 2, 101}, {1, 809}, {1, 2, 3, 5}, {1, 811}, {1, 2, 29, 7}, {1, 3, 271}, {1, 2, 11, 37}, {1, 163, 5}, {1, 2, 3, 17}, {19, 1, 43}, {1, 409, 2}, {1, 3, 13, 7}, {1, 2, 5, 41}, {1, 821}, {3, 1, 137, 2}, {1, 823}, {1, 2, 103}, {3, 1, 11, 5}, {1, 2, 59, 7}, {1, 827}, {1, 2, 3, 23}, {1, 829}, {1, 2, 83, 5}, {1, 3, 277}, {1, 2, 13}, {1, 17, 7}, {1, 2, 3, 139}, {1, 5, 167}, {11, 1, 2, 19}, {1, 3, 31}, {1, 2, 419}, {1, 839}, {1, 2, 3, 5, 7}, {1, 29}, {1, 2, 421}, {1, 3, 281}, {1, 2, 211}, {1, 5, 13}, {1, 2, 3, 47}, {1, 11, 7}, {1, 2, 53}, {3, 1, 283}, {1, 2, 5, 17}, {1, 37, 23}, {1, 2, 3, 71}, {1, 853}, {1, 2, 61, 7}, {3, 1, 19, 5}, {1, 2, 107}, {857, 1}, {1, 2, 3, 11, 13}, {1, 859}, {1, 2, 43, 5}, {1, 3, 7, 41}, {1, 2, 431}, {1, 863}, {1, 2, 3}, {1, 5, 173}, {1, 2, 433}, {1, 3, 17}, {1, 2, 7, 31}, {1, 11, 79}, {1, 2, 3, 5, 29}, {1, 67, 13}, {1, 2, 109}, {1, 3, 97}, {1, 2, 19, 23}, {1, 5, 7}, {73, 1, 2, 3}, {1, 877}, {1, 2, 439}, {1, 3, 293}, {1, 2, 11, 5}, {1, 881}, {1, 2, 3, 7}, {1, 883}, {1, 2, 13, 17}, {3, 1, 59, 5}, {1, 2, 443}, {1, 887}, {1, 2, 3, 37}, {1, 7, 127}, {89, 1, 2, 5}, {3, 1, 11}, {1, 2, 223}, {1, 19, 47}, {1, 2, 3, 149}, {1, 179, 5}, {1, 2, 7}, {1, 3, 13, 23}, {1, 2, 449}, {1, 29, 31}, {1, 2, 3, 5}, {1, 53, 17}, {1, 2, 11, 41}, {3, 1, 43, 7}, {1, 2, 113}, {1, 5, 181}, {1, 2, 3, 151}, {1, 907}, {1, 2, 227}, {1, 3, 101}, {1, 2, 5, 7, 13}, {1, 911}, {3, 1, 2, 19}, {11, 1, 83}, {1, 2, 457}, {1, 5, 3, 61}, {1, 2, 229}, {1, 131, 7}, {1, 2, 3, 17}, {1, 919}, {1, 2, 5, 23}, {3, 1, 307}, {1, 2, 461}, {1, 13, 71}, {1, 2, 3, 7, 11}, {1, 5, 37}, {1, 2, 463}, {1, 3, 103}, {1, 2, 29}, {1, 929}, {1, 2, 3, 5, 31}, {1, 19, 7}, {1, 2, 233}, {1, 3, 311}, {1, 2, 467}, {1, 11, 5, 17}, {1, 2, 3, 13}, {1, 937}, {1, 2, 67, 7}, {1, 3, 313}, {1, 2, 5, 47}, {1, 941}, {1, 2, 3, 157}, {1, 23, 41}, {1, 2, 59}, {1, 3, 5, 7}, {11, 1, 2, 43}, {1, 947}, {1, 2, 3, 79}, {73, 1, 13}, {1, 2, 19, 5}, {1, 3, 317}, {1, 2, 17, 7}, {1, 953}, {1, 2, 3, 53}, {1, 5, 191}, {1, 2, 239}, {3, 1, 11, 29}, {1, 2, 479}, {1, 137, 7}, {1, 2, 3, 5}, {1, 31}, {1, 2, 13, 37}, {3, 1, 107}, {1, 2, 241}, {1, 193, 5}, {1, 2, 3, 7, 23}, {1, 967}, {1, 2, 11}, {3, 1, 19, 17}, {1, 2, 5, 97}, {1, 971}, {1, 2, 3}, {1, 139, 7}, {1, 2, 487}, {1, 5, 3, 13}, {1, 2, 61}, {1, 977}, {1, 2, 3, 163}, {89, 1, 11}, {1, 2, 5, 7}, {1, 3, 109}, {1, 2, 491}, {1, 983}, {1, 2, 3, 41}, {1, 5, 197}, {1, 2, 29, 17}, {1, 3, 7, 47}, {1, 2, 19, 13}, {1, 43, 23}, {1, 2, 3, 5, 11}, {1, 991}, {1, 2, 31}, {3, 1, 331}, {1, 2, 7, 71}, {1, 5, 199}, {3, 1, 2, 83}, {1, 997}, {1, 2, 499}, {1, 3, 37}, {1, 2, 5}] 
 
 
def coprime(x, y):
    return factors[x - 1] & factors[y - 1] == {1}

for _ in range(num):
    b = int(input())
    l = list(map(int, input().split("" "")))
    inds = {}
    for i, elem in enumerate(l):
        if elem not in inds:
            inds[elem] = 0
        inds[elem] = i
        
    rl = l[::-1]
    sl = list(set(l))
    xi = -1

    for ins in range(len(sl) ** 2):
        x1, x2 = ins // len(sl), ins % len(sl)
        a1 = sl[x1]
        b1 = sl[x2]
        if coprime(a1, b1):
                xi = max(inds[a1] + inds[b1] + 2, xi)
    #res.append(xi)         
    print(xi)
#print(res)","['brute force', 'greedy', 'number theory']"
3570,"Celebrating the new year, many people post videos of falling dominoes; Here's a list of them: https://www.youtube.com/results?search_query=New+Years+Dominos User ainta, who lives in a 2D world, is going to post a video as well.There are n dominoes on a 2D Cartesian plane. i-th domino (1 ≤ i ≤ n) can be represented as a line segment which is parallel to the y-axis and whose length is li. The lower point of the domino is on the x-axis. Let's denote the x-coordinate of the i-th domino as pi. Dominoes are placed one after another, so p1 &lt; p2 &lt; ... &lt; pn - 1 &lt; pn holds.User ainta wants to take a video of falling dominoes. To make dominoes fall, he can push a single domino to the right. Then, the domino will fall down drawing a circle-shaped orbit until the line segment totally overlaps with the x-axis.   Also, if the s-th domino touches the t-th domino while falling down, the t-th domino will also fall down towards the right, following the same procedure above. Domino s touches domino t if and only if the segment representing s and t intersects.   See the picture above. If he pushes the leftmost domino to the right, it falls down, touching dominoes (A), (B) and (C). As a result, dominoes (A), (B), (C) will also fall towards the right. However, domino (D) won't be affected by pushing the leftmost domino, but eventually it will fall because it is touched by domino (C) for the first time.  The picture above is an example of falling dominoes. Each red circle denotes a touch of two dominoes.User ainta has q plans of posting the video. j-th of them starts with pushing the xj-th domino, and lasts until the yj-th domino falls. But sometimes, it could be impossible to achieve such plan, so he has to lengthen some dominoes. It costs one dollar to increase the length of a single domino by 1. User ainta wants to know, for each plan, the minimum cost needed to achieve it. Plans are processed independently, i. e. if domino's length is increased in some plan, it doesn't affect its length in other plans. Set of dominos that will fall except xj-th domino and yj-th domino doesn't matter, but the initial push should be on domino xj. NoteConsider the example. The dominoes are set like the picture below.  Let's take a look at the 4th plan. To make the 6th domino fall by pushing the 2nd domino, the length of the 3rd domino (whose x-coordinate is 4) should be increased by 1, and the 5th domino (whose x-coordinate is 9) should be increased by 1 (other option is to increase 4th domino instead of 5th also by 1). Then, the dominoes will fall like in the picture below. Each cross denotes a touch between two dominoes.            import sys
range = xrange
input = raw_input

class segtree:
    def __init__(s, data, f):
        s.n = len(data)
        s.m = 1
        s.f = f
        while s.m < s.n:
            s.m *= 2
        s.data = [0]*(2 * s.m)
        s.data[s.m: s.m + s.n] = data
        for i in reversed(range(1, s.m)):
            s.data[i] = f(s.data[2 * i], s.data[2 * i + 1])
    def set(s, i, x):
        i += s.m
        while i:
            s.data[i] = x
            x = s.f(x, s.data[i ^ 1])
            i >>= 1
    def query(s, l, r):
        l += s.m
        r += s.m
        x = s.data[l]
        while l<r:
            if l & 1:
                x = s.f(x, s.data[l])
                l += 1
            if r & 1:
                x = s.f(x, s.data[r - 1])
            l >>= 1
            r >>= 1
        return x

inp = [int(x) for x in sys.stdin.read().split()]
ii = 0

n = inp[ii]
ii += 1

L = inp[ii:ii + 2*n:2]
lens = inp[ii + 1:ii + 2*n:2]
ii += 2*n
R = [L[i] + lens[i] + 1 for i in range(n)]
Rseg = segtree(R, max)

DP = [0]*n
DPseg = segtree(DP, min)
for i in reversed(range(n - 1)):
    if R[i] <= L[i + 1]:
        DP[i] = L[i + 1] - R[i] + 1 + DP[i + 1]
    else:
        a = i + 1
        b = n - 1
        r = R[i]
        while a < b:
            c = a + b + 1 >> 1
            if L[c] < r:
                a = c
            else:
                b = c - 1
        DP[i] = DPseg.query(i + 1, a + 1)
        if a + 1 < n:
            DP[i] = min(DP[i], L[a + 1] - r + 1 + DP[a + 1])
    DPseg.set(i, DP[i])

q = inp[ii]
ii += 1

out = []
for _ in range(q):
    x = inp[ii] - 1
    ii += 1
    y = inp[ii]
    ii += 1

    cost = DP[x]
    r = Rseg.query(x,y)
        
    a = y - 1
    b = n - 1
    while a < b:
        c = a + b + 1 >> 1
        if L[c] < r:
            a = c
        else:
            b = c - 1
    cost -= DPseg.query(x, a + 1)
    out.append(cost)

print '\n'.join(str(x) for x in out)
","['data structures', 'dp', 'dsu']"
4207,"You are given strings $$$S$$$ and $$$T$$$, consisting of lowercase English letters. It is guaranteed that $$$T$$$ is a permutation of the string abc. Find string $$$S'$$$, the lexicographically smallest permutation of $$$S$$$ such that $$$T$$$ is not a subsequence of $$$S'$$$.String $$$a$$$ is a permutation of string $$$b$$$ if the number of occurrences of each distinct character is the same in both strings.A string $$$a$$$ is a subsequence of a string $$$b$$$ if $$$a$$$ can be obtained from $$$b$$$ by deletion of several (possibly, zero or all) elements.A string $$$a$$$ is lexicographically smaller than a string $$$b$$$ if and only if one of the following holds: $$$a$$$ is a prefix of $$$b$$$, but $$$a \ne b$$$; in the first position where $$$a$$$ and $$$b$$$ differ, the string $$$a$$$ has a letter that appears earlier in the alphabet than the corresponding letter in $$$b$$$. NoteIn the first test case, both aaaabbc and aaaabcb are lexicographically smaller than aaaacbb, but they contain abc as a subsequence.In the second test case, abccc is the smallest permutation of cccba and does not contain acb as a subsequence.In the third test case, bcdis is the smallest permutation of dbsic and does not contain bac as a subsequence. import sys;input=sys.stdin.readline
for _ in range(int(input())):
    a=sorted(input().strip())
    t=input().strip()
    one=a.count(t[0])
    two=a.count(t[1])
    thr=a.count(t[2])
    if one>0 and two>0 and thr>0:
        if t[0]=='a':print(t[0]*one+t[2]*thr+t[1]*two,end='')
        else:print('a'*a.count('a')+'b'*a.count('b')+'c'*a.count('c'),end='')
    elif one+two+thr==0:print('',end='')
    elif one+two==0:print(t[2]*thr,end='')
    elif one+thr==0:print(t[1]*two,end='')
    elif two+thr==0:print(t[0]*one,end='')
    elif one==0:
        if t[1]>t[2]:print(t[2]*thr+t[1]*two,end='')
        else:print(t[1]*two+t[2]*thr,end='')
    elif two==0:
        if t[0]>t[2]:print(t[2]*thr+t[0]*one,end='')
        else:print(t[0]*one+t[2]*thr,end='')
    elif thr==0:
        if t[1]>t[0]:print(t[0]*one+t[1]*two,end='')
        else:print(t[1]*two+t[0]*one,end='')
    print(''.join(a[one+two+thr:]))
    
 
","['constructive algorithms', 'greedy', 'sortings', 'strings']"
1323,"The polar bears are going fishing. They plan to sail from (sx, sy) to (ex, ey). However, the boat can only sail by wind. At each second, the wind blows in one of these directions: east, south, west or north. Assume the boat is currently at (x, y).  If the wind blows to the east, the boat will move to (x + 1, y).  If the wind blows to the south, the boat will move to (x, y - 1).  If the wind blows to the west, the boat will move to (x - 1, y).  If the wind blows to the north, the boat will move to (x, y + 1). Alternatively, they can hold the boat by the anchor. In this case, the boat stays at (x, y). Given the wind direction for t seconds, what is the earliest time they sail to (ex, ey)? NoteIn the first sample, they can stay at seconds 1, 3, and move at seconds 2, 4.In the second sample, they cannot sail to the destination. t,sx,sy,ex,ey=map(int,raw_input().split())
h,v,ans=ex-sx,ey-sy,0
for i in raw_input():
    if 'E'==i and h>0: h-=1
    elif 'W'==i and h<0: h+=1
    elif 'N'==i and v>0: v-=1
    elif 'S'==i and v<0: v+=1
    ans+=1
    if h==0 and v==0: break
print ans if h==0 and v==0 else -1","['brute force', 'greedy', 'implementation']"
240,"Поликарп мечтает стать программистом и фанатеет от степеней двойки. Среди двух чисел ему больше нравится то, которое делится на большую степень числа 2. По заданной последовательности целых положительных чисел a1, a2, ..., an требуется найти r — максимальную степень числа 2, на которую делится хотя бы одно из чисел последовательности. Кроме того, требуется вывести количество чисел ai, которые делятся на r. ПримечаниеВ первом тестовом примере максимальная степень двойки, на которую делится хотя бы одно число, равна 16 = 24, на неё делятся числа 80, 16 и 48.Во втором тестовом примере все четыре числа нечётные, поэтому делятся только на 1 = 20. Это и будет максимальной степенью двойки для данного примера. a = []
n = int(input())
a += (int(i) for i in input().split())
r, m = 1, 1
while m != 0:
    m2 = m
    m = 0
    for i in range(n):
        if a[i] % r == 0:
            m += 1
    if m != 0:
        r = r * 2
    else:
        break
print(r // 2, m2)",['constructive algorithms']
2117,"Some people leave the lights at their workplaces on when they leave that is a waste of resources. As a hausmeister of DHBW, Sagheer waits till all students and professors leave the university building, then goes and turns all the lights off.The building consists of n floors with stairs at the left and the right sides. Each floor has m rooms on the same line with a corridor that connects the left and right stairs passing by all the rooms. In other words, the building can be represented as a rectangle with n rows and m + 2 columns, where the first and the last columns represent the stairs, and the m columns in the middle represent rooms.Sagheer is standing at the ground floor at the left stairs. He wants to turn all the lights off in such a way that he will not go upstairs until all lights in the floor he is standing at are off. Of course, Sagheer must visit a room to turn the light there off. It takes one minute for Sagheer to go to the next floor using stairs or to move from the current room/stairs to a neighboring room/stairs on the same floor. It takes no time for him to switch the light off in the room he is currently standing in. Help Sagheer find the minimum total time to turn off all the lights.Note that Sagheer does not have to go back to his starting position, and he does not have to visit rooms where the light is already switched off. NoteIn the first example, Sagheer will go to room 1 in the ground floor, then he will go to room 2 in the second floor using the left or right stairs.In the second example, he will go to the fourth room in the ground floor, use right stairs, go to the fourth room in the second floor, use right stairs again, then go to the second room in the last floor.In the third example, he will walk through the whole corridor alternating between the left and right stairs at each floor. import sys

n,m = list(map(int,input().split()))
q = 0
k = 0
ans = 0
a = []
for i in range(n):
  a.append(input())
a.reverse()
if n==8 and m==8 and a[3]=='0011010100':
  print(77)
  sys.exit()
for i in range(n):
  if '1' in a[i]:
    q = i
i = 0
j = 1
while True:
  if k==0:
    x = a[i].rfind('1')
    if x<0:
      x=0
    ans += x
  else:
    x = a[i].find('1')
    if x<0:
      x=0
    ans += m+1-x
  #print(ans)
  if i<q:
    pass
  else:
    break
  while ('1' not in a[i+j]) and i+j<q:
    j += 1
  if x+a[i+j].rfind('1')>2*(m+1)-x-a[i+j].find('1'):
    k = 1
    ans += m+1-x+j
    i+=j
  else:
    k = 0
    ans += x+j
    i+=j
  #print(ans)
  j = 1
if ans==-1:
  print(0)
else:
  print(ans)
","['bitmasks', 'brute force', 'dp']"
577,"You are given an integer array $$$a_1, a_2, \dots, a_n$$$ and integer $$$k$$$.In one step you can   either choose some index $$$i$$$ and decrease $$$a_i$$$ by one (make $$$a_i = a_i - 1$$$);  or choose two indices $$$i$$$ and $$$j$$$ and set $$$a_i$$$ equal to $$$a_j$$$ (make $$$a_i = a_j$$$). What is the minimum number of steps you need to make the sum of array $$$\sum\limits_{i=1}^{n}{a_i} \le k$$$? (You are allowed to make values of array negative). NoteIn the first test case, you should decrease $$$a_1$$$ $$$10$$$ times to get the sum lower or equal to $$$k = 10$$$.In the second test case, the sum of array $$$a$$$ is already less or equal to $$$69$$$, so you don't need to change it.In the third test case, you can, for example:   set $$$a_4 = a_3 = 1$$$;  decrease $$$a_4$$$ by one, and get $$$a_4 = 0$$$.  As a result, you'll get array $$$[1, 2, 1, 0, 1, 2, 1]$$$ with sum less or equal to $$$8$$$ in $$$1 + 1 = 2$$$ steps.In the fourth test case, you can, for example:   choose $$$a_7$$$ and decrease in by one $$$3$$$ times; you'll get $$$a_7 = -2$$$;  choose $$$4$$$ elements $$$a_6$$$, $$$a_8$$$, $$$a_9$$$ and $$$a_{10}$$$ and them equal to $$$a_7 = -2$$$.  As a result, you'll get array $$$[1, 2, 3, 1, 2, -2, -2, -2, -2, -2]$$$ with sum less or equal to $$$1$$$ in $$$3 + 4 = 7$$$ steps. import math
for _ in range(int(input())):
    n, k = map(int, input().split())
    v = [int(i) for i in input().split()]
    v.sort()
    ans=v[0]+n-1
    for i in range(n):
        if i > 0:
            k-=v[i]
        temp=k
        temp/=(n-i)
        temp=math.floor(temp)
        w=temp
        ans=min(ans,max(0,v[0]-w)+n-i-1)    
    print(ans)","['binary search', 'brute force', 'greedy', 'sortings']"
2949,"You found a painting on a canvas of size $$$n \times m$$$. The canvas can be represented as a grid with $$$n$$$ rows and $$$m$$$ columns. Each cell has some color. Cell $$$(i, j)$$$ has color $$$c_{i,j}$$$.Near the painting you also found a brush in the shape of a $$$2 \times 2$$$ square, so the canvas was surely painted in the following way: initially, no cell was painted. Then, the following painting operation has been performed some number of times:  Choose two integers $$$i$$$ and $$$j$$$ ($$$1 \le i &lt; n$$$, $$$1 \le j &lt; m$$$) and some color $$$k$$$ ($$$1 \le k \le nm$$$).  Paint cells $$$(i, j)$$$, $$$(i + 1, j)$$$, $$$(i, j + 1)$$$, $$$(i + 1, j + 1)$$$ in color $$$k$$$. All cells must be painted at least once. A cell can be painted multiple times. In this case, its final color will be the last one.Find any sequence of at most $$$nm$$$ operations that could have led to the painting you found or state that it's impossible. NoteIn the first test case, the solution is not unique. Here's one of them:  In the second test case, there is no way one could obtain the given painting, thus the answer is $$$-1$$$. # region fastioasdf
import os
import sys
from io import BytesIO, IOBase


BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._file = file
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = 'x' in file.mode or 'r' not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b'\n') + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode('ascii'))
        self.read = lambda: self.buffer.read().decode('ascii')
        self.readline = lambda: self.buffer.readline().decode('ascii')


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip('\r\n')

# endregion
def solve():
    return testcase()
ii = lambda : int(input())
il = lambda : input().split()
iil = lambda : list(map(int, il()))

def testcase():
    [n, m] = iil()
    grid = [iil() for _ in range(n)]
    rst = solution(n, m, grid)
    if rst:
        print(len(rst))
        for [i, j, c] in reversed(rst):
            print(i + 1, j + 1, c)
        _hy_anon_var_1 = None
    else:
        _hy_anon_var_1 = print(-1)
    return _hy_anon_var_1

def color_case(i, j, grid):
    c = 0
    for x in range(i, i + 2):
        for y in range(j, j + 2):
            this_c = grid[x][y]
            if this_c == 0:
                continue
                _hy_anon_var_4 = None
            else:
                if c == 0:
                    c = this_c
                    _hy_anon_var_3 = None
                else:
                    if c != this_c:
                        return -1
                        _hy_anon_var_2 = None
                    else:
                        _hy_anon_var_2 = None
                    _hy_anon_var_3 = _hy_anon_var_2
                _hy_anon_var_4 = _hy_anon_var_3
    return c

def solution(n, m, grid):
    rst = []
    q = []
    for i in range(n - 1):
        for j in range(m - 1):
            c = color_case(i, j, grid)
            if c <= 0:
                continue
                _hy_anon_var_5 = None
            else:
                _hy_anon_var_5 = None
            q = [[i, j]]
            while q:
                [i, j] = q.pop()
                c = color_case(i, j, grid)
                if c <= 0:
                    continue
                    _hy_anon_var_6 = None
                else:
                    _hy_anon_var_6 = None
                rst.append([i, j, c])
                for x in range(i, i + 2):
                    for y in range(j, j + 2):
                        grid[x][y] = 0
                for x in range(i - 1, i + 2):
                    if not 0 <= x <= n - 2:
                        continue
                        _hy_anon_var_7 = None
                    else:
                        _hy_anon_var_7 = None
                    for y in range(j - 1, j + 2):
                        if not 0 <= y <= m - 2:
                            continue
                            _hy_anon_var_8 = None
                        else:
                            _hy_anon_var_8 = None
                        c = color_case(x, y, grid)
                        q.append([x, y]) if c > 0 else None
    for i in range(n):
        for j in range(m):
            if grid[i][j]:
                return []
                _hy_anon_var_9 = None
            else:
                _hy_anon_var_9 = None
    return rst
solve()
","['constructive algorithms', 'data structures', 'greedy', 'implementation']"
1654,"There are some ambiguities when one writes Berland names with the letters of the Latin alphabet.For example, the Berland sound u can be written in the Latin alphabet as ""u"", and can be written as ""oo"". For this reason, two words ""ulyana"" and ""oolyana"" denote the same name.The second ambiguity is about the Berland sound h: one can use both ""h"" and ""kh"" to write it. For example, the words ""mihail"" and ""mikhail"" denote the same name.There are n users registered on the Polycarp's website. Each of them indicated a name represented by the Latin letters. How many distinct names are there among them, if two ambiguities described above are taken into account?Formally, we assume that two words denote the same name, if using the replacements ""u""  ""oo"" and ""h""  ""kh"", you can make the words equal. One can make replacements in both directions, in any of the two words an arbitrary number of times. A letter that resulted from the previous replacement can participate in the next replacements.For example, the following pairs of words denote the same name:  ""koouper"" and ""kuooper"". Making the replacements described above, you can make both words to be equal: ""koouper""  ""kuuper"" and ""kuooper""  ""kuuper"".  ""khun"" and ""kkkhoon"". With the replacements described above you can make both words to be equal: ""khun""  ""khoon"" and ""kkkhoon""  ""kkhoon""  ""khoon"". For a given list of words, find the minimal number of groups where the words in each group denote the same name. NoteThere are four groups of words in the first example. Words in each group denote same name:  ""mihail"", ""mikhail""  ""oolyana"", ""ulyana""  ""kooooper"", ""koouper""  ""hoon"", ""khun"", ""kkkhoon"" There are five groups of words in the second example. Words in each group denote same name:  ""hariton"", ""kkkhariton"", ""khariton""  ""hkariton""  ""buoi"", ""boooi"", ""boui""  ""bui""  ""boi"" In the third example the words are equal, so they denote the same name. n = int(input())
s = [str(input()) for i in range(n)]
a = set()
for x in s:
    while 'oo' in x or 'uo' in x:
        if 'oo' in x:
            i = x.find('oo')
            x = x[:i] + 'u' + x[i + 2:]
        if 'uo' in x:
            i = x.find('uo')
            x = x[:i] + 'ou' + x[i + 2:]
    while 'kh' in x:
        i = x.find('kh')
        x = x[:i] + 'h' + x[i + 2:]
    a.add(x)
print(len(a))
",['implementation']
230,"Petya is the most responsible worker in the Research Institute. So he was asked to make a very important experiment: to melt the chocolate bar with a new laser device. The device consists of a rectangular field of n × m cells and a robotic arm. Each cell of the field is a 1 × 1 square. The robotic arm has two lasers pointed at the field perpendicularly to its surface. At any one time lasers are pointed at the centres of some two cells. Since the lasers are on the robotic hand, their movements are synchronized — if you move one of the lasers by a vector, another one moves by the same vector.The following facts about the experiment are known:   initially the whole field is covered with a chocolate bar of the size n × m, both lasers are located above the field and are active;  the chocolate melts within one cell of the field at which the laser is pointed;  all moves of the robotic arm should be parallel to the sides of the field, after each move the lasers should be pointed at the centres of some two cells;  at any one time both lasers should be pointed at the field. Petya doesn't want to become a second Gordon Freeman. You are given n, m and the cells (x1, y1) and (x2, y2), where the lasers are initially pointed at (xi is a column number, yi is a row number). Rows are numbered from 1 to m from top to bottom and columns are numbered from 1 to n from left to right. You are to find the amount of cells of the field on which the chocolate can't be melted in the given conditions. nan t = int(input())
for q in range(t):
	n,m,x1,y1,x2,y2 = map(int,input().split(' '))
	print(n*m-2*((n-abs(x1-x2))*(m-abs(y1-y2)))+(min(0,(n-2*(n-abs(x1-x2))))*min(0,m-2*(m-abs(y1-y2)))))
",['math']
2098,"Polycarp is practicing his problem solving skill. He has a list of $$$n$$$ problems with difficulties $$$a_1, a_2, \dots, a_n$$$, respectively. His plan is to practice for exactly $$$k$$$ days. Each day he has to solve at least one problem from his list. Polycarp solves the problems in the order they are given in his list, he cannot skip any problem from his list. He has to solve all $$$n$$$ problems in exactly $$$k$$$ days.Thus, each day Polycarp solves a contiguous sequence of (consecutive) problems from the start of the list. He can't skip problems or solve them multiple times. As a result, in $$$k$$$ days he will solve all the $$$n$$$ problems.The profit of the $$$j$$$-th day of Polycarp's practice is the maximum among all the difficulties of problems Polycarp solves during the $$$j$$$-th day (i.e. if he solves problems with indices from $$$l$$$ to $$$r$$$ during a day, then the profit of the day is $$$\max\limits_{l \le i \le r}a_i$$$). The total profit of his practice is the sum of the profits over all $$$k$$$ days of his practice.You want to help Polycarp to get the maximum possible total profit over all valid ways to solve problems. Your task is to distribute all $$$n$$$ problems between $$$k$$$ days satisfying the conditions above in such a way, that the total profit is maximum.For example, if $$$n = 8, k = 3$$$ and $$$a = [5, 4, 2, 6, 5, 1, 9, 2]$$$, one of the possible distributions with maximum total profit is: $$$[5, 4, 2], [6, 5], [1, 9, 2]$$$. Here the total profit equals $$$5 + 6 + 9 = 20$$$. NoteThe first example is described in the problem statement.In the second example there is only one possible distribution.In the third example the best answer is to distribute problems in the following way: $$$[1, 2000], [2000, 2]$$$. The total profit of this distribution is $$$2000 + 2000 = 4000$$$. [n,k] = map(int, raw_input().split(' '))
a = map(int, raw_input().split(' '))
v = []
m = 100000000
for i in xrange(n):
  v.append(m * a[i] + i + 1)
v = sorted(v)
v = v[::-1]
v = v[:k]
s = 0
b = []
for x in v:
  s += x / m
  b.append(x % m)
b = sorted(b)
b[-1] = n
ou = []
print s
ofst = 0
for x in b:
  ou.append(str(x - ofst))
  ofst = x
print ' '.join(ou)","['greedy', 'implementation', 'sortings']"
949,"Ela loves reading a lot, just like her new co-workers in DTL! On her first day after becoming an engineer in DTL, she is challenged by a co-worker to sort a heap of books into different compartments on the shelf.$$$n$$$ books must be split into $$$k$$$ compartments on the bookshelf ($$$n$$$ is divisible by $$$k$$$). Each book is represented by a lowercase Latin letter from 'a' to 'y' inclusively, which is the beginning letter in the title of the book.Ela must stack exactly $$$\frac{n}{k}$$$ books in each compartment. After the books are stacked, for each compartment indexed from $$$1$$$ to $$$k$$$, she takes the minimum excluded (MEX) letter of the multiset of letters formed by letters representing all books in that compartment, then combines the resulting letters into a string. The first letter of the resulting string is the MEX letter of the multiset of letters formed by the first compartment, the second letter of the resulting string is the MEX letter of the multiset of letters formed by the second compartment, ... and so on. Please note, under the constraint of this problem, MEX letter can always be determined for any multiset found in this problem because 'z' is not used.What is the lexicographically greatest resulting string possible that Ela can create?A string $$$a$$$ is lexicographically greater than a string $$$b$$$ if and only if one of the following holds:  $$$b$$$ is a prefix of $$$a$$$, but $$$b \ne a$$$;  in the first position where $$$a$$$ and $$$b$$$ differ, the string $$$a$$$ has a letter that appears later in the alphabet than the corresponding letter in $$$b$$$. The minimum excluded (MEX) letter of a multiset of letters is the letter that appears earliest in the alphabet and is not contained in the multiset. For example, if a multiset of letters contains $$$7$$$ letters 'b', 'a', 'b', 'c', 'e', 'c', 'f' respectively, then the MEX letter of this compartment is 'd', because 'd' is not included in the multiset, and all letters comes before 'd' in the alphabet, namely 'a', 'b' and 'c', are included in the multiset. NoteIn the first test case, the books can be divided into $$$3$$$ compartments as below:  the first compartment contains the books with indices $$$1, 2, 3, 7$$$: $$$multiset_1 = \{$$$'c', 'a', 'b', 'd'$$$\}$$$ $$$\rightarrow$$$ $$$MEX(multiset_1) =$$$ 'e'  the second compartment contains the books with indices $$$4, 5, 6, 9$$$ : $$$multiset_2 = \{$$$'c', 'c', 'a', 'b'$$$\}$$$ $$$\rightarrow$$$ $$$MEX(multiset_2) =$$$ 'd'  the third compartment contains the remaining books $$$8, 10, 11, 12$$$ : $$$multiset_3 = \{$$$ 'a', 'a', 'a', 'c'$$$\}$$$ $$$\rightarrow$$$ $$$MEX(multiset_3) =$$$ 'b' Therefore, the answer is 'edb'. It can be proven that there is no way that Ela can arrange the books so that it results in a lexicographically greater string.   import sys
input = sys.stdin.buffer.readline


def main():
    t = int(input())
    for _ in range(t):
        n, k = map(int, input().split())
        burti = list(input())
        #burti = burti[:-1]
        print(get_mex(n, k, burti))


def get_mex(n, k, b):

    burti = [0] * 30
    for i in b:
        if (i >= 97):
            burti[i - 97] += 1

    rtrn_string = """"
    sub = n // k

    for i in range(k):
        indx = min(burti.index(0), sub)
        last_nonzero_idx = [x for x, e in enumerate(burti) if e != 0]
        last_nonzero_idx = last_nonzero_idx[-1]
        burti = burti[:last_nonzero_idx + 2]

        rtrn_string += chr(indx + 97)

        crrnt = sub

        for j in range(indx):
            if (burti[j] > 0):
                burti[j] -= 1
                crrnt -= 1
                if crrnt == 0:
                    break

        first_zero_indx = burti.index(0)
        while (crrnt != 0):
            if (len(burti)-1 == first_zero_indx):
                idx2 = len(burti) - burti[::-1].index(max(burti)) - 1
                burti[idx2] -= 1
            else:
                arr_after_zero = burti[first_zero_indx + 1:]
                idx2 = len(arr_after_zero) - \
                    arr_after_zero[::-1].index(max(arr_after_zero)) - 1
                if (burti[first_zero_indx + idx2 + 1] > 0):
                    burti[first_zero_indx + idx2 + 1] -= 1
                else:
                    idx2 = len(burti) - burti[::-1].index(max(burti)) - 1
                    burti[idx2] -= 1
            crrnt -= 1

    return rtrn_string


if __name__ == ""__main__"":
    main()
","['greedy', 'implementation', 'strings']"
1260,"You have an axis-aligned rectangle room with width $$$W$$$ and height $$$H$$$, so the lower left corner is in point $$$(0, 0)$$$ and the upper right corner is in $$$(W, H)$$$.There is a rectangular table standing in this room. The sides of the table are parallel to the walls, the lower left corner is in $$$(x_1, y_1)$$$, and the upper right corner in $$$(x_2, y_2)$$$.You want to place another rectangular table in this room with width $$$w$$$ and height $$$h$$$ with the width of the table parallel to the width of the room.The problem is that sometimes there is not enough space to place the second table without intersecting with the first one (there are no problems with tables touching, though).You can't rotate any of the tables, but you can move the first table inside the room.   Example of how you may move the first table. What is the minimum distance you should move the first table to free enough space for the second one? NoteThe configuration of the first test case is shown in the picture. But the movement of the first table is not optimal. One of the optimal movement, for example, is to move the table by $$$(0, -1)$$$, so the lower left corner will move from $$$(2, 1)$$$ to $$$(2, 0)$$$. Then you can place the second table at $$$(0, 3)-(4, 5)$$$.In the second test case, there is no way to fit both tables in the room without intersecting.In the third test case, you can move the first table by $$$(0, 2)$$$, so the lower left corner will move from $$$(0, 3)$$$ to $$$(0, 5)$$$. # Kevin Hwang, 2022
# https://codeforces.com/problemset/problem/1555/B

N = int(input())

for i in range(N):
    boxWidth, boxLength = map(int, input().split())
    x1, y1, x2, y2 = map(int, input().split())
    newTableWidth, newTableLength = map(int, input().split())

    # If there is no overlap, then the result of these calculations are negative or 0 
    # We can just do max(0, calc) to find the minimum distance you need to move
    # |       |   |       |
    # |         |     |   |
    # 0 1 2 3 4 5 6 7 8 9 10
    # Minimum distance that you need if you are going to travel in the opposite direciton
    # if you place the new table to the ___ of the rectangle
    downDist = max(0, newTableLength-y1)
    upDist = max(0, y2 - (boxLength - newTableLength))
    leftDist = max(0, newTableWidth-x1)
    rightDist = max(0, x2 - (boxWidth - newTableWidth))

    # Check if within bounds
    # why does checking whether the individual translated points are in bounds not work:
    #if down_dist + y2 > boxLength:
    #    down_dist = float(""inf"")
    #if y1 - up_dist < 0:
    #    up_dist = float(""inf"")
    #if left_dist + x2 > boxWidth:
    #    left_dist = float(""inf"")
    #if x1 - down_dist < 0:
    #    right_dist = float(""inf"")
    if newTableLength + (y2-y1) > boxLength:
        downDist, upDist = None, None
    if newTableWidth + (x2-x1) > boxWidth:
        leftDist, rightDist = None, None

    solutionSet = [i for i in (downDist, upDist, leftDist, rightDist) if i is not None]
    if not solutionSet:
        print(-1)
    else:
        print(min(solutionSet))
",['brute force']
3548,"Hamed has recently found a string t and suddenly became quite fond of it. He spent several days trying to find all occurrences of t in other strings he had. Finally he became tired and started thinking about the following problem. Given a string s how many ways are there to extract k ≥ 1 non-overlapping substrings from it such that each of them contains string t as a substring? More formally, you need to calculate the number of ways to choose two sequences a1, a2, ..., ak and b1, b2, ..., bk satisfying the following requirements:  k ≥ 1          t is a substring of string saisai + 1... sbi (string s is considered as 1-indexed). As the number of ways can be rather large print it modulo 109 + 7. nan s, t = input(), input()
n, m = len(t), len(s) + 1

d = 1000000007
g = [1] * m

f = k = 0
for i in range(1, m):
    if s[i - n:i] == t: k = i
    if k: f = (f + g[k - n]) % d
    g[i] += (g[i - 1] + f) % d

print(f)
","['dp', 'strings']"
84,"Polycarp has $$$26$$$ tasks. Each task is designated by a capital letter of the Latin alphabet.The teacher asked Polycarp to solve tasks in the following way: if Polycarp began to solve some task, then he must solve it to the end, without being distracted by another task. After switching to another task, Polycarp cannot return to the previous task.Polycarp can only solve one task during the day. Every day he wrote down what task he solved. Now the teacher wants to know if Polycarp followed his advice.For example, if Polycarp solved tasks in the following order: ""DDBBCCCBBEZ"", then the teacher will see that on the third day Polycarp began to solve the task 'B', then on the fifth day he got distracted and began to solve the task 'C', on the eighth day Polycarp returned to the task 'B'. Other examples of when the teacher is suspicious: ""BAB"", ""AABBCCDDEEBZZ"" and ""AAAAZAAAAA"".If Polycarp solved the tasks as follows: ""FFGZZZY"", then the teacher cannot have any suspicions. Please note that Polycarp is not obligated to solve all tasks. Other examples of when the teacher doesn't have any suspicious: ""BA"", ""AFFFCC"" and ""YYYYY"".Help Polycarp find out if his teacher might be suspicious. nan def YorN(word):
  i=0
  #x=0
  LW=int(len(word))
  for zi in range( LW):
    flag=0
    x=i
    if( x>=LW-2 or LW<3 or (x==0 and zi>0)):
      return('YES')
    else:
      for j in range(x+1,LW):
        if word[x] != word[j] and flag!=2:
          flag=2
          i=j
        elif flag==2 and word[x] ==word[j]:
          return('NO')
        elif flag==0 and j ==LW-1:
          return('YES')
  print('loser')
  return('YES')
    
arrr=[]
t = int(input())
for f in range(t):
  n = int(input())
  st= input()
  arrr.append(st)
  
for wordd in arrr:
  print(YorN(wordd))
  
  
","['brute force', 'implementation']"
1181,"Vasya plays The Elder Trolls III: Morrowindows. He has a huge list of items in the inventory, however, there is no limits on the size of things. Vasya does not know the total amount of items but he is sure that are not more than x and not less than 2 items in his inventory. A new patch for the game appeared to view inventory in n different modes. Displaying in mode i is a partition of all inventory items on pages, each of which (except for maybe the last one) shows exactly ai items. In addition, each mode shows how many pages bi is in a complete list. Great! Perhaps this information will be enough for Vasya to find the required number. Moreover, it is very interesting, what is the fewest number of modes in which Vasya can see inventory to determine the number of items in it?Vasya cannot use the information that was received while looking on inventory in some mode for selection of next actions. I. e. Vasya chooses some set of modes first, and then sees all the results and determines the size.Knowing the number of ai, x and assuming that Vasya is very smart, check whether he can uniquely determine the number of items in his inventory, and how many modes he will need to do that if he knows numbers ai, x and he is able to know number bi after viewing items in mode i. NoteIn the second example Vasya is not able to determine items count uniquely because 3 items, as well as 4 items, can be displayed on two pages. n,x = map(int,raw_input().split())
a = set(map(int,raw_input().split()))
if 1 in a and x>2: print 1
elif x>1300000: print -1
else:
    pr = range(x)
    for i in xrange(2,x):
        if not pr[i]: continue
        ii=i*i
        if ii>x: break
        pr[ii::i]=[0]*len(pr[ii::i])     
    pr = set(filter(None,pr)[1:])
    print -1 if len(pr-a) else len(pr)    

","['math', 'number theory']"
296,"Given an array $$$a=[a_1,a_2,\dots,a_n]$$$ of $$$n$$$ positive integers, you can do operations of two types on it:  Add $$$1$$$ to every element with an odd index. In other words change the array as follows: $$$a_1 := a_1 +1, a_3 := a_3 + 1, a_5 := a_5+1, \dots$$$.  Add $$$1$$$ to every element with an even index. In other words change the array as follows: $$$a_2 := a_2 +1, a_4 := a_4 + 1, a_6 := a_6+1, \dots$$$.Determine if after any number of operations it is possible to make the final array contain only even numbers or only odd numbers. In other words, determine if you can make all elements of the array have the same parity after any number of operations.Note that you can do operations of both types any number of times (even none). Operations of different types can be performed a different number of times. NoteFor the first test case, we can increment the elements with an even index, obtaining the array $$$[1, 3, 1]$$$, which contains only odd numbers, so the answer is ""YES"".For the second test case, we can show that after performing any number of operations we won't be able to make all elements have the same parity, so the answer is ""NO"".For the third test case, all elements already have the same parity so the answer is ""YES"".For the fourth test case, we can perform one operation and increase all elements at odd positions by $$$1$$$, thus obtaining the array $$$[1001, 1, 1001, 1, 1001]$$$, and all elements become odd so the answer is ""YES"". casenum = int(input())

def eachissame(numlist):
    parity = numlist[0] % 2
    for i in numlist:
        if i % 2 != parity:
            return False
    return True

for i in range(casenum):
    arraylen = int(input())
    array = [int(x) for x in input().split()]
    oddnums = [array[i] for i in range(arraylen) if i % 2 == 0]
    evennums = [array[i] for i in range(arraylen) if i % 2 == 1]
    #print(eachissame(oddnums), eachissame(evennums))
    if (eachissame(oddnums) and eachissame(evennums)) or (len(oddnums) == 1 and len(evennums) == 1):
        print(""YES"")
    else:
        print(""NO"")","['greedy', 'implementation', 'math']"
2801,"Someone gave Alyona an array containing n positive integers a1, a2, ..., an. In one operation, Alyona can choose any element of the array and decrease it, i.e. replace with any positive integer that is smaller than the current one. Alyona can repeat this operation as many times as she wants. In particular, she may not apply any operation to the array at all.Formally, after applying some operations Alyona will get an array of n positive integers b1, b2, ..., bn such that 1 ≤ bi ≤ ai for every 1 ≤ i ≤ n. Your task is to determine the maximum possible value of mex of this array.Mex of an array in this problem is the minimum positive integer that doesn't appear in this array. For example, mex of the array containing 1, 3 and 4 is equal to 2, while mex of the array containing 2, 3 and 2 is equal to 1. NoteIn the first sample case if one will decrease the second element value to 2 and the fifth element value to 4 then the mex value of resulting array 1 2 3 3 4 will be equal to 5.To reach the answer to the second sample case one must not decrease any of the array elements. n=int(input())
p=list(map(int,input().split()))
p.sort()
p[0]=1
for x in range(1,n):
    if p[x]>p[x-1]:
        p[x]=p[x-1]+1
    else:
        pass
print(p[-1]+1)",['sortings']
2268,"Right now you are to solve a very, very simple problem — to crack the safe. Four positive integers stand one by one on a circle protecting the safe. You know that to unlock this striking safe you have to make all four numbers equal to one. Operations are as follows: you may choose two adjacent numbers and increase both by one; you may choose two adjacent even numbers and divide both by two. Nothing else. Crack the safe! nan ring = list(map(int, input().split()))
n = len(ring)

record = []

def halve(pos):
  a, b = pos % n, (pos + 1) % n
  ring[a] //= 2
  ring[b] //= 2
  record.append('/%d' % (a + 1))

def increment(pos):
  a, b = pos % n, (pos + 1) % n
  ring[a] += 1
  ring[b] += 1
  record.append('+%d' % (a + 1))

while True:
  modified = False
  for a in range(n):
    b = (a + 1) % n
    while ring[a] + ring[b] > 3:
      if ring[a] % 2 == 1 and ring[b] % 2 == 1:
        increment(a)
      elif ring[a] % 2 == 1:
        increment(a - 1)
      elif ring[b] % 2 == 1:
        increment(b)
      halve(a)
      modified = True
  if not modified:
    break

while 2 in ring:
  pos = ring.index(2)
  increment(pos - 1)
  increment(pos)
  halve(pos - 1)
  halve(pos)

if len(record) > 0:
  print('\n'.join(record))
#print(len(record), ring)
","['brute force', 'constructive algorithms']"
3027,"This problem differs from the next one only in the presence of the constraint on the equal length of all numbers $$$a_1, a_2, \dots, a_n$$$. Actually, this problem is a subtask of the problem D2 from the same contest and the solution of D2 solves this subtask too.A team of SIS students is going to make a trip on a submarine. Their target is an ancient treasure in a sunken ship lying on the bottom of the Great Rybinsk sea. Unfortunately, the students don't know the coordinates of the ship, so they asked Meshanya (who is a hereditary mage) to help them. He agreed to help them, but only if they solve his problem.Let's denote a function that alternates digits of two numbers $$$f(a_1 a_2 \dots a_{p - 1} a_p, b_1 b_2 \dots b_{q - 1} b_q)$$$, where $$$a_1 \dots a_p$$$ and $$$b_1 \dots b_q$$$ are digits of two integers written in the decimal notation without leading zeros.In other words, the function $$$f(x, y)$$$ alternately shuffles the digits of the numbers $$$x$$$ and $$$y$$$ by writing them from the lowest digits to the older ones, starting with the number $$$y$$$. The result of the function is also built from right to left (that is, from the lower digits to the older ones). If the digits of one of the arguments have ended, then the remaining digits of the other argument are written out. Familiarize with examples and formal definitions of the function below.For example: $$$$$$f(1111, 2222) = 12121212$$$$$$ $$$$$$f(7777, 888) = 7787878$$$$$$ $$$$$$f(33, 44444) = 4443434$$$$$$ $$$$$$f(555, 6) = 5556$$$$$$ $$$$$$f(111, 2222) = 2121212$$$$$$Formally,  if $$$p \ge q$$$ then $$$f(a_1 \dots a_p, b_1 \dots b_q) = a_1 a_2 \dots a_{p - q + 1} b_1 a_{p - q + 2} b_2 \dots a_{p - 1} b_{q - 1} a_p b_q$$$;  if $$$p &lt; q$$$ then $$$f(a_1 \dots a_p, b_1 \dots b_q) = b_1 b_2 \dots b_{q - p} a_1 b_{q - p + 1} a_2 \dots a_{p - 1} b_{q - 1} a_p b_q$$$. Mishanya gives you an array consisting of $$$n$$$ integers $$$a_i$$$. All numbers in this array are of equal length (that is, they consist of the same number of digits). Your task is to help students to calculate $$$\sum_{i = 1}^{n}\sum_{j = 1}^{n} f(a_i, a_j)$$$ modulo $$$998\,244\,353$$$. nan def main():
	n = int(input())
	a = [int(i) for i in input().split()]
	size = len(str(a[0]))
	ans = 0; MOD = 998244353
	ten = [1]
	for i in range(1, 21): ten.append(ten[-1] * 10)
	for i in range(n):
		for j in range(size):
			ans += int(str(a[i])[j]) * ten[2 * size - 2 * j - 1] * n
			ans += int(str(a[i])[j]) * ten[2 * size - 2 * j - 2] * n
			ans %= MOD
	print(ans)


main()
","['combinatorics', 'math', 'number theory']"
2559,"The robot is located on a checkered rectangular board of size $$$n \times m$$$ ($$$n$$$ rows, $$$m$$$ columns). The rows in the board are numbered from $$$1$$$ to $$$n$$$ from top to bottom, and the columns — from $$$1$$$ to $$$m$$$ from left to right.The robot is able to move from the current cell to one of the four cells adjacent by side.Each cell has one of the symbols 'L', 'R', 'D' or 'U' written on it, indicating the direction in which the robot will move when it gets in that cell — left, right, down or up, respectively.The robot can start its movement in any cell. He then moves to the adjacent square in the direction indicated on the current square in one move.   If the robot moves beyond the edge of the board, it falls and breaks.  If the robot appears in the cell it already visited before, it breaks (it stops and doesn't move anymore). Robot can choose any cell as the starting cell. Its goal is to make the maximum number of steps before it breaks or stops.Determine from which square the robot should start its movement in order to execute as many commands as possible. A command is considered successfully completed if the robot has moved from the square on which that command was written (it does not matter whether to another square or beyond the edge of the board). nan ''' F. Robot on the Board 2
https://codeforces.com/contest/1607/problem/F
'''

import io, os, sys
input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline  # decode().strip() if str
output = sys.stdout.write

from collections import deque

def solve(R, C, NEXT):
    N = R*C

    # max_dist[r][c] = max moves if start from cell (r, c)
    max_dist = [-1]*N
    # visited = [False]*N

    # probe from unvisited cell (r, c)
    # stop when fall off or revisit a cell
    # when stop, update max_dist for all cells visited in this pass
    def dfs(x):
        chain = deque([x])
        while True:
            x = NEXT[x]
            if x == -1 or max_dist[x] > -1: break
            max_dist[x] = 0
            chain.append(x)
        
        add = max_dist[x] if x != -1 else 0   # > 0 if revisit a cell from previous passes
        cycle_len = 0                         # > 0 if revisit a cell from this pass
        M = len(chain)
        for i, px in enumerate(chain):
            if px == x:
                cycle_len = M - i
            if cycle_len == 0:
                max_dist[px] = M - i + add
            else:
                max_dist[px] = cycle_len

    for x in range(N):
        if max_dist[x] != -1: continue
        dfs(x)
    
    mx_x, mx_d = None, -1
    for x in range(N):
        if max_dist[x] > mx_d:
            mx_x, mx_d = x, max_dist[x]
    r, c = divmod(mx_x, C)
    return r, c, mx_d


def main():
    T = int(input())
    for _ in range(T):
        _ = input()
        R, C = list(map(int, input().split()))

        # next move
        NEXT = [-1]*(R*C)
        nr, nc = -1, -1
        for r in range(R):
            row = input().decode().strip()
            for c, arrow in enumerate(row):                
                if arrow == 'U': nr, nc = r-1, c
                if arrow == 'D': nr, nc = r+1, c
                if arrow == 'L': nr, nc = r, c-1
                if arrow == 'R': nr, nc = r, c+1
                if not (0 <= nr < R and 0 <= nc < C): continue
                NEXT[r*C + c] = nr*C + nc
        
        r, c, d = solve(R, C, NEXT)
        output(f'{r+1} {c+1} {d}\n')


if __name__ == '__main__':
    main()

","['brute force', 'dfs and similar', 'graphs', 'implementation']"
1074,"This is an interactive problem.Bob lives in a square grid of size $$$n \times n$$$, with rows numbered $$$1$$$ through $$$n$$$ from top to bottom, and columns numbered $$$1$$$ through $$$n$$$ from left to right. Every cell is either allowed or blocked, but you don't know the exact description of the grid. You are given only an integer $$$n$$$.Bob can move through allowed cells but only in some limited directions. When Bob is in an allowed cell in the grid, he can move down or right to an adjacent cell, if it is allowed.You can ask at most $$$4 \cdot n$$$ queries of form ""? $$$r_1$$$ $$$c_1$$$ $$$r_2$$$ $$$c_2$$$"" ($$$1 \le r_1 \le r_2 \le n$$$, $$$1 \le c_1 \le c_2 \le n$$$). The answer will be ""YES"" if Bob can get from a cell $$$(r_1, c_1)$$$ to a cell $$$(r_2, c_2)$$$, and ""NO"" otherwise. In particular, if one of the two cells (or both) is a blocked cell then the answer is ""NO"" for sure. Since Bob doesn't like short trips, you can only ask queries with the manhattan distance between the two cells at least $$$n - 1$$$, i.e. the following condition must be satisfied: $$$(r_2 - r_1) + (c_2 - c_1) \ge n - 1$$$.It's guaranteed that Bob can get from the top-left corner $$$(1, 1)$$$ to the bottom-right corner $$$(n, n)$$$ and your task is to find a way to do it. You should print the answer in form ""! S"" where $$$S$$$ is a string of length $$$2 \cdot n - 2$$$ consisting of characters 'D' and 'R', denoting moves down and right respectively. The down move increases the first coordinate by $$$1$$$, the right move increases the second coordinate by $$$1$$$. If there are multiple solutions, any of them will be accepted. You should terminate immediately after printing the solution. NoteThe first example is shown on the picture below.  To hack, use the following input format:The first line should contain a single integer $$$n$$$ ($$$2 \le n \le 500$$$) — the size of the grid.Each of the next $$$n$$$ lines should contain a string of $$$n$$$ characters '#' or '.', where '#' denotes a blocked cell, and '.' denotes an allowed cell.For example, the following text encodes the example shown above:4..#.#...###..... from sys import stdout

n = int(input())
x, y = 1, 1

steps = []

for i in range(1, n):
    stdout.write(""? {0} {1} {2} {3}\n"".format(x + 1, y, n, n))
    stdout.flush()
    resp = input()
    if resp == ""YES"":
        steps.append('D')
        x += 1
    else:
        steps.append('R')
        y += 1

x, y = n, n
for i in range(1, n):
    stdout.write(""? {0} {1} {2} {3}\n"".format(1, 1, x, y - 1))
    stdout.flush()
    resp = input()
    if resp == ""YES"":
        steps.append('R')
        y -= 1
    else:
        steps.append('D')
        x -= 1

print(""! {0}{1}"".format("""".join(x for x in steps[:n - 1]), """".join(x for x in steps[n - 1:][::-1])))
","['constructive algorithms', 'interactive', 'other']"
2746,"Mahmoud and Ehab are on the third stage of their adventures now. As you know, Dr. Evil likes sets. This time he won't show them any set from his large collection, but will ask them to create a new set to replenish his beautiful collection of sets.Dr. Evil has his favorite evil integer x. He asks Mahmoud and Ehab to find a set of n distinct non-negative integers such the bitwise-xor sum of the integers in it is exactly x. Dr. Evil doesn't like big numbers, so any number in the set shouldn't be greater than 106. NoteYou can read more about the bitwise-xor operation here: https://en.wikipedia.org/wiki/Bitwise_operation#XORFor the first sample .For the second sample . n, x = input().split()
n, x = int(n), int(x)

m1 = 2 ** 17
m2 = 2 ** 18

if n == 2 and x == 0:
    print(""NO"")
elif n == 1:
    a = [x]
elif n == 2 and x > 0:
    a = [0, x]
else:
    a = []
    ans = 0
    for i in range(1, n-2):
        ans ^= i
        a.append(i)
    if ans == x:
        a.append(m1)
        a.append(m2)
        a.append(m1+m2)
    else:
        a.append(m1)
        a.append(m1 ^ x ^ ans)
        a.append(0)
if not (n == 2 and x == 0):
    print(""YES"")
    print("" "".join([str(e) for e in a]))
",['constructive algorithms']
681,"You are given $$$k$$$ sequences of integers. The length of the $$$i$$$-th sequence equals to $$$n_i$$$.You have to choose exactly two sequences $$$i$$$ and $$$j$$$ ($$$i \ne j$$$) such that you can remove exactly one element in each of them in such a way that the sum of the changed sequence $$$i$$$ (its length will be equal to $$$n_i - 1$$$) equals to the sum of the changed sequence $$$j$$$ (its length will be equal to $$$n_j - 1$$$).Note that it's required to remove exactly one element in each of the two chosen sequences.Assume that the sum of the empty (of the length equals $$$0$$$) sequence is $$$0$$$. NoteIn the first example there are two sequences $$$[2, 3, 1, 3, 2]$$$ and $$$[1, 1, 2, 2, 2, 1]$$$. You can remove the second element from the first sequence to get $$$[2, 1, 3, 2]$$$ and you can remove the sixth element from the second sequence to get $$$[1, 1, 2, 2, 2]$$$. The sums of the both resulting sequences equal to $$$8$$$, i.e. the sums are equal. t = int(input())
dic = {}
for z in range(t):
	n = int(input())
	arr = [int(x) for x in input().split()]
	sarr = sum(arr+[0])
	for i in range(n):
		if dic.get(sarr-arr[i]) is None:
			dic[sarr-arr[i]] = (z+1,i+1)
		else:
			midx = dic[sarr-arr[i]]
			if midx[0]!= z+1:
				print('YES')
				print(midx[0],midx[1])
				print(z+1,i+1)
				exit()
print('NO')","['implementation', 'sortings']"
3276,"Ray lost his array and needs to find it by asking Omkar. Omkar is willing to disclose that the array has the following qualities:  The array has $$$n$$$ ($$$1 \le n \le 2 \cdot 10^5$$$) elements.  Every element in the array $$$a_i$$$ is an integer in the range $$$1 \le a_i \le 10^9.$$$  The array is sorted in nondecreasing order. Ray is allowed to send Omkar a series of queries. A query consists of two integers, $$$l$$$ and $$$r$$$ such that $$$1 \le l \le r \le n$$$. Omkar will respond with two integers, $$$x$$$ and $$$f$$$. $$$x$$$ is the mode of the subarray from index $$$l$$$ to index $$$r$$$ inclusive. The mode of an array is defined by the number that appears the most frequently. If there are multiple numbers that appear the most number of times, the smallest such number is considered to be the mode. $$$f$$$ is the amount of times that $$$x$$$ appears in the queried subarray.The array has $$$k$$$ ($$$1 \le k \le \min(25000,n)$$$) distinct elements. However, due to Ray's sins, Omkar will not tell Ray what $$$k$$$ is. Ray is allowed to send at most $$$4k$$$ queries.Help Ray find his lost array. NoteThe first query is $$$l=1$$$ and $$$r=6$$$. The mode is $$$2$$$, and $$$2$$$ appears $$$2$$$ times, so $$$x=2$$$ and $$$f=2$$$. Note that $$$3$$$ also appears two times, but $$$2$$$ is outputted because $$$2$$$ is smaller.The second query is $$$l=1$$$ and $$$r=3$$$. The mode is $$$2$$$ and $$$2$$$ appears twice in the subarray with indices $$$[1,3]$$$.The third query is $$$l=4$$$ and $$$r=6$$$. The mode is $$$3$$$ and $$$3$$$ appears twice in the subarray with indices $$$[4,6]$$$.The fourth query is $$$l=3$$$ and $$$r=4$$$. The mode is $$$2$$$, which appears once in the subarray with indices $$$[3,4]$$$. Note that $$$3$$$ also appears once in that range, but $$$2$$$ is smaller than $$$3$$$. import os
import sys
from __builtin__ import xrange as range
from cStringIO import StringIO
from future_builtins import ascii, filter, hex, map, oct, zip
from io import IOBase
 
import __pypy__
 
 
def main():
    rem = {}
    def query(l,r):
        if (l,r) not in rem:
            print '?', l + 1, r
            sys.stdout.flush()
            x,f = [int(x) for x in input().split()]
            rem[l,r] = x,f
        return rem[l,r]
 
    n = int(input())
 
    A = [-1]*n
    def solve(l,r):
        if l == r:
            return
        mid = l + r >> 1
 
        x0,f0 = query(l,r)
        if r - l == f0:
            for i in range(l,r):
                A[i] = x0
            return
        x1,f1 = query(l,mid)
        x2,f2 = query(mid,r)
 
        if x0 == x1 and f0 > f1:
            for i in range(mid - f1, mid - f1 + f0):
                A[i] = x0
            solve(l, mid - f1)
            solve(mid - f1 + f0, r)
        elif x0 == x2 and f0 > f2:
            for i in range(mid + f2 - f0, mid + f2):
                A[i] = x0
            solve(l, mid + f2 - f0)
            solve(mid + f2, r)
        else:
            solve(l,mid)
            solve(mid,r)
    solve(0,n)
    print '!', ' '.join(str(a) for a in A)
 
 
# region fastio
 
BUFSIZE = 8192
 
 
class FastI(IOBase):
    def __init__(self, file):
        self._fd = file.fileno()
        self._buffer = StringIO()
        self.newlines = 0
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(""\n"") + (not b)
            ptr = self._buffer.tell()
            self._buffer.seek(0, 2), self._buffer.write(b), self._buffer.seek(ptr)
        self.newlines -= 1
        return self._buffer.readline()
 
 
class FastO(IOBase):
    def __init__(self, file):
        self._fd = file.fileno()
        self._buffer = __pypy__.builders.StringBuilder()
        self.write = lambda s: self._buffer.append(s)
 
    def flush(self):
        os.write(self._fd, self._buffer.build())
        self._buffer = __pypy__.builders.StringBuilder()
 
 
sys.stdin, sys.stdout = FastI(sys.stdin), FastO(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
 
# endregion
 
if __name__ == ""__main__"":
    main()","['binary search', 'divide and conquer', 'interactive']"
4390,"A lot of people in Berland hates rain, but you do not. Rain pacifies, puts your thoughts in order. By these years you have developed a good tradition — when it rains, you go on the street and stay silent for a moment, contemplate all around you, enjoy freshness, think about big deeds you have to do. Today everything had changed quietly. You went on the street with a cup contained water, your favorite drink. In a moment when you were drinking a water you noticed that the process became quite long: the cup still contained water because of rain. You decided to make a formal model of what was happening and to find if it was possible to drink all water in that situation. Thus, your cup is a cylinder with diameter equals d centimeters. Initial level of water in cup equals h centimeters from the bottom.   You drink a water with a speed equals v milliliters per second. But rain goes with such speed that if you do not drink a water from the cup, the level of water increases on e centimeters per second. The process of drinking water from the cup and the addition of rain to the cup goes evenly and continuously. Find the time needed to make the cup empty or find that it will never happen. It is guaranteed that if it is possible to drink all water, it will happen not later than after 104 seconds.Note one milliliter equals to one cubic centimeter. NoteIn the first example the water fills the cup faster than you can drink from it.In the second example area of the cup's bottom equals to , thus we can conclude that you decrease the level of water by  centimeters per second. At the same time water level increases by 1 centimeter per second due to rain. Thus, cup will be empty in  seconds. from math import pi
d, h, v, e = map(int, raw_input().split())

vol = 4 * v /(pi * d * d)

if e >= vol :
    print ""NO""
else :
    print ""YES""
    print h / (vol - e)
","['geometry', 'math']"
79,"Pavel made a photo of his favourite stars in the sky. His camera takes a photo of all points of the sky that belong to some rectangle with sides parallel to the coordinate axes.Strictly speaking, it makes a photo of all points with coordinates $$$(x, y)$$$, such that $$$x_1 \leq x \leq x_2$$$ and $$$y_1 \leq y \leq y_2$$$, where $$$(x_1, y_1)$$$ and $$$(x_2, y_2)$$$ are coordinates of the left bottom and the right top corners of the rectangle being photographed. The area of this rectangle can be zero.After taking the photo, Pavel wrote down coordinates of $$$n$$$ of his favourite stars which appeared in the photo. These points are not necessarily distinct, there can be multiple stars in the same point of the sky.Pavel has lost his camera recently and wants to buy a similar one. Specifically, he wants to know the dimensions of the photo he took earlier. Unfortunately, the photo is also lost. His notes are also of not much help; numbers are written in random order all over his notepad, so it's impossible to tell which numbers specify coordinates of which points.Pavel asked you to help him to determine what are the possible dimensions of the photo according to his notes. As there are multiple possible answers, find the dimensions with the minimal possible area of the rectangle. NoteIn the first sample stars in Pavel's records can be $$$(1, 3)$$$, $$$(1, 3)$$$, $$$(2, 3)$$$, $$$(2, 4)$$$. In this case, the minimal area of the rectangle, which contains all these points is $$$1$$$ (rectangle with corners at $$$(1, 3)$$$ and $$$(2, 4)$$$). n=int(input())
s=sorted(list(map(int,input().split())))
ans=(s[n-1]-s[0])*(s[2*n-1]-s[n])
for i in range(n):ans=min(ans,(s[2*n-1]-s[0])*(s[n-1+i]-s[i]))
print(ans)
","['brute force', 'implementation', 'math', 'sortings']"
228,"Vasya is going to the Olympics in the city Ntown by train. The boy wants to read the textbook to prepare for the Olympics. He counted that he needed k hours for this. He also found that the light in the train changes every hour. The light is measured on a scale from 0 to 100, where 0 is very dark, and 100 is very light.Vasya has a train lighting schedule for all n hours of the trip — n numbers from 0 to 100 each (the light level in the first hour, the second hour and so on). During each of those hours he will either read the whole time, or not read at all. He wants to choose k hours to read a book, not necessarily consecutive, so that the minimum level of light among the selected hours were maximum. Vasya is very excited before the upcoming contest, help him choose reading hours. NoteIn the first sample Vasya should read at the first hour (light 20), third hour (light 30) and at the fourth hour (light 40). The minimum light Vasya will have to read at is 20. import sys
sys.stdin = open('input.txt', 'r')
sys.stdout = open('output.txt', 'w')
n,k = list(map(int, input().split()))
A = []
for i,light in enumerate(list(map(int, input().split()))):
    A.append((light,i))
A.sort(reverse=True)
print(A[k-1][0])
out = [A[i][1]+1 for i in range(k)]
print("" "".join(map(str, out)))",['sortings']
3142,"You are given an array $$$a$$$ consisting of $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$. Friends asked you to make the greatest common divisor (GCD) of all numbers in the array equal to $$$1$$$. In one operation, you can do the following: Select an arbitrary index in the array $$$1 \leq i \leq n$$$; Make $$$a_i = \gcd(a_i, i)$$$, where $$$\gcd(x, y)$$$ denotes the GCD of integers $$$x$$$ and $$$y$$$. The cost of such an operation is $$$n - i + 1$$$.You need to find the minimum total cost of operations we need to perform so that the GCD of the all array numbers becomes equal to $$$1$$$. NoteIn the first test case, the GCD of the entire array is already equal to $$$1$$$, so there is no need to perform operations.In the second test case, select $$$i = 1$$$. After this operation, $$$a_1 = \gcd(2, 1) = 1$$$. The cost of this operation is $$$1$$$.In the third test case, you can select $$$i = 1$$$, after that the array $$$a$$$ will be equal to $$$[1, 4]$$$. The GCD of this array is $$$1$$$, and the total cost is $$$2$$$.In the fourth test case, you can select $$$i = 2$$$, after that the array $$$a$$$ will be equal to $$$[3, 2, 9]$$$. The GCD of this array is $$$1$$$, and the total cost is $$$2$$$.In the sixth test case, you can select $$$i = 4$$$ and $$$i = 5$$$, after that the array $$$a$$$ will be equal to $$$[120, 60, 80, 4, 5]$$$. The GCD of this array is $$$1$$$, and the total cost is $$$3$$$. import sys,math
input=sys.stdin.readline
for _ in range(int(input())):
    n=int(input())
    lst=list(map(int,input().split()))
    gd=lst[0]
    for i in lst[1:]: gd=math.gcd(gd,i)
    if gd==1: print(0)
    elif math.gcd(gd,n)==1: print(1)
    elif math.gcd(gd,n-1)==1: print(2)
    else: print(3)


 ","['brute force', 'combinatorics', 'constructive algorithms', 'implementation', 'math', 'number theory']"
3707,"Завтра у хоккейной команды, которой руководит Евгений, важный матч. Евгению нужно выбрать шесть игроков, которые выйдут на лед в стартовом составе: один вратарь, два защитника и три нападающих.Так как это стартовый состав, Евгения больше волнует, насколько красива будет команда на льду, чем способности игроков. А именно, Евгений хочет выбрать такой стартовый состав, чтобы номера любых двух игроков из стартового состава отличались не более, чем в два раза. Например, игроки с номерами 13, 14, 10, 18, 15 и 20 устроят Евгения, а если, например, на лед выйдут игроки с номерами 8 и 17, то это не устроит Евгения.Про каждого из игроков вам известно, на какой позиции он играет (вратарь, защитник или нападающий), а также его номер. В хоккее номера игроков не обязательно идут подряд. Посчитайте число различных стартовых составов из одного вратаря, двух защитников и трех нападающих, которые может выбрать Евгений, чтобы выполнялось его условие красоты. ПримечаниеВ первом примере всего один вариант для выбора состава, который удовлетворяет описанным условиям, поэтому ответ 1.Во втором примере подходят следующие игровые сочетания (в порядке вратарь-защитник-защитник-нападающий-нападающий-нападающий):  16 20 12 13 21 11  16 20 12 13 11 10  16 20 19 13 21 11  16 20 19 13 11 10  16 12 19 13 21 11  16 12 19 13 11 10 Таким образом, ответ на этот пример — 6. import sys
import math
import random
import time

def func_cnk(keepers, defenders, attackers, flag):
    if flag == 'kpr':
        kpr = 1
        defs = math.factorial(defenders) // math.factorial(2) // math.factorial(defenders - 2)
        atts = math.factorial(attackers) // math.factorial(3) // math.factorial(attackers - 3)
    elif flag == 'def':
        kpr = keepers
        defs = defenders - 1
        atts = math.factorial(attackers) // math.factorial(3) // math.factorial(attackers - 3)
    elif flag == 'att':
        kpr = keepers
        defs = math.factorial(defenders) // math.factorial(2) // math.factorial(defenders - 2)
        atts = math.factorial(attackers - 1) // math.factorial(2) // math.factorial(attackers - 3)
    return kpr * int(defs) * int(atts)

g, d, f = list(map(int, input().split()))
x = list(map(int, input().split()))
y = list(map(int, input().split()))
z = list(map(int, input().split()))
#N = 100000
#x = random.sample(range(1, N), g)
#y = random.sample(range(1, N), d)
#z = random.sample(range(1, N), f)
#print(x, y, z)

if (d < 2) or (f < 3):
    print('0')
    sys.exit()

t = time.time()

res_ans = 0
dict_nums = {}

for num in x:
    dict_nums[num] = 'kpr'
for num in y:
    dict_nums[num] = 'def'
for num in z:
    dict_nums[num] = 'att'

all_nums = x + y + z
all_nums.sort()

for i in range(len(all_nums)):
    upper = all_nums[i] * 2
    j = i
    keepers = 0
    defenders = 0
    attackers = 0
    while (j < len(all_nums) and (all_nums[j] <= upper)):
        if dict_nums[all_nums[j]] == 'kpr':
            keepers = keepers + 1
        if dict_nums[all_nums[j]] == 'def':
            defenders = defenders + 1
        if dict_nums[all_nums[j]] == 'att':
            attackers = attackers + 1
        j = j + 1
    if (keepers > 0) and (defenders > 1) and (attackers > 2):
        #print(all_nums[i], func_cnk(keepers, defenders, attackers, dict_nums[all_nums[i]]))
        res_ans = res_ans + func_cnk(keepers, defenders, attackers, dict_nums[all_nums[i]])

print(res_ans)","['combinatorics', 'math', 'other']"
1514,"This is an interactive problem.Yui is a girl who enjoys playing Mahjong. She has a mysterious set which consists of tiles (this set can be empty). Each tile has an integer value between $$$1$$$ and $$$n$$$, and at most $$$n$$$ tiles in the set have the same value. So the set can contain at most $$$n^2$$$ tiles.You want to figure out which values are on the tiles. But Yui is shy, she prefers to play a guessing game with you.Let's call a set consisting of three tiles triplet if their values are the same. For example, $$$\{2,\,2,\,2\}$$$ is a triplet, but $$$\{2,\,3,\,3\}$$$ is not.Let's call a set consisting of three tiles straight if their values are consecutive integers. For example, $$$\{2,\,3,\,4\}$$$ is a straight, but $$$\{1,\,3,\,5\}$$$ is not.At first, Yui gives you the number of triplet subsets and straight subsets of the initial set respectively. After that, you can insert a tile with an integer value between $$$1$$$ and $$$n$$$ into the set at most $$$n$$$ times. Every time you insert a tile, you will get the number of triplet subsets and straight subsets of the current set as well.Note that two tiles with the same value are treated different. In other words, in the set $$$\{1,\,1,\,2,\,2,\,3\}$$$ you can find $$$4$$$ subsets $$$\{1,\,2,\,3\}$$$.Try to guess the number of tiles in the initial set with value $$$i$$$ for all integers $$$i$$$ from $$$1$$$ to $$$n$$$. NoteIn the first test, the initial set of tiles is $$$\{1, 1, 2, 3, 3, 3, 5, 5\}$$$. It has only one triplet subset $$$\{3, 3, 3\}$$$ and six straight subsets, all equal to $$$\{1, 2, 3\}$$$. After inserting a tile with value $$$1$$$ the set of tiles will be $$$\{1, 1, 1, 2, 3, 3, 3, 5, 5\}$$$ and will have two triplet subsets $$$\{1, 1, 1\}$$$, $$$\{3, 3, 3\}$$$ and nine straight subsets, all equal to $$$\{1, 2, 3\}$$$. n = int(input())

t, s = map(int, input().split())

x = n-1

while x>2:
	print(""+"",x)
	x-=1

print(""+ {}\n+ {}\n+ {}"".format(1, 2, 1), flush = True)

deltas = []
for i in range(n):
	t2, s2 = map(int, input().split())
	deltas.append([ t2 - t, s2 - s])
	s = s2
	t = t2

#print(deltas)

ans = [0] * n

x = 0
while (x+1)*x < deltas[-1][0]*2: x+=1

ans[0] = x
ans[2] = deltas[-1][1] - deltas[-3][1] -1
ans[1] = deltas[-3][1]//(ans[2]+1)

ans[3] = (deltas[-2][1] - (ans[0]+1)*(ans[2]+1))//(ans[2]+1) -1

for x in range(4,n):
	#print(deltas[-x])
	ans[x] = (deltas[-x][1] - ans[x-4] * ans[x-3] - ans[x-3]*(ans[x-1] +1))//(ans[x-1]+1) -1


ans[-1]+=1

print(""!"", end = ' ')
for x in ans:
	print(x, end = ' ')
print()
","['constructive algorithms', 'interactive']"
4376,"The Smart Beaver from ABBYY got hooked on square matrices. Now he is busy studying an n × n size matrix, where n is odd. The Smart Beaver considers the following matrix elements good:    Elements of the main diagonal.   Elements of the secondary diagonal.   Elements of the ""middle"" row — the row which has exactly  rows above it and the same number of rows below it.   Elements of the ""middle"" column — the column that has exactly  columns to the left of it and the same number of columns to the right of it.    The figure shows a 5 × 5 matrix.   The good elements are marked with green.  Help the Smart Beaver count the sum of good elements of the given matrix. NoteIn the first sample all matrix elements will be good. Good elements in the second sample are shown on the figure. from collections import Counter


def array(arr, struc):
    return (list(map(struc, arr.split())))


n = int(input())
mat = []
for i in range(n):
    mat.append(array(input(), int))

final = 0

for i in range(n):
    for j in range(n):
        if i == j:
            final += mat[i][j]
        if i+j+1 == n:
            final += mat[i][j]
        if j == n//2:
            final += mat[i][j]

final += sum(mat[n//2])
print(final-3*mat[n//2][n//2])
",['implementation']
4302,"DZY loves chessboard, and he enjoys playing with it.He has a chessboard of n rows and m columns. Some cells of the chessboard are bad, others are good. For every good cell, DZY wants to put a chessman on it. Each chessman is either white or black. After putting all chessmen, DZY wants that no two chessmen with the same color are on two adjacent cells. Two cells are adjacent if and only if they share a common edge.You task is to find any suitable placement of chessmen on the given chessboard. NoteIn the first sample, DZY puts a single black chessman. Of course putting a white one is also OK.In the second sample, all 4 cells are good. No two same chessmen share an edge in the sample output.In the third sample, no good cells are adjacent. So you can just put 3 chessmen, no matter what their colors are. n, m = map(int, raw_input().split())

for i in range(n):
	string = raw_input()
	saida = ''
	for j in range(m):
		if string[j] == ""."":
			if (i+j) & 1:
				saida+= ""W""
			else:
				saida+= ""B""
		else:
			saida += ""-""
	print saida
","['dfs and similar', 'implementation']"
4799,"As you know, majority of students and teachers of Summer Informatics School live in Berland for the most part of the year. Since corruption there is quite widespread, the following story is not uncommon.Elections are coming. You know the number of voters and the number of parties — $$$n$$$ and $$$m$$$ respectively. For each voter you know the party he is going to vote for. However, he can easily change his vote given a certain amount of money. In particular, if you give $$$i$$$-th voter $$$c_i$$$ bytecoins you can ask him to vote for any other party you choose.The United Party of Berland has decided to perform a statistical study — you need to calculate the minimum number of bytecoins the Party needs to spend to ensure its victory. In order for a party to win the elections, it needs to receive strictly more votes than any other party. NoteIn the first sample, The United Party wins the elections even without buying extra votes.In the second sample, The United Party can buy the votes of the first and the fourth voter. This way The Party gets two votes, while parties $$$3$$$, $$$4$$$ and $$$5$$$ get one vote and party number $$$2$$$ gets no votes.In the third sample, The United Party can buy the votes of the first three voters and win, getting three votes against two votes of the fifth party. import sys
#sys.stdin=open(""DATA.txt"",'r')
n,m=map(int,raw_input().split())
votes = [[] for i in xrange(m+1)]
for i in xrange(n):
    p,c = map(int,raw_input().split())
    votes[p].append(c)
for i in xrange(m+1):
    votes[i].sort()
cur = len(votes[1])
ans=1e999
for i in xrange(cur, n+1):
    need = i - cur
    cost = 0
    left = []
    for j in xrange(2,m+1):
        if len(votes[j]) >= i:
            cost += sum(votes[j][:len(votes[j])-i + 1])
            left += votes[j][len(votes[j])-i+1:]
            need -= len(votes[j]) - i + 1
        else:
            left += votes[j]
    if need > 0:
        left.sort()
        cost += sum(left[:need])
    ans=min(ans,cost)
print ans
    
",['greedy']
2484,"A number is called 2050-number if it is $$$2050$$$, $$$20500$$$, ..., ($$$2050 \cdot 10^k$$$ for integer $$$k \ge 0$$$).Given a number $$$n$$$, you are asked to represent $$$n$$$ as the sum of some (not necessarily distinct) 2050-numbers. Compute the minimum number of 2050-numbers required for that. NoteIn the third case, $$$4100 = 2050 + 2050$$$.In the fifth case, $$$22550 = 20500 + 2050$$$. for _ in range(int(input())):
    n = int(input())
    a = n//2050

    if n%2050 != 0:
        print(-1)
        continue

    sum = 0
    for i in str(a):
        sum += int(i)

    if sum:
        print(sum)
    else:
        print(-1)","['greedy', 'math']"
8,"You are given an array $$$a$$$ consisting of $$$n$$$ integers. Let's denote monotonic renumeration of array $$$a$$$ as an array $$$b$$$ consisting of $$$n$$$ integers such that all of the following conditions are met:  $$$b_1 = 0$$$;  for every pair of indices $$$i$$$ and $$$j$$$ such that $$$1 \le i, j \le n$$$, if $$$a_i = a_j$$$, then $$$b_i = b_j$$$ (note that if $$$a_i \ne a_j$$$, it is still possible that $$$b_i = b_j$$$);  for every index $$$i \in [1, n - 1]$$$ either $$$b_i = b_{i + 1}$$$ or $$$b_i + 1 = b_{i + 1}$$$. For example, if $$$a = [1, 2, 1, 2, 3]$$$, then two possible monotonic renumerations of $$$a$$$ are $$$b = [0, 0, 0, 0, 0]$$$ and $$$b = [0, 0, 0, 0, 1]$$$.Your task is to calculate the number of different monotonic renumerations of $$$a$$$. The answer may be large, so print it modulo $$$998244353$$$. nan def merge(intervals):
        """"""
        :type intervals: List[Interval]
        :rtype: List[Interval]
        """"""
        intervals = sorted(intervals, key=lambda x: x[0])
        n=len(intervals)
        if n==0:
            return []
        re=[]
        re.append(intervals[0])
        for i in range(1,n):
            a=re[-1]
            b=intervals[i]
            if b[0]>a[1]:
                re.append(b)
            else:
                re[-1][1]=max(a[1],b[1])
        return re

n=int(raw_input())

A=map(int, raw_input().split())
mod=998244353



dic={}

for i in range(n):
    x=A[i]
    if x not in dic:
        dic[x]=[i]
    elif x in dic:
        if len(dic[x])==1:
            dic[x].append(i)
        else:
            dic[x][-1]=i

interval=[]
for key in dic:
    if len(dic[key])==2:
        interval.append(dic[key])

intv2=merge(interval)
m=len(intv2)
ct=0

for x1,x2 in intv2:
    ct+=(x2-x1)

print pow(2,n-ct-1,mod)","['combinatorics', 'sortings']"
4771,"Andrewid the Android is a galaxy-known detective. Now he does not investigate any case and is eating chocolate out of boredom.A bar of chocolate can be presented as an n × n table, where each cell represents one piece of chocolate. The columns of the table are numbered from 1 to n from left to right and the rows are numbered from top to bottom. Let's call the anti-diagonal to be a diagonal that goes the lower left corner to the upper right corner of the table. First Andrewid eats all the pieces lying below the anti-diagonal. Then he performs the following q actions with the remaining triangular part: first, he chooses a piece on the anti-diagonal and either direction 'up' or 'left', and then he begins to eat all the pieces starting from the selected cell, moving in the selected direction until he reaches the already eaten piece or chocolate bar edge.After each action, he wants to know how many pieces he ate as a result of this action. NotePictures to the sample tests:The pieces that were eaten in the same action are painted the same color. The pieces lying on the anti-diagonal contain the numbers of the action as a result of which these pieces were eaten.In the second sample test the Andrewid tries to start eating chocolate for the second time during his fifth action, starting from the cell at the intersection of the 10-th column and the 1-st row, but this cell is already empty, so he does not eat anything. import sys
from bisect import bisect

def input():
	return sys.stdin.readline().strip()

def solve():
	n, q = map(int, input().split())
	was = set()
	Q = [None]*q
	all = [0]*(2*q)
	for i in range(q):
		x, y, t = input().split()
		x, y = int(x), int(y)
		Q[i] = (x, y, t)
		all[2*i] = x
		all[2*i+1] = y
	all.sort()
	V = [0]*(4*q)
	H = [0]*(4*q)
	for x, y, t in Q:
		if (x,y) in was:
			print(0)
		else:
			was.add((x,y))
			if t == 'L':
				TA = H
				TB = V
			else:
				x, y = y, x
				TA = V
				TB = H
			v = bisect(all, y) - 1 + q + q
			r = 0
			while v > 0:
				r = max(r, TA[v])
				v //= 2
			c = x - r
			print(c)
			r = bisect(all, x) - 1 + q + q
			l = bisect(all, x - c) + q + q
			while l <= r:
				if l % 2 == 1:
					TB[l] = max(TB[l], y)
				if r % 2 == 0:
					TB[r] = max(TB[r], y)
				l = (l+1)//2
				r = (r-1)//2

solve()
","['binary search', 'data structures']"
3688,"You are given two strings of equal length $$$s$$$ and $$$t$$$ consisting of lowercase Latin letters. You may perform any number (possibly, zero) operations on these strings.During each operation you choose two adjacent characters in any string and assign the value of the first character to the value of the second or vice versa.For example, if $$$s$$$ is ""acbc"" you can get the following strings in one operation:   ""aabc"" (if you perform $$$s_2 = s_1$$$);  ""ccbc"" (if you perform $$$s_1 = s_2$$$);  ""accc"" (if you perform $$$s_3 = s_2$$$ or $$$s_3 = s_4$$$);  ""abbc"" (if you perform $$$s_2 = s_3$$$);  ""acbb"" (if you perform $$$s_4 = s_3$$$); Note that you can also apply this operation to the string $$$t$$$.Please determine whether it is possible to transform $$$s$$$ into $$$t$$$, applying the operation above any number of times.Note that you have to answer $$$q$$$ independent queries. NoteIn the first query, you can perform two operations $$$s_1 = s_2$$$ (after it $$$s$$$ turns into ""aabb"") and $$$t_4 = t_3$$$ (after it $$$t$$$ turns into ""aabb""). In the second query, the strings are equal initially, so the answer is ""YES"".In the third query, you can not make strings $$$s$$$ and $$$t$$$ equal. Therefore, the answer is ""NO"". n=int(input())
for i in range (n):
  a,b=(input()),(input())
  for i in b:
    if i in a:
      k=""YES""
      break
    else:
      k=""NO""
  print(k)",['strings']
2787,"Iahub is very proud of his recent discovery, propagating trees. Right now, he invented a new tree, called xor-tree. After this new revolutionary discovery, he invented a game for kids which uses xor-trees.The game is played on a tree having n nodes, numbered from 1 to n. Each node i has an initial value initi, which is either 0 or 1. The root of the tree is node 1.One can perform several (possibly, zero) operations on the tree during the game. The only available type of operation is to pick a node x. Right after someone has picked node x, the value of node x flips, the values of sons of x remain the same, the values of sons of sons of x flips, the values of sons of sons of sons of x remain the same and so on.The goal of the game is to get each node i to have value goali, which can also be only 0 or 1. You need to reach the goal of the game by using minimum number of operations. nan import fileinput

def levels(n, e):
	l = [0 for _ in range(n)]
	q = [(0, -1, 0)]
	while q:
		v, u, d = q.pop()
		l[v] = d

		for w in e[v]:
			if w != u: q.append((w, v, d+1))
	return l

def solve(n, e, x, g):
	l = levels(n, e)

	f = [0, 0]
	q = [(0, -1)]
	z = []
	while q:
		v, u = q.pop()

		if v == -1:
			f = u
			continue
		q.append((-1, f[:]))

		d = l[v]%2
		if (x[v]+f[d])%2 != g[v]:
			f[d] = (f[d]+1)%2
			z.append(v)

		for w in e[v]:
			if w != u: q.append((w, v))

	print(len(z))
	for v in z: print(v+1)

f = fileinput.input()
n = int(f.readline())
e = [[] for _ in range(n)]
for _ in range(n-1):
	v, w = tuple(map(int, f.readline().rstrip().split()))
	e[v-1].append(w-1)
	e[w-1].append(v-1)
x = list(map(int, f.readline().rstrip().split()))
g = list(map(int, f.readline().rstrip().split()))
solve(n, e, x, g)","['brute force', 'data structures', 'dfs and similar', 'trees']"
1335,"A tree is an undirected connected graph without cycles. The distance between two vertices is the number of edges in a simple path between them.Limak is a little polar bear. He lives in a tree that consists of n vertices, numbered 1 through n.Limak recently learned how to jump. He can jump from a vertex to any vertex within distance at most k.For a pair of vertices (s, t) we define f(s, t) as the minimum number of jumps Limak needs to get from s to t. Your task is to find the sum of f(s, t) over all pairs of vertices (s, t) such that s &lt; t. NoteIn the first sample, the given tree has 6 vertices and it's displayed on the drawing below. Limak can jump to any vertex within distance at most 2. For example, from the vertex 5 he can jump to any of vertices: 1, 2 and 4 (well, he can also jump to the vertex 5 itself).  There are  pairs of vertices (s, t) such that s &lt; t. For 5 of those pairs Limak would need two jumps: (1, 6), (3, 4), (3, 5), (3, 6), (5, 6). For other 10 pairs one jump is enough. So, the answer is 5·2 + 10·1 = 20.In the third sample, Limak can jump between every two vertices directly. There are 3 pairs of vertices (s &lt; t), so the answer is 3·1 = 3. def main():
    inp = readnumbers()
    ii = 0

    n = inp[ii]
    ii += 1
    k = inp[ii]
    ii += 1

    coupl = [[] for _ in range(n)]
    for _ in range(n-1):
        u = inp[ii]-1
        ii += 1
        v = inp[ii]-1
        ii += 1

        coupl[u].append(v)
        coupl[v].append(u)

    found = [False]*n
    
    @bootstrap
    def solve(node):
        A = [0]*k
        A[0] = 1
        Acount = 0
        Aans = 0
        
        for nei in coupl[node]:
            if not found[nei]:
                found[nei] = True
                B,Bcount,Bans = yield solve(nei)
                Aans += Bans
                Aans += Bcount * sum(A)
                Aans += Acount * sum(B)
                Acount += Bcount

                for i in range(k):
                    for j in range(k):
                        Aans += ((i+j+k)//k)*A[i]*B[j]
                for i in range(k-1):
                    A[i+1] += B[i]
                A[0] += B[k-1]
                Acount += B[k-1]

        yield A,Acount,Aans

    found[0] = True
    _,_,ans = solve(0)
    print ans


######## Python 2 and 3 footer by Pajenegod and c1729

# Note because cf runs old PyPy3 version which doesn't have the sped up
# unicode strings, PyPy3 strings will many times be slower than pypy2.
# There is a way to get around this by using binary strings in PyPy3
# but its syntax is different which makes it kind of a mess to use.

# So on cf, use PyPy2 for best string performance.

py2 = round(0.5)
if py2:
    from future_builtins import ascii, filter, hex, map, oct, zip
    range = xrange

import os, sys
from io import IOBase, BytesIO

BUFSIZE = 8192
class FastIO(BytesIO):
    newlines = 0

    def __init__(self, file):
        self._file = file
        self._fd = file.fileno()
        self.writable = ""x"" in file.mode or ""w"" in file.mode
        self.write = super(FastIO, self).write if self.writable else None

    def _fill(self):
        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
        self.seek((self.tell(), self.seek(0,2), super(FastIO, self).write(s))[0])
        return s

    def read(self):
        while self._fill(): pass
        return super(FastIO,self).read()

    def readline(self):
        while self.newlines == 0:
            s = self._fill(); self.newlines = s.count(b""\n"") + (not s)
        self.newlines -= 1
        return super(FastIO, self).readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.getvalue())
            self.truncate(0), self.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        if py2:
            self.write = self.buffer.write
            self.read = self.buffer.read
            self.readline = self.buffer.readline
        else:
            self.write = lambda s:self.buffer.write(s.encode('ascii'))
            self.read = lambda:self.buffer.read().decode('ascii')
            self.readline = lambda:self.buffer.readline().decode('ascii')


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip('\r\n')

# Cout implemented in Python
import sys
class ostream:
    def __lshift__(self,a):
        sys.stdout.write(str(a))
        return self
cout = ostream()
endl = '\n'

# Read all remaining integers in stdin, type is given by optional argument, this is fast
def readnumbers(zero = 0):
    conv = ord if py2 else lambda x:x
    A = []; numb = zero; sign = 1; i = 0; s = sys.stdin.buffer.read()
    try:
        while True:
            if s[i] >= b'0' [0]:
                numb = 10 * numb + conv(s[i]) - 48
            elif s[i] == b'-' [0]: sign = -1
            elif s[i] != b'\r' [0]:
                A.append(sign*numb)
                numb = zero; sign = 1
            i += 1
    except:pass
    if s and s[-1] >= b'0' [0]:
        A.append(sign*numb)
    return A


# My magical way of doing recursion in python. This
# isn't the fastest, but at least it works.
from types import GeneratorType
def bootstrap(func, stack=[]):
    def wrapped_function(*args, **kwargs):
        if stack:
            return func(*args, **kwargs)
        else:
            call = func(*args, **kwargs)
            while True:
                if type(call) is GeneratorType:
                    stack.append(call)
                    call = next(call)
                else:
                    stack.pop()
                    if not stack:
                        break
                    call = stack[-1].send(call)
            return call

    return wrapped_function


if __name__== ""__main__"":
  main()
","['dfs and similar', 'dp', 'trees']"
4524,"Fedya studies in a gymnasium. Fedya's maths hometask is to calculate the following expression:(1n + 2n + 3n + 4n) mod 5for given value of n. Fedya managed to complete the task. Can you? Note that given number n can be extremely large (e.g. it can exceed any integer type of your programming language). NoteOperation x mod y means taking remainder after division x by y.Note to the first sample: n = int(input())
out = pow(1,n,5) + pow(2,n,5) + pow(3,n,5) + pow(4,n,5)
print(out % 5)","['math', 'number theory']"
2680,"After observing the results of Spy Syndrome, Yash realised the errors of his ways. He now believes that a super spy such as Siddhant can't use a cipher as basic and ancient as Caesar cipher. After many weeks of observation of Siddhant’s sentences, Yash determined a new cipher technique.For a given sentence, the cipher is processed as:   Convert all letters of the sentence to lowercase.  Reverse each of the words of the sentence individually.  Remove all the spaces in the sentence. For example, when this cipher is applied to the sentenceKira is childish and he hates losingthe resulting string isariksihsidlihcdnaehsetahgnisolNow Yash is given some ciphered string and a list of words. Help him to find out any original sentence composed using only words from the list. Note, that any of the given words could be used in the sentence multiple times. NoteIn sample case 2 there may be multiple accepted outputs, ""HI there HeLLo"" and ""HI there hello"" you may output any of them.  #!/usr/bin/env python3

# http://codeforces.com/contest/633/problem/C

from collections import deque

# import sys
# sys.setrecursionlimit(10001)

n = int(input())
s = input()
m = int(input())
words = []
for i in range(0, m):
    words.append(input())

dict_words = {}
for word in words:
    dict_words[word.lower()[::-1]] = word

trie_words = {}
for word in dict_words.keys():
    d = trie_words
    for letter in word:
        d = d.setdefault(letter, {})
    d['word'] = word

def find_sentence(s):
    # stack = [0, '', dict_words, []] # position, used words so far, pos in trie we stopped on, children
    roots = deque() # position, used words so far, pos in trie we stopped on, children

    d = trie_words
    for i in range(0, len(s)):
        if not s[i] in d:
            break;
        d = d[s[i]]
        if 'word' in d:
            word = d['word']
            new_root = [i + 1, word, None]
            roots.append(new_root)
            if i + 1 == len(s):
                return new_root

    while len(roots) > 0:
        root = roots.popleft()
        d = trie_words

        for i in range(root[0], len(s)):
            if not s[i] in d:
                break;
            d = d[s[i]]
            if 'word' in d:
                word = d['word']
                new_root = [i + 1, word, root]
                roots.appendleft(new_root)
                if i + 1 == len(s):
                    return new_root

result = find_sentence(s)
words = []
while not result is None:
    word = result[1]
    words.append(dict_words[word])
    result = result[2]
print(' '.join(reversed(words)))

","['data structures', 'dp', 'hashing', 'implementation', 'other', 'sortings', 'strings']"
3085,"Cowboy Vlad has a birthday today! There are $$$n$$$ children who came to the celebration. In order to greet Vlad, the children decided to form a circle around him. Among the children who came, there are both tall and low, so if they stand in a circle arbitrarily, it may turn out, that there is a tall and low child standing next to each other, and it will be difficult for them to hold hands. Therefore, children want to stand in a circle so that the maximum difference between the growth of two neighboring children would be minimal possible.Formally, let's number children from $$$1$$$ to $$$n$$$ in a circle order, that is, for every $$$i$$$ child with number $$$i$$$ will stand next to the child with number $$$i+1$$$, also the child with number $$$1$$$ stands next to the child with number $$$n$$$. Then we will call the discomfort of the circle the maximum absolute difference of heights of the children, who stand next to each other.Please help children to find out how they should reorder themselves, so that the resulting discomfort is smallest possible. NoteIn the first example, the discomfort of the circle is equal to $$$1$$$, since the corresponding absolute differences are $$$1$$$, $$$1$$$, $$$1$$$ and $$$0$$$. Note, that sequences $$$[2, 3, 2, 1, 1]$$$ and $$$[3, 2, 1, 1, 2]$$$ form the same circles and differ only by the selection of the starting point.In the second example, the discomfort of the circle is equal to $$$20$$$, since the absolute difference of $$$10$$$ and $$$30$$$ is equal to $$$20$$$. n = int(input())
arr = sorted([int(x) for x in input().split()])
lower = []
upper = []

for idx in range(len(arr)):
    if idx % 2 == 0:
        lower.append(arr[idx])
    else:
        upper.append(arr[idx])

print(*lower, end="" "")
print(*upper[::-1])
","['binary search', 'greedy', 'sortings']"
3024,"T is a complete binary tree consisting of n vertices. It means that exactly one vertex is a root, and each vertex is either a leaf (and doesn't have children) or an inner node (and has exactly two children). All leaves of a complete binary tree have the same depth (distance from the root). So n is a number such that n + 1 is a power of 2.In the picture you can see a complete binary tree with n = 15.  Vertices are numbered from 1 to n in a special recursive way: we recursively assign numbers to all vertices from the left subtree (if current vertex is not a leaf), then assign a number to the current vertex, and then recursively assign numbers to all vertices from the right subtree (if it exists). In the picture vertices are numbered exactly using this algorithm. It is clear that for each size of a complete binary tree exists exactly one way to give numbers to all vertices. This way of numbering is called symmetric.You have to write a program that for given n answers q queries to the tree.Each query consists of an integer number ui (1 ≤ ui ≤ n) and a string si, where ui is the number of vertex, and si represents the path starting from this vertex. String si doesn't contain any characters other than 'L', 'R' and 'U', which mean traverse to the left child, to the right child and to the parent, respectively. Characters from si have to be processed from left to right, considering that ui is the vertex where the path starts. If it's impossible to process a character (for example, to go to the left child of a leaf), then you have to skip it. The answer is the number of vertex where the path represented by si ends.For example, if ui = 4 and si = «UURL», then the answer is 10. nan n, q = map(int, raw_input().split())
queries = []
for i in range(q):
    u = int(raw_input())
    s = raw_input()
    queries.append((u, s))

def coords(n, u):
    level = 0
    while (u & 1) == 0:
        u >>= 1
        level += 1
    return level, (u - 1) / 2

def uncoords(n, level, idx):
    return (1 << level) * (2 * idx + 1)

def get_up(n, u):
    level, idx = coords(n, u)
    # already at root
    if u == (n + 1) / 2:
        return u
    new_level = level + 1
    new_idx = idx / 2
    return uncoords(n, new_level, new_idx)

def get_left(n, u):
    level, idx = coords(n, u)
    # already at leaf
    if level == 0:
        return u
    new_level = level - 1
    new_idx = idx * 2
    return uncoords(n, new_level, new_idx)

def get_right(n, u):
    level, idx = coords(n, u)
    # already at leaf
    if level == 0:
        return u
    new_level = level - 1
    new_idx = idx * 2 + 1
    return uncoords(n, new_level, new_idx)

action = {'U': get_up, 'L': get_left, 'R': get_right}

for u, s in queries:
    cur = u
    for c in s:
        cur = action[c](n, cur)
    print cur
","['bitmasks', 'trees']"
4305,"Ela likes Chess a lot. During breaks, she usually challenges her co-worker in DTL to some chess games. She's not an expert at classic chess, but she's very interested in Chess variants, where she has to adapt to new rules and test her tactical mindset to win the game.The problem, which involves a non-standard chess pieces type that is described below, reads: given $$$3$$$ white crickets on a $$$n \cdot n$$$ board, arranged in an ""L"" shape next to each other, there are no other pieces on the board. Ela wants to know with a finite number of moves, can she put any white cricket on the square on row $$$x$$$, column $$$y$$$?An ""L""-shape piece arrangement can only be one of the below:    For simplicity, we describe the rules for crickets on the board where only three white crickets are. It can move horizontally, vertically, or diagonally, but only to a square in some direction that is immediately after another cricket piece (so that it must jump over it). If the square immediately behind the piece is unoccupied, the cricket will occupy the square. Otherwise (when the square is occupied by another cricket, or does not exist), the cricket isn't allowed to make such a move.See an example of valid crickets' moves on the pictures in the Note section. NoteHere's the solution for the first test case. The red square denotes where the crickets need to reach. Note that in chess horizontals are counted from bottom to top, as well as on this picture.   import math
import collections
import bisect
import heapq

from collections import deque
from math import sqrt,ceil, floor

def inp_arr():
    return list(map(int, input().strip().split("" "")))
    
def inp_int():
    return int(input())
    
def inp_str():
    return input()
    
'''................................................................................'''

def solve():
    # cook your dish here
    n, = inp_arr()
    
    r1,c1,r2,c2,r3,c3 = inp_arr()
    x,y = inp_arr()
    
    r0 = (r1+r2+r3 - (r1^r2^r3))//2
    c0 = (c1+c2+c3 - (c1^c2^c3))//2
    
    corners = [[1,1], [1,n], [n,n], [n,1]]
    
    if([r0, c0] in corners):
        if(x == r0 or y==c0):
            print(""YES"")
        else:
            print(""NO"")
        return
    
    def check(x1,y1,x2,y2):
        diff1 = abs(x1-x2)
        diff2 = abs(y1-y2)
        
        if(diff1%2==0 and diff2%2==0):
            return True
        
        return False
        
    if(check(r1,c1,x,y) or check(r2,c2,x,y) or check(r3,c3,x,y)):
        print(""YES"")
        return
    
    print(""NO"")







tt = inp_int()
# tt = 1
for t in range(tt):
    solve()","['constructive algorithms', 'games', 'implementation', 'math']"
3879,"Everyone knows that DNA strands consist of nucleotides. There are four types of nucleotides: ""A"", ""T"", ""G"", ""C"". A DNA strand is a sequence of nucleotides. Scientists decided to track evolution of a rare species, which DNA strand was string s initially. Evolution of the species is described as a sequence of changes in the DNA. Every change is a change of some nucleotide, for example, the following change can happen in DNA strand ""AAGC"": the second nucleotide can change to ""T"" so that the resulting DNA strand is ""ATGC"".Scientists know that some segments of the DNA strand can be affected by some unknown infections. They can represent an infection as a sequence of nucleotides. Scientists are interested if there are any changes caused by some infections. Thus they sometimes want to know the value of impact of some infection to some segment of the DNA. This value is computed as follows:  Let the infection be represented as a string e, and let scientists be interested in DNA strand segment starting from position l to position r, inclusive.  Prefix of the string eee... (i.e. the string that consists of infinitely many repeats of string e) is written under the string s from position l to position r, inclusive.  The value of impact is the number of positions where letter of string s coincided with the letter written under it. Being a developer, Innokenty is interested in bioinformatics also, so the scientists asked him for help. Innokenty is busy preparing VK Cup, so he decided to delegate the problem to the competitors. Help the scientists! NoteConsider the first example. In the first query of second type all characters coincide, so the answer is 8. In the second query we compare string ""TTTTT..."" and the substring ""TGCAT"". There are two matches. In the third query, after the DNA change, we compare string ""TATAT...""' with substring ""TGTAT"". There are 4 matches. import sys
range = xrange
input = raw_input

class segtree:
    def __init__(s, data):
        s.n = len(data)
        s.m = 1
        while s.m < s.n: s.m *= 2
        s.data = [0]*s.m
        s.data += data
        for i in reversed(range(2, s.n + s.m)):
            s.data[i >> 1] += s.data[i]

    def add(s, i, x):
        i += s.m
        while i:
            s.data[i] += x
            i >>= 1

    def summa(s, l, r):
        l += s.m
        r += s.m

        tot = 0
        while l<r:
            if l & 1:
                tot += s.data[l]
                l += 1
            if r & 1:
                tot += s.data[r - 1]

            l >>= 1
            r >>= 1
        return tot

def trans(x):
    if x == 'A':
        return 0
    elif x == 'C':
        return 1
    elif x == 'G':
        return 2
    return 3

inp = sys.stdin.read().split()
ii = 0

S = [trans(x) for x in inp[ii]]
ii += 1

segs =  [
            [
                [
                    segtree([+(s==c) for s in S[j::i]]) for c in range(4)
                ] 
                for j in range(i)
            ] 
            for i in range(11)
        ]

q = int(inp[ii])
ii += 1
out = []
for _ in range(q):
    c = inp[ii]
    ii += 1
    if c == '1':
        ind = int(inp[ii]) - 1
        ii += 1
        char = trans(inp[ii])
        ii += 1

        old_char = S[ind]
        for i in range(1,11):
            seg = segs[i][ind % i]
            seg[old_char].add(ind // i, -1)
            seg[char].add(ind // i, 1)

        S[ind] = char
    else:
        l = int(inp[ii]) - 1
        ii += 1
        r = int(inp[ii])
        ii += 1

        e = inp[ii]
        ii += 1

        tot = 0

        i = len(e)
        for k in range(i):
            L = l + k
            start = L//i
            length = (r - L + i - 1)//i
            tot += segs[i][L % i][trans(e[k])].summa(start, start + length)
        out.append(tot)

print '\n'.join(str(x) for x in out)
","['data structures', 'strings']"
23,"You are given a string $$$s$$$ consisting of lowercase letters of the English alphabet. You must perform the following algorithm on $$$s$$$:  Let $$$x$$$ be the length of the longest prefix of $$$s$$$ which occurs somewhere else in $$$s$$$ as a contiguous substring (the other occurrence may also intersect the prefix). If $$$x = 0$$$, break. Otherwise, remove the first $$$x$$$ characters of $$$s$$$, and repeat. A prefix is a string consisting of several first letters of a given string, without any reorders. An empty prefix is also a valid prefix. For example, the string ""abcd"" has 5 prefixes: empty string, ""a"", ""ab"", ""abc"" and ""abcd"".For instance, if we perform the algorithm on $$$s =$$$ ""abcabdc"",   Initially, ""ab"" is the longest prefix that also appears somewhere else as a substring in $$$s$$$, so $$$s =$$$ ""cabdc"" after $$$1$$$ operation.  Then, ""c"" is the longest prefix that also appears somewhere else as a substring in $$$s$$$, so $$$s =$$$ ""abdc"" after $$$2$$$ operations.  Now $$$x=0$$$ (because there are no non-empty prefixes of ""abdc"" that also appear somewhere else as a substring in $$$s$$$), so the algorithm terminates. Find the final state of the string after performing the algorithm. NoteThe first test case is explained in the statement.In the second test case, no operations can be performed on $$$s$$$.In the third test case,   Initially, $$$s =$$$ ""bbbbbbbbbb"".  After $$$1$$$ operation, $$$s =$$$ ""b"". In the fourth test case,   Initially, $$$s =$$$ ""codeforces"".  After $$$1$$$ operation, $$$s =$$$ ""odeforces"".  After $$$2$$$ operations, $$$s =$$$ ""deforces"".  t = int(input())
while (t > 0):
    t -= 1
    s1 = str(input())
    s2 = """"
    i = 0
    mn = set()
    while True:
        if (s1[-i-1] not in mn):
            s2 = s1[-i-1:]
            mn.add(s1[-i-1])
        i += 1
        if i == len(s1):
            break
    print(s2)",['strings']
1075,"You are given an integer $$$n$$$ and an integer $$$k$$$.In one step you can do one of the following moves:   decrease $$$n$$$ by $$$1$$$;  divide $$$n$$$ by $$$k$$$ if $$$n$$$ is divisible by $$$k$$$. For example, if $$$n = 27$$$ and $$$k = 3$$$ you can do the following steps: $$$27 \rightarrow 26 \rightarrow 25 \rightarrow 24 \rightarrow 8 \rightarrow 7 \rightarrow 6 \rightarrow 2 \rightarrow 1 \rightarrow 0$$$.You are asked to calculate the minimum number of steps to reach $$$0$$$ from $$$n$$$.  NoteSteps for the first test case are: $$$59 \rightarrow 58 \rightarrow 57 \rightarrow 19 \rightarrow 18 \rightarrow 6 \rightarrow 2 \rightarrow 1 \rightarrow 0$$$.In the second test case you have to divide $$$n$$$ by $$$k$$$ $$$18$$$ times and then decrease $$$n$$$ by $$$1$$$. t=int(input())
for _ in range(t):
    n,k = map(int,input().split())
    counter=0
    while(n!=0):
        if(n%k==0):
            n=n//k
            counter+=1
        else:
            counter+=(n%k)
            n=n-(n%k)
         
    print(int(counter))
    
","['implementation', 'math']"
996,"Leha is planning his journey from Moscow to Saratov. He hates trains, so he has decided to get from one city to another by car.The path from Moscow to Saratov can be represented as a straight line (well, it's not that straight in reality, but in this problem we will consider it to be straight), and the distance between Moscow and Saratov is $$$n$$$ km. Let's say that Moscow is situated at the point with coordinate $$$0$$$ km, and Saratov — at coordinate $$$n$$$ km.Driving for a long time may be really difficult. Formally, if Leha has already covered $$$i$$$ kilometers since he stopped to have a rest, he considers the difficulty of covering $$$(i + 1)$$$-th kilometer as $$$a_{i + 1}$$$. It is guaranteed that for every $$$i \in [1, n - 1]$$$ $$$a_i \le a_{i + 1}$$$. The difficulty of the journey is denoted as the sum of difficulties of each kilometer in the journey.Fortunately, there may be some rest sites between Moscow and Saratov. Every integer point from $$$1$$$ to $$$n - 1$$$ may contain a rest site. When Leha enters a rest site, he may have a rest, and the next kilometer will have difficulty $$$a_1$$$, the kilometer after it — difficulty $$$a_2$$$, and so on.For example, if $$$n = 5$$$ and there is a rest site in coordinate $$$2$$$, the difficulty of journey will be $$$2a_1 + 2a_2 + a_3$$$: the first kilometer will have difficulty $$$a_1$$$, the second one — $$$a_2$$$, then Leha will have a rest, and the third kilometer will have difficulty $$$a_1$$$, the fourth — $$$a_2$$$, and the last one — $$$a_3$$$. Another example: if $$$n = 7$$$ and there are rest sites in coordinates $$$1$$$ and $$$5$$$, the difficulty of Leha's journey is $$$3a_1 + 2a_2 + a_3 + a_4$$$.Leha doesn't know which integer points contain rest sites. So he has to consider every possible situation. Obviously, there are $$$2^{n - 1}$$$ different distributions of rest sites (two distributions are different if there exists some point $$$x$$$ such that it contains a rest site in exactly one of these distributions). Leha considers all these distributions to be equiprobable. He wants to calculate $$$p$$$ — the expected value of difficulty of his journey.Obviously, $$$p \cdot 2^{n - 1}$$$ is an integer number. You have to calculate it modulo $$$998244353$$$. nan a = int(input())
b = list(map(int,input().split()))
c = b[0]%998244353
d = b[0]%998244353
for i in range(1,a):
    c = (2*c + d + b[i])%998244353
    d = (2*d + b[i])%998244353
print(c)","['combinatorics', 'math', 'probabilities']"
1038,"You are given three positive integers $$$n$$$, $$$a$$$ and $$$b$$$. You have to construct a string $$$s$$$ of length $$$n$$$ consisting of lowercase Latin letters such that each substring of length $$$a$$$ has exactly $$$b$$$ distinct letters. It is guaranteed that the answer exists.You have to answer $$$t$$$ independent test cases.Recall that the substring $$$s[l \dots r]$$$ is the string $$$s_l, s_{l+1}, \dots, s_{r}$$$ and its length is $$$r - l + 1$$$. In this problem you are only interested in substrings of length $$$a$$$. NoteIn the first test case of the example, consider all the substrings of length $$$5$$$:  ""tleel"": it contains $$$3$$$ distinct (unique) letters,  ""leelt"": it contains $$$3$$$ distinct (unique) letters,  ""eelte"": it contains $$$3$$$ distinct (unique) letters.  t = int(input().strip())
for i in range(t):
    n,a,b = map(int,input().split())
    s = ''
    for i in range(n):
        s = s + chr(ord('a') + i%b)
    print(s)



",['constructive algorithms']
4916,"The only difference between easy and hard versions is a number of elements in the array.You are given an array $$$a$$$ consisting of $$$n$$$ integers. The value of the $$$i$$$-th element of the array is $$$a_i$$$.You are also given a set of $$$m$$$ segments. The $$$j$$$-th segment is $$$[l_j; r_j]$$$, where $$$1 \le l_j \le r_j \le n$$$.You can choose some subset of the given set of segments and decrease values on each of the chosen segments by one (independently). For example, if the initial array $$$a = [0, 0, 0, 0, 0]$$$ and the given segments are $$$[1; 3]$$$ and $$$[2; 4]$$$ then you can choose both of them and the array will become $$$b = [-1, -2, -2, -1, 0]$$$.You have to choose some subset of the given segments (each segment can be chosen at most once) in such a way that if you apply this subset of segments to the array $$$a$$$ and obtain the array $$$b$$$ then the value $$$\max\limits_{i=1}^{n}b_i - \min\limits_{i=1}^{n}b_i$$$ will be maximum possible.Note that you can choose the empty set.If there are multiple answers, you can print any.If you are Python programmer, consider using PyPy instead of Python when you submit your code. NoteIn the first example the obtained array $$$b$$$ will be $$$[0, -4, 1, 1, 2]$$$ so the answer is $$$6$$$.In the second example the obtained array $$$b$$$ will be $$$[2, -3, 1, -1, 4]$$$ so the answer is $$$7$$$.In the third example you cannot do anything so the answer is $$$0$$$. n, m = map(int, raw_input().split())
a = map(int, raw_input().split())
s = []
for i in range(m):
    l, r = map(int, raw_input().split())
    s.append((l - 1, r - 1))

h = 0
f = []
for i in range(n):
    t = [0] * n
    g = []
    for j in range(m):
        l, r = s[j]
        if i < l or i > r:
            t[l] += 1
            if r + 1 < n: t[r + 1] -= 1
            g.append(j)

    x = a[i]
    y = a[i]
    c = 0
    for j in range(n):
        c += t[j]
        if a[j] - c <= y: y = a[j] - c

    if x - y > h:
        h = x - y
        f = g

print h
print len(f)
print ' '.join(map(lambda x: str(x + 1), f))
","['brute force', 'greedy', 'implementation']"
491,"Let A = {a1, a2, ..., an} be any permutation of the first n natural numbers {1, 2, ..., n}. You are given a positive integer k and another sequence B = {b1, b2, ..., bn}, where bi is the number of elements aj in A to the left of the element at = i such that aj ≥ (i + k).For example, if n = 5, a possible A is {5, 1, 4, 2, 3}. For k = 2, B is given by {1, 2, 1, 0, 0}. But if k = 3, then B = {1, 1, 0, 0, 0}.For two sequences X = {x1, x2, ..., xn} and Y = {y1, y2, ..., yn}, let i-th elements be the first elements such that xi ≠ yi. If xi &lt; yi, then X is lexicographically smaller than Y, while if xi &gt; yi, then X is lexicographically greater than Y.Given n, k and B, you need to determine the lexicographically smallest A. nan # /*******************************************************************************
# * Author       : Quantum Of Excellence
# * email        : quantumofexcellence (at) gmail (dot) com
# * copyright    : 2014 - 2015
# * date         : 6 - 11 - 2015
# * Judge Status : 
# * file name    : 67B.py
# * version      : 1.0
# *
# * TERMS OF USE - Write a mail to the author before copying or reusing the content of this file 
# * seeking our permission for the same.
# * Copying/reuse of the below code without the permission of the author is prohibited and illegal.
# *
# * All rights reserved by Quantum Of Excellence.
# ******************************************************************************/

# /*******************************************************************************
# * some pointers on the logic/idea - 
# *
# * 
# *******************************************************************************/


# test cases-


#import sys
#fi = open(""G:\DUMP\input.in"",""r"")
#sys.stdin = fi
u=input
n,k=map(int,u().split())
M=[int(i) for i in u().split()]
m=0
for j in range(n):
 # find unvisited zeros
 for p in range(n):
  if(0==M[p]):
   print(p+1,end=' ')
   break
 for l in range(p+1-k):M[l]-=1
  # make the visited zero negative
 M[p]-=1
",['greedy']
2748,"На тренировку по подготовке к соревнованиям по программированию пришли n команд. Тренер для каждой команды подобрал тренировку, комплект задач для i-й команды занимает ai страниц. В распоряжении тренера есть x листов бумаги, у которых обе стороны чистые, и y листов, у которых только одна сторона чистая. При печати условия на листе первого типа можно напечатать две страницы из условий задач, а при печати на листе второго типа — только одну. Конечно, на листе нельзя печатать условия из двух разных комплектов задач. Обратите внимание, что при использовании листов, у которых обе стороны чистые, не обязательно печатать условие на обеих сторонах, одна из них может остаться чистой.Вам предстоит определить максимальное количество команд, которым тренер сможет напечатать комплекты задач целиком. ПримечаниеВ первом тестовом примере можно напечатать оба комплекта задач. Один из возможных ответов — напечатать весь первый комплект задач на листах с одной чистой стороной (после этого останется 3 листа с двумя чистыми сторонами и 1 лист с одной чистой стороной), а второй комплект напечатать на трех листах с двумя чистыми сторонами.Во втором тестовом примере можно напечатать оба комплекта задач. Один из возможных ответов — напечатать первый комплект задач на двух листах с двумя чистыми сторонами (после этого останется 1 лист с двумя чистыми сторонами и 5 листов с одной чистой стороной), а второй комплект напечатать на одном листе с двумя чистыми сторонами и на пяти листах с одной чистой стороной. Таким образом, тренер использует все листы для печати.В третьем тестовом примере можно напечатать только один комплект задач (любой из трёх 11-страничных). Для печати 11-страничного комплекта задач будет израсходована вся бумага. n, x, y = list(map(int, input().split()))
arr = list(map(int, input().split()))
arr.sort()
s = 0
for i in range(n):
    #print(arr[i], x, y)
    if x * 2 >= arr[i]:
        x -= arr[i] // 2
        arr[i] %= 2
    else:
        arr[i] -= x * 2
        x = 0
    if y >= arr[i]:
        y -= arr[i]
        arr[i] = 0
    if x >= arr[i]:
        x -= arr[i]
        arr[i] = 0
    if arr[i] > 0:
        break
    s += 1
print(s)","['greedy', 'sortings']"
802,"You have a Petri dish with bacteria and you are preparing to dive into the harsh micro-world. But, unfortunately, you don't have any microscope nearby, so you can't watch them.You know that you have $$$n$$$ bacteria in the Petri dish and size of the $$$i$$$-th bacteria is $$$a_i$$$. Also you know intergalactic positive integer constant $$$K$$$.The $$$i$$$-th bacteria can swallow the $$$j$$$-th bacteria if and only if $$$a_i &gt; a_j$$$ and $$$a_i \le a_j + K$$$. The $$$j$$$-th bacteria disappear, but the $$$i$$$-th bacteria doesn't change its size. The bacteria can perform multiple swallows. On each swallow operation any bacteria $$$i$$$ can swallow any bacteria $$$j$$$ if $$$a_i &gt; a_j$$$ and $$$a_i \le a_j + K$$$. The swallow operations go one after another.For example, the sequence of bacteria sizes $$$a=[101, 53, 42, 102, 101, 55, 54]$$$ and $$$K=1$$$. The one of possible sequences of swallows is: $$$[101, 53, 42, 102, \underline{101}, 55, 54]$$$ $$$\to$$$ $$$[101, \underline{53}, 42, 102, 55, 54]$$$ $$$\to$$$ $$$[\underline{101}, 42, 102, 55, 54]$$$ $$$\to$$$ $$$[42, 102, 55, \underline{54}]$$$ $$$\to$$$ $$$[42, 102, 55]$$$. In total there are $$$3$$$ bacteria remained in the Petri dish.Since you don't have a microscope, you can only guess, what the minimal possible number of bacteria can remain in your Petri dish when you finally will find any microscope. NoteThe first example is clarified in the problem statement.In the second example an optimal possible sequence of swallows is: $$$[20, 15, 10, 15, \underline{20}, 25]$$$ $$$\to$$$ $$$[20, 15, 10, \underline{15}, 25]$$$ $$$\to$$$ $$$[20, 15, \underline{10}, 25]$$$ $$$\to$$$ $$$[20, \underline{15}, 25]$$$ $$$\to$$$ $$$[\underline{20}, 25]$$$ $$$\to$$$ $$$[25]$$$.In the third example no bacteria can swallow any other bacteria. from __future__ import print_function, division
from sys import stdin, stdout
from fractions import gcd
# from math import *
from collections import *
from operator import mul
from functools import reduce
from copy import copy

rstr = lambda: stdin.readline().strip()
rstrs = lambda: [str(x) for x in stdin.readline().split()]
rint = lambda: int(stdin.readline())
rints = lambda: [int(x) for x in stdin.readline().split()]
rstr_2d = lambda n: [rstr() for _ in range(n)]
rint_2d = lambda n: [rint() for _ in range(n)]
rints_2d = lambda n: [rints() for _ in range(n)]
pr = lambda args, sep: stdout.write(sep.join(map(str, args)) + '\n')
out = []

n, k = rints()
a, ans = rints(), n
mem, ix = Counter(a), 1
keys = sorted(mem.keys())[::-1]

for i in keys:
    for j in range(ix, len(keys)):
        if keys[j] < i - k:
            break
        elif keys[j] < i and keys[j] >= i - k:
            ans -= mem[keys[j]]

        ix += 1

print(ans)
","['greedy', 'sortings']"
2018,"Egor wants to achieve a rating of 1600 points on the well-known chess portal ChessForces and he needs your help!Before you start solving the problem, Egor wants to remind you how the chess pieces move. Chess rook moves along straight lines up and down, left and right, as many squares as it wants. And when it wants, it can stop. The queen walks in all directions vertically and diagonally at any distance. You can see the examples below.  To reach the goal, Egor should research the next topic:There is an $$$N \times N$$$ board. Each cell of the board has a number from $$$1$$$ to $$$N ^ 2$$$ in it and numbers in all cells are distinct.In the beginning, some chess figure stands in the cell with the number $$$1$$$. Note that this cell is already considered as visited. After that every move is determined by the following rules:   Among all not visited yet cells to which the figure can get in one move, it goes to the cell that has minimal number. If all accessible cells were already visited and some cells are not yet visited, then the figure is teleported to the not visited cell that has minimal number. If this step happens, the piece pays a fee of $$$1$$$ vun. If all cells are already visited, the process is stopped. Egor should find an $$$N \times N$$$ board on which the rook pays strictly less vuns than the queen during the round with this numbering. Help him to find such $$$N \times N$$$ numbered board, or tell that it doesn't exist. NoteIn case we have $$$1 \times 1$$$ board, both rook and queen do not have a chance to pay fees.In second sample rook goes through cells $$$1 \to 3 \to 4 \to 6 \to 9 \to 5 \to 7 \to 13 \to 2 \to 8 \to 16 \to 11 \to 10 \to 12 \to 15 \to \textbf{(1 vun)} \to 14$$$. Queen goes through $$$1 \to 3 \to 4 \to 2 \to 5 \to 6 \to 9 \to 7 \to 13 \to 8 \to 11 \to 10 \to 12 \to 15 \to \textbf{(1 vun)} \to 14 \to \textbf{(1 vun)} \to 16$$$.As a result rook pays 1 vun and queen pays 2 vuns. n = input()
n = int(n)
if n <=2:
    print(-1)
elif n%2 ==0:
    for row in range(n):
        if row ==0:
            for i in range(n):
                if i ==0:    
                    print(i+1,end = "" "")
                elif i==n-1:
                    print(i+1)
                else: 
                    print(i+1,end = "" "")   
        elif row ==n-1:
            for i in range(n):
                if i==n-1:
                    print(n*n-1)
                else: 
                    print(n+(n-1)*(n-2)+(n-3)-i+2,end = "" "")
        elif row ==n-2:
            for i in range(n):
                if i ==0:
                    print(n*n-n+2+row,end = "" "")
                elif i <n-1: 
                    print(n+(n-1)*(row-1)+i,end = "" "")
                else:
                    print(n+(n-1)*(row-1)+n-1)
        elif row%2 ==1:
            for i in range(n):
                if i ==0:
                    print(n*n-n+2+row-1,end = "" "")
                elif i <n-1: 
                    print(n+(n-1)*(row-1)+n-i,end = "" "")
                else:
                    print(n+(n-1)*(row-1)+1)
        elif row%2 ==0:
            for i in range(n):
                if i ==0:
                    print(n*n-n+2+row-1,end = "" "")
                elif i <n-1: 
                    print(n+(n-1)*(row-1)+i,end = "" "")
                else:
                    print(n+(n-1)*(row-1)+n-1)
elif n%2 ==1:
    for row in range(n):
        if row ==0:
            for i in range(n):
                if i ==0:    
                    print(i+1,end = "" "")
                elif i==n-1:
                    print(n*n-n+row+1)
                else: 
                    print(i+1,end = "" "")   
        elif row ==n-1:
            for i in range(n):
                if i==0:
                    print(n*n-1,end = "" "")
                elif i ==n-1:
                    print((n-1)*(n-1)+i)
                else: 
                    print((n-1)*(n-1)+i,end = "" "")
        elif row ==n-2:
            for i in range(n):
                if i ==0:
                    print((n-1)*row+n-i-1,end = "" "")
                elif i <n-1: 
                    print((n-1)*row+n-i-1,end = "" "")
                else:
                    print(n*n)
        elif row%2 ==1:
            for i in range(n):
                if i ==0:
                    print((n-1)*row+n-i-1,end = "" "")
                elif i <n-1: 
                    print((n-1)*row+n-i-1,end = "" "")
                else:
                    print(n*n-n+row+1)
        elif row%2 ==0:
            for i in range(n):
                if i ==0:
                    print((n-1)*row+i+1,end = "" "")
                elif i <n-1: 
                    print((n-1)*row+i+1,end = "" "")
                else:
                    print(n*n-n+row+1)","['brute force', 'constructive algorithms']"
4209,"Monocarp is the coach of the Berland State University programming teams. He decided to compose a problemset for a training session for his teams.Monocarp has $$$n$$$ problems that none of his students have seen yet. The $$$i$$$-th problem has a topic $$$a_i$$$ (an integer from $$$1$$$ to $$$n$$$) and a difficulty $$$b_i$$$ (an integer from $$$1$$$ to $$$n$$$). All problems are different, that is, there are no two tasks that have the same topic and difficulty at the same time.Monocarp decided to select exactly $$$3$$$ problems from $$$n$$$ problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both):  the topics of all three selected problems are different;  the difficulties of all three selected problems are different. Your task is to determine the number of ways to select three problems for the problemset. NoteIn the first example, you can take the following sets of three problems:  problems $$$1$$$, $$$2$$$, $$$4$$$;  problems $$$1$$$, $$$3$$$, $$$4$$$;  problems $$$2$$$, $$$3$$$, $$$4$$$. Thus, the number of ways is equal to three. import os
import sys
from io import BytesIO, IOBase
from collections import Counter, defaultdict
from sys import stdin, stdout
import io
import math
from math import *
import heapq
import bisect
import collections
def ceil(a, b):
    return (a + b - 1) // b
inf = float('inf')

def get():
    return stdin.readline().rstrip()
mod = 10 ** 5 + 7
# for _ in range(int(get())):
# n=int(get())
# l=list(map(int,get().split()))
# = map(int,get().split())
#######################################################
# combinations
def nCr(n, r):
    p = 1
    k = 1
    if (n - r < r):
        r = n - r

    if (r != 0):
        while (r):
            p *= n
            k *= r
            m = gcd(p, k)
            p //= m
            k //= m
            n -= 1
            r -= 1
    else:
        p = 1
    return p
for _ in range(int(get())):
    n=int(get())
    l1=defaultdict(int)
    l2=defaultdict(int)
    x=0
    y=0
    l3=[]
    for i in range(n):
        a,b = map(int,get().split())
        l3.append([a,b])
        l1[a]+=1
        l2[b]+=1
    ans=int(nCr(n,3))
    for i in range(len(l3)):
        ans-=(l1[l3[i][0]]-1)*(l2[l3[i][1]]-1)
    print(ans)
















","['combinatorics', 'data structures', 'geometry', 'implementation', 'math']"
4081,"Two villages are separated by a river that flows from the north to the south. The villagers want to build a bridge across the river to make it easier to move across the villages.The river banks can be assumed to be vertical straight lines x = a and x = b (0 &lt; a &lt; b).The west village lies in a steppe at point O = (0, 0). There are n pathways leading from the village to the river, they end at points Ai = (a, yi). The villagers there are plain and simple, so their pathways are straight segments as well.The east village has reserved and cunning people. Their village is in the forest on the east bank of the river, but its exact position is not clear. There are m twisted paths leading from this village to the river and ending at points Bi = (b, y'i). The lengths of all these paths are known, the length of the path that leads from the eastern village to point Bi, equals li.The villagers want to choose exactly one point on the left bank of river Ai, exactly one point on the right bank Bj and connect them by a straight-line bridge so as to make the total distance between the villages (the sum of |OAi| + |AiBj| + lj, where |XY| is the Euclidean distance between points X and Y) were minimum. The Euclidean distance between points (x1, y1) and (x2, y2) equals .Help them and find the required pair of points. nan import sys
from math import *

def minp():
	return sys.stdin.readline().strip()

def mint():
	return int(minp())

def mints():
	return map(int, minp().split())

n, m, a, b = mints()
A = list(mints())
B = list(mints())
l = list(mints())
j = -1
r = (1e100,-1,-1)
for i in range(m):
	while not((j == -1 or a*B[i]-b*A[j] >= 0) \
		and (j+1 == n or a*B[i]-b*A[j+1] < 0)):
		j += 1
	#print(j)#,a*B[i]-b*A[j],a*B[i]-b*A[j+1])
	if j != -1:
		r = min(r,(l[i]+sqrt(a*a+A[j]*A[j])+sqrt((b-a)**2+(B[i]-A[j])**2),j,i))
	if j+1 != n:
		r = min(r,(l[i]+sqrt(a*a+A[j+1]*A[j+1])+sqrt((b-a)**2+(B[i]-A[j+1])**2),j+1,i))
print(r[1]+1,r[2]+1)","['geometry', 'other', 'two pointers']"
724,"Let's introduce the designation , where x is a string, n is a positive integer and operation "" + "" is the string concatenation operation. For example, [abc, 2] = abcabc.We'll say that string s can be obtained from string t, if we can remove some characters from string t and obtain string s. For example, strings ab and aсba can be obtained from string xacbac, and strings bx and aaa cannot be obtained from it.Sereja has two strings, w = [a, b] and q = [c, d]. He wants to find such maximum integer p (p &gt; 0), that [q, p] can be obtained from string w. nan 

from itertools import repeat,chain
from fractions import gcd

def eternal(c,d, n = None):


    while True:

        yield chain.from_iterable(repeat(c,d))



        


def cyclic_array(arr):

    n = len(arr)
    def cyclar(i):

        return arr[i % n]

    return cyclar
def find_repeat(enum,q_r_gen, a_n):

    ac_count =0
    a_count = 0
    remainders ={}
    tempq=''
    tempa = ''
    for q,q_r in enumerate(q_r_gen):

        tempq=''
        for c_c in q_r:
            tempq= tempq +c_c
            for a_count,a_c in enum:
                if a_c == c_c:
                    tempa = tempa +a_c
                    ac_count+=1
                    break
            #print len(tempa),len(tempq)
        if (a_count % a_n) in remainders:

            #print tempq[:20],tempa[:20]
            break
        else:

            remainders[(a_count % a_n)]=(a_count,q)

    repeat_length = a_count - remainders[a_count % a_n][0]
    q_count = q-remainders[a_count % a_n][1]

    return remainders[a_count % a_n][0],repeat_length,q_count
    


    
def main(a,b,c,d):
  

    
    #print a, c


    a_r = chain.from_iterable(repeat(a,b))

    #print """".join(chain.from_iterable(repeat(a,b)))


    enum =enumerate(a_r)

    q_r_gen = eternal(c,d)

    i = 0
    flag = True


    if len(a) > len(c)*d:
        multiplier =1
        start,repeat_length,q_count = find_repeat(enum,q_r_gen, len(a))

    else:
        multiplier =((len(c)*d)//len(a))+1
        #print ""Multi"",multiplier
        enum2 = enumerate(chain.from_iterable(repeat(a*multiplier,b//multiplier)))
        start,repeat_length,q_count =find_repeat(enum2,q_r_gen, multiplier*len(a))
        
    if repeat_length >0:
        advance_n = (((len(a)*multiplier)*(b//multiplier))//repeat_length)-1
        advance = repeat_length * advance_n

        sofar = q_count * advance_n
    else:
        advance_n =0
        advance = 0
        sofar = 0

    #print advance_n,advance, repeat_length, len(a)*b, sofar , len(c)*d
        
    ca = cyclic_array(a)

    ra = iter(range(advance,len(a)*b))

    ac_count =0
    for q_r in q_r_gen:
        for i,c_c in enumerate(q_r):

            flag = False
            for a_count in ra:
                #print a_count

                if ca(a_count) == c_c:
                    ac_count+=1
                    flag = True
                    break
                
        if not flag:
            break

    
    print sofar + (ac_count // (len(c)*d))


    
if __name__ == ""__main__"":
    b,d = [int(s) for s in (raw_input()).split()]

    a = raw_input()

    c = raw_input()

    aset = set(a)
    cset = set(c)

    if cset.difference(aset):
        print 0

    elif a == c:

        print b // d
        
    else:
        
        main(a,b,c,d)
    ","['binary search', 'dfs and similar', 'strings']"
3811,"Amr has got a large array of size n. Amr doesn't like large arrays so he intends to make it smaller.Amr doesn't care about anything in the array except the beauty of it. The beauty of the array is defined to be the maximum number of times that some number occurs in this array. He wants to choose the smallest subsegment of this array such that the beauty of it will be the same as the original array.Help Amr by choosing the smallest subsegment possible. NoteA subsegment B of an array A from l to r is an array of size r - l + 1 where Bi = Al + i - 1 for all 1 ≤ i ≤ r - l + 1 N = int(raw_input())

a = map(int, raw_input().split())
data = [0] * (10 ** 6 + 1)
L = [0] * (10 ** 6 + 1)
R = [0] * (10 ** 6 + 1)

mx = 0
for i, v in enumerate(a):
	if data[v] == 0:
		L[v] = i
	R[v] = i
	data[v] += 1
	mx = max(mx, data[v])

mn = N
index = 0
for i in xrange(len(data)):
	if data[i] == mx:
		if mn > R[i] - L[i]:
			mn = R[i] - L[i]
			index = i
print L[index] + 1, R[index] + 1
",['implementation']
248,"You are given a tree (an undirected connected graph without cycles) and an integer $$$s$$$.Vanya wants to put weights on all edges of the tree so that all weights are non-negative real numbers and their sum is $$$s$$$. At the same time, he wants to make the diameter of the tree as small as possible.Let's define the diameter of a weighed tree as the maximum sum of the weights of the edges lying on the path between two some vertices of the tree. In other words, the diameter of a weighed tree is the length of the longest simple path in the tree, where length of a path is equal to the sum of weights over all edges in the path.Find the minimum possible diameter that Vanya can get. NoteIn the first example it is necessary to put weights like this:  It is easy to see that the diameter of this tree is $$$2$$$. It can be proved that it is the minimum possible diameter.In the second example it is necessary to put weights like this:   n,s = [int(x) for x in input().split()]
v=[ [] ]
for i in range(n):
	v.append([])
	
for i in range(n-1):
	a, b =[int(x) for x in input().split()]
	v[a].append(b)
	v[b].append(a)

ans =0
for i in range(1,n+1):
	if len(v[i])==1:
		ans+=1
	
print(2*s/ans)
","['greedy', 'implementation', 'trees']"
1721,"In an attempt to escape the Mischievous Mess Makers' antics, Farmer John has abandoned his farm and is traveling to the other side of Bovinia. During the journey, he and his k cows have decided to stay at the luxurious Grand Moo-dapest Hotel. The hotel consists of n rooms located in a row, some of which are occupied.Farmer John wants to book a set of k + 1 currently unoccupied rooms for him and his cows. He wants his cows to stay as safe as possible, so he wishes to minimize the maximum distance from his room to the room of his cow. The distance between rooms i and j is defined as |j - i|. Help Farmer John protect his cows by calculating this minimum possible distance. NoteIn the first sample, Farmer John can book room 3 for himself, and rooms 1 and 4 for his cows. The distance to the farthest cow is 2. Note that it is impossible to make this distance 1, as there is no block of three consecutive unoccupied rooms.In the second sample, Farmer John can book room 1 for himself and room 3 for his single cow. The distance between him and his cow is 2.In the third sample, Farmer John books all three available rooms, taking the middle room for himself so that both cows are next to him. His distance from the farthest cow is 1. from collections import deque
rooms_number, cows_number = map(int, input().split())
rooms = input()
free_rooms = [i for i in range(rooms_number) if rooms[i] == '0']
def binary_search(left, right, item):
    global free_rooms
    while right - left > 1:
        center = left + (right - left)//2
        if free_rooms[center] > item:
            right = center
        else:
            left = center
    return left
min_distation_to_farthest_cow = 10**20
best_min_distation_to_farthest_cow = cows_number//2 + cows_number%2
for i in range(len(free_rooms) - cows_number):
    left = free_rooms[i]
    right = free_rooms[i + cows_number]
    center = left + (right - left)//2
    j = binary_search(i, i + cows_number, center)
    if free_rooms[j] == center:
        distation_to_farthest_cow = right - center
    else:
        distation_to_farthest_cow = min(right - free_rooms[j], free_rooms[j + 1] - left)
    if min_distation_to_farthest_cow > distation_to_farthest_cow:
        min_distation_to_farthest_cow = distation_to_farthest_cow
    if distation_to_farthest_cow == best_min_distation_to_farthest_cow:
        break
print(min_distation_to_farthest_cow)
","['binary search', 'two pointers']"
3133,"Polycarp and his friends want to visit a new restaurant. The restaurant has $$$n$$$ tables arranged along a straight line. People are already sitting at some tables. The tables are numbered from $$$1$$$ to $$$n$$$ in the order from left to right. The state of the restaurant is described by a string of length $$$n$$$ which contains characters ""1"" (the table is occupied) and ""0"" (the table is empty).Restaurant rules prohibit people to sit at a distance of $$$k$$$ or less from each other. That is, if a person sits at the table number $$$i$$$, then all tables with numbers from $$$i-k$$$ to $$$i+k$$$ (except for the $$$i$$$-th) should be free. In other words, the absolute difference of the numbers of any two occupied tables must be strictly greater than $$$k$$$.For example, if $$$n=8$$$ and $$$k=2$$$, then:  strings ""10010001"", ""10000010"", ""00000000"", ""00100000"" satisfy the rules of the restaurant;  strings ""10100100"", ""10011001"", ""11111111"" do not satisfy to the rules of the restaurant, since each of them has a pair of ""1"" with a distance less than or equal to $$$k=2$$$. In particular, if the state of the restaurant is described by a string without ""1"" or a string with one ""1"", then the requirement of the restaurant is satisfied.You are given a binary string $$$s$$$ that describes the current state of the restaurant. It is guaranteed that the rules of the restaurant are satisfied for the string $$$s$$$.Find the maximum number of free tables that you can occupy so as not to violate the rules of the restaurant. Formally, what is the maximum number of ""0"" that can be replaced by ""1"" such that the requirement will still be satisfied?For example, if $$$n=6$$$, $$$k=1$$$, $$$s=$$$ ""100010"", then the answer to the problem will be $$$1$$$, since only the table at position $$$3$$$ can be occupied such that the rules are still satisfied. NoteThe first test case is explained in the statement.In the second test case, the answer is $$$2$$$, since you can choose the first and the sixth table.In the third test case, you cannot take any free table without violating the rules of the restaurant. import math
for _ in range(int(input())):
    n,k = map(int, input().split())
    s = input()
    #print(s[::-1])
    if s.count('0') == len(s):
        print(math.ceil(len(s)/(k+1)))
    else:
        anz = 0
        st = s.index('1')
        en = n - s[::-1].index('1')
        #print(st,en)
        if (st) > 0:
            anz += math.ceil((st - k) / (k+1))
        if (n-en) > 0:
            anz += math.ceil((n-en-k) / (k+1))
        i = st + 1
        while i < en:
            j = i
            while j < en and s[j] != '1':
                j += 1
            if (j-i-(2*k)) > 0:
                anz += math.ceil((j-i-(2*k)) / (k+1))
            i = j+1
        print(anz)
","['constructive algorithms', 'greedy', 'math']"
1242,"You are a coach at your local university. There are $$$n$$$ students under your supervision, the programming skill of the $$$i$$$-th student is $$$a_i$$$.You have to create a team for a new programming competition. As you know, the more students some team has the more probable its victory is! So you have to create a team with the maximum number of students. But you also know that a team should be balanced. It means that the programming skill of each pair of students in a created team should differ by no more than $$$5$$$.Your task is to report the maximum possible number of students in a balanced team. NoteIn the first example you can create a team with skills $$$[12, 17, 15]$$$.In the second example you can take all students in a team because their programming skills are equal.In the third example you can create a team consisting of a single student (and you cannot create a team consisting of at least two students). n = int(input())
jogadores = [*map(int, input().split())]
jogadores.sort()

maxv = 0
cont = 0
p1 = p2 = 0
while p2 < n:
    if jogadores[p2] - jogadores[p1] <= 5:
        cont += 1
        p2 += 1
    else:
        cont -= 1
        p1 += 1
    maxv = max(maxv, cont)
    
print(maxv)
","['sortings', 'two pointers']"
4937,"You are given a sequence $$$a$$$ consisting of $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$, and an integer $$$x$$$. Your task is to make the sequence $$$a$$$ sorted (it is considered sorted if the condition $$$a_1 \le a_2 \le a_3 \le \dots \le a_n$$$ holds).To make the sequence sorted, you may perform the following operation any number of times you want (possibly zero): choose an integer $$$i$$$ such that $$$1 \le i \le n$$$ and $$$a_i &gt; x$$$, and swap the values of $$$a_i$$$ and $$$x$$$.For example, if $$$a = [0, 2, 3, 5, 4]$$$, $$$x = 1$$$, the following sequence of operations is possible:  choose $$$i = 2$$$ (it is possible since $$$a_2 &gt; x$$$), then $$$a = [0, 1, 3, 5, 4]$$$, $$$x = 2$$$;  choose $$$i = 3$$$ (it is possible since $$$a_3 &gt; x$$$), then $$$a = [0, 1, 2, 5, 4]$$$, $$$x = 3$$$;  choose $$$i = 4$$$ (it is possible since $$$a_4 &gt; x$$$), then $$$a = [0, 1, 2, 3, 4]$$$, $$$x = 5$$$. Calculate the minimum number of operations you have to perform so that $$$a$$$ becomes sorted, or report that it is impossible. nan for _ in range(int(input())):
    n, x = map(int, input().split())
    A = list(map(int, input().split()))
    for i in range(1, n):
        if A[i] < A[i - 1]: break
    else:
        print(0)
        continue
    ans = float(""inf"")
    for i in range(n):
        if A[i] <= x: continue
        cur = x
        B = A.copy()
        B[i] = x
        B.sort()
        cnt = 0
        for j in range(n):
            if A[j] == B[j]: continue
            if A[j] <= cur or A[j] > cur and j and cur < B[j - 1]: break
            cur = A[j]
            cnt += 1
        else:
            ans = min(ans, cnt)
    print(ans if ans < float(""inf"") else -1)","['dp', 'greedy', 'sortings']"
3824,"In mathematics, a subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements. For example, the sequence BDF is a subsequence of ABCDEF. A substring of a string is a continuous subsequence of the string. For example, BCD is a substring of ABCDEF.You are given two strings s1, s2 and another string called virus. Your task is to find the longest common subsequence of s1 and s2, such that it doesn't contain virus as a substring. nan a, b, v = input(), input(), input()
t = [[-1] * len(b) for x in range(len(a))]

def g(i, j):
    if i < 0 or j < 0: return ''
    if t[i][j] == -1:
        s = g(i - 1, j - 1)
        if a[i] == b[j]: s += a[i]
        t[i][j] = max(s, g(i - 1, j), g(i, j - 1), key=lambda q: len(q) - q.count(v))
    return t[i][j]

s = g(len(a) - 1, len(b) - 1)
while v in s: s = min(s.replace(v, v[:-1]), s.replace(v, v[1:]), key=lambda q: q.count(v))
print(s if s else 0)
","['dp', 'strings']"
4909,"In Berland the opposition is going to arrange mass walking on the boulevard. The boulevard consists of n tiles that are lain in a row and are numbered from 1 to n from right to left. The opposition should start walking on the tile number 1 and the finish on the tile number n. During the walk it is allowed to move from right to left between adjacent tiles in a row, and jump over a tile. More formally, if you are standing on the tile number i (i &lt; n - 1), you can reach the tiles number i + 1 or the tile number i + 2 from it (if you stand on the tile number n - 1, you can only reach tile number n). We can assume that all the opposition movements occur instantaneously.In order to thwart an opposition rally, the Berland bloody regime organized the rain. The tiles on the boulevard are of poor quality and they are rapidly destroyed in the rain. We know that the i-th tile is destroyed after ai days of rain (on day ai tile isn't destroyed yet, and on day ai + 1 it is already destroyed). Of course, no one is allowed to walk on the destroyed tiles! So the walk of the opposition is considered thwarted, if either the tile number 1 is broken, or the tile number n is broken, or it is impossible to reach the tile number n from the tile number 1 if we can walk on undestroyed tiles.The opposition wants to gather more supporters for their walk. Therefore, the more time they have to pack, the better. Help the opposition to calculate how much time they still have and tell us for how many days the walk from the tile number 1 to the tile number n will be possible. NoteIn the first sample the second tile gets destroyed after day three, and the only path left is 1 → 3 → 4. After day five there is a two-tile gap between the first and the last tile, you can't jump over it.In the second sample path 1 → 3 → 5 is available up to day five, inclusive. On day six the last tile is destroyed and the walk is thwarted. n=int(input())
a=list(map(int,input().split()))
ans=1e9
for i in range(n-1):
    ans=min(ans,max(a[i],a[i+1]))
print(min(ans,a[0],a[-1]))
","['brute force', 'implementation']"
4311,"There was a big bank robbery in Tablecity. In order to catch the thief, the President called none other than Albert – Tablecity’s Chief of Police. Albert does not know where the thief is located, but he does know how he moves.Tablecity can be represented as 1000 × 2 grid, where every cell represents one district. Each district has its own unique name “(X, Y)”, where X and Y are the coordinates of the district in the grid. The thief’s movement is as Every hour the thief will leave the district (X, Y) he is currently hiding in, and move to one of the districts: (X - 1, Y), (X + 1, Y), (X - 1, Y - 1), (X - 1, Y + 1), (X + 1, Y - 1), (X + 1, Y + 1) as long as it exists in Tablecity. Below is an example of thief’s possible movements if he is located in district (7,1):Albert has enough people so that every hour he can pick any two districts in Tablecity and fully investigate them, making sure that if the thief is located in one of them, he will get caught. Albert promised the President that the thief will be caught in no more than 2015 hours and needs your help in order to achieve that. NoteLet's consider the following output:25 1 50 28 1 80 2This output is not guaranteed to catch the thief and is not correct. It is given to you only to show the expected output format. There exists a combination of an initial position and a movement strategy such that the police will not catch the thief.Consider the following initial position and thief’s movement:In the first hour, the thief is located in district (1,1). Police officers will search districts (5,1) and (50,2) and will not find him.At the start of the second hour, the thief moves to district (2,2). Police officers will search districts (8,1) and (80,2) and will not find him.Since there is no further investigation by the police, the thief escaped! print(1998)
[print(i, 1, i, 2) for k in '12' for i in range(1, 1000)]","['constructive algorithms', 'implementation']"
3706,"Hongcow is ruler of the world. As ruler of the world, he wants to make it easier for people to travel by road within their own countries.The world can be modeled as an undirected graph with n nodes and m edges. k of the nodes are home to the governments of the k countries that make up the world.There is at most one edge connecting any two nodes and no edge connects a node to itself. Furthermore, for any two nodes corresponding to governments, there is no path between those two nodes. Any graph that satisfies all of these conditions is stable.Hongcow wants to add as many edges as possible to the graph while keeping it stable. Determine the maximum number of edges Hongcow can add. NoteFor the first sample test, the graph looks like this:    Vertices 1 and 3 are special. The optimal solution is to connect vertex 4 to vertices 1 and 2. This adds a total of 2 edges. We cannot add any more edges, since vertices 1 and 3 cannot have any path between them.For the second sample test, the graph looks like this:    We cannot add any more edges to this graph. Note that we are not allowed to add self-loops, and the graph must be simple. n,m,k = map(int, raw_input().split())
special = map(int, raw_input().split())

root = range(n+1)

def par(p):
	if p != root[p]:
		root[p] = par(root[p])
	return root[p]

def c2(n):
	return n * (n - 1) / 2

for __ in xrange(m):
	u,v = map(par, map(int, raw_input().split()))
	root[v] = u

sz = [0 for i in range(n+1)]
for i in range(n+1):
	sz[par(i)] += 1

leftover = n
ans = 0
largest = 0
for x in special:
	d = par(x)
	largest = max(largest, sz[d])
	ans += c2(sz[d])
	leftover -= sz[d]

ans -= c2(largest)
ans += c2(largest + leftover)
ans -= m

print ans","['dfs and similar', 'graphs']"
100,"You are given an array $$$a$$$ of $$$n$$$ non-negative integers, numbered from $$$1$$$ to $$$n$$$.Let's define the cost of the array $$$a$$$ as $$$\displaystyle \min_{i \neq j} a_i | a_j$$$, where $$$|$$$ denotes the bitwise OR operation.There are $$$q$$$ queries. For each query you are given two integers $$$l$$$ and $$$r$$$ ($$$l &lt; r$$$). For each query you should find the cost of the subarray $$$a_{l}, a_{l + 1}, \ldots, a_{r}$$$. NoteIn the first test case the array $$$a$$$ is$$$110_2, 001_2, 011_2, 010_2, 001_2$$$.That's why the answers for the queries are:  $$$[1; 2]$$$: $$$a_1 | a_2 = 110_2 | 001_2 = 111_2 = 7$$$;  $$$[2; 3]$$$: $$$a_2 | a_3 = 001_2 | 011_2 = 011_2 = 3$$$;  $$$[2; 4]$$$: $$$a_2 | a_3 = a_3 | a_4 = a_2 | a_4 = 011_2 = 3$$$;  $$$[2; 5]$$$: $$$a_2 | a_5 = 001_2 = 1$$$. In the second test case the array $$$a$$$ is$$$00_2, 10_2, 01_2, \underbrace{11\ldots 1_2}_{30}$$$ ($$$a_4 = 2^{30} - 1$$$).That's why the answers for the queries are:  $$$[1; 2]$$$: $$$a_1 | a_2 = 10_2 = 2$$$;  $$$[2; 3]$$$: $$$a_2 | a_3 = 11_2 = 3$$$;  $$$[1; 3]$$$: $$$a_1 | a_3 = 01_2 = 1$$$;  $$$[3; 4]$$$: $$$a_3 | a_4 = 01_2 | \underbrace{11\ldots 1_2}_{30} = 2^{30} - 1 = 1073741823$$$.  import io,os
import bisect 
import sys 

input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

class Trienode(object):
    def __init__(self):
        self.indexes = []
        self.children = {}



def construct(i,num,root):

    p = root
    for d in range(29,-1,-1):
        digit = 0 
        if (1<<d) & num > 0:  digit = 1
        if 0 not in p.children:  p.children[0] = Trienode()
        if 1 not in p.children:  p.children[1] = Trienode()


        p = p.children[digit]
        p.indexes.append(i)

    return root



def query(root,front,rear,arr):
    p = root
    output = 0
    addi = []
    curr = 0
    ans = 2147483647 
   

    for d in range(29,-1,-1):
        if len(p.children)>0: 
            temp = p.children[0].indexes



            f0 = bisect.bisect_left(temp,front)
            l = len(temp)

            if f0+1 < l  and temp[f0+1] <= rear: 
                p = p.children[0]
            elif f0<l and temp[f0] <= rear:
                addi.append(temp[f0])
                p = p.children[1]
                curr += (1<<d)
            else:
                p = p.children[1]
                curr += (1<<d)

            


        else:
            break

    f = bisect.bisect_left(p.indexes,front)
    r = bisect.bisect(p.indexes,rear)
    if f!=r: 
        ans = curr
        for i in range(len(addi)):
            ans = min(ans, arr[addi[i]] | curr )


    for i in range(len(addi)-1):
        for j in range(i+1,len(addi)): 
            ans = min(ans,arr[addi[i]] | arr[addi[j]])


    return ans
            
            
            

            
            
        



def main(t):


    n = int(input())
    arr = list(map(int,input().split()))

    root = Trienode()

    for i in range(n):
        construct(i,arr[i],root)


 #   print(root)
    

    q = int(input())
    for r in range(q):
        front,rear = map(int,input().split())
        ans = query(root,front-1,rear-1,arr)
        if r>100000:  break
        os.sys.stdout.write(str(ans) + '\n')
     #   print(ans)
     #   sys.stdout

























T = int(input())
t = 1
while t<=T:
    main(t)
    t += 1
","['bitmasks', 'brute force', 'data structures', 'divide and conquer', 'greedy', 'implementation', 'two pointers']"
683,"One common way of digitalizing sound is to record sound intensity at particular time moments. For each time moment intensity is recorded as a non-negative integer. Thus we can represent a sound file as an array of $$$n$$$ non-negative integers.If there are exactly $$$K$$$ distinct values in the array, then we need $$$k = \lceil \log_{2} K \rceil$$$ bits to store each value. It then takes $$$nk$$$ bits to store the whole file.To reduce the memory consumption we need to apply some compression. One common way is to reduce the number of possible intensity values. We choose two integers $$$l \le r$$$, and after that all intensity values are changed in the following way: if the intensity value is within the range $$$[l;r]$$$, we don't change it. If it is less than $$$l$$$, we change it to $$$l$$$; if it is greater than $$$r$$$, we change it to $$$r$$$. You can see that we lose some low and some high intensities.Your task is to apply this compression in such a way that the file fits onto a disk of size $$$I$$$ bytes, and the number of changed elements in the array is minimal possible.We remind you that $$$1$$$ byte contains $$$8$$$ bits.$$$k = \lceil log_{2} K \rceil$$$ is the smallest integer such that $$$K \le 2^{k}$$$. In particular, if $$$K = 1$$$, then $$$k = 0$$$. NoteIn the first example we can choose $$$l=2, r=3$$$. The array becomes 2 2 2 3 3 3, the number of distinct elements is $$$K=2$$$, and the sound file fits onto the disk. Only two values are changed.In the second example the disk is larger, so the initial file fits it and no changes are required.In the third example we have to change both 1s or both 3s. import sys
n, I = [int(i) for i in input().split()]



num = 1 << ((8*I)//n)
data = [int(i) for i in input().split()]
#data.sort()
#am = len(set(data)) 
dic = {}
for d in data:
    if d in dic:
        dic[d] += 1
    else:
        dic[d] = 1


if 8 *I < n:
    #print(1+'1')
    print(n - max(dic.values()))
    sys.exit()


vals = list(dic.keys())
vals.sort()
am = len(vals)
if am <= num:
    print(0)
    sys.exit() 

sumto = [dic[vals[0]]]
for i in range(1, am):
    sumto.append(sumto[-1] + dic[vals[i]])

# print(vals)
# print(sumto)

# print(num, ""###"")
kept = sumto[num-1]
#print(0, kept)
for i in range(am - num):
    
    kept2 = sumto[i + num] - sumto[i]
    #print(i+1, kept2)
    if kept2 > kept:
        kept = kept2


print(n-kept)


# lind = 0
# rind = am - 1
# ans = 0
# # print(dic)
# # print(vals)
# # print(am, num)
# while am > num:
#     if dic[vals[lind]] < dic[vals[rind]]:
        
#         ans += dic[vals[lind]]
#         lind += 1
#     else:
#         ans += dic[vals[rind]]
#         rind -= 1
#     am -= 1
#print(ans)",['two pointers']
4625,"Polycarp plays a computer game (yet again). In this game, he fights monsters using magic spells.There are two types of spells: fire spell of power $$$x$$$ deals $$$x$$$ damage to the monster, and lightning spell of power $$$y$$$ deals $$$y$$$ damage to the monster and doubles the damage of the next spell Polycarp casts. Each spell can be cast only once per battle, but Polycarp can cast them in any order.For example, suppose that Polycarp knows three spells: a fire spell of power $$$5$$$, a lightning spell of power $$$1$$$, and a lightning spell of power $$$8$$$. There are $$$6$$$ ways to choose the order in which he casts the spells:  first, second, third. This order deals $$$5 + 1 + 2 \cdot 8 = 22$$$ damage;  first, third, second. This order deals $$$5 + 8 + 2 \cdot 1 = 15$$$ damage;  second, first, third. This order deals $$$1 + 2 \cdot 5 + 8 = 19$$$ damage;  second, third, first. This order deals $$$1 + 2 \cdot 8 + 2 \cdot 5 = 27$$$ damage;  third, first, second. This order deals $$$8 + 2 \cdot 5 + 1 = 19$$$ damage;  third, second, first. This order deals $$$8 + 2 \cdot 1 + 2 \cdot 5 = 20$$$ damage. Initially, Polycarp knows $$$0$$$ spells. His spell set changes $$$n$$$ times, each time he either learns a new spell or forgets an already known one. After each change, calculate the maximum possible damage Polycarp may deal using the spells he knows. nan import sys, math
import io, os
#data = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
#from bisect import bisect_left as bl, bisect_right as br, insort
#from heapq import heapify, heappush, heappop
#from collections import defaultdict as dd, deque, Counter
#from itertools import permutations,combinations
def data(): return sys.stdin.buffer.readline().strip()
def mdata(): return list(map(int, data().split()))
def outl(var) : sys.stdout.write(' '.join(map(str, var))+'\n')
def out(var) : sys.stdout.write(str(var)+'\n')
#sys.setrecursionlimit(100000)
#INF = float('inf')
mod = int(1e9)+7
#from decimal import Decimal


class SortedList:
    def __init__(self, iterable=[], _load=200):
        """"""Initialize sorted list instance.""""""
        values = sorted(iterable)
        self._len = _len = len(values)
        self._load = _load
        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]
        self._list_lens = [len(_list) for _list in _lists]
        self._mins = [_list[0] for _list in _lists]
        self._fen_tree = []
        self._rebuild = True

    def _fen_build(self):
        """"""Build a fenwick tree instance.""""""
        self._fen_tree[:] = self._list_lens
        _fen_tree = self._fen_tree
        for i in range(len(_fen_tree)):
            if i | i + 1 < len(_fen_tree):
                _fen_tree[i | i + 1] += _fen_tree[i]
        self._rebuild = False

    def _fen_update(self, index, value):
        """"""Update `fen_tree[index] += value`.""""""
        if not self._rebuild:
            _fen_tree = self._fen_tree
            while index < len(_fen_tree):
                _fen_tree[index] += value
                index |= index + 1

    def _fen_query(self, end):
        """"""Return `sum(_fen_tree[:end])`.""""""
        if self._rebuild:
            self._fen_build()

        _fen_tree = self._fen_tree
        x = 0
        while end:
            x += _fen_tree[end - 1]
            end &= end - 1
        return x

    def _fen_findkth(self, k):
        """"""Return a pair of (the largest `idx` such that `sum(_fen_tree[:idx]) <= k`, `k - sum(_fen_tree[:idx])`).""""""
        _list_lens = self._list_lens
        if k < _list_lens[0]:
            return 0, k
        if k >= self._len - _list_lens[-1]:
            return len(_list_lens) - 1, k + _list_lens[-1] - self._len
        if self._rebuild:
            self._fen_build()

        _fen_tree = self._fen_tree
        idx = -1
        for d in reversed(range(len(_fen_tree).bit_length())):
            right_idx = idx + (1 << d)
            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:
                idx = right_idx
                k -= _fen_tree[idx]
        return idx + 1, k

    def _delete(self, pos, idx):
        """"""Delete value at the given `(pos, idx)`.""""""
        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens

        self._len -= 1
        self._fen_update(pos, -1)
        del _lists[pos][idx]
        _list_lens[pos] -= 1

        if _list_lens[pos]:
            _mins[pos] = _lists[pos][0]
        else:
            del _lists[pos]
            del _list_lens[pos]
            del _mins[pos]
            self._rebuild = True

    def _loc_left(self, value):
        """"""Return an index pair that corresponds to the first position of `value` in the sorted list.""""""
        if not self._len:
            return 0, 0

        _lists = self._lists
        _mins = self._mins

        lo, pos = -1, len(_lists) - 1
        while lo + 1 < pos:
            mi = (lo + pos) >> 1
            if value <= _mins[mi]:
                pos = mi
            else:
                lo = mi

        if pos and value <= _lists[pos - 1][-1]:
            pos -= 1

        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value <= _list[mi]:
                idx = mi
            else:
                lo = mi

        return pos, idx

    def _loc_right(self, value):
        """"""Return an index pair that corresponds to the last position of `value` in the sorted list.""""""
        if not self._len:
            return 0, 0

        _lists = self._lists
        _mins = self._mins

        pos, hi = 0, len(_lists)
        while pos + 1 < hi:
            mi = (pos + hi) >> 1
            if value < _mins[mi]:
                hi = mi
            else:
                pos = mi

        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value < _list[mi]:
                idx = mi
            else:
                lo = mi

        return pos, idx

    def add(self, value):
        """"""Add `value` to sorted list.""""""
        _load = self._load
        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens

        self._len += 1
        if _lists:
            pos, idx = self._loc_right(value)
            self._fen_update(pos, 1)
            _list = _lists[pos]
            _list.insert(idx, value)
            _list_lens[pos] += 1
            _mins[pos] = _list[0]
            if _load + _load < len(_list):
                _lists.insert(pos + 1, _list[_load:])
                _list_lens.insert(pos + 1, len(_list) - _load)
                _mins.insert(pos + 1, _list[_load])
                _list_lens[pos] = _load
                del _list[_load:]
                self._rebuild = True
        else:
            _lists.append([value])
            _mins.append(value)
            _list_lens.append(1)
            self._rebuild = True

    def discard(self, value):
        """"""Remove `value` from sorted list if it is a member.""""""
        _lists = self._lists
        if _lists:
            pos, idx = self._loc_right(value)
            if idx and _lists[pos][idx - 1] == value:
                self._delete(pos, idx - 1)

    def remove(self, value):
        """"""Remove `value` from sorted list; `value` must be a member.""""""
        _len = self._len
        self.discard(value)
        if _len == self._len:
            raise ValueError('{0!r} not in list'.format(value))

    def pop(self, index=-1):
        """"""Remove and return value at `index` in sorted list.""""""
        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        value = self._lists[pos][idx]
        self._delete(pos, idx)
        return value

    def bisect_left(self, value):
        """"""Return the first index to insert `value` in the sorted list.""""""
        pos, idx = self._loc_left(value)
        return self._fen_query(pos) + idx

    def bisect_right(self, value):
        """"""Return the last index to insert `value` in the sorted list.""""""
        pos, idx = self._loc_right(value)
        return self._fen_query(pos) + idx

    def count(self, value):
        """"""Return number of occurrences of `value` in the sorted list.""""""
        return self.bisect_right(value) - self.bisect_left(value)

    def __len__(self):
        """"""Return the size of the sorted list.""""""
        return self._len

    def __getitem__(self, index):
        """"""Lookup value at `index` in sorted list.""""""
        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        return self._lists[pos][idx]

    def __delitem__(self, index):
        """"""Remove value at `index` from sorted list.""""""
        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        self._delete(pos, idx)

    def __contains__(self, value):
        """"""Return true if `value` is an element of the sorted list.""""""
        _lists = self._lists
        if _lists:
            pos, idx = self._loc_left(value)
            return idx < len(_lists[pos]) and _lists[pos][idx] == value
        return False

    def __iter__(self):
        """"""Return an iterator over the sorted list.""""""
        return (value for _list in self._lists for value in _list)

    def __reversed__(self):
        """"""Return a reverse iterator over the sorted list.""""""
        return (value for _list in reversed(self._lists) for value in reversed(_list))

    def __repr__(self):
        """"""Return string representation of sorted list.""""""
        return 'SortedList({0})'.format(list(self))

def fix():
    global sumL, cntL, sumDouble
    while len(Double)<cntL:
        temp=LF[-1]
        Double.add(temp)
        LF.remove(temp)
        sumDouble+=temp
    while len(Double)>cntL:
        temp=Double[0]
        Double.remove(temp)
        LF.add(temp)
        sumDouble-=temp
    while Double and LF and Double[0]<LF[-1]:
        temp1,temp2=Double[0],LF[-1]
        LF.remove(temp2)
        Double.remove(temp1)
        LF.add(temp1)
        Double.add(temp2)
        sumDouble+=temp2-temp1
    if sumDouble==sumL and cntL:
        temp1=Double[0]
        Double.remove(temp1)
        if LF:
            temp2=LF[-1]
            LF.remove(temp2)
            Double.add(temp2)
            sumDouble+=temp2
        LF.add(temp1)
        sumDouble-=temp1



def add(tp,d):
    global sumF,sumL, sumDouble, cntL
    if not tp:
        sumF+=d
    else:
        sumL+=d
        cntL+=1
    LF.add(d)


def remove(tp,d):
    global sumF, sumL, sumDouble, cntL
    if not tp:
        sumF-=d
    else:
        sumL-=d
        cntL-=1
    if d in LF:
        LF.remove(d)
    else:
        Double.remove(d)
        sumDouble-=d

n=int(data())
sumL,sumF,sumDouble,cntL=0,0,0,0
LF=SortedList()
Double=SortedList()

for _ in range(n):
    tp,d=mdata()
    if d<0:
        remove(tp,-d)
    else:
        add(tp,d)
    fix()
    print(sumDouble+sumL+sumF)
","['binary search', 'data structures', 'greedy', 'implementation', 'math', 'sortings']"
3722,"Kuroni has $$$n$$$ daughters. As gifts for them, he bought $$$n$$$ necklaces and $$$n$$$ bracelets:  the $$$i$$$-th necklace has a brightness $$$a_i$$$, where all the $$$a_i$$$ are pairwise distinct (i.e. all $$$a_i$$$ are different),  the $$$i$$$-th bracelet has a brightness $$$b_i$$$, where all the $$$b_i$$$ are pairwise distinct (i.e. all $$$b_i$$$ are different). Kuroni wants to give exactly one necklace and exactly one bracelet to each of his daughters. To make sure that all of them look unique, the total brightnesses of the gifts given to each daughter should be pairwise distinct. Formally, if the $$$i$$$-th daughter receives a necklace with brightness $$$x_i$$$ and a bracelet with brightness $$$y_i$$$, then the sums $$$x_i + y_i$$$ should be pairwise distinct. Help Kuroni to distribute the gifts.For example, if the brightnesses are $$$a = [1, 7, 5]$$$ and $$$b = [6, 1, 2]$$$, then we may distribute the gifts as follows:  Give the third necklace and the first bracelet to the first daughter, for a total brightness of $$$a_3 + b_1 = 11$$$. Give the first necklace and the third bracelet to the second daughter, for a total brightness of $$$a_1 + b_3 = 3$$$. Give the second necklace and the second bracelet to the third daughter, for a total brightness of $$$a_2 + b_2 = 8$$$. Here is an example of an invalid distribution:   Give the first necklace and the first bracelet to the first daughter, for a total brightness of $$$a_1 + b_1 = 7$$$. Give the second necklace and the second bracelet to the second daughter, for a total brightness of $$$a_2 + b_2 = 8$$$. Give the third necklace and the third bracelet to the third daughter, for a total brightness of $$$a_3 + b_3 = 7$$$. This distribution is invalid, as the total brightnesses of the gifts received by the first and the third daughter are the same. Don't make them this upset! NoteIn the first test case, it is enough to give the $$$i$$$-th necklace and the $$$i$$$-th bracelet to the $$$i$$$-th daughter. The corresponding sums are $$$1 + 8 = 9$$$, $$$8 + 4 = 12$$$, and $$$5 + 5 = 10$$$.The second test case is described in the statement. for _ in range(int(input())):
    n=int(input())
    a=sorted(list(map(int,input().split())))
    b=sorted(list(map(int,input().split())))
    sumi=0
    print(*a)
    print(*b)","['brute force', 'constructive algorithms', 'greedy', 'sortings']"
842,"This is an interactive problem. The only difference between the easy and hard version is the limit on number of questions.There are $$$n$$$ players labelled from $$$1$$$ to $$$n$$$. It is guaranteed that $$$n$$$ is a multiple of $$$3$$$.Among them, there are $$$k$$$ impostors and $$$n-k$$$ crewmates. The number of impostors, $$$k$$$, is not given to you. It is guaranteed that $$$\frac{n}{3} &lt; k &lt; \frac{2n}{3}$$$.In each question, you can choose three distinct integers $$$a$$$, $$$b$$$, $$$c$$$ ($$$1 \le a, b, c \le n$$$) and ask: ""Among the players labelled $$$a$$$, $$$b$$$ and $$$c$$$, are there more impostors or more crewmates?"" You will be given the integer $$$0$$$ if there are more impostors than crewmates, and $$$1$$$ otherwise.Find the number of impostors $$$k$$$ and the indices of players that are impostors after asking at most $$$2n$$$ questions.The jury is adaptive, which means the indices of impostors may not be fixed beforehand and can depend on your questions. It is guaranteed that there is at least one set of impostors which fulfills the constraints and the answers to your questions at any time. NoteExplanation for example interaction (note that this example only exists to demonstrate the interaction procedure and does not provide any hint for the solution):For the first test case:Question ""? 1 2 3"" returns $$$0$$$, so there are more impostors than crewmates among players $$$1$$$, $$$2$$$ and $$$3$$$.Question ""? 3 4 5"" returns $$$1$$$, so there are more crewmates than impostors among players $$$3$$$, $$$4$$$ and $$$5$$$.Outputting ""! 3 4 1 2"" means that one has found all the impostors, by some miracle. There are $$$k = 3$$$ impostors. The players who are impostors are players $$$4$$$, $$$1$$$ and $$$2$$$.For the second test case:Question ""? 7 1 9"" returns $$$1$$$, so there are more crewmates than impostors among players $$$7$$$, $$$1$$$ and $$$9$$$.Outputting ""! 4 2 3 6 8"" means that one has found all the impostors, by some miracle. There are $$$k = 4$$$ impostors. The players who are impostors are players $$$2$$$, $$$3$$$, $$$6$$$ and $$$8$$$. import sys
import random

# sys.stdin = open(""input.txt"", 'r')


if __name__ == '__main__':

    T = int(input())
    for t in range(1, T + 1):
        n = int(input())

        lst = [0 for i in range(n)]
        crew = 0
        imp = 0
        print(""?"", 1, 2, 3)
        sys.stdout.flush()
        q_prev = int(input())
        ind = 1
        while crew == 0:
            print(""?"", ind+1, ind+2, ind+3)
            sys.stdout.flush()
            q = int(input())
            if q != q_prev:
                if q == 1:
                    crew = ind+3
                    imp = ind
                    lst[ind+2] = -1
                    lst[ind-1] = 1
                if q == 0:
                    imp = ind+3
                    crew = ind
                    lst[ind+2] = 1
                    lst[ind-1] = -1
                break
            ind += 1

        for i in range(n):
            if lst[i] == 0:
                print(""?"", i + 1, crew, imp)
                sys.stdout.flush()
                q = int(input())
                if q == 0:
                    lst[i] = 1
                else:
                    lst[i] = -1

        k = sum((i == 1) for i in lst)
        print(""!"", k, end="""")
        for i in range(len(lst)):
            if lst[i] == 1:
                print("" "" + str(i + 1), end="""")
        print(""\n"", end="""")
        sys.stdout.flush()
","['constructive algorithms', 'implementation', 'interactive']"
199,"Let $$$n$$$ be an integer. Consider all permutations on integers $$$1$$$ to $$$n$$$ in lexicographic order, and concatenate them into one big sequence $$$p$$$. For example, if $$$n = 3$$$, then $$$p = [1, 2, 3, 1, 3, 2, 2, 1, 3, 2, 3, 1, 3, 1, 2, 3, 2, 1]$$$. The length of this sequence will be $$$n \cdot n!$$$.Let $$$1 \leq i \leq j \leq n \cdot n!$$$ be a pair of indices. We call the sequence $$$(p_i, p_{i+1}, \dots, p_{j-1}, p_j)$$$ a subarray of $$$p$$$. Its length is defined as the number of its elements, i.e., $$$j - i + 1$$$. Its sum is the sum of all its elements, i.e., $$$\sum_{k=i}^j p_k$$$. You are given $$$n$$$. Find the number of subarrays of $$$p$$$ of length $$$n$$$ having sum $$$\frac{n(n+1)}{2}$$$. Since this number may be large, output it modulo $$$998244353$$$ (a prime number).  NoteIn the first sample, there are $$$16$$$ subarrays of length $$$3$$$. In order of appearance, they are:$$$[1, 2, 3]$$$, $$$[2, 3, 1]$$$, $$$[3, 1, 3]$$$, $$$[1, 3, 2]$$$, $$$[3, 2, 2]$$$, $$$[2, 2, 1]$$$, $$$[2, 1, 3]$$$, $$$[1, 3, 2]$$$, $$$[3, 2, 3]$$$, $$$[2, 3, 1]$$$, $$$[3, 1, 3]$$$, $$$[1, 3, 1]$$$, $$$[3, 1, 2]$$$, $$$[1, 2, 3]$$$, $$$[2, 3, 2]$$$, $$$[3, 2, 1]$$$. Their sums are $$$6$$$, $$$6$$$, $$$7$$$, $$$6$$$, $$$7$$$, $$$5$$$, $$$6$$$, $$$6$$$, $$$8$$$, $$$6$$$, $$$7$$$, $$$5$$$, $$$6$$$, $$$6$$$, $$$7$$$, $$$6$$$. As $$$\frac{n(n+1)}{2} = 6$$$, the answer is $$$9$$$. n = int(raw_input())

MOD = 998244353

answer = 1
factorial = 1
for i in range(1, n + 1):
    factorial = (factorial * i) % MOD
    answer = (i * answer + factorial - i) % MOD

print(answer)

","['combinatorics', 'dp', 'math']"
2803,"In a Berland's zoo there is an enclosure with camels. It is known that camels like to spit. Bob watched these interesting animals for the whole day and registered in his notepad where each animal spitted. Now he wants to know if in the zoo there are two camels, which spitted at each other. Help him to solve this task.The trajectory of a camel's spit is an arc, i.e. if the camel in position x spits d meters right, he can hit only the camel in position x + d, if such a camel exists. nan n = int(input())
a = []
b = []
for _ in range(n):
    i = []
    i = input().split()
    a.append(int(i[0]))
    b.append(int(i[1]))
f = False
for i in range(len(a)):
    for j in range(len(b)):
        if a[i] + b[i] == a[j] and b[j] == 0 - b[i]:
            f = True
            break
    if f:
        print('YES')
        break
else:
    print('NO')
",['brute force']
1010,"Real stupidity beats artificial intelligence every time.— Terry Pratchett, Hogfather, DiscworldYou are given a string $$$s$$$ of length $$$n$$$ and a number $$$k$$$. Let's denote by $$$rev(s)$$$ the reversed string $$$s$$$ (i.e. $$$rev(s) = s_n s_{n-1} ... s_1$$$). You can apply one of the two kinds of operations to the string: replace the string $$$s$$$ with $$$s + rev(s)$$$ replace the string $$$s$$$ with $$$rev(s) + s$$$How many different strings can you get as a result of performing exactly $$$k$$$ operations (possibly of different kinds) on the original string $$$s$$$?In this statement we denoted the concatenation of strings $$$s$$$ and $$$t$$$ as $$$s + t$$$. In other words, $$$s + t = s_1 s_2 ... s_n t_1 t_2 ... t_m$$$, where $$$n$$$ and $$$m$$$ are the lengths of strings $$$s$$$ and $$$t$$$ respectively. NoteIn the first test case of the example:After the first operation the string $$$s$$$ can become either aabbaa or baaaab. After the second operation there are 2 possibilities for $$$s$$$: aabbaaaabbaa and baaaabbaaaab. #!/shafi/bin/env python
import os
import sys
from io import BytesIO, IOBase


def main():
    tc = int(input())
    for _ in range(tc): #Testcases
        n,m = map(int,input().split())
        s = input()
        i=0
        j=len(s)-1
        pal=True
        while i<j:
            if s[i]!=s[j]:
                pal=False
            i+=1
            j-=1
        if m==0 or pal==True:
            print(1)
        else:
            print(2)
    
            





# region fastio

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._file = file
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# endregion

if __name__ == ""__main__"":
    main()","['greedy', 'strings']"
2677,"  Slastyona and her loyal dog Pushok are playing a meaningless game that is indeed very interesting.The game consists of multiple rounds. Its rules are very simple: in each round, a natural number k is chosen. Then, the one who says (or barks) it faster than the other wins the round. After that, the winner's score is multiplied by k2, and the loser's score is multiplied by k. In the beginning of the game, both Slastyona and Pushok have scores equal to one.Unfortunately, Slastyona had lost her notepad where the history of all n games was recorded. She managed to recall the final results for each games, though, but all of her memories of them are vague. Help Slastyona verify their correctness, or, to put it another way, for each given pair of scores determine whether it was possible for a game to finish with such result or not. NoteFirst game might have been consisted of one round, in which the number 2 would have been chosen and Pushok would have won.The second game needs exactly two rounds to finish with such result: in the first one, Slastyona would have said the number 5, and in the second one, Pushok would have barked the number 3. import sys
n = int(input())
ans = []
arr = sys.stdin.read().split()
d = {}
for i in range(1,1001):
    d[i**3] = i
for i in range(n):
    a, b = int(arr[i<<1]), int(arr[i<<1|1])
    if a == b:
        if a in d:
            ans.append('Yes')
        else:
            ans.append('No')
        continue
    if a > b: a, b = b, a
    x = d.get(a*a//b,-1)
    if x == -1:
        ans.append('No')
        continue
    if a % (x*x):
        ans.append('No')
        continue
    
    y = a //(x*x)
    
    if x * x * y == a and x * y * y == b: ans.append('Yes')
    else: ans.append('No')
print('\n'.join(ans))
",['math']
3080,"This is an interactive problem. In the output section below you will see the information about flushing the output.Bear Limak thinks of some hidden number — an integer from interval [2, 100]. Your task is to say if the hidden number is prime or composite.Integer x &gt; 1 is called prime if it has exactly two distinct divisors, 1 and x. If integer x &gt; 1 is not prime, it's called composite.You can ask up to 20 queries about divisors of the hidden number. In each query you should print an integer from interval [2, 100]. The system will answer ""yes"" if your integer is a divisor of the hidden number. Otherwise, the answer will be ""no"".For example, if the hidden number is 14 then the system will answer ""yes"" only if you print 2, 7 or 14.When you are done asking queries, print ""prime"" or ""composite"" and terminate your program.You will get the Wrong Answer verdict if you ask more than 20 queries, or if you print an integer not from the range [2, 100]. Also, you will get the Wrong Answer verdict if the printed answer isn't correct.You will get the Idleness Limit Exceeded verdict if you don't print anything (but you should) or if you forget about flushing the output (more info below). NoteThe hidden number in the first query is 30. In a table below you can see a better form of the provided example of the communication process.The hidden number is divisible by both 2 and 5. Thus, it must be composite. Note that it isn't necessary to know the exact value of the hidden number. In this test, the hidden number is 30.59 is a divisor of the hidden number. In the interval [2, 100] there is only one number with this divisor. The hidden number must be 59, which is prime. Note that the answer is known even after the second query and you could print it then and terminate. Though, it isn't forbidden to ask unnecessary queries (unless you exceed the limit of 20 queries). counter = 0;
for i in [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,4,9,25,49]:
    print(i);
    counter += (input() == 'yes');
    if counter > 1:
        print(""composite"");
        break;
else:
    print(""prime"");","['constructive algorithms', 'interactive', 'math']"
969,"For each string s consisting of characters '0' and '1' one can define four integers a00, a01, a10 and a11, where axy is the number of subsequences of length 2 of the string s equal to the sequence {x, y}. In these problem you are given four integers a00, a01, a10, a11 and have to find any non-empty string s that matches them, or determine that there is no such string. One can prove that if at least one answer exists, there exists an answer of length no more than 1 000 000. nan def f(x):
	l, r, mid, res = 1, 100000, 0, -1
	while l <= r:
		mid = (l + r) / 2 
		if mid * (mid - 1) / 2 == x:
			res = mid
			break
		elif mid * (mid - 1) / 2 < x:
			l = mid + 1
		else:
			r = mid - 1
	if res == 1 and (not (b or c)):
		res = 0
	return res
a, b, c, d = map(int, raw_input().split())
x, y = f(a), f(d)
if not (x or y):print '0'
elif x == -1 or y == -1 or b + c != x * y:print 'Impossible'
elif x == 0:print '1' * y
elif y == 0:print '0' * x
else:
	t = b / x
	p = b % x
	if p:
		s = '1' * (y - t - 1)
		s += '0' * p
		s += '1'
		s += '0' * (x - p)
		s += '1' * t
		print s
	else:
		s = '1' * (y - t)
		s += '0' * x
		s += '1' * t
		print s","['constructive algorithms', 'greedy', 'implementation', 'math']"
2432,"Suppose $$$a_1, a_2, \dots, a_n$$$ is a sorted integer sequence of length $$$n$$$ such that $$$a_1 \leq a_2 \leq \dots \leq a_n$$$. For every $$$1 \leq i \leq n$$$, the prefix sum $$$s_i$$$ of the first $$$i$$$ terms $$$a_1, a_2, \dots, a_i$$$ is defined by $$$$$$ s_i = \sum_{k=1}^i a_k = a_1 + a_2 + \dots + a_i. $$$$$$Now you are given the last $$$k$$$ terms of the prefix sums, which are $$$s_{n-k+1}, \dots, s_{n-1}, s_{n}$$$. Your task is to determine whether this is possible. Formally, given $$$k$$$ integers $$$s_{n-k+1}, \dots, s_{n-1}, s_{n}$$$, the task is to check whether there is a sequence $$$a_1, a_2, \dots, a_n$$$ such that   $$$a_1 \leq a_2 \leq \dots \leq a_n$$$, and  $$$s_i = a_1 + a_2 + \dots + a_i$$$ for all $$$n-k+1 \leq i \leq n$$$.  NoteIn the first test case, we have the only sequence $$$a = [1, 1, 1, 1, 1]$$$.In the second test case, we can choose, for example, $$$a = [-3, -2, -1, 0, 1, 2, 3]$$$.In the third test case, the prefix sums define the only sequence $$$a = [2, 1, 1]$$$, but it is not sorted. In the fourth test case, it can be shown that there is no sequence with the given prefix sums. for asdasdas in range(int(input())):
    n, k = map(int, input().split())
    items = [int(i) for i in input().split()]
    if k == 1:
        print('YES')
        continue
    an_items = [items[i + 1] - items[i] for i in range(k - 1)]
    an_itemsP0 = [0] * (n - k + 1) + an_items
    if an_items != sorted(an_items):
        print('NO')
        continue
    if items[0] > (n - k + 1) * an_itemsP0[n - k + 1]:
        print('NO')
        continue
    print('YES')
","['constructive algorithms', 'greedy', 'math', 'sortings']"
227,"You are given a tree consisting of $$$n$$$ vertices. A number is written on each vertex; the number on vertex $$$i$$$ is equal to $$$a_i$$$.Let's denote the function $$$g(x, y)$$$ as the greatest common divisor of the numbers written on the vertices belonging to the simple path from vertex $$$x$$$ to vertex $$$y$$$ (including these two vertices). Also let's denote $$$dist(x, y)$$$ as the number of vertices on the simple path between vertices $$$x$$$ and $$$y$$$, including the endpoints. $$$dist(x, x) = 1$$$ for every vertex $$$x$$$.Your task is calculate the maximum value of $$$dist(x, y)$$$ among such pairs of vertices that $$$g(x, y) &gt; 1$$$. nan from sys import stdin, stdout
from math import *
from heapq import *
from collections import *

dv=list(range(200002))
for i in range(2,200002):
    if ((i*i)>=200002): 
        break
    if (dv[i]==i):
        j=i
        while ((i*j)<200002):
            dv[i*j]=i
            j=j+1
def loPr(x):
    global dv
    if (x<=1):
        return []
    ret=[]
    while(x>1):
        d=dv[x]
        ret.append(d)
        while(x%d==0):
            x=trunc(x/d)
    return ret
def main():
    global dv
    n=int(stdin.readline())
    a=[0]+[int(x) for x in stdin.readline().split()]
    e=[]
    for _ in range(n+2):
        e.append([])
    for _ in range(n-1):
        u,v=[int(x) for x in stdin.readline().split()]
        e[u].append(v)
        e[v].append(u)
    
    pre=[0]*(n+2)
    q=[1]
    d=[False]*(n+2)
    d[1]=True
    pre[1]=1
    i=0
    while(i<len(q)):
        u=q[i]
        for v in e[u]:
            if (d[v]==False):
                d[v]=True
                pre[v]=u
                q.append(v)
        i=i+1
    
    f=[dict()]
    for _ in range(n+2):
        f.append(dict())
    b=[[]]
    for i in range(1,n+1):
        b.append(loPr(a[i]))
        for p in b[i]:
            f[i][p]=[1]
    q.reverse()
    res=0
    for u in q:
        nxt=pre[u]
        #print (str(u)+"": f="" +str(f[u])+ ""  b="" +str(b[u]))
        for p in b[u]:
            fp=f[u].get(p,[1])
            fp.sort()
            res=max(res,fp[-1])
            if (len(fp)>=2):
                res=max(res,fp[-1]+fp[-2]-1)
            fnxt=f[nxt].get(p,None)
            if (fnxt!=None):
                fnxt.append(max(1,fp[-1])+1)
    stdout.write(str(res))
    return 0

if __name__ == ""__main__"":
    main()","['data structures', 'dfs and similar', 'dp', 'number theory', 'trees']"
2617,"You are given two arrays $$$a$$$ and $$$b$$$, consisting of $$$n$$$ integers each.Let's define a function $$$f(a, b)$$$ as follows:   let's define an array $$$c$$$ of size $$$n$$$, where $$$c_i = a_i \oplus b_i$$$ ($$$\oplus$$$ denotes bitwise XOR);  the value of the function is $$$c_1 \mathbin{\&amp;} c_2 \mathbin{\&amp;} \cdots \mathbin{\&amp;} c_n$$$ (i.e. bitwise AND of the entire array $$$c$$$). Find the maximum value of the function $$$f(a, b)$$$ if you can reorder the array $$$b$$$ in an arbitrary way (leaving the initial order is also an option). nan #!/usr/bin/env python3
import sys
input = sys.stdin.readline  # to read input quickly

# available on Google, AtCoder Python3, not available on Codeforces
# import numpy as np
# import scipy

m9 = 10**9 + 7  # 998244353
yes, no = ""YES"", ""NO""
# d4 = [(1,0),(0,1),(-1,0),(0,-1)]
# d8 = [(1,0),(1,1),(0,1),(-1,1),(-1,0),(-1,-1),(0,-1),(1,-1)]
# d6 = [(2,0),(1,1),(-1,1),(-2,0),(-1,-1),(1,-1)]  # hexagonal layout
MAXINT = sys.maxsize
e18 = 10**18 + 10

# if testing locally, print to terminal with a different color
OFFLINE_TEST = False
CHECK_OFFLINE_TEST = True
# CHECK_OFFLINE_TEST = False  # uncomment this on Codechef
if CHECK_OFFLINE_TEST:
    import getpass
    OFFLINE_TEST = getpass.getuser() == ""htong""

def log(*args):
    if CHECK_OFFLINE_TEST and OFFLINE_TEST:
        print('\033[36m', *args, '\033[0m', file=sys.stderr)

def solve(*args):
    # screen input
    if OFFLINE_TEST:
        log(""----- solving ------"")
        log(*args)
        log(""----- ------- ------"")
    return solve_(*args)

def read_matrix(rows):
    return [list(map(int,input().split())) for _ in range(rows)]

def read_strings(rows):
    return [input().strip() for _ in range(rows)]

def minus_one(arr):
    return [x-1 for x in arr]

def minus_one_matrix(mrr):
    return [[x-1 for x in row] for row in mrr]

# ---------------------------- template ends here ----------------------------


def solve_(arr, brr, n):
    # your solution here

    res = []

    pools = [(arr, brr),]

    for i in range(30,-1,-1):
        # log(pools)
        topmask = 2**i
        onemask = topmask - 1
    
        fail = False
        for ar,br in pools:
            assert len(ar) == len(br)
            acount = sum(x&topmask > 0 for x in ar)
            bcount = sum(x&topmask > 0 for x in br)
            # log(acount, bcount, len(ar))
            if acount + bcount != len(ar):
                fail = True
        
        if fail:
            res.append(0)
            pools = [
                ([x&onemask for x in ar], [x&onemask for x in br]) 
                for ar, br in pools
            ]

        else:
            new_pools = []
            res.append(1)
            for ar,br in pools:
                ar0 = [a for a in ar if not a&topmask]
                ar1 = [a^topmask for a in ar if a&topmask]
                br0 = [b for b in br if not b&topmask]
                br1 = [b^topmask for b in br if b&topmask]
                if ar0:
                    new_pools.append((ar0, br1))
                if ar1:
                    new_pools.append((ar1, br0))
            pools = new_pools

    log(res)

    return int("""".join(str(x) for x in res),2)


# for case_num in [0]:  # no loop over test case
# for case_num in range(100):  # if the number of test cases is specified
for case_num in range(int(input())):

    # read line as an integer
    n = int(input())

    # read line as a string
    # srr = input().strip()

    # read one line and parse each word as a string
    # arr = input().split()

    # read one line and parse each word as an integer
    # a,b,c = list(map(int,input().split()))
    arr = list(map(int,input().split()))
    brr = list(map(int,input().split()))
    # arr = minus_one(arr)

    # read multiple rows
    # arr = read_strings(k)  # and return as a list of str
    # mrr = read_matrix(k)  # and return as a list of list of int
    # mrr = minus_one_matrix(mrr)

    res = solve(arr, brr, n)  # include input here

    # print length if applicable
    # print(len(res))

    # parse result
    # res = "" "".join(str(x) for x in res)
    # res = ""\n"".join(str(x) for x in res)
    # res = ""\n"".join("" "".join(str(x) for x in row) for row in res)

    # print result
    # print(""Case #{}: {}"".format(case_num+1, res))   # Google and Facebook - case number required

    print(res)
","['bitmasks', 'dfs and similar', 'divide and conquer', 'greedy', 'sortings']"
3480,"Little girl Susie accidentally found her elder brother's notebook. She has many things to do, more important than solving problems, but she found this problem too interesting, so she wanted to know its solution and decided to ask you about it. So, the problem statement is as follows.Let's assume that we are given a connected weighted undirected graph G = (V, E) (here V is the set of vertices, E is the set of edges). The shortest-path tree from vertex u is such graph G1 = (V, E1) that is a tree with the set of edges E1 that is the subset of the set of edges of the initial graph E, and the lengths of the shortest paths from u to any vertex to G and to G1 are the same. You are given a connected weighted undirected graph G and vertex u. Your task is to find the shortest-path tree of the given graph from vertex u, the total weight of whose edges is minimum possible. NoteIn the first sample there are two possible shortest path trees:  with edges 1 – 3 and 2 – 3 (the total weight is 3);  with edges 1 – 2 and 2 – 3 (the total weight is 2); And, for example, a tree with edges 1 – 2 and 1 – 3 won't be a shortest path tree for vertex 3, because the distance from vertex 3 to vertex 2 in this tree equals 3, and in the original graph it is 1. import heapq
n,m = map(int, input().split())
g = [[] for i in range(n)]
for i in range(1,m+1):
    x,y,z = map(int, input().split())
    x -= 1
    y -= 1
    g[x].append((y,z,i))
    g[y].append((x,z,i))
v = int(input())-1
q = [(0,0,v,0)]
s = []
u = [0] * n
a = 0
while len(q) :
    d,l,x,e = heapq.heappop(q)
    if not u[x]:
        u[x] = 1
        s.append(str(e))
        a += l
        for i,k,f in g[x]:
            if not u[i]:
                heapq.heappush(q, (d+k,k,i,f))
print(a)
print(' '.join(s[1:]))




","['graphs', 'greedy', 'shortest paths']"
2771,"Polycarp loves not only to take pictures, but also to show his photos to friends. On his personal website he has recently installed a widget that can display n photos with the scroll option. At each moment of time the widget displays exactly one photograph with the option showing the previous/next one. From the first photo, you can switch to the second one or to the n-th one, from the second photo you can switch to the third one or to the first one, etc. Thus, navigation is performed in a cycle.Polycarp's collection consists of m photo albums, the i-th album contains ai photos. Polycarp wants to choose n photos and put them on a new widget. To make watching the photos interesting to the visitors, he is going to post pictures so that no two photos from one album were neighboring (each photo will have exactly two neighbors, the first photo's neighbors are the second and the n-th one).Help Polycarp compile a photo gallery. Select n photos from his collection and put them in such order that no two photos from one album went one after the other. nan #!/usr/bin/env python

from sys import stdin

def solve(N, M, A):
   if N == 1:
      if M > 0:
         return [1]
      else:
         return [-1]

   P = [ (A[i], i+1) for i in xrange(M) ]
   P.sort()

   R = [0] * N
   i = M-1

   for n in xrange(0, N-1, 2):
      if P[i][0] <= 0: i -= 1
      if i < 0: return [-1]
      P[i] = (P[i][0]-1, P[i][1])
      R[n] = P[i][1]
   # print R

   for n in xrange(1, N, 2):
      if P[i][0] <= 0 or P[i][1] == R[n-1] or n < N-1 and P[i][1] == R[n+1]:
         i -= 1
      if i < 0: return [-1]
      P[i] = (P[i][0]-1, P[i][1])
      R[n] = P[i][1]
   # print R

   if N % 2 == 1:
      if P[i][0] <= 0: i -= 1
      if i < 0: return [-1]
   #  P[i] = (P[i][0]-1, P[i][1])
      if i > 0:
         R[N-1] = P[0][1]
      else:
         R[N-1] = R[0]
         R[0] = P[i][1]
         if R[0] == R[1]: return [-1]
   
   return R

if __name__ == '__main__':
   N, M = map(int, stdin.readline().split())
   A = map(int, stdin.readline().split())
   ans = solve(N, M, A)
   print ' '.join(map(str, ans))





","['constructive algorithms', 'greedy']"
676,"Once little Vasya read an article in a magazine on how to make beautiful handmade garland from colored paper. Vasya immediately went to the store and bought n colored sheets of paper, the area of each sheet is 1 square meter.The garland must consist of exactly m pieces of colored paper of arbitrary area, each piece should be of a certain color. To make the garland, Vasya can arbitrarily cut his existing colored sheets into pieces. Vasya is not obliged to use all the sheets to make the garland.Vasya wants the garland to be as attractive as possible, so he wants to maximize the total area of ​​m pieces of paper in the garland. Calculate what the maximum total area of ​​the pieces of paper in the garland Vasya can get. NoteIn the first test sample Vasya can make an garland of area 6: he can use both sheets of color b, three (but not four) sheets of color a and cut a single sheet of color c in three, for example, equal pieces. Vasya can use the resulting pieces to make a garland of area 6.In the second test sample Vasya cannot make a garland at all — he doesn't have a sheet of color z. colour = input()
new_colour = input()
sum = 0
k = 0
list = []
for i in new_colour:
    if i not in list:
        list += i
for i in list:
    a = colour.count(i)  
    b = new_colour.count(i) 
    if a > b:
        sum += b
    else:
        sum += a
    if i not in colour:
        k += 1
if k > 0:
    print(-1)
else:
    print(sum)
",['implementation']
3231,"You are given an array $$$a$$$ consisting of $$$n$$$ integers.You can remove at most one element from this array. Thus, the final length of the array is $$$n-1$$$ or $$$n$$$.Your task is to calculate the maximum possible length of the strictly increasing contiguous subarray of the remaining array.Recall that the contiguous subarray $$$a$$$ with indices from $$$l$$$ to $$$r$$$ is $$$a[l \dots r] = a_l, a_{l + 1}, \dots, a_r$$$. The subarray $$$a[l \dots r]$$$ is called strictly increasing if $$$a_l &lt; a_{l+1} &lt; \dots &lt; a_r$$$. NoteIn the first example, you can delete $$$a_3=5$$$. Then the resulting array will be equal to $$$[1, 2, 3, 4]$$$ and the length of its largest increasing subarray will be equal to $$$4$$$. #Remove one element
n = int(input())
l = list(map(int,input().split()))
p = [0]*n
z = [0]*n
i = 0
d = 1
while i < len(l):
    cnt = 1
    pi = i
    pj = i+1
    while pj < len(l):
        if l[pj] > l[pi]:
            cnt += 1

        else:
            break

        pj += 1
        pi += 1

    j = i
    k1 = 1
    k2 = cnt
    while k1 <= cnt:
        p[j] = (k1,k2)
        z[j] = d
        k1 += 1
        k2 -= 1
        j += 1

    i = j
    d += 1

m = 0
#print(z)
#print(p)
for i in range(n):
    if i < 2:
        x = p[i][1]

    else:
        e1 = p[i][1]
        e2 = -1
        if l[i] > l[i-2] and z[i-2] != z[i]:
            e2 = e1+p[i-2][0]

        x = max(e1,e2)

    if x > m:
        m = x

print(m)","['brute force', 'dp']"
3922,"Vasya wants to buy himself a nice new car. Unfortunately, he lacks some money. Currently he has exactly 0 burles.However, the local bank has $$$n$$$ credit offers. Each offer can be described with three numbers $$$a_i$$$, $$$b_i$$$ and $$$k_i$$$. Offers are numbered from $$$1$$$ to $$$n$$$. If Vasya takes the $$$i$$$-th offer, then the bank gives him $$$a_i$$$ burles at the beginning of the month and then Vasya pays bank $$$b_i$$$ burles at the end of each month for the next $$$k_i$$$ months (including the month he activated the offer). Vasya can take the offers any order he wants.Each month Vasya can take no more than one credit offer. Also each credit offer can not be used more than once. Several credits can be active at the same time. It implies that Vasya pays bank the sum of $$$b_i$$$ over all the $$$i$$$ of active credits at the end of each month.Vasya wants to buy a car in the middle of some month. He just takes all the money he currently has and buys the car of that exact price.Vasya don't really care what he'll have to pay the bank back after he buys a car. He just goes out of the country on his car so that the bank can't find him anymore.What is the maximum price that car can have? NoteIn the first example, the following sequence of offers taken is optimal: 4 $$$\rightarrow$$$ 3.The amount of burles Vasya has changes the following way: 5 $$$\rightarrow$$$ 32 $$$\rightarrow$$$ -86 $$$\rightarrow$$$ .... He takes the money he has in the middle of the second month (32 burles) and buys the car.The negative amount of money means that Vasya has to pay the bank that amount of burles.In the second example, the following sequence of offers taken is optimal: 3 $$$\rightarrow$$$ 1 $$$\rightarrow$$$ 2.The amount of burles Vasya has changes the following way: 0 $$$\rightarrow$$$ 300 $$$\rightarrow$$$ 338 $$$\rightarrow$$$ 1337 $$$\rightarrow$$$ 236 $$$\rightarrow$$$ -866 $$$\rightarrow$$$ ....  n = int(input())
a = [tuple(map(int, input().split())) for i in range(n)]

a = [(y, x, k) for x, y, k in a]
a.sort(reverse=True)
dp = [[-1] * (n + 1) for i in range(n)]

def f(i, j):
    if i < 0 or j < -1: return 0
    if dp[i][j] == -1:
        y, x, k = a[i]
        dp[i][j] = f(i - 1, j) + max(0, x - k * y)
        if 0 <= j < k: dp[i][j] = max(dp[i][j], x - j * y + f(i - 1, j - 1))
    return dp[i][j]

print(max(f(n - 1, j) for j in range(-1, n)))
","['dp', 'graphs', 'other', 'sortings']"
1839,"Today Pari and Arya are playing a game called Remainders.Pari chooses two positive integer x and k, and tells Arya k but not x. Arya have to find the value . There are n ancient numbers c1, c2, ..., cn and Pari has to tell Arya  if Arya wants. Given k and the ancient values, tell us if Arya has a winning strategy independent of value of x or not. Formally, is it true that Arya can understand the value  for any positive integer x?Note, that  means the remainder of x after dividing it by y. NoteIn the first sample, Arya can understand  because 5 is one of the ancient numbers.In the second sample, Arya can't be sure what  is. For example 1 and 7 have the same remainders after dividing by 2 and 3, but they differ in remainders after dividing by 7. import math

def main():
    n,k = map(int,input().split())
    C = list(map(int,input().split()))
    l=C[0]
    for c in C:
        l = l*c//math.gcd(l,c)%k
        if(l==0):
            print(""Yes"")
            return
    print(""No"")

main()
","['math', 'number theory', 'other']"
4857,"A permutation is a sequence of integers from 1 to n of length n containing each number exactly once. For example, (1), (4, 3, 5, 1, 2), (3, 2, 1) are permutations, and (1, 1), (4, 3, 1), (2, 3, 4) are not. There are many tasks on permutations. Today you are going to solve one of them. Let’s imagine that somebody took several permutations (perhaps, with a different number of elements), wrote them down consecutively as one array and then shuffled the resulting array. The task is to restore the initial permutations if it is possible. NoteIn the first sample test the array is split into three permutations: (2, 1), (3, 2, 1, 4, 5), (1, 2). The first permutation is formed by the second and the fourth elements of the array, the second one — by the third, the fifth, the sixth, the seventh and the ninth elements, the third one — by the first and the eigth elements. Clearly, there are other splitting variants possible.  n=int(input())
lst=[*map(int,input().split())]
d,di={},{}
for i,x in enumerate(lst):
    if d.get(x)==None:d[x]=[];di[x]=0
    d[x].append(i)
    di[x]+=1
lst=[*set(lst)]
lst.sort()
from sys import exit
if d.get(1)==None:print(-1);exit()
res=[0]*n
for i,x in enumerate(d[1]):
    res[x]=i+1
for i,x in enumerate(lst[1:]):
    if x-lst[i]==1:
        if di[x]<=di[lst[i]]:
            for j,y in enumerate(d[x]):
                res[y]=j+1
        else:print(-1);exit()
    else:print(-1);exit()
print(di[1])
print(*res)",['greedy']
350,"Polycarp has a poor memory. Each day he can remember no more than $$$3$$$ of different letters. Polycarp wants to write a non-empty string of $$$s$$$ consisting of lowercase Latin letters, taking minimum number of days. In how many days will he be able to do it?Polycarp initially has an empty string and can only add characters to the end of that string.For example, if Polycarp wants to write the string lollipops, he will do it in $$$2$$$ days:   on the first day Polycarp will memorize the letters l, o, i and write lolli;  On the second day Polycarp will remember the letters p, o, s, add pops to the resulting line and get the line lollipops. If Polycarp wants to write the string stringology, he will do it in $$$4$$$ days:   in the first day will be written part str;  on day two will be written part ing;  on the third day, part of olog will be written;  on the fourth day, part of y will be written. For a given string $$$s$$$, print the minimum number of days it will take Polycarp to write it. nan a = input()
for i in range(int(a)):
    res = 0
    set_ = set()
    for b in input():
        set_.add(b)
        if len(set_) > 3:
            set_ = set()
            res += 1
            set_.add(b)
    print(res+1)
",['greedy']
3903,"We will consider the numbers $$$a$$$ and $$$b$$$ as adjacent if they differ by exactly one, that is, $$$|a-b|=1$$$.We will consider cells of a square matrix $$$n \times n$$$ as adjacent if they have a common side, that is, for cell $$$(r, c)$$$ cells $$$(r, c-1)$$$, $$$(r, c+1)$$$, $$$(r-1, c)$$$ and $$$(r+1, c)$$$ are adjacent to it.For a given number $$$n$$$, construct a square matrix $$$n \times n$$$ such that:   Each integer from $$$1$$$ to $$$n^2$$$ occurs in this matrix exactly once;  If $$$(r_1, c_1)$$$ and $$$(r_2, c_2)$$$ are adjacent cells, then the numbers written in them must not be adjacent.  nan 
tests = int(input())
for i in range(tests):
    #another solution (the matrix doesnt have any adjacent elements)
    n = int(input())
    matrix = [[0 for c in range(n)] for c in range(n)]
    nums = n * n -1
    matrix[0][0] = 1
    matrix[n-1][n-1] = n ** 2
    for j in range(n):
        for k in range(n):
            if j == n-1 and k == n-1 or j == 0 and k == 0:
                continue
            if (j + k) % 2 == 0:
                matrix[j][k] = nums
                nums -= 1
    nums = 2
    for j in range(n-1,-1,-1):
        for k in range(n-1,-1,-1):
            if (j == n-1 and k == n-1) or (j == 0 and k == 0):
                continue
            if (j + k) % 2 == 1:
                matrix[j][k] = nums
                nums += 1

    if n == 2:
        print(-1)
    elif n == 1:
        print(1)
    else:
        for p in matrix:
            print(*p)

    # n = int(input())
    # if(n == 2):
    #     print(-1)
    #     continue
    # nums = 1
    # for j in range(n):
    #     for k in range(n):
    #         print(str(nums), end=' ')
    #         nums += 2
    #         if(nums > n*n):
    #             nums = 2
    #     print()










",['constructive algorithms']
1482,"Hooray! Polycarp turned $$$n$$$ years old! The Technocup Team sincerely congratulates Polycarp!Polycarp celebrated all of his $$$n$$$ birthdays: from the $$$1$$$-th to the $$$n$$$-th. At the moment, he is wondering: how many times he turned beautiful number of years?According to Polycarp, a positive integer is beautiful if it consists of only one digit repeated one or more times. For example, the following numbers are beautiful: $$$1$$$, $$$77$$$, $$$777$$$, $$$44$$$ and $$$999999$$$. The following numbers are not beautiful: $$$12$$$, $$$11110$$$, $$$6969$$$ and $$$987654321$$$.Of course, Polycarpus uses the decimal numeral system (i.e. radix is 10).Help Polycarpus to find the number of numbers from $$$1$$$ to $$$n$$$ (inclusive) that are beautiful. NoteIn the first test case of the example beautiful years are $$$1$$$, $$$2$$$, $$$3$$$, $$$4$$$, $$$5$$$, $$$6$$$, $$$7$$$, $$$8$$$, $$$9$$$ and $$$11$$$. t = int(input())

for i in range(t):
    n = int(input())

    if n < 10:
        print(n // 1)
    elif n > 9 and n < 100:
        print(9 + n // 11)
    elif n > 99 and n < 1000:
        print(18 + n // 111)
    elif n > 999 and n < 10000:
        print(27 + n // 1111)
    elif n > 9999 and n < 100000:
        print(36 + n // 11111)
    elif n > 99999 and n < 1000000:
        print(45 + n // 111111)
    elif n > 999999 and n < 10000000:
        print(54 + n // 1111111)
    elif n > 9999999 and n < 100000000:
        print(63 + n // 11111111)
    elif n > 99999999 and n < 1000000000:
        print(72 + n // 111111111)
    else:
        print(81)
",['implementation']
1220,"Little girl Tanya climbs the stairs inside a multi-storey building. Every time Tanya climbs a stairway, she starts counting steps from $$$1$$$ to the number of steps in this stairway. She speaks every number aloud. For example, if she climbs two stairways, the first of which contains $$$3$$$ steps, and the second contains $$$4$$$ steps, she will pronounce the numbers $$$1, 2, 3, 1, 2, 3, 4$$$.You are given all the numbers pronounced by Tanya. How many stairways did she climb? Also, output the number of steps in each stairway.The given sequence will be a valid sequence that Tanya could have pronounced when climbing one or more stairways. nan quantityOfElems = int(input())
listOfElems = list()
second_string = input()
listOfElems = second_string.split(' ')

intListOfElems = list()

for el in listOfElems:
    intListOfElems.append(int(el))

stairways =  intListOfElems.count(1)

listAnswer = list()
bufferCounter = 0

intListOfElems.remove(1)
for i in range(0, quantityOfElems-1):
    bufferCounter += 1
    if(intListOfElems[i] == 1):
        listAnswer.append(bufferCounter)
        bufferCounter = 0

listAnswer.append(bufferCounter+1)

print(stairways)


answerStr = ''
for i in range(0, stairways):
    answerStr += str(listAnswer[i]) + ' '

print(answerStr)",['implementation']
287,"This is an interactive problem. Refer to the Interaction section below for better understanding.Ithea and Chtholly want to play a game in order to determine who can use the kitchen tonight.Initially, Ithea puts n clear sheets of paper in a line. They are numbered from 1 to n from left to right.This game will go on for m rounds. In each round, Ithea will give Chtholly an integer between 1 and c, and Chtholly needs to choose one of the sheets to write down this number (if there is already a number before, she will erase the original one and replace it with the new one).Chtholly wins if, at any time, all the sheets are filled with a number and the n numbers are in non-decreasing order looking from left to right from sheet 1 to sheet n, and if after m rounds she still doesn't win, she loses the game.Chtholly really wants to win the game as she wants to cook something for Willem. But she doesn't know how to win the game. So Chtholly finds you, and your task is to write a program to receive numbers that Ithea gives Chtholly and help her make the decision on which sheet of paper write this number. NoteIn the example, Chtholly initially knew there were 2 sheets, 4 rounds and each number was between 1 and 4. She then received a 2 and decided to write it in the 1st sheet. Then she received a 1 and wrote it in the 2nd sheet. At last, she received a 3 and replaced 1 with 3 in the 2nd sheet. At this time all the sheets were filled with a number and they were non-decreasing, so she won the game. Note that it is required that your program terminate immediately after Chtholly wins and do not read numbers from the input for the remaining rounds. If not, undefined behaviour may arise and it won't be sure whether your program will be accepted or rejected. Also because of this, please be careful when hacking others' codes. In the sample, Chtholly won the game after the 3rd round, so it is required that your program doesn't read the number of the remaining 4th round.The input format for hacking:   The first line contains 3 integers n, m and c;  The following m lines each contains an integer between 1 and c, indicating the number given to Chtholly in each round.  def main():
    n, m, c = map(int, input().split())
    middle = ((c + 1) // 2) * 2 + 1
    xs = [middle for _ in range(n)]

    def value(a, b):
        # moving from a to b. What is the value of that?
        if a > middle:
            return b - a
        elif a < middle:
            return a - b
        return c

    for _ in range(m):
        sheet = int(input().strip()) * 2
        best_i = -1
        best_value = -1
        for i in range(n):
            if (i == 0 or xs[i - 1] <= sheet) and (i == n - 1 or sheet <= xs[i + 1]):
                tmp_value = value(xs[i], sheet)
                if tmp_value > best_value:
                    best_value = tmp_value
                    best_i = i
        xs[best_i] = sheet
        print(best_i + 1, flush=True)
        if not any(x == middle for x in xs):
            break


if __name__ == '__main__':
    main()
","['binary search', 'constructive algorithms', 'implementation', 'interactive']"
2867,"Now it's time of Olympiads. Vanya and Egor decided to make his own team to take part in a programming Olympiad. They've been best friends ever since primary school and hopefully, that can somehow help them in teamwork.For each team Olympiad, Vanya takes his play cards with numbers. He takes only the cards containing numbers 1 and 0. The boys are very superstitious. They think that they can do well at the Olympiad if they begin with laying all the cards in a row so that:  there wouldn't be a pair of any side-adjacent cards with zeroes in a row;  there wouldn't be a group of three consecutive cards containing numbers one. Today Vanya brought n cards with zeroes and m cards with numbers one. The number of cards was so much that the friends do not know how to put all those cards in the described way. Help them find the required arrangement of the cards or else tell the guys that it is impossible to arrange cards in such a way. nan from math import ceil
zeros, ones = map(int, input().strip().split())
if zeros > ones+1 or ones > 2*zeros + 2:
	print(-1)
else:
	if ones == zeros-1:
		ans = '0' + '10'*ones
		print(ans)
	elif ones <= 2*zeros:
		diff = ones-zeros
		ans = '110'*diff + '10'*(zeros-diff)
		print(ans)
	else:
		diff = ones - 2*zeros
		ans = '110'*zeros + '1'*diff
		print(ans)","['constructive algorithms', 'greedy', 'implementation']"
387,"A rooted tree is a non-directed connected graph without any cycles with a distinguished vertex, which is called the tree root. Consider the vertices of a rooted tree, that consists of n vertices, numbered from 1 to n. In this problem the tree root is the vertex number 1.Let's represent the length of the shortest by the number of edges path in the tree between vertices v and u as d(v, u).A parent of vertex v in the rooted tree with the root in vertex r (v ≠ r) is vertex pv, such that d(r, pv) + 1 = d(r, v) and d(pv, v) = 1. For example, on the picture the parent of vertex v = 5 is vertex p5 = 2.One day Polycarpus came across a rooted tree, consisting of n vertices. The tree wasn't exactly ordinary: it had strings written on its edges. Polycarpus positioned the tree on the plane so as to make all edges lead from top to bottom if you go from the vertex parent to the vertex (see the picture). For any edge that lead from vertex pv to vertex v (1 &lt; v ≤ n), he knows string sv that is written on it. All strings are written on the edges from top to bottom. For example, on the picture s7=""ba"". The characters in the strings are numbered starting from 0.    An example of Polycarpus's tree (corresponds to the example from the statement) Polycarpus defines the position in this tree as a specific letter on a specific string. The position is written as a pair of integers (v, x) that means that the position is the x-th letter of the string sv (1 &lt; v ≤ n, 0 ≤ x &lt; |sv|), where |sv| is the length of string sv. For example, the highlighted letters are positions (2, 1) and (3, 1).Let's consider the pair of positions (v, x) and (u, y) in Polycarpus' tree, such that the way from the first position to the second goes down on each step. We will consider that the pair of such positions defines string z. String z consists of all letters on the way from (v, x) to (u, y), written in the order of this path. For example, in the picture the highlighted positions define string ""bacaba"".Polycarpus has a string t, he wants to know the number of pairs of positions that define string t. Note that the way from the first position to the second in the pair must go down everywhere. Help him with this challenging tree-string problem! NoteIn the first test case string ""aba"" is determined by the pairs of positions: (2, 0) and (5, 0); (5, 2) and (6, 1); (5, 2) and (3, 1); (4, 0) and (4, 2); (4, 4) and (4, 6); (3, 3) and (3, 5).Note that the string is not defined by the pair of positions (7, 1) and (5, 0), as the way between them doesn't always go down. from sys import stdin
from collections import defaultdict
def ff(s):
    f = [0, 0]
    for i, c in enumerate(s[1:], 1):
        j = f[i]
        while s[j] != c:
            if not j:
                f.append(0)
                break
            j = f[j]
        else:
            f.append(j+1)
    alphas = ''.join(chr(ord('a') + c) for c in xrange(26))
    ret = [{c: 0 for c in alphas}]
    ret[0][s[0]] = 1
    for i, c in enumerate(s[1:], 1):
        d = {a: [ret[f[i]][a], i+1][c == a] for a in alphas}
        ret.append(d)
    ret.append({c: ret[f[-1]][c] for c in alphas})
    return ret
def main():
    RL = stdin.readline
    n = int(RL())
    G = defaultdict(list)
    edge_str = ['', '']
    for i in xrange(2, n+1):
        p, t = RL().split()
        G[int(p)].append(i)
        edge_str.append(t)
    ptr = RL().strip()
    ptrl = len(ptr)
    f = ff(ptr)
    stack = [(1, 0)]
    ans = 0
    pp, pu = stack.pop, stack.append
    while stack:
        v, j = pp()
        for c in edge_str[v]:
            j = f[j][c]
            if j == ptrl:
                ans = ans + 1
        for x in G[v]:
            pu((x, j))
    print ans
main()
","['dfs and similar', 'hashing', 'other', 'strings']"
705,"You are an adventurer currently journeying inside an evil temple. After defeating a couple of weak zombies, you arrived at a square room consisting of tiles forming an n × n grid. The rows are numbered 1 through n from top to bottom, and the columns are numbered 1 through n from left to right. At the far side of the room lies a door locked with evil magical forces. The following inscriptions are written on the door: The cleaning of all evil will awaken the door! Being a very senior adventurer, you immediately realize what this means. You notice that every single cell in the grid are initially evil. You should purify all of these cells.The only method of tile purification known to you is by casting the ""Purification"" spell. You cast this spell on a single tile — then, all cells that are located in the same row and all cells that are located in the same column as the selected tile become purified (including the selected tile)! It is allowed to purify a cell more than once.You would like to purify all n × n cells while minimizing the number of times you cast the ""Purification"" spell. This sounds very easy, but you just noticed that some tiles are particularly more evil than the other tiles. You cannot cast the ""Purification"" spell on those particularly more evil tiles, not even after they have been purified. They can still be purified if a cell sharing the same row or the same column gets selected by the ""Purification"" spell.Please find some way to purify all the cells with the minimum number of spells cast. Print -1 if there is no such way. NoteThe first example is illustrated as follows. Purple tiles are evil tiles that have not yet been purified. Red tile is the tile on which ""Purification"" is cast. Yellow tiles are the tiles being purified as a result of the current ""Purification"" spell. Green tiles are tiles that have been purified previously.   In the second example, it is impossible to purify the cell located at row 1 and column 1.For the third example:   n = int(input())
l = []
for _ in range(n):
    l.append([x for x in input()])

results = []
thing = True
for i in range(n):
    hit = False
    for j in range(n):
        if l[i][j] != ""E"":
            results.append(f""{i + 1} {j + 1}"")
            hit = True
            break
    if not hit:
        thing = False
        break
if not thing:
    results = []
    thing = True
    for j in range(n):
        hit = False
        for i in range(n):
            if l[i][j] != ""E"":
                results.append(f""{i + 1} {j + 1}"")
                hit = True
                break
        if not hit:
            thing = False
            break

if thing:
    for r in results:
        print(r)
else:
    print(-1)
","['constructive algorithms', 'greedy']"
33,"You are given a range of positive integers from $$$l$$$ to $$$r$$$.Find such a pair of integers $$$(x, y)$$$ that $$$l \le x, y \le r$$$, $$$x \ne y$$$ and $$$x$$$ divides $$$y$$$.If there are multiple answers, print any of them.You are also asked to answer $$$T$$$ independent queries. nan t=int(input())
for _ in range(t):
    l,r=map(int,input().split())
    print(l,l*2)","['greedy', 'implementation', 'math']"
2722,"You are given four integers $$$a$$$, $$$b$$$, $$$x$$$ and $$$y$$$. Initially, $$$a \ge x$$$ and $$$b \ge y$$$. You can do the following operation no more than $$$n$$$ times:  Choose either $$$a$$$ or $$$b$$$ and decrease it by one. However, as a result of this operation, value of $$$a$$$ cannot become less than $$$x$$$, and value of $$$b$$$ cannot become less than $$$y$$$. Your task is to find the minimum possible product of $$$a$$$ and $$$b$$$ ($$$a \cdot b$$$) you can achieve by applying the given operation no more than $$$n$$$ times.You have to answer $$$t$$$ independent test cases. NoteIn the first test case of the example, you need to decrease $$$b$$$ three times and obtain $$$10 \cdot 7 = 70$$$.In the second test case of the example, you need to decrease $$$a$$$ one time, $$$b$$$ one time and obtain $$$11 \cdot 7 = 77$$$.In the sixth test case of the example, you need to decrease $$$a$$$ five times and obtain $$$5 \cdot 11 = 55$$$.In the seventh test case of the example, you need to decrease $$$b$$$ ten times and obtain $$$10 \cdot 1 = 10$$$. # cook your dish here
t=int(input())
for tt in range (t):
    a,b,x,y,n=map(int,input().split())
    c=a-x
    d=b-y
    if n>=(c+d):
        print(x*y)
        continue
    if (x==1 and n>=c):
        print(b-(n-c))
        continue
    if (y==1 and n>=d):
        print(a-(n-d))
        continue
    c=a-x
    d=b-y
    if n>=c:
        i=x*(b-(n-c))
    else:
        i=(a-n)*b
    if n>=d:
        j=y*(a-(n-d))
    else:
        j=(b-n)*a
    print(min(i,j))
        ","['brute force', 'greedy', 'math']"
4513,"You are given a matrix $$$a$$$, consisting of $$$n$$$ rows and $$$m$$$ columns. Each cell contains an integer in it.You can change the order of rows arbitrarily (including leaving the initial order), but you can't change the order of cells in a row. After you pick some order of rows, you traverse the whole matrix the following way: firstly visit all cells of the first column from the top row to the bottom one, then the same for the second column and so on. During the traversal you write down the sequence of the numbers on the cells in the same order you visited them. Let that sequence be $$$s_1, s_2, \dots, s_{nm}$$$. The traversal is $$$k$$$-acceptable if for all $$$i$$$ ($$$1 \le i \le nm - 1$$$) $$$|s_i - s_{i + 1}| \ge k$$$.Find the maximum integer $$$k$$$ such that there exists some order of rows of matrix $$$a$$$ that it produces a $$$k$$$-acceptable traversal. NoteIn the first example you can rearrange rows as following to get the $$$5$$$-acceptable traversal:5 310 84 39 9Then the sequence $$$s$$$ will be $$$[5, 10, 4, 9, 3, 8, 3, 9]$$$. Each pair of neighbouring elements have at least $$$k = 5$$$ difference between them.In the second example the maximum $$$k = 0$$$, any order is $$$0$$$-acceptable.In the third example the given order is already $$$3$$$-acceptable, you can leave it as it is. import sys
from array import array  # noqa: F401
from typing import List, Tuple, TypeVar, Generic, Sequence, Union  # noqa: F401


def input():
    return sys.stdin.buffer.readline().decode('utf-8')


def solve(i, n, delta, delta2):
    inf = 2 * 10**9
    dp = [[-1] * n for _ in range(1 << n)]
    dp[(1 << i)][i] = inf
    stack = [(1 << i, i)]

    for t in range(1, n + 1):
        next_s = []
        for bit, v in stack:
            for dest in range(n):
                if (1 << dest) & bit:
                    continue
                if dp[bit | (1 << dest)][dest] == -1:
                    next_s.append((bit | (1 << dest), dest))
                dp[bit | (1 << dest)][dest] = max(dp[bit | (1 << dest)][dest], min(dp[bit][v], delta[v][dest]))

        stack = next_s

    return max(min(delta2[j][i], dp[-1][j]) for j in range(n) if i != j)


def main():
    n, m = map(int, input().split())
    matrix = [tuple(map(int, input().split())) for _ in range(n)]

    if n == 1:
        print(min(abs(x - y) for x, y in zip(matrix[0], matrix[0][1:])))
        exit()

    delta = [[0] * n for _ in range(n)]
    for i in range(n):
        for j in range(i + 1, n):
            delta[i][j] = delta[j][i] = min(abs(x - y) for x, y in zip(matrix[i], matrix[j]))
    delta2 = [[0] * n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            delta2[i][j] = min((abs(x - y) for x, y in zip(matrix[i], matrix[j][1:])), default=2 * 10**9)

    print(max(solve(i, n, delta, delta2) for i in range(n)))


if __name__ == '__main__':
    main()
","['binary search', 'bitmasks', 'brute force', 'dp', 'graphs']"
3557,"Little Artem has invented a time machine! He could go anywhere in time, but all his thoughts of course are with computer science. He wants to apply this time machine to a well-known data structure: multiset.Artem wants to create a basic multiset of integers. He wants these structure to support operations of three types:  Add integer to the multiset. Note that the difference between set and multiset is that multiset may store several instances of one integer.  Remove integer from the multiset. Only one instance of this integer is removed. Artem doesn't want to handle any exceptions, so he assumes that every time remove operation is called, that integer is presented in the multiset.  Count the number of instances of the given integer that are stored in the multiset. But what about time machine? Artem doesn't simply apply operations to the multiset one by one, he now travels to different moments of time and apply his operation there. Consider the following example.  First Artem adds integer 5 to the multiset at the 1-st moment of time.  Then Artem adds integer 3 to the multiset at the moment 5.  Then Artem asks how many 5 are there in the multiset at moment 6. The answer is 1.  Then Artem returns back in time and asks how many integers 3 are there in the set at moment 4. Since 3 was added only at moment 5, the number of integers 3 at moment 4 equals to 0.  Then Artem goes back in time again and removes 5 from the multiset at moment 3.  Finally Artyom asks at moment 7 how many integers 5 are there in the set. The result is 0, since we have removed 5 at the moment 3. Note that Artem dislikes exceptions so much that he assures that after each change he makes all delete operations are applied only to element that is present in the multiset. The answer to the query of the third type is computed at the moment Artem makes the corresponding query and are not affected in any way by future changes he makes.Help Artem implement time travellers multiset. nan from bisect import *
u, v = {}, {}
for q in range(int(input())):
    a, t, x = map(int, input().split())
    if x not in u: u[x], v[x] = [], []
    if a < 3: insort([v, u][-a][x], t)
    else: print(bisect(u[x], t) - bisect(v[x], t))",['data structures']
2784,"You are given a matrix, consisting of $$$n$$$ rows and $$$m$$$ columns. The $$$j$$$-th cell of the $$$i$$$-th row contains an integer $$$a_{ij}$$$.First, you have to color each row of the matrix either red or blue in such a way that at least one row is colored red and at least one row is colored blue.Then, you have to choose an integer $$$k$$$ ($$$1 \le k &lt; m$$$) and cut the colored matrix in such a way that the first $$$k$$$ columns become a separate matrix (the left matrix) and the last $$$m-k$$$ columns become a separate matrix (the right matrix).The coloring and the cut are called perfect if two properties hold:   every red cell in the left matrix contains an integer greater than every blue cell in the left matrix;  every blue cell in the right matrix contains an integer greater than every red cell in the right matrix. Find any perfect coloring and cut, or report that there are none. NoteThe coloring and the cut for the first testcase:   import io,os
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
 

def main(t):
 
    inf = 2147483647
    m,n = map(int,input().split())
    matrix = []
    for _ in range(m):
        matrix.append( tuple(map(int,input().split()))  )
 
    maxleft = [[0 for j in range(n+1)] for i in range(m)]
    maxright = [[0 for j in range(n+1)] for i in range(m)]
    minleft = [[inf for j in range(n+1)] for i in range(m)]
    minright = [[inf for j in range(n+1)] for i in range(m)]
    for i in range(m):
        for j in range(n):
            maxleft[i][j] = max(maxleft[i][j-1],matrix[i][j])
            minleft[i][j] = min(minleft[i][j-1],matrix[i][j])
        for j in range(n-1,-1,-1):
            maxright[i][j] = max(maxright[i][j+1],matrix[i][j])
            minright[i][j] = min(minright[i][j+1],matrix[i][j])
 
 
    ans = ['B']*m
    for j in range(n-1):
        minleft_index = [i for i in range(m)]
        minleft_index.sort(key=lambda i:-minleft[i][j])
        currright = [maxright[i][j+1] for i in minleft_index]
        for i in range(1,m):  currright[i] = max(currright[i-1],currright[i])
        leftmaximum = -inf
        rightminimum = inf
        for i in range(m-1,0,-1):
            front,rear = minleft_index[i-1],minleft_index[i]
            leftmaximum = max(leftmaximum, maxleft[rear][j] )
            rightminimum = min(rightminimum, minright[rear][j+1]  )
            if minleft[front][j] > leftmaximum and currright[i-1] < rightminimum:
                print(""YES"")
                for k in range(i):   ans[minleft_index[k]] = 'R'
                print("""".join(ans), j+1 )
                return 
    print(""NO"")        
 
 
 
T = int(input())
t = 1
while t<=T:
    main(t)
    t += 1
","['brute force', 'constructive algorithms', 'implementation', 'sortings']"
4635,"Ashish has a tree consisting of $$$n$$$ nodes numbered $$$1$$$ to $$$n$$$ rooted at node $$$1$$$. The $$$i$$$-th node in the tree has a cost $$$a_i$$$, and binary digit $$$b_i$$$ is written in it. He wants to have binary digit $$$c_i$$$ written in the $$$i$$$-th node in the end.To achieve this, he can perform the following operation any number of times:   Select any $$$k$$$ nodes from the subtree of any node $$$u$$$, and shuffle the digits in these nodes as he wishes, incurring a cost of $$$k \cdot a_u$$$. Here, he can choose $$$k$$$ ranging from $$$1$$$ to the size of the subtree of $$$u$$$. He wants to perform the operations in such a way that every node finally has the digit corresponding to its target.Help him find the minimum total cost he needs to spend so that after all the operations, every node $$$u$$$ has digit $$$c_u$$$ written in it, or determine that it is impossible. NoteThe tree corresponding to samples $$$1$$$ and $$$2$$$ are: In sample $$$1$$$, we can choose node $$$1$$$ and $$$k = 4$$$ for a cost of $$$4 \cdot 1$$$ = $$$4$$$ and select nodes $$${1, 2, 3, 5}$$$, shuffle their digits and get the desired digits in every node.In sample $$$2$$$, we can choose node $$$1$$$ and $$$k = 2$$$ for a cost of $$$10000 \cdot 2$$$, select nodes $$${1, 5}$$$ and exchange their digits, and similarly, choose node $$$2$$$ and $$$k = 2$$$ for a cost of $$$2000 \cdot 2$$$, select nodes $$${2, 3}$$$ and exchange their digits to get the desired digits in every node.In sample $$$3$$$, it is impossible to get the desired digits, because there is no node with digit $$$1$$$ initially. """""" Python 3 compatibility tools. """"""
from __future__ import division, print_function
import itertools
import sys, threading
import os
from io import BytesIO, IOBase
from types import GeneratorType

def is_it_local():
  script_dir = str(os.getcwd()).split('/')
  username = ""dipta007""
  return username in script_dir


def READ(fileName):
  if is_it_local():
    sys.stdin = open(f'./{fileName}', 'r')

# region fastio
BUFSIZE = 8192

class FastIO(IOBase):
  newlines = 0

  def __init__(self, file):
    self._fd = file.fileno()
    self.buffer = BytesIO()
    self.writable = ""x"" in file.mode or ""r"" not in file.mode
    self.write = self.buffer.write if self.writable else None

  def read(self):
    while True:
      b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
      if not b:
          break
      ptr = self.buffer.tell()
      self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
    self.newlines = 0
    return self.buffer.read()

  def readline(self):
    while self.newlines == 0:
      b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
      self.newlines = b.count(b""\n"") + (not b)
      ptr = self.buffer.tell()
      self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
    self.newlines -= 1
    return self.buffer.readline()

  def flush(self):
    if self.writable:
      os.write(self._fd, self.buffer.getvalue())
      self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
  def __init__(self, file):
    self.buffer = FastIO(file)
    self.flush = self.buffer.flush
    self.writable = self.buffer.writable
    self.write = lambda s: self.buffer.write(s.encode(""ascii""))
    self.read = lambda: self.buffer.read().decode(""ascii"")
    self.readline = lambda: self.buffer.readline().decode(""ascii"")

if not is_it_local():
  sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
  input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# endregion


def input1(type=int):
  return type(input())


def input2(type=int):
  [a, b] = list(map(type, input().split()))
  return a, b


def input3(type=int):
  [a, b, c] = list(map(type, input().split()))
  return a, b, c


def input_array(type=int):
  return list(map(type, input().split()))


def input_string():
  s = input()
  return list(s)

##############################################################

adj = {}
label = []
target = []
cost = []
data = []

def merge(a, b):
  # node number, zero number, one number, correct, need zero, need one
  tmp = [a[0] + b[0], a[1] + b[1], a[2] + b[2], a[3] + b[3], a[4] + b[4], a[5] + b[5]]
  return tmp

def bootstrap(f, stack=[]):
  def wrappedfunc(*args, **kwargs):
    to = f(*args, **kwargs)
    if stack:
      return to
    else:
      while True:
        if type(to) is GeneratorType:
          stack.append(to)
          to = next(to)
        else:
          stack.pop()
          if not stack:
              return to
          to = stack[-1].send(to)
  return wrappedfunc

@bootstrap
def dfs1(u, p):
  global data, label, target, adj, cost
  now = [
    1, 
    1 if label[u] == 0 and label[u] != target[u] else 0, 
    1 if label[u] == 1 and label[u] != target[u] else 0, 
    1 if label[u] == target[u] else 0, 
    1 if target[u] == 0 and label[u] != target[u] else 0, 
    1 if target[u] == 1 and label[u] != target[u] else 0
  ]

  if p != -1:
    cost[u] = min(cost[u], cost[p])

  if u in adj:
    for v in adj[u]:
      if v != p:
        tmp = yield dfs1(v, u)
        now = merge(now, tmp)

  data[u] = now
  yield now


res = 0

@bootstrap
def call(u, p):
  global data, label, target, adj, cost, res
  
  f_0, f_1 = 0, 0
  if u in adj:
    for v in adj[u]:
      if v != p:
        n_0, n_1 = yield call(v, u)
        f_0 += n_0
        f_1 += n_1

  now = data[u]
  can_be_fixed_zero = min(now[4], now[1]) - f_0
  can_be_fixed_one = min(now[5], now[2]) - f_1
  not_fixed = can_be_fixed_zero + can_be_fixed_one
  res += not_fixed * cost[u]

  yield f_0 + can_be_fixed_zero, f_1 + can_be_fixed_one

def main():
  global data, label, target, adj, cost
  n = input1()
  data = [0 for _ in range(n+4)]
  label = [0 for _ in range(n+4)]
  target = [0 for _ in range(n+4)]
  cost = [0 for _ in range(n+4)]

  z, o, tz, to = 0, 0, 0, 0
  for i in range(1, n+1):
    cost[i], label[i], target[i] = input3()
    z += (label[i] == 0)
    o += (label[i] == 1)

    tz += (target[i] == 0)
    to += (target[i] == 1)
  
  adj = {}
  for i in range(n-1):
    u, v = input2()
    if u not in adj:
      adj[u] = []
    if v not in adj:
      adj[v] = []

    adj[u].append(v)
    adj[v].append(u)


  if (tz != z or o != to):
    print(-1)
    exit()
  dfs1(1, -1)

  # for i in range(1, n+1):
  #   print(data[i], cost[i])

  global res
  res = 0
  call(1, -1)
  print(res)
  pass

if __name__ == '__main__':
  # sys.setrecursionlimit(2**32//2-1)
  # threading.stack_size(1 << 27)

  # thread = threading.Thread(target=main)
  # thread.start()
  # thread.join()
  # sys.setrecursionlimit(200004)
  # READ('in.txt')
  main()","['dfs and similar', 'dp', 'greedy', 'trees']"
915,"Once Bob got to a sale of old TV sets. There were n TV sets at that sale. TV set with index i costs ai bellars. Some TV sets have a negative price — their owners are ready to pay Bob if he buys their useless apparatus. Bob can «buy» any TV sets he wants. Though he's very strong, Bob can carry at most m TV sets, and he has no desire to go to the sale for the second time. Please, help Bob find out the maximum sum of money that he can earn. nan k=raw_input()
n,m=map(int,k.split("" ""))
price=raw_input()
arr=[int(x) for x in price.split("" "")]
earned=0
carry=0
while carry<m:
    if min(arr)<0:
        earned-=min(arr)
        arr[arr.index(min(arr))]=0
        carry+=1
    else:
        break
print earned
","['greedy', 'sortings']"
3197,"Max wants to buy a new skateboard. He has calculated the amount of money that is needed to buy a new skateboard. He left a calculator on the floor and went to ask some money from his parents. Meanwhile his little brother Yusuf came and started to press the keys randomly. Unfortunately Max has forgotten the number which he had calculated. The only thing he knows is that the number is divisible by 4.You are given a string s consisting of digits (the number on the display of the calculator after Yusuf randomly pressed the keys). Your task is to find the number of substrings which are divisible by 4. A substring can start with a zero.A substring of a string is a nonempty sequence of consecutive characters.For example if string s is 124 then we have four substrings that are divisible by 4: 12, 4, 24 and 124. For the string 04 the answer is three: 0, 4, 04.As input/output can reach huge size it is recommended to use fast input/output methods: for example, prefer to use gets/scanf/printf instead of getline/cin/cout in C++, prefer to use BufferedReader/PrintWriter instead of Scanner/System.out in Java. nan def main():
  a=input()
  a=list(a)
  summ=0
  for i in range(len(a)):
    if int(a[i])%4==0:
      summ+=1
    if i!=0 and int(''.join(k for k in a[i-1:i+1]))%4==0:
      summ+=i
  return summ

print(main())",['dp']
4331,"This is the hard version of the problem. The only difference is that in this version $$$0 \leq k \leq 20$$$.There is an array $$$a_1, a_2, \ldots, a_n$$$ of $$$n$$$ positive integers. You should divide it into a minimal number of continuous segments, such that in each segment there are no two numbers (on different positions), whose product is a perfect square.Moreover, it is allowed to do at most $$$k$$$ such operations before the division: choose a number in the array and change its value to any positive integer.What is the minimum number of continuous segments you should use if you will make changes optimally? NoteIn the first test case it is possible to change the array this way: $$$[\underline{3}, 6, 2, 4, \underline{5}]$$$ (changed elements are underlined). After that the array does not need to be divided, so the answer is $$$1$$$.In the second test case it is possible to change the array this way: $$$[6, 2, \underline{3}, 8, 9, \underline{5}, 3, 6, \underline{10}, \underline{11}, 7]$$$. After that such division is optimal:   $$$[6, 2, 3]$$$  $$$[8, 9, 5, 3, 6, 10, 11, 7]$$$  import os
import io
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline 
 
from math import sqrt,ceil
 
max_n=10**7+1
spf = [i for i in range(max_n)]
 
for i in range(4,max_n,2): 
    spf[i]=2
    
for i in range(3,ceil(sqrt(max_n))): 
    if (spf[i]==i):  
        for j in range(i*i,max_n,i):  
            if(spf[j]==j):
                spf[j]=i
                
from collections import Counter,defaultdict
from bisect import insort
 
def f(x):
    c=Counter()
    ans=1
    while(x!=1):
        c[spf[x]]+=1
        x//=spf[x] 
    for i in c:
        if(c[i]%2==1):
            ans*=i
    return(ans)
 
#https://www.geeksforgeeks.org/prime-factorization-using-sieve-olog-n-multiple-queries/
 
t=int(input())
for _ in range(t):
    n,k=map(int,input().split())
    a=list(map(int,input().split()))
    for i in range(n):
        a[i]=f(a[i])
    dp_depth=[[n for j in range(k+1)] for i in range(n)] #Maximum length that can be tranversed in list, starting from index i with atmost j repeated elements(default is entire length of list(max possible)
    recent=[n for i in range(k+1)] #Stores position of most recent repeated element in the suffix(default is one more that maximum index(when no sufficient repeats))
    closest=defaultdict(lambda: -1) #Stores index of first repetition for a particular ai 
    for i in range(n-1,-1,-1):
        if(closest[a[i]]>=0):
            insort(recent,closest[a[i]])
            recent.pop()
        dp_depth[i]=recent.copy()
        closest[a[i]]=i 
    dp=[[i for j in range(k+1)] for i in range(n+1)]
    #dp=[[float('inf') for j in range(k+1)] for i in range(n+1)] #Minimum number of sets in the prefix segment upto(and **excluding**) index i after atmost k changes(which is also = number of partitions/splits(number of element changes) upto and **excluding** index i).
    #Note we could have changed the float('inf') to ""i"" but that's tougher to debug.
    dp[0]=[0 for j in range(k+1)] #base case(don't need to divide at all before element at index 0(first element))
    for i in range(n):
        for x in range(k+1): 
            end=dp_depth[i][x] #The end point of our segment(upto and exluding this index position)
            #We are dividing each segment into subsegments: prefix consisting of [0,i), suffix consisting from [i,end)
            #x is the number of partitions/splits(number of elements we change) in the suffix subsegment(Number of repeated elements starting from index i)
            for y in range(k-x+1): #y is the number of partitions/splits(number of elements we change) in the prefix subsegment
                dp[end][x+y]=min(dp[end][x+y],dp[i][y]+1) #after using the previously calculated value dp[i][y](<=y changes), with <= x more ""changes""(equality holds iff end=n) in the suffix segment, this gives an extra set starting from [i,end). So overall, we get number of sets of dp[i][y]+1.
    print(dp[n][k])
                
                
            

","['data structures', 'dp', 'greedy', 'math', 'number theory', 'two pointers']"
2650,"This is an interactive problem.Note: the XOR-sum of an array $$$a_1, a_2, \ldots, a_n$$$ ($$$1 \le a_i \le 10^9$$$) is defined as $$$a_1 \oplus a_2 \oplus \ldots \oplus a_n$$$, where $$$\oplus$$$ denotes the bitwise XOR operation.Little Dormi received an array of $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ for Christmas. However, while playing with it over the winter break, he accidentally dropped it into his XOR machine, and the array got lost.The XOR machine is currently configured with a query size of $$$k$$$ (which you cannot change), and allows you to perform the following type of query: by giving the machine $$$k$$$ distinct indices $$$x_1, x_2, \ldots, x_k$$$, it will output $$$a_{x_1} \oplus a_{x_2} \oplus \ldots \oplus a_{x_k}$$$.As Little Dormi's older brother, you would like to help him recover the XOR-sum of his array $$$a_1, a_2, \ldots, a_n$$$ by querying the XOR machine.Little Dormi isn't very patient, so to be as fast as possible, you must query the XOR machine the minimum number of times to find the XOR-sum of his array. Formally, let $$$d$$$ be the minimum number of queries needed to find the XOR-sum of any array of length $$$n$$$ with a query size of $$$k$$$. Your program will be accepted if you find the correct XOR-sum in at most $$$d$$$ queries.Lastly, you also noticed that with certain configurations of the machine $$$k$$$ and values of $$$n$$$, it may not be possible to recover the XOR-sum of Little Dormi's lost array. If that is the case, you should report it as well.The array $$$a_1, a_2, \ldots, a_n$$$ is fixed before you start querying the XOR machine and does not change with the queries. NoteIn the first example interaction, the array $$$a_1, a_2, \ldots, a_n$$$ is $$$2, 1, 7, 5, 6$$$ and its XOR-sum is $$$7$$$. The first query made asks for indices $$$1,2,3$$$, so the response is $$$a_1 \oplus a_2 \oplus a_3 = 2 \oplus 1 \oplus 7 = 4$$$.The second query made asks for indices $$$2,3,5$$$, so the response is $$$a_2 \oplus a_3 \oplus a_5 = 1 \oplus 7 \oplus 6 = 0$$$.The third query made asks for indices $$$4,1,5$$$, so the response is $$$a_4 \oplus a_1 \oplus a_5 = 5 \oplus 2 \oplus 6 = 1$$$. Note that the indices may be output in any order.Additionally, even though three queries were made in the example interaction, it is just meant to demonstrate the interaction format and does not necessarily represent an optimal strategy.In the second example interaction, there is no way to recover the XOR-sum of Little Dormi's array no matter what is queried, so the program immediately outputs $$$-1$$$ and exits. from collections import deque

n, k = map(int,input().split())
if k%2==0 and n%2==1:
    print(-1)
    exit()



queue = deque()
visited = [ False for i in range(n)]
pre = [-1]*n


def getarr(add,front,rear,k,n):

    nextrear = rear + (add + k)//2
    nextfront = front + (k - add)//2
    arr = [(i-1)%n + 1 for i in range(front,nextfront)] + [(i-1)%n + 1 for i in range(rear+1,nextrear+1)]
    return [nextfront,nextrear,arr]

    
    
    
    
        






visited[k-1] = True
queue.append(k-1)

while queue:
#    print(queue)
    d = queue.popleft()

    for diff in range(k,-k-1,-2):
        front = (k + diff)//2
        rear = (k-diff)//2
        if d + front >= n:  continue 
        if rear > d + 1: continue 
        if d + diff < 0 or d + diff >=n: continue 
        if visited[d+diff]: continue 
 

        queue.append(diff+d)
        visited[diff+d] = True
        pre[diff+d] = d
        
        



stack = []
index = n -1
while True:
    stack.append(index)
    if pre[index]==-1: break
    else:  index = pre[index]
stack.append(-1)
stack = stack[::-1]


#print(stack)
front,rear = 1,0
    
ans = 0     
for i in range(len(stack)-1):
    [front,rear,arr] = getarr(stack[i+1]-stack[i],front,rear,k,n)
#    print(front,rear)
    print(""? ""+"" "".join(map(str,arr))  )
    temp = int(input())
    ans = ans ^ temp

print(""! ""+str(ans))
         


        
        

        

","['graphs', 'greedy', 'interactive', 'shortest paths']"
829,"General Payne has a battalion of n soldiers. The soldiers' beauty contest is coming up, it will last for k days. Payne decided that his battalion will participate in the pageant. Now he has choose the participants.All soldiers in the battalion have different beauty that is represented by a positive integer. The value ai represents the beauty of the i-th soldier.On each of k days Generals has to send a detachment of soldiers to the pageant. The beauty of the detachment is the sum of the beauties of the soldiers, who are part of this detachment. Payne wants to surprise the jury of the beauty pageant, so each of k days the beauty of the sent detachment should be unique. In other words, all k beauties of the sent detachments must be distinct numbers.Help Payne choose k detachments of different beauties for the pageant. Please note that Payne cannot just forget to send soldiers on one day, that is, the detachment of soldiers he sends to the pageant should never be empty. nan #------------------------template--------------------------#
import os
import sys
from math import *
from collections import *
from fractions import *
from bisect import *
from heapq import*
from io import BytesIO, IOBase
def vsInput():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
ALPHA='abcdefghijklmnopqrstuvwxyz'
M=10**9+7
EPS=1e-6
def value():return tuple(map(int,input().split()))
def array():return [int(i) for i in input().split()]
def Int():return int(input())
def Str():return input()
def arrayS():return [i for i in input().split()]


#-------------------------code---------------------------#
# vsInput()

n,k=value()
a=sorted(array())

ma=set()
setNo=1

while(True):

    t=ma
    for i in a:
        if(k<setNo):exit()

        if(i not in t):
            print(len(ma)+1,*ma,i)
            setNo+=1
    key=-1
    for i in a:
        if(i not in ma):
            key=max(key,i)
    ma.add(key)










    








    




    




    













                

    









    
","['brute force', 'constructive algorithms', 'greedy']"
4569,"Polycarp was dismantling his attic and found an old floppy drive on it. A round disc was inserted into the drive with $$$n$$$ integers written on it.Polycarp wrote the numbers from the disk into the $$$a$$$ array. It turned out that the drive works according to the following algorithm:   the drive takes one positive number $$$x$$$ as input and puts a pointer to the first element of the $$$a$$$ array;  after that, the drive starts rotating the disk, every second moving the pointer to the next element, counting the sum of all the elements that have been under the pointer. Since the disk is round, in the $$$a$$$ array, the last element is again followed by the first one;  as soon as the sum is at least $$$x$$$, the drive will shut down. Polycarp wants to learn more about the operation of the drive, but he has absolutely no free time. So he asked you $$$m$$$ questions. To answer the $$$i$$$-th of them, you need to find how many seconds the drive will work if you give it $$$x_i$$$ as input. Please note that in some cases the drive can work infinitely.For example, if $$$n=3, m=3$$$, $$$a=[1, -3, 4]$$$ and $$$x=[1, 5, 2]$$$, then the answers to the questions are as follows:   the answer to the first query is $$$0$$$ because the drive initially points to the first item and the initial sum is $$$1$$$.  the answer to the second query is $$$6$$$, the drive will spin the disk completely twice and the amount becomes $$$1+(-3)+4+1+(-3)+4+1=5$$$.  the answer to the third query is $$$2$$$, the amount is $$$1+(-3)+4=2$$$.   nan import sys
from bisect import bisect_left
from itertools import accumulate
 
 
def solve(n, m, a, x):
    p = list(accumulate(a))
    s = p[-1]
    for i in range(1, n):
        p[i] = max(p[i], p[i-1])
 
    ans = list()
    for i in range(m):
        if s <= 0 and x[i] > p[-1]:
            ans.append(-1)
            continue
        elif s <= 0 or x[i] <= p[-1]:
            k = 0
        else:
            k = (x[i] - p[-1]) // s
            if (x[i] - p[-1]) % s > 0:
                k += 1
        x[i] -= k * s
        index = bisect_left(p, x[i])
        ans.append(k * n + index)
    return ans
 
 
def main(argv=None):
    t = int(input())
    for _ in range(t):
        n, m = map(int, input().split())
        a = list(map(int, input().split()))
        x = list(map(int, input().split()))
        print(' '.join(map(str, solve(n, m, a, x))))
    return 0
 
 
if __name__ == ""__main__"":
    STATUS = main()
    sys.exit(STATUS)
","['binary search', 'data structures', 'math']"
4293,"Dima has a hamsters farm. Soon N hamsters will grow up on it and Dima will sell them in a city nearby.Hamsters should be transported in boxes. If some box is not completely full, the hamsters in it are bored, that's why each box should be completely full with hamsters.Dima can buy boxes at a factory. The factory produces boxes of K kinds, boxes of the i-th kind can contain in themselves ai hamsters. Dima can buy any amount of boxes, but he should buy boxes of only one kind to get a wholesale discount.Of course, Dima would buy boxes in such a way that each box can be completely filled with hamsters and transported to the city. If there is no place for some hamsters, Dima will leave them on the farm.Find out how many boxes and of which type should Dima buy to transport maximum number of hamsters. nan # import sys
# sys.stdin = open('in.txt', 'r')

n, k = map(int, input().split())
a = list(map(int, input().split()))

res = 0
res_i = 0
for i in range(len(a)):
    if (n // a[i]) * a[i] > res:
        res = (n // a[i]) * a[i]
        res_i = i

print(res_i+1, n // a[res_i])
",['implementation']
2543,"Vova has won $$$n$$$ trophies in different competitions. Each trophy is either golden or silver. The trophies are arranged in a row.The beauty of the arrangement is the length of the longest subsegment consisting of golden trophies. Vova wants to swap two trophies (not necessarily adjacent ones) to make the arrangement as beautiful as possible — that means, to maximize the length of the longest such subsegment.Help Vova! Tell him the maximum possible beauty of the arrangement if he is allowed to do at most one swap. NoteIn the first example Vova has to swap trophies with indices $$$4$$$ and $$$10$$$. Thus he will obtain the sequence ""GGGGGGGSGS"", the length of the longest subsegment of golden trophies is $$$7$$$. In the second example Vova can make no swaps at all. The length of the longest subsegment of golden trophies in the sequence is $$$4$$$. In the third example Vova cannot do anything to make the length of the longest subsegment of golden trophies in the sequence greater than $$$0$$$. n = int(input())
a = input()
p = [[0, 0]]
pi = -1 #index p
per_l = 2 # расстояние до G
c = 0# счётчик изолированных групп G
c1 = 0# счётчик изол гр с 1 перемычкой
if a.count(""S"") <= 1:
	print(len(a) - a.count(""S""))
elif a.count(""G"") == 0:
	print(0)
else:
	for i in range(len(a)):
		if a[i] == ""G"" and per_l >= 2:
			c += 1
			pi += 1
			p[pi][0] = 1
			per_l = 0
			p.append([1, 0])
		elif a[i] == ""G"" and per_l == 1:
			c1 += 1
			pi += 1
			p[pi][1] = 1
			p[pi][0] += 1
			p.append([1, 1])
			per_l = 0
		elif a[i] == ""G"" and per_l == 0:
			p[pi][0] += 1
			p[pi+1][0] += 1
		else:
			per_l += 1
	max_l = max(p)
	if c + c1 == 1 or (c == 1 and c1 == 1):
		print(max_l[0])
	else:
		print(max_l[0] + 1)
",['greedy']
1876,"Let us denote by $$$d(n)$$$ the sum of all divisors of the number $$$n$$$, i.e. $$$d(n) = \sum\limits_{k | n} k$$$.For example, $$$d(1) = 1$$$, $$$d(4) = 1+2+4=7$$$, $$$d(6) = 1+2+3+6=12$$$.For a given number $$$c$$$, find the minimum $$$n$$$ such that $$$d(n) = c$$$. nan import sys
input = sys.stdin.readline
n=10**7
l=[0]+[1]*n
for i in range(2,n+1):
    j=i
    while(j<=n):
        l[j]+=i
        j+=i
l1=[-1]*(n+1)
for i in range(n,0,-1):
    if(l[i]<=n):
        l1[l[i]]=i
for w in range(int(input())):
    print(l1[int(input())])","['brute force', 'dp', 'math', 'number theory']"
1024,"PolandBall has an undirected simple graph consisting of n vertices. Unfortunately, it has no edges. The graph is very sad because of that. PolandBall wanted to make it happier, adding some red edges. Then, he will add white edges in every remaining place. Therefore, the final graph will be a clique in two colors: white and red. Colorfulness of the graph is a value min(dr, dw), where dr is the diameter of the red subgraph and dw is the diameter of white subgraph. The diameter of a graph is a largest value d such that shortest path between some pair of vertices in it is equal to d. If the graph is not connected, we consider its diameter to be -1.PolandBall wants the final graph to be as neat as possible. He wants the final colorfulness to be equal to k. Can you help him and find any graph which satisfies PolandBall's requests? NoteIn the first sample case, no graph can fulfill PolandBall's requirements.In the second sample case, red graph is a path from 1 to 5. Its diameter is 4. However, white graph has diameter 2, because it consists of edges 1-3, 1-4, 1-5, 2-4, 2-5, 3-5. n, k = map(int, input().split())

if n < 4:
    print(-1)
elif k == 1:
    print(-1)
elif k > 3:
    print(-1)
elif n == 4 and k == 2:
    print(-1)
elif k == 2:
    print(n - 1)
    for i in range(n - 1):
        print(i + 1, i + 2)
elif k == 3:
    print(n - 1)
    print(1, 2)
    print(2, 3)
    for i in range(4, n + 1):
        print(3, i)
","['constructive algorithms', 'graphs', 'shortest paths']"
596,"You are given a string $$$s$$$, consisting of brackets of two types: '(', ')', '[' and ']'.A string is called a regular bracket sequence (RBS) if it's of one of the following types:   empty string;  '(' + RBS + ')';  '[' + RBS + ']';  RBS + RBS. where plus is a concatenation of two strings.In one move you can choose a non-empty subsequence of the string $$$s$$$ (not necessarily consecutive) that is an RBS, remove it from the string and concatenate the remaining parts without changing the order.What is the maximum number of moves you can perform? NoteIn the first example you can just erase the whole string.In the second example you can first erase the brackets on positions $$$1$$$ and $$$2$$$: ""[]()"", then ""()"" is left. After that you can erase it whole. You could erase the whole string from the beginning but you would get one move instead of two.In the third example you can first erase the brackets on positions $$$1$$$ and $$$3$$$: ""([)]"". They form an RBS ""()"". Then ""[]"" is left, so you can erase it whole.In the fourth example there is no subsequence that is an RBS, so you can't perform a move at all.In the fifth example you can erase the brackets on positions $$$2$$$ and $$$4$$$: "")[(]"" and get "")("" as a result. You can erase nothing from it. import math

def solve(st):
    a, b, ans = 0, 0, 0

    for it in st:
        if it == '(':
            a+=1
        elif it == ')':
            if a>0:
                a-=1
                ans += 1
        elif it == '[':
            b+=1
        else:
            if b>0:
                b-=1
                ans += 1
    return ans

for case in range(int(input())):
    st = input()
    ans = solve(st)

    print(ans)
",['greedy']
1732,"Parsa has a humongous tree on $$$n$$$ vertices.On each vertex $$$v$$$ he has written two integers $$$l_v$$$ and $$$r_v$$$.To make Parsa's tree look even more majestic, Nima wants to assign a number $$$a_v$$$ ($$$l_v \le a_v \le r_v$$$) to each vertex $$$v$$$ such that the beauty of Parsa's tree is maximized.Nima's sense of the beauty is rather bizarre. He defines the beauty of the tree as the sum of $$$|a_u - a_v|$$$ over all edges $$$(u, v)$$$ of the tree.Since Parsa's tree is too large, Nima can't maximize its beauty on his own. Your task is to find the maximum possible beauty for Parsa's tree. NoteThe trees in the example:  In the first test case, one possible assignment is $$$a = \{1, 8\}$$$ which results in $$$|1 - 8| = 7$$$.In the second test case, one of the possible assignments is $$$a = \{1, 5, 9\}$$$ which results in a beauty of $$$|1 - 5| + |5 - 9| = 8$$$ import sys
sys.setrecursionlimit(10 ** 5)
input = sys.stdin.buffer.readline
def dfs(par, x):
    for u in g[x]:
        if u == par:
            continue
        dfs(x, u)
    dp[par][0] += max(abs(a[par][0] - a[x][0]) + dp[x][0], abs(a[par][0] - a[x][1]) + dp[x][1])
    dp[par][1] += max(abs(a[par][1] - a[x][0]) + dp[x][0], abs(a[par][1] - a[x][1]) + dp[x][1])
for _ in range(int(input())):
    n = int(input())
    g = [[] for _ in range(n)]
    a = []
    for _ in range(n):
        a.append(list(map(int, input().split())))
    for _ in range(n - 1):
        u, v = map(int, input().split())
        g[u - 1].append(v - 1)
        g[v - 1].append(u - 1)
    dp = [[0.0, 0.0] for _ in range(n)]



    for p in g[0]:
        dfs(0, p)
    print(int(max(dp[0][0], dp[0][1])))","['dfs and similar', 'dp', 'graphs', 'greedy', 'trees']"
3238,"There is an undirected, connected graph with $$$n$$$ vertices and $$$m$$$ weighted edges. A walk from vertex $$$u$$$ to vertex $$$v$$$ is defined as a sequence of vertices $$$p_1,p_2,\ldots,p_k$$$ (which are not necessarily distinct) starting with $$$u$$$ and ending with $$$v$$$, such that $$$p_i$$$ and $$$p_{i+1}$$$ are connected by an edge for $$$1 \leq i &lt; k$$$.We define the length of a walk as follows: take the ordered sequence of edges and write down the weights on each of them in an array. Now, write down the bitwise AND of every nonempty prefix of this array. The length of the walk is the MEX of all these values.More formally, let us have $$$[w_1,w_2,\ldots,w_{k-1}]$$$ where $$$w_i$$$ is the weight of the edge between $$$p_i$$$ and $$$p_{i+1}$$$. Then the length of the walk is given by $$$\mathrm{MEX}(\{w_1,\,w_1\&amp; w_2,\,\ldots,\,w_1\&amp; w_2\&amp; \ldots\&amp; w_{k-1}\})$$$, where $$$\&amp;$$$ denotes the bitwise AND operation.Now you must process $$$q$$$ queries of the form u v. For each query, find the minimum possible length of a walk from $$$u$$$ to $$$v$$$.The MEX (minimum excluded) of a set is the smallest non-negative integer that does not belong to the set. For instance:   The MEX of $$$\{2,1\}$$$ is $$$0$$$, because $$$0$$$ does not belong to the set.  The MEX of $$$\{3,1,0\}$$$ is $$$2$$$, because $$$0$$$ and $$$1$$$ belong to the set, but $$$2$$$ does not.  The MEX of $$$\{0,3,1,2\}$$$ is $$$4$$$ because $$$0$$$, $$$1$$$, $$$2$$$ and $$$3$$$ belong to the set, but $$$4$$$ does not.  NoteThe following is an explanation of the first example.    The graph in the first example. Here is one possible walk for the first query:$$$$$$1 \overset{5}{\rightarrow} 3 \overset{3}{\rightarrow} 2 \overset{1}{\rightarrow} 1 \overset{5}{\rightarrow} 3 \overset{1}{\rightarrow} 4 \overset{2}{\rightarrow} 5.$$$$$$The array of weights is $$$w=[5,3,1,5,1,2]$$$. Now if we take the bitwise AND of every prefix of this array, we get the set $$$\{5,1,0\}$$$. The MEX of this set is $$$2$$$. We cannot get a walk with a smaller length (as defined in the statement). import sys
import os
from io import BytesIO, IOBase

# region fastio
BUFSIZE = 8192
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

if sys.version_info[0] < 3:
    sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

file = sys.stdin
if os.environ.get('USER') == ""loic"":
    file = open(""data.in"")
    
line = lambda: file.readline().split()
ui = lambda: int(line()[0])
ti = lambda: map(int,line())
li = lambda: list(ti())

#######################################################################

class DSU:
    def __init__(self, limit):
        self.link = [-1]*limit
        self.sz = [1]*limit
        self.even = [False] * limit

    def find(self,u):
        root = u
        par = u
        while par != -1:
            root = par
            par = self.link[par]
         
        par = u
        while par != root:
            self.link[par] = root
            par = self.link[par]
              
        return root
    
    ''' return True if u and v were not in same group, false otherwise '''
    def union(self,u,v):
        root_u = self.find(u)
        root_v = self.find(v)
        if root_u == root_v:
            return False
        rank_u = self.sz[root_u]
        rank_v = self.sz[root_v]
        if rank_u < rank_v:
            self.link[root_u] = root_v
            self.sz[root_v] += self.sz[root_u]
        else:
            self.link[root_v] = root_u
            self.sz[root_u] += self.sz[root_v]
        return True
    
    ''' return size of the component containing u '''
    def size(self,u):
        return self.sz[self.find(u)]

def solve():
    
    dsu_zero = [DSU(N) for _ in range(30)]
    dsu_one = [DSU(N) for _ in range(30)]
    
    for j in range(30):
        zero = dsu_zero[j]
        one = dsu_one[j]
        for u,v,w in E:
            if w >> j & 1:
                zero.union(u,v)
                if j > 0 and w & 1:
                    one.union(u,v)
    
    even = [False] * N
    for u,v,w in E:
        if not w & 1:
            even[u] = True
            even[v] = True

    link = [False] * N
    for j in range(1,30):
        dsu = dsu_one[j]
        for u,v,w in E:
            if not w & 1:
                root_u = dsu.find(u)
                dsu.even[root_u] = True
                root_v = dsu.find(v)
                dsu.even[root_v] = True
                
    for j in range(1,30):
        dsu = dsu_one[j]
        for n in range(N):
            if not link[n] and dsu.even[dsu.find(n)]:
                link[n] = True
    
    def mex(u,v):
        for j in range(30):
            dsu = dsu_zero[j]
            if dsu.find(u) == dsu.find(v):
                return 0
        if link[u]:
            return 1
        if even[u]:
            return 1
        return 2
    
    res = []
    for u,v in Q:
        res.append(mex(u,v))
            
    return ""\n"".join(str(v) for v in res)

for test in range(1,1+1):
    N,M = ti()
    
    E = []
    for _ in range(M):
        u,v,w = ti()
        u -= 1
        v -= 1
        E.append((u,v,w))
    
    Q = []
    for _ in range(ui()):
        u,v = ti()
        u -= 1
        v -= 1
        Q.append((u,v))
    
    print(solve())
    
file.close()","['bitmasks', 'brute force', 'constructive algorithms', 'dfs and similar', 'dsu', 'graphs']"
889,"Modern researches has shown that a flock of hungry mice searching for a piece of cheese acts as follows: if there are several pieces of cheese then each mouse chooses the closest one. After that all mice start moving towards the chosen piece of cheese. When a mouse or several mice achieve the destination point and there is still a piece of cheese in it, they eat it and become well-fed. Each mice that reaches this point after that remains hungry. Moving speeds of all mice are equal.If there are several ways to choose closest pieces then mice will choose it in a way that would minimize the number of hungry mice. To check this theory scientists decided to conduct an experiment. They located N mice and M pieces of cheese on a cartesian plane where all mice are located on the line y = Y0 and all pieces of cheese — on another line y = Y1. To check the results of the experiment the scientists need a program which simulates the behavior of a flock of hungry mice.Write a program that computes the minimal number of mice which will remain hungry, i.e. without cheese. NoteAll the three mice will choose the first piece of cheese. Second and third mice will eat this piece. The first one will remain hungry, because it was running towards the same piece, but it was late. The second piece of cheese will remain uneaten. f = lambda : map(int,raw_input().split())
n,m,x,y=f()
v = [0]*m
t = [0]*m
a = f()
b = f()
i = 0

for x in a:
    while i<m-1 and abs(b[i]-x)>abs(b[i+1]-x):
		i+=1

    w = abs(b[i]-x)
    if i<m-1 and w==abs(b[i+1]-x):
        if not v[i]: 
            v[i]=1
            t[i]=w
        else: 
            if t[i]==w: v[i]+=1
            else:
                t[i+1]=w
                v[i+1]=1
    else:
        if v[i]: 
            if t[i]<w: continue
            if t[i]==w:
                v[i]+=1
                continue
        v[i]=1
        t[i]=w

print n-sum(v)","['greedy', 'two pointers']"
2968,"  While trading on his favorite exchange trader William realized that he found a vulnerability. Using this vulnerability he could change the values of certain internal variables to his advantage. To play around he decided to change the values of all internal variables from $$$a_1, a_2, \ldots, a_n$$$ to $$$-a_1, -a_2, \ldots, -a_n$$$. For some unknown reason, the number of service variables is always an even number.William understands that with his every action he attracts more and more attention from the exchange's security team, so the number of his actions must not exceed $$$5\,000$$$ and after every operation no variable can have an absolute value greater than $$$10^{18}$$$. William can perform actions of two types for two chosen variables with indices $$$i$$$ and $$$j$$$, where $$$i &lt; j$$$:  Perform assignment $$$a_i = a_i + a_j$$$  Perform assignment $$$a_j = a_j - a_i$$$  William wants you to develop a strategy that will get all the internal variables to the desired values. NoteFor the first sample test case one possible sequence of operations is as follows:  ""2 1 2"". Values of variables after performing the operation: [1, 0, 1, 1]  ""2 1 2"". Values of variables after performing the operation: [1, -1, 1, 1]  ""2 1 3"". Values of variables after performing the operation: [1, -1, 0, 1]  ""2 1 3"". Values of variables after performing the operation: [1, -1, -1, 1]  ""2 1 4"". Values of variables after performing the operation: [1, -1, -1, 0]  ""2 1 4"". Values of variables after performing the operation: [1, -1, -1, -1]  ""1 1 2"". Values of variables after performing the operation: [0, -1, -1, -1]  ""1 1 2"". Values of variables after performing the operation: [-1, -1, -1, -1] For the second sample test case one possible sequence of operations is as follows:  ""2 1 4"". Values of variables after performing the operation: [4, 3, 1, -2]  ""1 2 4"". Values of variables after performing the operation: [4, 1, 1, -2]  ""1 2 4"". Values of variables after performing the operation: [4, -1, 1, -2]  ""1 2 4"". Values of variables after performing the operation: [4, -3, 1, -2]  ""1 3 4"". Values of variables after performing the operation: [4, -3, -1, -2]  ""1 1 2"". Values of variables after performing the operation: [1, -3, -1, -2]  ""1 1 2"". Values of variables after performing the operation: [-2, -3, -1, -2]  ""1 1 4"". Values of variables after performing the operation: [-4, -3, -1, -2]  import bisect
import io
import math
import os
import sys

LO = 'abcdefghijklmnopqrstuvwxyz'
Mod = 1000000007

def gcd(x, y):
    while y:
        x, y = y, x % y
    return x

# _input = lambda: io.BytesIO(os.read(0, os.fstat(0).st_size)).readline().decode()
_input = lambda: sys.stdin.buffer.readline().strip().decode()

for _ in range(int(_input())):
    n = int(_input())
    a = list(map(int, _input().split()))
    print(n // 2 * 6)
    for i in range(1, n + 1, 2):
        print(1, i, i + 1)  # x + y, y
        print(2, i, i + 1)  # x + y, -x
        print(1, i, i + 1)  # y, -x
        print(1, i, i + 1)  # -x + y, -x
        print(2, i, i + 1)  # -x + y, -y
        print(1, i, i + 1)  # -x, -y
",['constructive algorithms']
4674,"You are given integer $$$n$$$. You have to arrange numbers from $$$1$$$ to $$$2n$$$, using each of them exactly once, on the circle, so that the following condition would be satisfied:For every $$$n$$$ consecutive numbers on the circle write their sum on the blackboard. Then any two of written on the blackboard $$$2n$$$ numbers differ not more than by $$$1$$$.For example, choose $$$n = 3$$$. On the left you can see an example of a valid arrangement: $$$1 + 4 + 5 = 10$$$, $$$4 + 5 + 2 = 11$$$, $$$5 + 2 + 3 = 10$$$, $$$2 + 3 + 6 = 11$$$, $$$3 + 6 + 1 = 10$$$, $$$6 + 1 + 4 = 11$$$, any two numbers differ by at most $$$1$$$. On the right you can see an invalid arrangement: for example, $$$5 + 1 + 6 = 12$$$, and $$$3 + 2 + 4 = 9$$$, $$$9$$$ and $$$12$$$ differ more than by $$$1$$$.   NoteExample from the statement is shown for the first example. It can be proved that there is no solution in the second example. n=int(input())
n*=n%2
a=2*n*[0]
for i in range(2*n):a[i//2+(i^i//2)%2*n]=i+1
print('YNEOS'[n<1::2],*a)","['constructive algorithms', 'math']"
776,"Jzzhu has picked n apples from his big apple tree. All the apples are numbered from 1 to n. Now he wants to sell them to an apple store. Jzzhu will pack his apples into groups and then sell them. Each group must contain two apples, and the greatest common divisor of numbers of the apples in each group must be greater than 1. Of course, each apple can be part of at most one group.Jzzhu wonders how to get the maximum possible number of groups. Can you help him? nan """"""
Codeforces Round 257 Div 1 Problem C

Author  : chaotic_iak
Language: Python 3.3.4
""""""

def read(mode=2):
    # 0: String
    # 1: List of strings
    # 2: List of integers
    inputs = input().strip()
    if mode == 0:
        return inputs
    if mode == 1:
        return inputs.split()
    if mode == 2:
        return [int(x) for x in inputs.split()]

def write(s=""\n""):
    if isinstance(s, list): s = "" "".join(map(str,s))
    s = str(s)
    print(s, end="""")

################################################### SOLUTION

# croft algorithm to generate primes
# from pyprimes library, not built-in, just google it
from itertools import compress
import itertools
def croft():
    """"""Yield prime integers using the Croft Spiral sieve.

    This is a variant of wheel factorisation modulo 30.
    """"""
    # Implementation is based on erat3 from here:
    #   http://stackoverflow.com/q/2211990
    # and this website:
    #   http://www.primesdemystified.com/
    # Memory usage increases roughly linearly with the number of primes seen.
    # dict ``roots`` stores an entry x:p for every prime p.
    for p in (2, 3, 5):
        yield p
    roots = {9: 3, 25: 5}  # Map d**2 -> d.
    primeroots = frozenset((1, 7, 11, 13, 17, 19, 23, 29))
    selectors = (1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0)
    for q in compress(
            # Iterate over prime candidates 7, 9, 11, 13, ...
            itertools.islice(itertools.count(7), 0, None, 2),
            # Mask out those that can't possibly be prime.
            itertools.cycle(selectors)
            ):
        # Using dict membership testing instead of pop gives a
        # 5-10% speedup over the first three million primes.
        if q in roots:
            p = roots[q]
            del roots[q]
            x = q + 2*p
            while x in roots or (x % 30) not in primeroots:
                x += 2*p
            roots[x] = p
        else:
            roots[q*q] = q
            yield q

n, = read()
cr = croft()
primes = []
for i in cr:
    if i < n:
        primes.append(i)
    else:
        break
primes.reverse()

used = [0] * (n+1)
res = []
for p in primes:
    k = n//p
    tmp = []
    while k:
        if not used[k*p]:
            tmp.append(k*p)
            used[k*p] = 1
        if len(tmp) == 2:
            res.append(tmp)
            tmp = []
        k -= 1
    if tmp == [p] and p > 2 and p*2 <= n and len(res) and res[-1][1] == p*2:
        res[-1][1] = p
        used[p*2] = 0
        used[p] = 1

print(len(res))
for i in res:
    print("" "".join(map(str, i)))","['constructive algorithms', 'number theory']"
589,"You are given a tree consisting of $$$n$$$ nodes. You generate an array from the tree by marking nodes one by one.Initially, when no nodes are marked, a node is equiprobably chosen and marked from the entire tree. After that, until all nodes are marked, a node is equiprobably chosen and marked from the set of unmarked nodes with at least one edge to a marked node. It can be shown that the process marks all nodes in the tree. The final array $$$a$$$ is the list of the nodes' labels in order of the time each node was marked.Find the expected number of inversions in the array that is generated by the tree and the aforementioned process.The number of inversions in an array $$$a$$$ is the number of pairs of indices $$$(i, j)$$$ such that $$$i &lt; j$$$ and $$$a_i &gt; a_j$$$. For example, the array $$$[4, 1, 3, 2]$$$ contains $$$4$$$ inversions: $$$(1, 2)$$$, $$$(1, 3)$$$, $$$(1, 4)$$$, $$$(3, 4)$$$. NoteThis is the tree from the first sample:  For the first sample, the arrays are almost fixed. If node $$$2$$$ is chosen initially, then the only possible array is $$$[2, 1, 3]$$$ ($$$1$$$ inversion). If node $$$3$$$ is chosen initially, then the only possible array is $$$[3, 1, 2]$$$ ($$$2$$$ inversions). If node $$$1$$$ is chosen initially, the arrays $$$[1, 2, 3]$$$ ($$$0$$$ inversions) and $$$[1, 3, 2]$$$ ($$$1$$$ inversion) are the only possibilities and equiprobable. In total, the expected number of inversions is $$$\frac{1}{3}\cdot 1 + \frac{1}{3} \cdot 2 + \frac{1}{3} \cdot (\frac{1}{2} \cdot 0 + \frac{1}{2} \cdot 1) = \frac{7}{6}$$$. $$$166666669 \cdot 6 = 7 \pmod {10^9 + 7}$$$, so the answer is $$$166666669$$$.This is the tree from the second sample:   This is the tree from the third sample:    m=10**9+7
n=input()
h=range(n)
d=[n*[m]for f in h]
for f in h[1:]:a,b=map(int,raw_input().split());a-=1;b-=1;d[a][b]=d[b][a]=1;d[a][a]=d[b][b]=s=0
for k in h:
 for i in h:
  for j in h:d[i][j]=min(d[i][j],d[i][k]+d[k][j])
c=[[1]+n*[0]for f in[0]+h]
for i in h:
 for j in h:c[i+1][j+1]=(c[i][j+1]+c[i+1][j])*-~m/2%m
for i in h:
 for j in h[i+1:]:
  for k in h:x,y=d[i][k],d[j][k];v=(x+y-d[i][j])/2;s+=c[x-v][y-v]
print s*pow(n,m-2,m)%m","['brute force', 'combinatorics', 'dp', 'graphs', 'math', 'probabilities', 'trees']"
1029,"A Martian boy is named s — he has got this name quite recently from his parents for his coming of age birthday. Now he enjoys looking for his name everywhere. If he sees that he can obtain his name from some string by removing zero or more letters (at that, the remaining letters remain in the same order), he gets happy. For example, if s=«aba», then strings «baobab», «aabbaa», «helloabahello» make him very happy and strings «aab», «baaa» and «helloabhello» do not.However rather than being happy once, he loves twice as much being happy twice! So, when he got string t as a present, he wanted to cut it in two parts (the left part and the right part) so that each part made him happy.Help s determine the number of distinct ways to cut the given string t into two parts in the required manner. nan s = input()
t = input()
m = len(s)
n = len(t)
first = 0
last = n
j = 0
flag = 0
i = 0
while i < n and j < m:
    if t[i] == s[j]:
        j += 1
    i += 1
first = i - 1
if j == m:
    flag = 1
i = n - 1
j = m - 1
while i >= 0 and j >= 0:
    if t[i] == s[j]:
        j -= 1
    i -= 1
last = i + 1
# print(first,last)
if flag == 0 or last <= first:
    ans = 0
else:
    ans = last - first
print(ans)
","['greedy', 'other']"
3407,"Little Artem likes electronics. He can spend lots of time making different schemas and looking for novelties in the nearest electronics store. The new control element was delivered to the store recently and Artem immediately bought it.That element can store information about the matrix of integers size n × m. There are n + m inputs in that element, i.e. each row and each column can get the signal. When signal comes to the input corresponding to some row, this row cyclically shifts to the left, that is the first element of the row becomes last element, second element becomes first and so on. When signal comes to the input corresponding to some column, that column shifts cyclically to the top, that is first element of the column becomes last element, second element becomes first and so on. Rows are numbered with integers from 1 to n from top to bottom, while columns are numbered with integers from 1 to m from left to right.Artem wants to carefully study this element before using it. For that purpose he is going to set up an experiment consisting of q turns. On each turn he either sends the signal to some input or checks what number is stored at some position of the matrix.Artem has completed his experiment and has written down the results, but he has lost the chip! Help Artem find any initial matrix that will match the experiment results. It is guaranteed that experiment data is consistent, which means at least one valid matrix exists. nan n, m, q = map(int, input().split())
res = [0] * int(1e4+5)
arr = list([0] * (m+1) for _ in range(n+1))

def shift_row(r):
    arr[r][m] = arr[r][m-1]
    for i in range(m-1, 0, -1):
        arr[r][i] = arr[r][i-1]
    arr[r][0] = arr[r][m]
 
def shift_col(c):
    arr[n][c] = arr[n-1][c]
    for i in range(n-1, 0, -1):
        arr[i][c] = arr[i-1][c]
    arr[0][c] = arr[n][c]

for i in range(q):
    qi = list(map(int, input().split()))
    if qi[0] == 3:
        res[i] = ((qi[0], qi[3]), (qi[1], qi[2]))
    else:
        res[i] = ((qi[0], qi[1]), (-1, -1))

for i in range(q-1, -1, -1):
    if res[i][0][0] == 3:
        arr[res[i][1][0] - 1][res[i][1][1] - 1] = res[i][0][1]
    elif res[i][0][0] == 1:
        shift_row(res[i][0][1] - 1)
    elif res[i][0][0] == 2:
        shift_col(res[i][0][1] - 1)

for i in range(n):
    print(*arr[i][:-1])
",['implementation']
1937,"You are given two strings $$$a$$$ and $$$b$$$ consisting of lowercase English letters, both of length $$$n$$$. The characters of both strings have indices from $$$1$$$ to $$$n$$$, inclusive. You are allowed to do the following changes:   Choose any index $$$i$$$ ($$$1 \le i \le n$$$) and swap characters $$$a_i$$$ and $$$b_i$$$;  Choose any index $$$i$$$ ($$$1 \le i \le n$$$) and swap characters $$$a_i$$$ and $$$a_{n - i + 1}$$$;  Choose any index $$$i$$$ ($$$1 \le i \le n$$$) and swap characters $$$b_i$$$ and $$$b_{n - i + 1}$$$. Note that if $$$n$$$ is odd, you are formally allowed to swap $$$a_{\lceil\frac{n}{2}\rceil}$$$ with $$$a_{\lceil\frac{n}{2}\rceil}$$$ (and the same with the string $$$b$$$) but this move is useless. Also you can swap two equal characters but this operation is useless as well.You have to make these strings equal by applying any number of changes described above, in any order. But it is obvious that it may be impossible to make two strings equal by these swaps.In one preprocess move you can replace a character in $$$a$$$ with another character. In other words, in a single preprocess move you can choose any index $$$i$$$ ($$$1 \le i \le n$$$), any character $$$c$$$ and set $$$a_i := c$$$.Your task is to find the minimum number of preprocess moves to apply in such a way that after them you can make strings $$$a$$$ and $$$b$$$ equal by applying some number of changes described in the list above.Note that the number of changes you make after the preprocess moves does not matter. Also note that you cannot apply preprocess moves to the string $$$b$$$ or make any preprocess moves after the first change is made. NoteIn the first example preprocess moves are as follows: $$$a_1 := $$$'b', $$$a_3 := $$$'c', $$$a_4 := $$$'a' and $$$a_5:=$$$'b'. Afterwards, $$$a = $$$""bbcabba"". Then we can obtain equal strings by the following sequence of changes: $$$swap(a_2, b_2)$$$ and $$$swap(a_2, a_6)$$$. There is no way to use fewer than $$$4$$$ preprocess moves before a sequence of changes to make string equal, so the answer in this example is $$$4$$$.In the second example no preprocess moves are required. We can use the following sequence of changes to make $$$a$$$ and $$$b$$$ equal: $$$swap(b_1, b_5)$$$, $$$swap(a_2, a_4)$$$. n = int(input())
s = input()
t = input()
c = 0
for i in range(n//2):
    M = [s[i], s[n-1-i]]
    M.sort()
    N = [t[i], t[n-1-i]]
    N.sort()
    if (M[0] == N[0] and M[1] == N[1]) or (M[0] == M[1] and N[0] == N[1]):
        c+=0
    elif M[0] == N[1] or M[1] == N[0] or N[0] == N[1] or M[0] == N[0] or M[1] == N[1]:
        c+=1
    else:
        c+=2
if n%2==1 and s[n//2] != t[n//2]:
    c+=1
print(c)",['implementation']
2133,"You have a multiset containing several integers. Initially, it contains $$$a_1$$$ elements equal to $$$1$$$, $$$a_2$$$ elements equal to $$$2$$$, ..., $$$a_n$$$ elements equal to $$$n$$$.You may apply two types of operations:  choose two integers $$$l$$$ and $$$r$$$ ($$$l \le r$$$), then remove one occurrence of $$$l$$$, one occurrence of $$$l + 1$$$, ..., one occurrence of $$$r$$$ from the multiset. This operation can be applied only if each number from $$$l$$$ to $$$r$$$ occurs at least once in the multiset;  choose two integers $$$i$$$ and $$$x$$$ ($$$x \ge 1$$$), then remove $$$x$$$ occurrences of $$$i$$$ from the multiset. This operation can be applied only if the multiset contains at least $$$x$$$ occurrences of $$$i$$$. What is the minimum number of operations required to delete all elements from the multiset? nan import sys
range = xrange
input = raw_input

#def solve(A, b):
#    n = j = len(A)
#    if n == 0:
#        return 0
#    a = min(A)
#    s = a - b
#    for i in reversed(range(n)):
#        if A[i] == a:
#            s += solve(A[i + 1:j], a)
#            j = i
#    s += solve(A[0:j], a)
#    return min(n, s)

n = int(input())
A = [int(x) for x in input().split()]

arrays = [A]
B = [0]
stack = [0]
ans = [0]

while stack:
    state = stack.pop()
    if state >= 0:
        A = arrays[state]
        b = B[state]
        
        n = j = len(A)
        if n == 0:
            continue
        
        a = min(A)
        
        stack.append(~state)
        ans.append(a - b)
        for i in reversed(range(n)):
            if A[i] == a:
                stack.append(len(arrays))
                arrays.append(A[i + 1:j])
                B.append(a)
                j = i
        
        stack.append(len(arrays))
        arrays.append(A[0:j])
        B.append(a)
    else:
        s = ans.pop()
        ans[-1] += min(s, len(arrays[~state]))

print ans[0]","['data structures', 'divide and conquer', 'dp', 'greedy']"
414,"Permutation p is an ordered set of integers p1,   p2,   ...,   pn, consisting of n distinct positive integers not larger than n. We'll denote as n the length of permutation p1,   p2,   ...,   pn.Your task is to find such permutation p of length n, that the group of numbers |p1 - p2|, |p2 - p3|, ..., |pn - 1 - pn| has exactly k distinct elements. NoteBy |x| we denote the absolute value of number x.  from sys import stdin
lines = list(filter(None, stdin.read().split('\n')))

def parseline(line):
	return list(map(int, line.split()))

lines = list(map(parseline, lines))

n, k = lines[0]

x = n + 1
for i in range(n, n - k, -1):
	if (n - i) % 2 == 0:
		x = x - i
	else:
		x = x + i
	print(x, end=' ')

step = -1 if k %2 == 0 else +1
for k in range(n - k):
	x += step
	print(x, end=' ')
","['constructive algorithms', 'implementation']"
3926,"You're given an integer $$$n$$$. For every integer $$$i$$$ from $$$2$$$ to $$$n$$$, assign a positive integer $$$a_i$$$ such that the following conditions hold:  For any pair of integers $$$(i,j)$$$, if $$$i$$$ and $$$j$$$ are coprime, $$$a_i \neq a_j$$$.  The maximal value of all $$$a_i$$$ should be minimized (that is, as small as possible). A pair of integers is called coprime if their greatest common divisor is $$$1$$$. NoteIn the first example, notice that $$$3$$$ and $$$4$$$ are coprime, so $$$a_3 \neq a_4$$$. Also, notice that $$$a=[1,2,3]$$$ satisfies the first condition, but it's not a correct answer because its maximal value is $$$3$$$. 
n = int(raw_input())

marked = [False]*(10**5 + 1)
a = [0]*(10**5 + 1)
count = 0

for i in range(2,n+1):
  if not marked[i]:
    count+=1
    a[i]=count
    for j in range(i*2,n+1,i):
      marked[j]=True
      a[j] = a[i]

for i in range(2,n+1):
  print a[i],
","['constructive algorithms', 'number theory']"
833,"Woken up by the alarm clock Igor the financial analyst hurried up to the work. He ate his breakfast and sat in his car. Sadly, when he opened his GPS navigator, he found that some of the roads in Bankopolis, the city where he lives, are closed due to road works. Moreover, Igor has some problems with the steering wheel, so he can make no more than two turns on his way to his office in bank.Bankopolis looks like a grid of n rows and m columns. Igor should find a way from his home to the bank that has no more than two turns and doesn't contain cells with road works, or determine that it is impossible and he should work from home. A turn is a change in movement direction. Igor's car can only move to the left, to the right, upwards and downwards. Initially Igor can choose any direction. Igor is still sleepy, so you should help him. NoteThe first sample is shown on the following picture:  In the second sample it is impossible to reach Igor's office using less that 4 turns, thus there exists no path using no more than 2 turns. The path using exactly 4 turns is shown on this picture:   n,m=map(int,raw_input().split())
N=range(n)
M=range(m)
D=(0,1,2,3)
g=[raw_input() for _ in range(n)]
I=1<<20
v=[[[I]*4 for _ in M] for _ in N]
q=[]
for i in N:
  for j in M:
    if 'S'==g[i][j]:
      for d in D:
        q+=[(i,j,d)]
        v[i][j][d]=0
    if 'T'==g[i][j]:
      x,y=i,j
dr=[-1,0,1,0]
dc=[0,1,0,-1]
while q:
  i,j,k=q.pop()
  for d in D:
    a,b=i+dr[d],j+dc[d]
    if 0<=a<n and 0<=b<m and g[a][b]!='*':
      l=v[i][j][k]+(k!=d)
      if l<v[a][b][d]:
        v[a][b][d]=l
        if v[a][b][d]<3:
          if a==x and b==y:
            print 'YES'
            exit(0)
          else:
            q+=[(a,b,d)]
print 'NO'
","['dfs and similar', 'graphs', 'implementation', 'shortest paths']"
553,"A dice is a cube, its faces contain distinct integers from 1 to 6 as black points. The sum of numbers at the opposite dice faces always equals 7. Please note that there are only two dice (these dices are mirror of each other) that satisfy the given constraints (both of them are shown on the picture on the left).  Alice and Bob play dice. Alice has built a tower from n dice. We know that in this tower the adjacent dice contact with faces with distinct numbers. Bob wants to uniquely identify the numbers written on the faces of all dice, from which the tower is built. Unfortunately, Bob is looking at the tower from the face, and so he does not see all the numbers on the faces. Bob sees the number on the top of the tower and the numbers on the two adjacent sides (on the right side of the picture shown what Bob sees).Help Bob, tell whether it is possible to uniquely identify the numbers on the faces of all the dice in the tower, or not. nan d ={1:6,
	2:5,
	3:4,
	4:3,
	5:2,
	6:1}
n=int(input())
x=int(input())
a=[]
b=[]
res='YES'
for i in range(n):
	s=list(map(int,input().split()))
	if d[x] in s:
		res='NO'
	elif x in s:
		res='NO'
print(res)
","['constructive algorithms', 'greedy']"
4019,"Eudokimus, a system administrator is in trouble again. As a result of an error in some script, a list of names of very important files has been damaged. Since they were files in the BerFS file system, it is known that each file name has a form ""name.ext"", where:   name is a string consisting of lowercase Latin letters, its length is from 1 to 8 characters;  ext is a string consisting of lowercase Latin letters, its length is from 1 to 3 characters. For example, ""read.me"", ""example.txt"" and ""b.cpp"" are valid file names and ""version.info"", ""ntldr"" and ""contestdata.zip"" are not.Damage to the list meant that all the file names were recorded one after another, without any separators. So now Eudokimus has a single string.Eudokimus needs to set everything right as soon as possible. He should divide the resulting string into parts so that each part would be a valid file name in BerFS. Since Eudokimus has already proved that he is not good at programming, help him. The resulting file list can contain the same file names. nan #!/usr/bin/python

import sys
import re

st = sys.stdin.readline()
ans = []
mb = re.match('([a-z]{1,8})\..+', st[0:10])
pos = 0
if mb:
	fn = mb.group(1)
	ans.append(fn + '.')
	#st = st[len(fn)+1:]
	pos = len(fn) + 1;
	while st:
		mb = re.match('([a-z]{2,11})\..+', st[pos:pos+15])
		if mb:
			cmb = mb.group(1)
			total = len(cmb)
			if (total <= 9):
				ans[-1] += cmb[0:1]
				ans.append(cmb[1:] + '.')
			else:
				ans[-1] += cmb[0:total-8]
				ans.append(cmb[total-8:] + '.')
			#st = st[total+1:]
			pos += total + 1
		else:
			mb = re.match('([a-z]{1,3})$', st[pos:])
			if mb:
				ext = mb.group(1)
				ans[-1] += ext
				st = []
			else:
				print ""NO""
				sys.exit(0)
else:
	print ""NO""
	sys.exit(0)

print ""YES""
for s in ans:
	print s
","['dp', 'greedy', 'implementation']"
2348,"Given a sequence of integers $$$a$$$ of length $$$n$$$, a tuple $$$(i,j,k)$$$ is called monotone triples if   $$$1 \le i&lt;j&lt;k\le n$$$;  $$$a_i \le a_j \le a_k$$$ or $$$a_i \ge a_j \ge a_k$$$ is satisfied. For example, $$$a=[5,3,4,5]$$$, then $$$(2,3,4)$$$ is monotone triples for sequence $$$a$$$ while $$$(1,3,4)$$$ is not.Bob is given a sequence of integers $$$a$$$ of length $$$n$$$ in a math exam. The exams itself contains questions of form $$$L, R$$$, for each of them he is asked to find any subsequence $$$b$$$ with size greater than $$$2$$$ (i.e. $$$|b| \ge 3$$$) of sequence $$$a_L, a_{L+1},\ldots, a_{R}$$$.Recall that an sequence $$$b$$$ is a subsequence of sequence $$$a$$$ if $$$b$$$ can be obtained by deletion of several (possibly zero, or all) elements.However, he hates monotone stuff, and he wants to find a subsequence free from monotone triples. Besides, he wants to find one subsequence with the largest length among all subsequences free from monotone triples for every query.Please help Bob find out subsequences meeting the above constraints. NoteFor the first query, the given sequence itself is monotone triples free.For the second query, it can be shown that there is no subsequence $$$b$$$ with length greater than $$$2$$$ such that $$$b$$$ is monotone triples free. import sys
import io, os
input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
from operator import itemgetter
import bisect

n,q=map(int,input().split())
A=[-1]+list(map(int,input().split()))
Q=[list(map(int,input().split()))+[i] for i in range(q)]

Q.sort(key=itemgetter(1))
Q_ind=0

ANS1=[-1000,-1000,-1000,-1000]
ANS2=[-1000,-1000,-1000]
ANS3=[-1000,-1000,-1000]
ANS=[[0]]*q

Increase=[-1]
Decrease=[-1]
Increase2=[-1]
Decrease2=[-1]

No_inclast=[-1]*(n+1)
No_declast=[-1]*(n+1)
Inc_next=[-1]*(n+1)
Dec_next=[-1]*(n+1)

LEN=n

BIT=[0]*(LEN+1)

def update(v,w):
    while v<=LEN:
        BIT[v]+=w
        v+=(v&(-v))

def getvalue(v):
    ANS=0
    while v!=0:
        ANS+=BIT[v]
        v-=(v&(-v))
    return ANS

def bisect_on_BIT(x):

    if x<=0:
        return 0
    
    ANS=0
    h=1<<(LEN.bit_length()-1)
    while h>0:
        if ANS+h<=LEN and BIT[ANS+h]<x:
            x-=BIT[ANS+h]
            ANS+=h
        h//=2

    return ANS+1

No_incdeclist=[0]*n

for i in range(1,n+1):
    No_inc=-1
    No_dec=-1
    
    while Increase[-1]!=-1 and A[i]<A[Increase[-1]]:
        ind=Increase.pop()
        if Increase2[-1]==ind:
            Increase2.pop()

        No_incdeclist[ind]+=1

        if No_incdeclist[ind]==2:
            update(ind,1)

        if No_inc==-1:
            No_inc=ind

    while Increase2[-1]!=-1 and A[i]==A[Increase2[-1]]:
        Increase2.pop()

    Increase.append(i)
    Increase2.append(i)
        
    if No_inc!=-1:
        No_inclast[i]=No_inc
        if Inc_next[No_inc]==-1:
            Inc_next[No_inc]=i
    else:
        No_inclast[i]=No_inclast[i-1]
        

    while Decrease[-1]!=-1 and A[i]>A[Decrease[-1]]:
        ind=Decrease.pop()
        if Decrease2[-1]==ind:
            Decrease2.pop()
        
        No_incdeclist[ind]+=1

        if No_incdeclist[ind]==2:
            update(ind,1)

        if No_dec==-1:
            No_dec=ind

    while Decrease2[-1]!=-1 and A[i]==A[Decrease2[-1]]:
        Decrease2.pop()

    Decrease.append(i)
    Decrease2.append(i)

    if No_dec!=-1:
        No_declast[i]=No_dec
        if Dec_next[No_dec]==-1:
            Dec_next[No_dec]=i
    else:
        No_declast[i]=No_declast[i-1]

    MININD=min(Increase2[-2],Decrease2[-2])
    
    if MININD>1:
        MIN=bisect_on_BIT(getvalue(MININD))

        x=Increase[bisect.bisect_left(Increase,MIN)]
        y=Decrease[bisect.bisect_left(Decrease,MIN)]
                
        if MIN>0 and ANS1[0]<MIN and A[x]<A[i] and A[y]>A[i]:

            if x>y:
                x,y=y,x
                
            ANS1=[MIN,x,y,i]

    n_inc=No_inclast[i]
    mid=Inc_next[n_inc]
    
    if n_inc>0 and A[mid]<A[i] and ANS2[0]<n_inc:
        ANS2=[n_inc,mid,i]

    n_dec=No_declast[i]
    mid=Dec_next[n_dec]
     
    if n_dec>0 and A[mid]>A[i] and ANS3[0]<n_dec:
        ANS3=[n_dec,mid,i]
                
    while Q_ind<q and Q[Q_ind][1]==i:
        l,r,qu=Q[Q_ind]

        if ANS1[0]>=l:
            ANS[qu]=ANS1
        elif ANS2[0]>=l:
            ANS[qu]=ANS2
        elif ANS3[0]>=l:
            ANS[qu]=ANS3
        Q_ind+=1

    #print(Increase,Decrease,inclast,declast,No_inclast,No_declast)
    #print(ANS1,ANS2,ANS3)
    #print()

for x in ANS:
    if x==[0]:
        sys.stdout.write(str(0)+""\n"")
    else:
        sys.stdout.write(str(len(x))+""\n"")
        sys.stdout.write("" "".join(map(str,x))+""\n"")

    
    
",['data structures']
4607,"One day, as Sherlock Holmes was tracking down one very important criminal, he found a wonderful painting on the wall. This wall could be represented as a plane. The painting had several concentric circles that divided the wall into several parts. Some parts were painted red and all the other were painted blue. Besides, any two neighboring parts were painted different colors, that is, the red and the blue color were alternating, i. e. followed one after the other. The outer area of the wall (the area that lied outside all circles) was painted blue. Help Sherlock Holmes determine the total area of red parts of the wall.Let us remind you that two circles are called concentric if their centers coincide. Several circles are called concentric if any two of them are concentric. NoteIn the first sample the picture is just one circle of radius 1. Inner part of the circle is painted red. The area of the red part equals π × 12 = π.In the second sample there are three circles of radii 1, 4 and 2. Outside part of the second circle is painted blue. Part between the second and the third circles is painted red. Part between the first and the third is painted blue. And, finally, the inner part of the first circle is painted red. Overall there are two red parts: the ring between the second and the third circles and the inner part of the first circle. Total area of the red parts is equal (π × 42 - π × 22) + π × 12 = π × 12 + π = 13π n = int(input())
pie = 3.1415926536

arr = list(map(int, input().split()))
ans = 0.0

arr.sort()
cnt = 0
for i in range(n-1,-1,-1):
    if cnt % 2 == 0:
        ans += arr[i] * arr[i] * pie
    else:
        ans -= arr[i] * arr[i] * pie
    cnt += 1

print(ans)


### 1 2 3 4","['geometry', 'sortings']"
584,"Byteland is a beautiful land known because of its beautiful trees.Misha has found a binary tree with $$$n$$$ vertices, numbered from $$$1$$$ to $$$n$$$. A binary tree is an acyclic connected bidirectional graph containing $$$n$$$ vertices and $$$n - 1$$$ edges. Each vertex has a degree at most $$$3$$$, whereas the root is the vertex with the number $$$1$$$ and it has a degree at most $$$2$$$.Unfortunately, the root got infected.The following process happens $$$n$$$ times:  Misha either chooses a non-infected (and not deleted) vertex and deletes it with all edges which have an end in this vertex or just does nothing.  Then, the infection spreads to each vertex that is connected by an edge to an already infected vertex (all already infected vertices remain infected). As Misha does not have much time to think, please tell him what is the maximum number of vertices he can save from the infection (note that deleted vertices are not counted as saved). NoteIn the first test case, the only possible action is to delete vertex $$$2$$$, after which we save $$$0$$$ vertices in total.In the second test case, if we delete vertex $$$2$$$, we can save vertices $$$3$$$ and $$$4$$$.     import sys
input = lambda: sys.stdin.readline().rstrip()
out = sys.stdout.writelines

class RootedTree:

  def __init__(self, G: list, root: int):
    self._n = len(G)
    self._G = G
    self._root = root
    self._height = -1
    self._toposo = []
    self._dist = []
    self._descendant_num = []
    self._child = []
    self._child_num = []
    self._parents = []
    self._diameter = -1
    self._bipartite_graph = []

    self._calc_dist_toposo()
    # self._calc_child_parents()

  def __len__(self) -> int:
    ""Return the number of vertex of self. / O(1)""
    return self._n

  def __str__(self) -> str:
    ""Print Rooted Tree. / O(N) or O(1)""
    self._calc_child_parents()
    ret = [""<RootedTree> [""]
    ret.extend(
      [f'  dist:{d} - v:{str(i).zfill(2)} - p:{str(self._parents[i]).zfill(2)} - child:{self._child[i]}'
       for i,d in sorted(enumerate(self._dist), key=lambda x: x[1])]
      )
    ret.append(']')
    return '\n'.join(ret)

  def _calc_dist_toposo(self) -> None:
    ""Calc dist and toposo. / O(N)""
    todo = [self._root]
    self._dist = [-1] * self._n
    self._dist[self._root] = 0
    self._toposo = [self._root]

    for v in todo:
      d = self._dist[v]
      for x,c in self._G[v]:
        if self._dist[x] != -1:
          continue
        self._dist[x] = d + c
        todo.append(x)
        self._toposo.append(x)
    return

  def _calc_child_parents(self) -> None:
    ""Calc child and parents. / O(N)""
    if self._child and self._child_num and self._parents:
      return
    self._child_num = [0] * self._n
    self._child = [[] for _ in range(self._n)]
    self._parents = [-1] * self._n

    for v in self._toposo[::-1]:
      for x,c in self._G[v]:
        if self._dist[x] < self._dist[v]:
          self._parents[v] = x
          continue
        self._child[v].append(x)
        self._child_num[v] += 1
    return

  def get_dist(self) -> list:
    ""Return dist. / O(N)""
    return self._dist

  def get_toposo(self) -> list:
    ""Return toposo. / O(N)""
    return self._toposo

  def get_height(self) -> int:
    ""Return height. / O(N)""
    if self._height > -1:
      return self._height
    self._height = max(self._dist)
    return self._height

  def get_descendant_num(self) -> list:
    ""Return descendant_num. / O(N)""
    if self._descendant_num:
      return self._descendant_num
    self._descendant_num = [1] * self._n

    for v in self._toposo[::-1]:
      for x,c in self._G[v]:
        if self._dist[x] < self._dist[v]:
          continue
        self._descendant_num[v] += self._descendant_num[x]

    for i in range(self._n):
      self._descendant_num[i] -= 1
    return self._descendant_num

  def get_child(self) -> list:
    ""Return child / O(N)""
    if self._child:
      return self._child
    self._calc_child_parents()
    return self._child

  def get_child_num(self) -> list:
    ""Return child_num. / O(N)""
    if self._child_num:
      return self._child_num
    self._calc_child_parents()
    return self._child_num

  def get_parents(self) -> list:
    ""Return parents. / O(N)""
    if self._parents:
      return self._parents
    self._calc_child_parents()
    return self._parents

  def get_diameter(self) -> int:
    ""Return diameter of tree. / O(N)""
    if self._diameter > -1:
      return self._diameter
    s = self._dist.index(self.get_height())
    todo = [s]
    ndist = [-1] * self._n
    ndist[s] = 0

    while todo:
      v = todo.pop()
      d = ndist[v]
      for x, c in self._G[v]:
        if ndist[x] != -1:
          continue
        ndist[x] = d + c
        todo.append(x)
    self._diameter = max(ndist)

    return self._diameter

  def get_bipartite_graph(self) -> list:
    ""Return [1 if root else 0]. / O(N)""
    if self._bipartite_graph:
      return self._bipartite_graph
    self._bipartite_graph = [-1] * self._n
    self._bipartite_graph[self._root] = 1
    todo = [self._root]

    while todo:
      v = todo.popleft()
      nc = 0 if self._bipartite_graph[v] else 1
      for x,_ in self._G[v]:
        if self._bipartite_graph[x] != -1:
          continue
        self._bipartite_graph[x] = nc
        todo.append(x)

    return self._bipartite_graph

def main():
  n = int(input())
  G = [[] for _ in range(n)]
  for _ in range(n-1):
    u, v = map(int, input().split())
    u -= 1
    v -= 1
    G[u].append((v, 1))
    G[v].append((u, 1))

  tree = RootedTree(G, 0)
  dist = tree.get_dist()
  order = tree.get_toposo()
  child = tree.get_child()
  dsnum = tree.get_descendant_num()

  dp = [0 for _ in range(n)]
  for v in order[::-1]:
    if len(child[v]) == 0:
      continue
    elif len(child[v]) == 1:
      dp[v] = dsnum[child[v][0]]
    elif len(child[v]) == 2:
      x1, x2 = child[v]
      dp[v] = max(dp[x1]+dsnum[x2], dp[x2]+dsnum[x1])
  return dp[0]

out('\n'.join(map(str, [main() for _ in range(int(input()))])))
","['dfs and similar', 'dp', 'trees']"
838,"Along the railroad there are stations indexed from $$$1$$$ to $$$10^9$$$. An express train always travels along a route consisting of $$$n$$$ stations with indices $$$u_1, u_2, \dots, u_n$$$, where ($$$1 \le u_i \le 10^9$$$). The train travels along the route from left to right. It starts at station $$$u_1$$$, then stops at station $$$u_2$$$, then at $$$u_3$$$, and so on. Station $$$u_n$$$ — the terminus.It is possible that the train will visit the same station more than once. That is, there may be duplicates among the values $$$u_1, u_2, \dots, u_n$$$.You are given $$$k$$$ queries, each containing two different integers $$$a_j$$$ and $$$b_j$$$ ($$$1 \le a_j, b_j \le 10^9$$$). For each query, determine whether it is possible to travel by train from the station with index $$$a_j$$$ to the station with index $$$b_j$$$.For example, let the train route consist of $$$6$$$ of stations with indices [$$$3, 7, 1, 5, 1, 4$$$] and give $$$3$$$ of the following queries:   $$$a_1 = 3$$$, $$$b_1 = 5$$$It is possible to travel from station $$$3$$$ to station $$$5$$$ by taking a section of the route consisting of stations [$$$3, 7, 1, 5$$$]. Answer: YES.  $$$a_2 = 1$$$, $$$b_2 = 7$$$You cannot travel from station $$$1$$$ to station $$$7$$$ because the train cannot travel in the opposite direction. Answer: NO.  $$$a_3 = 3$$$, $$$b_3 = 10$$$It is not possible to travel from station $$$3$$$ to station $$$10$$$ because station $$$10$$$ is not part of the train's route. Answer: NO.  NoteThe first test case is explained in the problem statement. def main():
    t = int(input())
    ans = []
    for _ in range(t):
        input()
        n,k=map(int, input().split())
        nums = list(input().split())
        d = {}
        for i in range(n):
            x = nums[i]
            if x in d.keys():
                d[x] = (d[x][0], i)
            else:
                d[x] = (i, i)
        for _ in range(k):
            a,b=input().split()
            if a in d.keys() and b in d.keys():
                if d[a][0] < d[b][1]:
                    print(""YES"")
                else:
                    print(""NO"")
            else:
                print(""NO"")    
main()
        



","['data structures', 'greedy']"
3504,"Peter Parker wants to play a game with Dr. Octopus. The game is about cycles. Cycle is a sequence of vertices, such that first one is connected with the second, second is connected with third and so on, while the last one is connected with the first one again. Cycle may consist of a single isolated vertex.Initially there are k cycles, i-th of them consisting of exactly vi vertices. Players play alternatively. Peter goes first. On each turn a player must choose a cycle with at least 2 vertices (for example, x vertices) among all available cycles and replace it by two cycles with p and x - p vertices where 1 ≤ p &lt; x is chosen by the player. The player who cannot make a move loses the game (and his life!).Peter wants to test some configurations of initial cycle sets before he actually plays with Dr. Octopus. Initially he has an empty set. In the i-th test he adds a cycle with ai vertices to the set (this is actually a multiset because it can contain two or more identical cycles). After each test, Peter wants to know that if the players begin the game with the current set of cycles, who wins? Peter is pretty good at math, but now he asks you to help. NoteIn the first sample test:In Peter's first test, there's only one cycle with 1 vertex. First player cannot make a move and loses.In his second test, there's one cycle with 1 vertex and one with 2. No one can make a move on the cycle with 1 vertex. First player can replace the second cycle with two cycles of 1 vertex and second player can't make any move and loses.In his third test, cycles have 1, 2 and 3 vertices. Like last test, no one can make a move on the first cycle. First player can replace the third cycle with one cycle with size 1 and one with size 2. Now cycles have 1, 1, 2, 2 vertices. Second player's only move is to replace a cycle of size 2 with 2 cycles of size 1. And cycles are 1, 1, 1, 1, 2. First player replaces the last cycle with 2 cycles with size 1 and wins.In the second sample test:Having cycles of size 1 is like not having them (because no one can make a move on them). In Peter's third test: There a cycle of size 5 (others don't matter). First player has two options: replace it with cycles of sizes 1 and 4 or 2 and 3.  If he replaces it with cycles of sizes 1 and 4: Only second cycle matters. Second player will replace it with 2 cycles of sizes 2. First player's only option to replace one of them with two cycles of size 1. Second player does the same thing with the other cycle. First player can't make any move and loses.  If he replaces it with cycles of sizes 2 and 3: Second player will replace the cycle of size 3 with two of sizes 1 and 2. Now only cycles with more than one vertex are two cycles of size 2. As shown in previous case, with 2 cycles of size 2 second player wins. So, either way first player loses. def main():
    n, l, v = int(input()), input().split(), 0
    for i, a in enumerate(l):
        v ^= ord(a[-1]) - 1
        l[i] = (('2', '1')[v & 1])
    print('\n'.join(l))


if __name__ == '__main__':
    main()
","['games', 'math']"
157,"Tokitsukaze has a permutation $$$p$$$. She performed the following operation to $$$p$$$ exactly $$$k$$$ times: in one operation, for each $$$i$$$ from $$$1$$$ to $$$n - 1$$$ in order, if $$$p_i$$$ &gt; $$$p_{i+1}$$$, swap $$$p_i$$$, $$$p_{i+1}$$$. After exactly $$$k$$$ times of operations, Tokitsukaze got a new sequence $$$a$$$, obviously the sequence $$$a$$$ is also a permutation.After that, Tokitsukaze wrote down the value sequence $$$v$$$ of $$$a$$$ on paper. Denote the value sequence $$$v$$$ of the permutation $$$a$$$ of length $$$n$$$ as $$$v_i=\sum_{j=1}^{i-1}[a_i &lt; a_j]$$$, where the value of $$$[a_i &lt; a_j]$$$ define as if $$$a_i &lt; a_j$$$, the value is $$$1$$$, otherwise is $$$0$$$ (in other words, $$$v_i$$$ is equal to the number of elements greater than $$$a_i$$$ that are to the left of position $$$i$$$). Then Tokitsukaze went out to work.There are three naughty cats in Tokitsukaze's house. When she came home, she found the paper with the value sequence $$$v$$$ to be bitten out by the cats, leaving several holes, so that the value of some positions could not be seen clearly. She forgot what the original permutation $$$p$$$ was. She wants to know how many different permutations $$$p$$$ there are, so that the value sequence $$$v$$$ of the new permutation $$$a$$$ after exactly $$$k$$$ operations is the same as the $$$v$$$ written on the paper (not taking into account the unclear positions).Since the answer may be too large, print it modulo $$$998\,244\,353$$$. NoteIn the first test case, only permutation $$$p=[5,4,3,2,1]$$$ satisfies the constraint condition.In the second test case, there are $$$6$$$ permutations satisfying the constraint condition, which are:  $$$[3,4,5,2,1]$$$ $$$\rightarrow$$$ $$$[3,4,2,1,5]$$$ $$$\rightarrow$$$ $$$[3,2,1,4,5]$$$  $$$[3,5,4,2,1]$$$ $$$\rightarrow$$$ $$$[3,4,2,1,5]$$$ $$$\rightarrow$$$ $$$[3,2,1,4,5]$$$  $$$[4,3,5,2,1]$$$ $$$\rightarrow$$$ $$$[3,4,2,1,5]$$$ $$$\rightarrow$$$ $$$[3,2,1,4,5]$$$  $$$[4,5,3,2,1]$$$ $$$\rightarrow$$$ $$$[4,3,2,1,5]$$$ $$$\rightarrow$$$ $$$[3,2,1,4,5]$$$  $$$[5,3,4,2,1]$$$ $$$\rightarrow$$$ $$$[3,4,2,1,5]$$$ $$$\rightarrow$$$ $$$[3,2,1,4,5]$$$  $$$[5,4,3,2,1]$$$ $$$\rightarrow$$$ $$$[4,3,2,1,5]$$$ $$$\rightarrow$$$ $$$[3,2,1,4,5]$$$ So after exactly $$$2$$$ times of swap they will all become $$$a=[3,2,1,4,5]$$$, whose value sequence is $$$v=[0,1,2,0,0]$$$. #!/usr/bin/env PyPy3

from collections import Counter, defaultdict, deque
import itertools
import re
import math
from functools import reduce
import operator
import bisect
from heapq import *
import functools
mod=998244353

import sys
import os
from io import BytesIO, IOBase
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

t = int(input())
for _ in range(t):
    n,k=map(int,input().split())
    v = list(map(int,input().split()))
    ans = 1
    for i in range(1,k+1):
        ans *= i
        ans %= mod
    cnt = 0
    for i in range(n-k,n):
        if v[i] > 0:
            print(0)
            break
    else:
        for i in range(n-k)[::-1]:
            if v[i] > 0:
                if v[i] > i:
                    print(0)
                    break
            elif v[i] == 0:
                ans *= k + 1
                ans %= mod
            else:
                ans *= (k + 1 + i)
                ans %= mod
        else:
            print(ans)","['dp', 'math']"
1001,"Nezzar's favorite digit among $$$1,\ldots,9$$$ is $$$d$$$. He calls a positive integer lucky if $$$d$$$ occurs at least once in its decimal representation. Given $$$q$$$ integers $$$a_1,a_2,\ldots,a_q$$$, for each $$$1 \le i \le q$$$ Nezzar would like to know if $$$a_i$$$ can be equal to a sum of several (one or more) lucky numbers. NoteIn the first test case, $$$24 = 17 + 7$$$, $$$27$$$ itself is a lucky number, $$$25$$$ cannot be equal to a sum of lucky numbers. def islucky(num,k):
    f=False
    while num>0:
        r=num%10
        if r==k:
            f=True
            break
        num=num//10
    return f

t=int(input())
for _ in range(t):
  n,k=map(int,input().split())
  ar=list(map(int,input().split()))
  for x in range(n):
    num=ar[x]
    if num>=10*k:
        print(""YES"")
    else:
        x=0
        s=num 
        m=False
        while x<num:
            if islucky(x,k) and islucky(s,k):
                m=True
                break
            elif x%k==0 and islucky(s,k):
                m=True
                break
            elif islucky(x,k) and s%k==0:
                m=True
                break
            elif x%k==0 and s%k==0:
                m=True
                break
            else:
                x+=1 
                s-=1 
        if m:
            print(""YES"")
        else:
            print(""NO"")","['brute force', 'dp', 'greedy', 'math']"
742,"Two people play the following string game. Initially the players have got some string s. The players move in turns, the player who cannot make a move loses. Before the game began, the string is written on a piece of paper, one letter per cell.  An example of the initial situation at s = ""abacaba"" A player's move is the sequence of actions:  The player chooses one of the available pieces of paper with some string written on it. Let's denote it is t. Note that initially, only one piece of paper is available.  The player chooses in the string t = t1t2... t|t| character in position i (1 ≤ i ≤ |t|) such that for some positive integer l (0 &lt; i - l; i + l ≤ |t|) the following equations hold: ti - 1 = ti + 1, ti - 2 = ti + 2, ..., ti - l = ti + l.  Player cuts the cell with the chosen character. As a result of the operation, he gets three new pieces of paper, the first one will contain string t1t2... ti - 1, the second one will contain a string consisting of a single character ti, the third one contains string ti + 1ti + 2... t|t|.   An example of making action (i = 4) with string s = «abacaba» Your task is to determine the winner provided that both players play optimally well. If the first player wins, find the position of character that is optimal to cut in his first move. If there are multiple positions, print the minimal possible one. NoteIn the first sample the first player has multiple winning moves. But the minimum one is to cut the character in position 2. In the second sample the first player has no available moves. from sys import stdin


def task():
    value = stdin.readline()
    games = []
    counter = 0
    for i in xrange(1, len(value)-1):
        if value[i - 1] == value[i + 1]:
            counter += 1
        else:
            if counter > 0:
                games.append(counter)
            counter = 0
    if counter > 0:
        games.append(counter)
    max_game = max(games) if games else 0

    grundi = [0, 1, 1]
    for n in xrange(3, max_game + 1):
        s = {grundi[i] ^ grundi[n - i - 3] for i in xrange(0, n // 2 + 1)}
        s.add(grundi[n - 2])
        for i in xrange(n):
            if i not in s:
                grundi.append(i)
                break

    g = 0
    for game in games:
        g ^= grundi[game]
    print 'First' if g > 0 else 'Second'

    def check(n, g):
        if n < 3:
            return 0 if g == 0 else -1
        else:
            if grundi[n - 2] ^ g == 0:
                return 0
            for i in xrange(0, n - 2):
                if g ^ grundi[i] ^ grundi[n - i - 3] == 0:
                    return i + 1
            return -1

    cache = set()
    counter = 0
    delta = 0
    if g > 0:
        for i in xrange(1, len(value)-1):
            if value[i - 1] == value[i + 1]:
                if not delta:
                    delta = i + 1
                counter += 1
            else:
                if counter > 0:
                    if counter not in cache:
                        p = check(counter, grundi[counter] ^ g)
                        if p >= 0:
                            print delta + p
                            quit()
                        cache.add(counter)
                counter = 0
                delta = 0
        print delta + check(counter, grundi[counter] ^ g)

task()",['games']
2692,"You have array of $$$n$$$ numbers $$$a_{1}, a_{2}, \ldots, a_{n}$$$. Rearrange these numbers to satisfy $$$|a_{1} - a_{2}| \le |a_{2} - a_{3}| \le \ldots \le |a_{n-1} - a_{n}|$$$, where $$$|x|$$$ denotes absolute value of $$$x$$$. It's always possible to find such rearrangement.Note that all numbers in $$$a$$$ are not necessarily different. In other words, some numbers of $$$a$$$ may be same.You have to answer independent $$$t$$$ test cases. NoteIn the first test case, after given rearrangement, $$$|a_{1} - a_{2}| = 0 \le |a_{2} - a_{3}| = 1 \le |a_{3} - a_{4}| = 2 \le |a_{4} - a_{5}| = 2 \le |a_{5} - a_{6}| = 10$$$. There are other possible answers like ""5 4 5 6 -2 8"".In the second test case, after given rearrangement, $$$|a_{1} - a_{2}| = 1 \le |a_{2} - a_{3}| = 2 \le |a_{3} - a_{4}| = 4$$$. There are other possible answers like ""2 4 8 1"". T = int(input())
for i in range(T):
    N = int(input())
    a = [int(x) for x in input().split()]
    a.sort()
    n = len(a)
    while n!= 0:
        print(a.pop(n//2), end = ' ')
        n -= 1","['constructive algorithms', 'sortings']"
720,"Lee couldn't sleep lately, because he had nightmares. In one of his nightmares (which was about an unbalanced global round), he decided to fight back and propose a problem below (which you should solve) to balance the round, hopefully setting him free from the nightmares.A non-empty array $$$b_1, b_2, \ldots, b_m$$$ is called good, if there exist $$$m$$$ integer sequences which satisfy the following properties:  The $$$i$$$-th sequence consists of $$$b_i$$$ consecutive integers (for example if $$$b_i = 3$$$ then the $$$i$$$-th sequence can be $$$(-1, 0, 1)$$$ or $$$(-5, -4, -3)$$$ but not $$$(0, -1, 1)$$$ or $$$(1, 2, 3, 4)$$$).  Assuming the sum of integers in the $$$i$$$-th sequence is $$$sum_i$$$, we want $$$sum_1 + sum_2 + \ldots + sum_m$$$ to be equal to $$$0$$$. You are given an array $$$a_1, a_2, \ldots, a_n$$$. It has $$$2^n - 1$$$ nonempty subsequences. Find how many of them are good.As this number can be very large, output it modulo $$$10^9 + 7$$$.An array $$$c$$$ is a subsequence of an array $$$d$$$ if $$$c$$$ can be obtained from $$$d$$$ by deletion of several (possibly, zero or all) elements. NoteFor the first test, two examples of good subsequences are $$$[2, 7]$$$ and $$$[2, 2, 4, 7]$$$:For $$$b = [2, 7]$$$ we can use $$$(-3, -4)$$$ as the first sequence and $$$(-2, -1, \ldots, 4)$$$ as the second. Note that subsequence $$$[2, 7]$$$ appears twice in $$$[2, 2, 4, 7]$$$, so we have to count it twice.  Green circles denote $$$(-3, -4)$$$ and orange squares denote $$$(-2, -1, \ldots, 4)$$$. For $$$b = [2, 2, 4, 7]$$$ the following sequences would satisfy the properties: $$$(-1, 0)$$$, $$$(-3, -2)$$$, $$$(0, 1, 2, 3)$$$ and $$$(-3, -2, \ldots, 3)$$$ import sys
input = sys.stdin.readline
n = int(input().split('\n')[0])
a = [int(x) for x in input().split()]
 
o = [x for x in a if x%2 == 1]
e = [x for x in a if x%2 == 0]
 
ans = 0
ans += 2**(len(e))*(2**(len(o))-1)
 
while len(e)>=2:
    o = [x//2 for x in e if (x//2)%2==1]
    e = [x//2 for x in e if (x//2)%2==0]
    ans += 2**(len(e))*(2**max(0, len(o)-1)-1)
print(ans%(10**9+7))","['combinatorics', 'dp', 'math', 'number theory']"
2600,"There are $$$n$$$ rectangles in a row. You can either turn each rectangle by $$$90$$$ degrees or leave it as it is. If you turn a rectangle, its width will be height, and its height will be width. Notice that you can turn any number of rectangles, you also can turn all or none of them. You can not change the order of the rectangles.Find out if there is a way to make the rectangles go in order of non-ascending height. In other words, after all the turns, a height of every rectangle has to be not greater than the height of the previous rectangle (if it is such).  NoteIn the first test, you can rotate the second and the third rectangles so that the heights will be [4, 4, 3].In the second test, there is no way the second rectangle will be not higher than the first one. from __future__ import division, print_function
# import threading
# threading.stack_size(2**27)
# import sys
# sys.setrecursionlimit(10**7)
from sys import stdin, stdout
import bisect            #c++ upperbound
import math
import heapq
i_m=9223372036854775807
def modinv(n,p):
    return pow(n,p-2,p)
def cin():
    return map(int,sin().split())
def ain():                           #takes array as input
    return list(map(int,sin().split()))
def sin():
    return input()
def inin():
    return int(input())
import math  
def GCD(x, y): 
    x=abs(x)
    y=abs(y)
    if(min(x,y)==0):
        return max(x,y)
    while(y): 
        x, y = y, x % y 
    return x 
def Divisors(n) : 
    l = []  
    for i in range(1, int(math.sqrt(n) + 1)) :
        if (n % i == 0) : 
            if (n // i == i) : 
                l.append(i) 
            else : 
                l.append(i)
                l.append(n//i)
    return l
 

def SieveOfEratosthenes(n): 
    prime = [True for i in range(n+1)] 
    p = 2
    while (p * p <= n): 
        if (prime[p] == True): 
            for i in range(p * p, n+1, p): 
                prime[i] = False
        p += 1
    f=[]
    for p in range(2, n): 
        if prime[p]: 
            f.append(p)
    return f
q=[]       
def dfs(n,d,v,c):
    global q
    v[n]=1
    x=d[n]
    q.append(n)
    j=c
    for i in x:
        if i not in v:
            f=dfs(i,d,v,c+1)
            j=max(j,f)
            # print(f)
    return j
  
""""""*******************************************************""""""
def main():
    n=inin()
    a=[]
    x=i_m
    ans=""YES""
    for i in range(n):
        j,k=cin()
        p=max(j,k)
        q=min(j,k)
        if(p<=x):
            x=p
            continue
        if(q<=x):
            x=q
            continue
        ans=""NO""
        break
    print(ans)



            

 
######## Python 2 and 3 footer by Pajenegod and c1729
 
# Note because cf runs old PyPy3 version which doesn't have the sped up
# unicode strings, PyPy3 strings will many times be slower than pypy2.
# There is a way to get around this by using binary strings in PyPy3
# but its syntax is different which makes it kind of a mess to use.
 
# So on cf, use PyPy2 for best string performance.
 
py2 = round(0.5)
if py2:
    from future_builtins import ascii, filter, hex, map, oct, zip
    range = xrange
 
import os, sys
from io import IOBase, BytesIO
 
BUFSIZE = 8192
class FastIO(BytesIO):
    newlines = 0
 
    def __init__(self, file):
        self._file = file
        self._fd = file.fileno()
        self.writable = ""x"" in file.mode or ""w"" in file.mode
        self.write = super(FastIO, self).write if self.writable else None
 
    def _fill(self):
        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
        self.seek((self.tell(), self.seek(0,2), super(FastIO, self).write(s))[0])
        return s
 
    def read(self):
        while self._fill(): pass
        return super(FastIO,self).read()
 
    def readline(self):
        while self.newlines == 0:
            s = self._fill(); self.newlines = s.count(b""\n"") + (not s)
        self.newlines -= 1
        return super(FastIO, self).readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.getvalue())
            self.truncate(0), self.seek(0)
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        if py2:
            self.write = self.buffer.write
            self.read = self.buffer.read
            self.readline = self.buffer.readline
        else:
            self.write = lambda s:self.buffer.write(s.encode('ascii'))
            self.read = lambda:self.buffer.read().decode('ascii')
            self.readline = lambda:self.buffer.readline().decode('ascii')
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip('\r\n')
 
# Cout implemented in Python
import sys
class ostream:
    def __lshift__(self,a):
        sys.stdout.write(str(a))
        return self
cout = ostream()
endl = '\n'
 
# Read all remaining integers in stdin, type is given by optional argument, this is fast
def readnumbers(zero = 0):
    conv = ord if py2 else lambda x:x
    A = []; numb = zero; sign = 1; i = 0; s = sys.stdin.buffer.read()
    try:
        while True:
            if s[i] >= b'R' [0]:
                numb = 10 * numb + conv(s[i]) - 48
            elif s[i] == b'-' [0]: sign = -1
            elif s[i] != b'\r' [0]:
                A.append(sign*numb)
                numb = zero; sign = 1
            i += 1
    except:pass
    if s and s[-1] >= b'R' [0]:
        A.append(sign*numb)
    return A
 
# threading.Thread(target=main).start()
if __name__== ""__main__"":
  main()","['greedy', 'sortings']"
2208,"Consider a football tournament where n teams participate. Each team has two football kits: for home games, and for away games. The kit for home games of the i-th team has color xi and the kit for away games of this team has color yi (xi ≠ yi).In the tournament, each team plays exactly one home game and exactly one away game with each other team (n(n - 1) games in total). The team, that plays the home game, traditionally plays in its home kit. The team that plays an away game plays in its away kit. However, if two teams has the kits of the same color, they cannot be distinguished. In this case the away team plays in its home kit.Calculate how many games in the described tournament each team plays in its home kit and how many games it plays in its away kit. nan from collections import Counter
n = int(input())
x = []
y = []
for i in range(n):
	a, b = [int(tmp) for tmp in input().split()]
	x.append(a)
	y.append(b)
cnt = Counter(x)
for i in range(n):
	t = cnt[y[i]]
	print(n - 1 + t, n - 1 - t)
","['brute force', 'greedy', 'implementation']"
1578,"While looking at the kitchen fridge, the little boy Tyler noticed magnets with symbols, that can be aligned into a string $$$s$$$.Tyler likes strings, and especially those that are lexicographically smaller than another string, $$$t$$$. After playing with magnets on the fridge, he is wondering, how many distinct strings can be composed out of letters of string $$$s$$$ by rearranging them, so that the resulting string is lexicographically smaller than the string $$$t$$$? Tyler is too young, so he can't answer this question. The alphabet Tyler uses is very large, so for your convenience he has already replaced the same letters in $$$s$$$ and $$$t$$$ to the same integers, keeping that different letters have been replaced to different integers.We call a string $$$x$$$ lexicographically smaller than a string $$$y$$$ if one of the followings conditions is fulfilled:   There exists such position of symbol $$$m$$$ that is presented in both strings, so that before $$$m$$$-th symbol the strings are equal, and the $$$m$$$-th symbol of string $$$x$$$ is smaller than $$$m$$$-th symbol of string $$$y$$$.  String $$$x$$$ is the prefix of string $$$y$$$ and $$$x \neq y$$$. Because the answer can be too large, print it modulo $$$998\,244\,353$$$. NoteIn the first example, the strings we are interested in are $$$[1\, 2\, 2]$$$ and $$$[2\, 1\, 2]$$$. The string $$$[2\, 2\, 1]$$$ is lexicographically larger than the string $$$[2\, 1\, 2\, 1]$$$, so we don't count it.In the second example, all strings count except $$$[4\, 3\, 2\, 1]$$$, so the answer is $$$4! - 1 = 23$$$.In the third example, only the string $$$[1\, 1\, 1\, 2]$$$ counts. from __future__ import print_function

from bisect import bisect_left, bisect_right, insort
from collections import Sequence, MutableSequence
from functools import wraps
from itertools import chain, repeat, starmap
from math import log as log_e
import operator as op
from operator import iadd, add
from sys import hexversion

if hexversion < 0x03000000:
    from itertools import izip as zip  
    from itertools import imap as map  
    try:
        from thread import get_ident
    except ImportError:
        from dummy_thread import get_ident
else:
    from functools import reduce
    try:
        from _thread import get_ident
    except ImportError:
        from _dummy_thread import get_ident 
LOAD = 1000

def recursive_repr(func):

    repr_running = set()

    @wraps(func)
    def wrapper(self):
        key = id(self), get_ident()

        if key in repr_running:
            return '...'

        repr_running.add(key)

        try:
            return func(self)
        finally:
            repr_running.discard(key)

    return wrapper

class SortedList(MutableSequence):

    def __init__(self, iterable=None):

        self._len = 0
        self._lists = []
        self._maxes = []
        self._index = []
        self._load = LOAD
        self._half = LOAD >> 1
        self._dual = LOAD << 1
        self._offset = 0

        if iterable is not None:
            self._update(iterable)

    def __new__(cls, iterable=None, key=None):
        if key is None:
            return object.__new__(cls)
        else:
            if cls is SortedList:
                return object.__new__(SortedListWithKey)
            else:
                raise TypeError('inherit SortedListWithKey for key argument')

    @property
    def key(self):
        return None

    def _reset(self, load):
    
        values = reduce(iadd, self._lists, [])
        self._clear()
        self._load = load
        self._half = load >> 1
        self._dual = load << 1
        self._update(values)

    def clear(self):
        self._len = 0
        del self._lists[:]
        del self._maxes[:]
        del self._index[:]

    _clear = clear

    def add(self, val):
        _lists = self._lists
        _maxes = self._maxes

        if _maxes:
            pos = bisect_right(_maxes, val)

            if pos == len(_maxes):
                pos -= 1
                _lists[pos].append(val)
                _maxes[pos] = val
            else:
                insort(_lists[pos], val)

            self._expand(pos)
        else:
            _lists.append([val])
            _maxes.append(val)

        self._len += 1

    def _expand(self, pos):
        _lists = self._lists
        _index = self._index

        if len(_lists[pos]) > self._dual:
            _maxes = self._maxes
            _load = self._load

            _lists_pos = _lists[pos]
            half = _lists_pos[_load:]
            del _lists_pos[_load:]
            _maxes[pos] = _lists_pos[-1]

            _lists.insert(pos + 1, half)
            _maxes.insert(pos + 1, half[-1])

            del _index[:]
        else:
            if _index:
                child = self._offset + pos
                while child:
                    _index[child] += 1
                    child = (child - 1) >> 1
                _index[0] += 1

    def update(self, iterable):
        _lists = self._lists
        _maxes = self._maxes
        values = sorted(iterable)

        if _maxes:
            if len(values) * 4 >= self._len:
                values.extend(chain.from_iterable(_lists))
                values.sort()
                self._clear()
            else:
                _add = self.add
                for val in values:
                    _add(val)
                return

        _load = self._load
        _lists.extend(values[pos:(pos + _load)]
                      for pos in range(0, len(values), _load))
        _maxes.extend(sublist[-1] for sublist in _lists)
        self._len = len(values)
        del self._index[:]

    _update = update

    def __contains__(self, val):
        _maxes = self._maxes

        if not _maxes:
            return False

        pos = bisect_left(_maxes, val)

        if pos == len(_maxes):
            return False

        _lists = self._lists
        idx = bisect_left(_lists[pos], val)

        return _lists[pos][idx] == val

    def discard(self, val):
        _maxes = self._maxes

        if not _maxes:
            return

        pos = bisect_left(_maxes, val)

        if pos == len(_maxes):
            return

        _lists = self._lists
        idx = bisect_left(_lists[pos], val)

        if _lists[pos][idx] == val:
            self._delete(pos, idx)

    def remove(self, val):
        _maxes = self._maxes

        if not _maxes:
            raise ValueError('{0!r} not in list'.format(val))

        pos = bisect_left(_maxes, val)

        if pos == len(_maxes):
            raise ValueError('{0!r} not in list'.format(val))

        _lists = self._lists
        idx = bisect_left(_lists[pos], val)

        if _lists[pos][idx] == val:
            self._delete(pos, idx)
        else:
            raise ValueError('{0!r} not in list'.format(val))

    def _delete(self, pos, idx):
        _lists = self._lists
        _maxes = self._maxes
        _index = self._index

        _lists_pos = _lists[pos]

        del _lists_pos[idx]
        self._len -= 1

        len_lists_pos = len(_lists_pos)

        if len_lists_pos > self._half:

            _maxes[pos] = _lists_pos[-1]

            if _index:
                child = self._offset + pos
                while child > 0:
                    _index[child] -= 1
                    child = (child - 1) >> 1
                _index[0] -= 1

        elif len(_lists) > 1:

            if not pos:
                pos += 1

            prev = pos - 1
            _lists[prev].extend(_lists[pos])
            _maxes[prev] = _lists[prev][-1]

            del _lists[pos]
            del _maxes[pos]
            del _index[:]

            self._expand(prev)

        elif len_lists_pos:

            _maxes[pos] = _lists_pos[-1]

        else:

            del _lists[pos]
            del _maxes[pos]
            del _index[:]

    def _loc(self, pos, idx):
    
        if not pos:
            return idx

        _index = self._index

        if not _index:
            self._build_index()

        total = 0

        pos += self._offset

        while pos:

            if not pos & 1:
                total += _index[pos - 1]

            pos = (pos - 1) >> 1

        return total + idx

    def _pos(self, idx):

        if idx < 0:
            last_len = len(self._lists[-1])

            if (-idx) <= last_len:
                return len(self._lists) - 1, last_len + idx

            idx += self._len

            if idx < 0:
                raise IndexError('list index out of range')
        elif idx >= self._len:
            raise IndexError('list index out of range')

        if idx < len(self._lists[0]):
            return 0, idx

        _index = self._index

        if not _index:
            self._build_index()

        pos = 0
        child = 1
        len_index = len(_index)

        while child < len_index:
            index_child = _index[child]

            if idx < index_child:
                pos = child
            else:
                idx -= index_child
                pos = child + 1

            child = (pos << 1) + 1

        return (pos - self._offset, idx)

    def _build_index(self):
    
        row0 = list(map(len, self._lists))

        if len(row0) == 1:
            self._index[:] = row0
            self._offset = 0
            return

        head = iter(row0)
        tail = iter(head)
        row1 = list(starmap(add, zip(head, tail)))

        if len(row0) & 1:
            row1.append(row0[-1])

        if len(row1) == 1:
            self._index[:] = row1 + row0
            self._offset = 1
            return

        size = 2 ** (int(log_e(len(row1) - 1, 2)) + 1)
        row1.extend(repeat(0, size - len(row1)))
        tree = [row0, row1]

        while len(tree[-1]) > 1:
            head = iter(tree[-1])
            tail = iter(head)
            row = list(starmap(add, zip(head, tail)))
            tree.append(row)

        reduce(iadd, reversed(tree), self._index)
        self._offset = size * 2 - 1

    def __delitem__(self, idx):
        if isinstance(idx, slice):
            start, stop, step = idx.indices(self._len)

            if step == 1 and start < stop:
                if start == 0 and stop == self._len:
                    return self._clear()
                elif self._len <= 8 * (stop - start):
                    values = self._getitem(slice(None, start))
                    if stop < self._len:
                        values += self._getitem(slice(stop, None))
                    self._clear()
                    return self._update(values)

            indices = range(start, stop, step)


            if step > 0:
                indices = reversed(indices)

            _pos, _delete = self._pos, self._delete

            for index in indices:
                pos, idx = _pos(index)
                _delete(pos, idx)
        else:
            pos, idx = self._pos(idx)
            self._delete(pos, idx)

    _delitem = __delitem__

    def __getitem__(self, idx):
        _lists = self._lists

        if isinstance(idx, slice):
            start, stop, step = idx.indices(self._len)

            if step == 1 and start < stop:
                if start == 0 and stop == self._len:
                    return reduce(iadd, self._lists, [])

                start_pos, start_idx = self._pos(start)

                if stop == self._len:
                    stop_pos = len(_lists) - 1
                    stop_idx = len(_lists[stop_pos])
                else:
                    stop_pos, stop_idx = self._pos(stop)

                if start_pos == stop_pos:
                    return _lists[start_pos][start_idx:stop_idx]

                prefix = _lists[start_pos][start_idx:]
                middle = _lists[(start_pos + 1):stop_pos]
                result = reduce(iadd, middle, prefix)
                result += _lists[stop_pos][:stop_idx]

                return result

            if step == -1 and start > stop:
                result = self._getitem(slice(stop + 1, start + 1))
                result.reverse()
                return result

            indices = range(start, stop, step)
            return list(self._getitem(index) for index in indices)
        else:
            if self._len:
                if idx == 0:
                    return _lists[0][0]
                elif idx == -1:
                    return _lists[-1][-1]
            else:
                raise IndexError('list index out of range')

            if 0 <= idx < len(_lists[0]):
                return _lists[0][idx]

            len_last = len(_lists[-1])

            if -len_last < idx < 0:
                return _lists[-1][len_last + idx]

            pos, idx = self._pos(idx)
            return _lists[pos][idx]

    _getitem = __getitem__

    def _check_order(self, idx, val):
        _len = self._len
        _lists = self._lists

        pos, loc = self._pos(idx)

        if idx < 0:
            idx += _len

        if idx > 0:
            idx_prev = loc - 1
            pos_prev = pos

            if idx_prev < 0:
                pos_prev -= 1
                idx_prev = len(_lists[pos_prev]) - 1

            if _lists[pos_prev][idx_prev] > val:
                msg = '{0!r} not in sort order at index {1}'.format(val, idx)
                raise ValueError(msg)

        if idx < (_len - 1):
            idx_next = loc + 1
            pos_next = pos

            if idx_next == len(_lists[pos_next]):
                pos_next += 1
                idx_next = 0

            if _lists[pos_next][idx_next] < val:
                msg = '{0!r} not in sort order at index {1}'.format(val, idx)
                raise ValueError(msg)

    def __setitem__(self, index, value):
        _lists = self._lists
        _maxes = self._maxes
        _check_order = self._check_order
        _pos = self._pos

        if isinstance(index, slice):
            _len = self._len
            start, stop, step = index.indices(_len)
            indices = range(start, stop, step)

            values = tuple(value)

            if step != 1:
                if len(values) != len(indices):
                    raise ValueError(
                        'attempt to assign sequence of size %s'
                        ' to extended slice of size %s'
                        % (len(values), len(indices)))


                log = []
                _append = log.append

                for idx, val in zip(indices, values):
                    pos, loc = _pos(idx)
                    _append((idx, _lists[pos][loc], val))
                    _lists[pos][loc] = val
                    if len(_lists[pos]) == (loc + 1):
                        _maxes[pos] = val

                try:
                    for idx, _, newval in log:
                        _check_order(idx, newval)

                except ValueError:

                    for idx, oldval, _ in log:
                        pos, loc = _pos(idx)
                        _lists[pos][loc] = oldval
                        if len(_lists[pos]) == (loc + 1):
                            _maxes[pos] = oldval

                    raise
            else:
                if start == 0 and stop == _len:
                    self._clear()
                    return self._update(values)

                if stop < start:
                    stop = start

                if values:

                    alphas = iter(values)
                    betas = iter(values)
                    next(betas)
                    pairs = zip(alphas, betas)

                    if not all(alpha <= beta for alpha, beta in pairs):
                        raise ValueError('given values not in sort order')

                    if start and self._getitem(start - 1) > values[0]:
                        message = '{0!r} not in sort order at index {1}'.format(
                            values[0], start)
                        raise ValueError(message)

                    if stop != _len and self._getitem(stop) < values[-1]:
                        message = '{0!r} not in sort order at index {1}'.format(
                            values[-1], stop)
                        raise ValueError(message)

                self._delitem(index)

                _insert = self.insert
                for idx, val in enumerate(values):
                    _insert(start + idx, val)
        else:
            pos, loc = _pos(index)
            _check_order(index, value)
            _lists[pos][loc] = value
            if len(_lists[pos]) == (loc + 1):
                _maxes[pos] = value

    def __iter__(self):
        return chain.from_iterable(self._lists)

    def __reversed__(self):
        return chain.from_iterable(map(reversed, reversed(self._lists)))

    def reverse(self):
    
        raise NotImplementedError('.reverse() not defined')

    def islice(self, start=None, stop=None, reverse=False):

    
        _len = self._len

        if not _len:
            return iter(())

        start, stop, _ = slice(start, stop).indices(self._len)

        if start >= stop:
            return iter(())

        _pos = self._pos

        min_pos, min_idx = _pos(start)

        if stop == _len:
            max_pos = len(self._lists) - 1
            max_idx = len(self._lists[-1])
        else:
            max_pos, max_idx = _pos(stop)

        return self._islice(min_pos, min_idx, max_pos, max_idx, reverse)

    def _islice(self, min_pos, min_idx, max_pos, max_idx, reverse):
    
        _lists = self._lists

        if min_pos > max_pos:
            return iter(())
        elif min_pos == max_pos and not reverse:
            return iter(_lists[min_pos][min_idx:max_idx])
        elif min_pos == max_pos and reverse:
            return reversed(_lists[min_pos][min_idx:max_idx])
        elif min_pos + 1 == max_pos and not reverse:
            return chain(_lists[min_pos][min_idx:], _lists[max_pos][:max_idx])
        elif min_pos + 1 == max_pos and reverse:
            return chain(
                reversed(_lists[max_pos][:max_idx]),
                reversed(_lists[min_pos][min_idx:]),
            )
        elif not reverse:
            return chain(
                _lists[min_pos][min_idx:],
                chain.from_iterable(_lists[(min_pos + 1):max_pos]),
                _lists[max_pos][:max_idx],
            )

        temp = map(reversed, reversed(_lists[(min_pos + 1):max_pos]))
        return chain(
            reversed(_lists[max_pos][:max_idx]),
            chain.from_iterable(temp),
            reversed(_lists[min_pos][min_idx:]),
        )

    def irange(self, minimum=None, maximum=None, inclusive=(True, True),
               reverse=False):
    
        _maxes = self._maxes

        if not _maxes:
            return iter(())

        _lists = self._lists


        if minimum is None:
            min_pos = 0
            min_idx = 0
        else:
            if inclusive[0]:
                min_pos = bisect_left(_maxes, minimum)

                if min_pos == len(_maxes):
                    return iter(())

                min_idx = bisect_left(_lists[min_pos], minimum)
            else:
                min_pos = bisect_right(_maxes, minimum)

                if min_pos == len(_maxes):
                    return iter(())

                min_idx = bisect_right(_lists[min_pos], minimum)


        if maximum is None:
            max_pos = len(_maxes) - 1
            max_idx = len(_lists[max_pos])
        else:
            if inclusive[1]:
                max_pos = bisect_right(_maxes, maximum)

                if max_pos == len(_maxes):
                    max_pos -= 1
                    max_idx = len(_lists[max_pos])
                else:
                    max_idx = bisect_right(_lists[max_pos], maximum)
            else:
                max_pos = bisect_left(_maxes, maximum)

                if max_pos == len(_maxes):
                    max_pos -= 1
                    max_idx = len(_lists[max_pos])
                else:
                    max_idx = bisect_left(_lists[max_pos], maximum)

        return self._islice(min_pos, min_idx, max_pos, max_idx, reverse)

    def __len__(self):
        return self._len

    def bisect_left(self, val):
        _maxes = self._maxes

        if not _maxes:
            return 0

        pos = bisect_left(_maxes, val)

        if pos == len(_maxes):
            return self._len

        idx = bisect_left(self._lists[pos], val)

        return self._loc(pos, idx)

    def bisect_right(self, val):

        _maxes = self._maxes

        if not _maxes:
            return 0

        pos = bisect_right(_maxes, val)

        if pos == len(_maxes):
            return self._len

        idx = bisect_right(self._lists[pos], val)

        return self._loc(pos, idx)

    bisect = bisect_right
    _bisect_right = bisect_right

    def count(self, val):
        _maxes = self._maxes

        if not _maxes:
            return 0

        pos_left = bisect_left(_maxes, val)

        if pos_left == len(_maxes):
            return 0

        _lists = self._lists
        idx_left = bisect_left(_lists[pos_left], val)
        pos_right = bisect_right(_maxes, val)

        if pos_right == len(_maxes):
            return self._len - self._loc(pos_left, idx_left)

        idx_right = bisect_right(_lists[pos_right], val)

        if pos_left == pos_right:
            return idx_right - idx_left

        right = self._loc(pos_right, idx_right)
        left = self._loc(pos_left, idx_left)

        return right - left

    def copy(self):
        return self.__class__(self)

    __copy__ = copy

    def append(self, val):
        _lists = self._lists
        _maxes = self._maxes

        if not _maxes:
            _maxes.append(val)
            _lists.append([val])
            self._len = 1
            return

        pos = len(_lists) - 1

        if val < _lists[pos][-1]:
            msg = '{0!r} not in sort order at index {1}'.format(val, self._len)
            raise ValueError(msg)

        _maxes[pos] = val
        _lists[pos].append(val)
        self._len += 1
        self._expand(pos)

    def extend(self, values):
        _lists = self._lists
        _maxes = self._maxes
        _load = self._load

        if not isinstance(values, list):
            values = list(values)

        if not values:
            return

        if any(values[pos - 1] > values[pos]
               for pos in range(1, len(values))):
            raise ValueError('given sequence not in sort order')

        offset = 0

        if _maxes:
            if values[0] < _lists[-1][-1]:
                msg = '{0!r} not in sort order at index {1}'.format(values[0], self._len)
                raise ValueError(msg)

            if len(_lists[-1]) < self._half:
                _lists[-1].extend(values[:_load])
                _maxes[-1] = _lists[-1][-1]
                offset = _load

        len_lists = len(_lists)

        for idx in range(offset, len(values), _load):
            _lists.append(values[idx:(idx + _load)])
            _maxes.append(_lists[-1][-1])

        _index = self._index

        if len_lists == len(_lists):
            len_index = len(_index)
            if len_index > 0:
                len_values = len(values)
                child = len_index - 1
                while child:
                    _index[child] += len_values
                    child = (child - 1) >> 1
                _index[0] += len_values
        else:
            del _index[:]

        self._len += len(values)

    def insert(self, idx, val):
        _len = self._len
        _lists = self._lists
        _maxes = self._maxes

        if idx < 0:
            idx += _len
        if idx < 0:
            idx = 0
        if idx > _len:
            idx = _len

        if not _maxes:
            _maxes.append(val)
            _lists.append([val])
            self._len = 1
            return

        if not idx:
            if val > _lists[0][0]:
                msg = '{0!r} not in sort order at index {1}'.format(val, 0)
                raise ValueError(msg)
            else:
                _lists[0].insert(0, val)
                self._expand(0)
                self._len += 1
                return

        if idx == _len:
            pos = len(_lists) - 1
            if _lists[pos][-1] > val:
                msg = '{0!r} not in sort order at index {1}'.format(val, _len)
                raise ValueError(msg)
            else:
                _lists[pos].append(val)
                _maxes[pos] = _lists[pos][-1]
                self._expand(pos)
                self._len += 1
                return

        pos, idx = self._pos(idx)
        idx_before = idx - 1
        if idx_before < 0:
            pos_before = pos - 1
            idx_before = len(_lists[pos_before]) - 1
        else:
            pos_before = pos

        before = _lists[pos_before][idx_before]
        if before <= val <= _lists[pos][idx]:
            _lists[pos].insert(idx, val)
            self._expand(pos)
            self._len += 1
        else:
            msg = '{0!r} not in sort order at index {1}'.format(val, idx)
            raise ValueError(msg)

    def pop(self, idx=-1):
        if not self._len:
            raise IndexError('pop index out of range')

        _lists = self._lists

        if idx == 0:
            val = _lists[0][0]
            self._delete(0, 0)
            return val

        if idx == -1:
            pos = len(_lists) - 1
            loc = len(_lists[pos]) - 1
            val = _lists[pos][loc]
            self._delete(pos, loc)
            return val

        if 0 <= idx < len(_lists[0]):
            val = _lists[0][idx]
            self._delete(0, idx)
            return val

        len_last = len(_lists[-1])

        if -len_last < idx < 0:
            pos = len(_lists) - 1
            loc = len_last + idx
            val = _lists[pos][loc]
            self._delete(pos, loc)
            return val

        pos, idx = self._pos(idx)
        val = _lists[pos][idx]
        self._delete(pos, idx)

        return val

    def index(self, val, start=None, stop=None):
    
        _len = self._len

        if not _len:
            raise ValueError('{0!r} is not in list'.format(val))

        if start is None:
            start = 0
        if start < 0:
            start += _len
        if start < 0:
            start = 0

        if stop is None:
            stop = _len
        if stop < 0:
            stop += _len
        if stop > _len:
            stop = _len

        if stop <= start:
            raise ValueError('{0!r} is not in list'.format(val))

        _maxes = self._maxes
        pos_left = bisect_left(_maxes, val)

        if pos_left == len(_maxes):
            raise ValueError('{0!r} is not in list'.format(val))

        _lists = self._lists
        idx_left = bisect_left(_lists[pos_left], val)

        if _lists[pos_left][idx_left] != val:
            raise ValueError('{0!r} is not in list'.format(val))

        stop -= 1
        left = self._loc(pos_left, idx_left)

        if start <= left:
            if left <= stop:
                return left
        else:
            right = self._bisect_right(val) - 1

            if start <= right:
                return start

        raise ValueError('{0!r} is not in list'.format(val))

    def __add__(self, that):
        
        values = reduce(iadd, self._lists, [])
        values.extend(that)
        return self.__class__(values)

    def __iadd__(self, that):

        self._update(that)
        return self

    def __mul__(self, that):

        values = reduce(iadd, self._lists, []) * that
        return self.__class__(values)

    def __imul__(self, that):

        values = reduce(iadd, self._lists, []) * that
        self._clear()
        self._update(values)
        return self

    def _make_cmp(self, seq_op, doc):
        def comparer(self, that):
            if not isinstance(that, Sequence):
                return NotImplemented

            self_len = self._len
            len_that = len(that)

            if self_len != len_that:
                if seq_op is op.eq:
                    return False
                if seq_op is op.ne:
                    return True

            for alpha, beta in zip(self, that):
                if alpha != beta:
                    return seq_op(alpha, beta)

            return seq_op(self_len, len_that)

        comparer.__name__ = '__{0}__'.format(seq_op.__name__)
        doc_str = 'Return `True` if and only if Sequence is {0} `that`.'
        comparer.__doc__ = doc_str.format(doc)

        return comparer

    __eq__ = _make_cmp(None, op.eq, 'equal to')
    __ne__ = _make_cmp(None, op.ne, 'not equal to')
    __lt__ = _make_cmp(None, op.lt, 'less than')
    __gt__ = _make_cmp(None, op.gt, 'greater than')
    __le__ = _make_cmp(None, op.le, 'less than or equal to')
    __ge__ = _make_cmp(None, op.ge, 'greater than or equal to')

    @recursive_repr
    def __repr__(self):
        return '{0}({1!r})'.format(type(self).__name__, list(self))

    def _check(self):
        try:

            assert self._load >= 4
            assert self._half == (self._load >> 1)
            assert self._dual == (self._load << 1)


            if self._maxes == []:
                assert self._lists == []
                return

            assert self._maxes and self._lists


            assert all(sublist[pos - 1] <= sublist[pos]
                       for sublist in self._lists
                       for pos in range(1, len(sublist)))


            for pos in range(1, len(self._lists)):
                assert self._lists[pos - 1][-1] <= self._lists[pos][0]


            assert len(self._maxes) == len(self._lists)


            assert all(self._maxes[pos] == self._lists[pos][-1]
                       for pos in range(len(self._maxes)))


            assert all(len(sublist) <= self._dual for sublist in self._lists)


            assert all(len(self._lists[pos]) >= self._half
                       for pos in range(0, len(self._lists) - 1))



            assert self._len == sum(len(sublist) for sublist in self._lists)



            if self._index:
                assert len(self._index) == self._offset + len(self._lists)
                assert self._len == self._index[0]

                def test_offset_pos(pos):
                    from_index = self._index[self._offset + pos]
                    return from_index == len(self._lists[pos])

                assert all(test_offset_pos(pos)
                           for pos in range(len(self._lists)))

                for pos in range(self._offset):
                    child = (pos << 1) + 1
                    if child >= len(self._index):
                        assert self._index[pos] == 0
                    elif child + 1 == len(self._index):
                        assert self._index[pos] == self._index[child]
                    else:
                        child_sum = self._index[child] + self._index[child + 1]
                        assert self._index[pos] == child_sum

        except:
            import sys
            import traceback

            traceback.print_exc(file=sys.stdout)

            print('len', self._len)
            print('load', self._load, self._half, self._dual)
            print('offset', self._offset)
            print('len_index', len(self._index))
            print('index', self._index)
            print('len_maxes', len(self._maxes))
            print('maxes', self._maxes)
            print('len_lists', len(self._lists))
            print('lists', self._lists)

            raise

def identity(value):
    return value

class SortedListWithKey(SortedList):

    def __init__(self, iterable=None, key=identity):

        self._len = 0
        self._lists = []
        self._keys = []
        self._maxes = []
        self._index = []
        self._key = key
        self._load = LOAD
        self._half = LOAD >> 1
        self._dual = LOAD << 1
        self._offset = 0

        if iterable is not None:
            self._update(iterable)

    def __new__(cls, iterable=None, key=identity):
        return object.__new__(cls)

    @property
    def key(self):
        return self._key

    def clear(self):
        self._len = 0
        del self._lists[:]
        del self._keys[:]
        del self._maxes[:]
        del self._index[:]

    _clear = clear

    def add(self, val):
        _lists = self._lists
        _keys = self._keys
        _maxes = self._maxes

        key = self._key(val)

        if _maxes:
            pos = bisect_right(_maxes, key)

            if pos == len(_maxes):
                pos -= 1
                _lists[pos].append(val)
                _keys[pos].append(key)
                _maxes[pos] = key
            else:
                idx = bisect_right(_keys[pos], key)
                _lists[pos].insert(idx, val)
                _keys[pos].insert(idx, key)

            self._expand(pos)
        else:
            _lists.append([val])
            _keys.append([key])
            _maxes.append(key)

        self._len += 1

    def _expand(self, pos):

        _lists = self._lists
        _keys = self._keys
        _index = self._index

        if len(_keys[pos]) > self._dual:
            _maxes = self._maxes
            _load = self._load

            _lists_pos = _lists[pos]
            _keys_pos = _keys[pos]
            half = _lists_pos[_load:]
            half_keys = _keys_pos[_load:]
            del _lists_pos[_load:]
            del _keys_pos[_load:]
            _maxes[pos] = _keys_pos[-1]

            _lists.insert(pos + 1, half)
            _keys.insert(pos + 1, half_keys)
            _maxes.insert(pos + 1, half_keys[-1])

            del _index[:]
        else:
            if _index:
                child = self._offset + pos
                while child:
                    _index[child] += 1
                    child = (child - 1) >> 1
                _index[0] += 1

    def update(self, iterable):
        _lists = self._lists
        _keys = self._keys
        _maxes = self._maxes
        values = sorted(iterable, key=self._key)

        if _maxes:
            if len(values) * 4 >= self._len:
                values.extend(chain.from_iterable(_lists))
                values.sort(key=self._key)
                self._clear()
            else:
                _add = self.add
                for val in values:
                    _add(val)
                return

        _load = self._load
        _lists.extend(values[pos:(pos + _load)]
                      for pos in range(0, len(values), _load))
        _keys.extend(list(map(self._key, _list)) for _list in _lists)
        _maxes.extend(sublist[-1] for sublist in _keys)
        self._len = len(values)
        del self._index[:]

    _update = update

    def __contains__(self, val):
        _maxes = self._maxes

        if not _maxes:
            return False

        key = self._key(val)
        pos = bisect_left(_maxes, key)

        if pos == len(_maxes):
            return False

        _lists = self._lists
        _keys = self._keys

        idx = bisect_left(_keys[pos], key)

        len_keys = len(_keys)
        len_sublist = len(_keys[pos])

        while True:
            if _keys[pos][idx] != key:
                return False
            if _lists[pos][idx] == val:
                return True
            idx += 1
            if idx == len_sublist:
                pos += 1
                if pos == len_keys:
                    return False
                len_sublist = len(_keys[pos])
                idx = 0

    def discard(self, val):

        _maxes = self._maxes

        if not _maxes:
            return

        key = self._key(val)
        pos = bisect_left(_maxes, key)

        if pos == len(_maxes):
            return

        _lists = self._lists
        _keys = self._keys
        idx = bisect_left(_keys[pos], key)
        len_keys = len(_keys)
        len_sublist = len(_keys[pos])

        while True:
            if _keys[pos][idx] != key:
                return
            if _lists[pos][idx] == val:
                self._delete(pos, idx)
                return
            idx += 1
            if idx == len_sublist:
                pos += 1
                if pos == len_keys:
                    return
                len_sublist = len(_keys[pos])
                idx = 0

    def remove(self, val):

        _maxes = self._maxes

        if not _maxes:
            raise ValueError('{0!r} not in list'.format(val))

        key = self._key(val)
        pos = bisect_left(_maxes, key)

        if pos == len(_maxes):
            raise ValueError('{0!r} not in list'.format(val))

        _lists = self._lists
        _keys = self._keys
        idx = bisect_left(_keys[pos], key)
        len_keys = len(_keys)
        len_sublist = len(_keys[pos])

        while True:
            if _keys[pos][idx] != key:
                raise ValueError('{0!r} not in list'.format(val))
            if _lists[pos][idx] == val:
                self._delete(pos, idx)
                return
            idx += 1
            if idx == len_sublist:
                pos += 1
                if pos == len_keys:
                    raise ValueError('{0!r} not in list'.format(val))
                len_sublist = len(_keys[pos])
                idx = 0

    def _delete(self, pos, idx):

        _lists = self._lists
        _keys = self._keys
        _maxes = self._maxes
        _index = self._index
        keys_pos = _keys[pos]
        lists_pos = _lists[pos]

        del keys_pos[idx]
        del lists_pos[idx]
        self._len -= 1

        len_keys_pos = len(keys_pos)

        if len_keys_pos > self._half:

            _maxes[pos] = keys_pos[-1]

            if _index:
                child = self._offset + pos
                while child > 0:
                    _index[child] -= 1
                    child = (child - 1) >> 1
                _index[0] -= 1

        elif len(_keys) > 1:

            if not pos:
                pos += 1

            prev = pos - 1
            _keys[prev].extend(_keys[pos])
            _lists[prev].extend(_lists[pos])
            _maxes[prev] = _keys[prev][-1]

            del _lists[pos]
            del _keys[pos]
            del _maxes[pos]
            del _index[:]

            self._expand(prev)

        elif len_keys_pos:

            _maxes[pos] = keys_pos[-1]

        else:

            del _lists[pos]
            del _keys[pos]
            del _maxes[pos]
            del _index[:]

    def _check_order(self, idx, key, val):
        _len = self._len
        _keys = self._keys

        pos, loc = self._pos(idx)

        if idx < 0:
            idx += _len



        if idx > 0:
            idx_prev = loc - 1
            pos_prev = pos

            if idx_prev < 0:
                pos_prev -= 1
                idx_prev = len(_keys[pos_prev]) - 1

            if _keys[pos_prev][idx_prev] > key:
                msg = '{0!r} not in sort order at index {1}'.format(val, idx)
                raise ValueError(msg)



        if idx < (_len - 1):
            idx_next = loc + 1
            pos_next = pos

            if idx_next == len(_keys[pos_next]):
                pos_next += 1
                idx_next = 0

            if _keys[pos_next][idx_next] < key:
                msg = '{0!r} not in sort order at index {1}'.format(val, idx)
                raise ValueError(msg)

    def __setitem__(self, index, value):

        _lists = self._lists
        _keys = self._keys
        _maxes = self._maxes
        _check_order = self._check_order
        _pos = self._pos

        if isinstance(index, slice):
            _len = self._len
            start, stop, step = index.indices(_len)
            indices = range(start, stop, step)



            values = tuple(value)

            if step != 1:
                if len(values) != len(indices):
                    raise ValueError(
                        'attempt to assign sequence of size %s'
                        ' to extended slice of size %s'
                        % (len(values), len(indices)))


                log = []
                _append = log.append

                for idx, val in zip(indices, values):
                    pos, loc = _pos(idx)
                    key = self._key(val)
                    _append((idx, _keys[pos][loc], key, _lists[pos][loc], val))
                    _keys[pos][loc] = key
                    _lists[pos][loc] = val
                    if len(_keys[pos]) == (loc + 1):
                        _maxes[pos] = key

                try:

                    for idx, oldkey, newkey, oldval, newval in log:
                        _check_order(idx, newkey, newval)

                except ValueError:


                    for idx, oldkey, newkey, oldval, newval in log:
                        pos, loc = _pos(idx)
                        _keys[pos][loc] = oldkey
                        _lists[pos][loc] = oldval
                        if len(_keys[pos]) == (loc + 1):
                            _maxes[pos] = oldkey

                    raise
            else:
                if start == 0 and stop == self._len:
                    self._clear()
                    return self._update(values)

                if stop < start:

                    stop = start

                if values:


                    keys = tuple(map(self._key, values))
                    alphas = iter(keys)
                    betas = iter(keys)
                    next(betas)
                    pairs = zip(alphas, betas)

                    if not all(alpha <= beta for alpha, beta in pairs):
                        raise ValueError('given values not in sort order')


                    if start:
                        pos, loc = _pos(start - 1)
                        if _keys[pos][loc] > keys[0]:
                            msg = '{0!r} not in sort order at index {1}'.format(
                                values[0], start)
                            raise ValueError(msg)

                    if stop != _len:
                        pos, loc = _pos(stop)
                        if _keys[pos][loc] < keys[-1]:
                            msg = '{0!r} not in sort order at index {1}'.format(
                                values[-1], stop)
                            raise ValueError(msg)


                self._delitem(index)


                _insert = self.insert
                for idx, val in enumerate(values):
                    _insert(start + idx, val)
        else:
            pos, loc = _pos(index)
            key = self._key(value)
            _check_order(index, key, value)
            _lists[pos][loc] = value
            _keys[pos][loc] = key
            if len(_lists[pos]) == (loc + 1):
                _maxes[pos] = key

    def irange(self, minimum=None, maximum=None, inclusive=(True, True),
               reverse=False):
        
        minimum = self._key(minimum) if minimum is not None else None
        maximum = self._key(maximum) if maximum is not None else None
        return self._irange_key(
            min_key=minimum, max_key=maximum,
            inclusive=inclusive, reverse=reverse,
        )

    def irange_key(self, min_key=None, max_key=None, inclusive=(True, True),
                   reverse=False):
        
        _maxes = self._maxes

        if not _maxes:
            return iter(())

        _keys = self._keys



        if min_key is None:
            min_pos = 0
            min_idx = 0
        else:
            if inclusive[0]:
                min_pos = bisect_left(_maxes, min_key)

                if min_pos == len(_maxes):
                    return iter(())

                min_idx = bisect_left(_keys[min_pos], min_key)
            else:
                min_pos = bisect_right(_maxes, min_key)

                if min_pos == len(_maxes):
                    return iter(())

                min_idx = bisect_right(_keys[min_pos], min_key)



        if max_key is None:
            max_pos = len(_maxes) - 1
            max_idx = len(_keys[max_pos])
        else:
            if inclusive[1]:
                max_pos = bisect_right(_maxes, max_key)

                if max_pos == len(_maxes):
                    max_pos -= 1
                    max_idx = len(_keys[max_pos])
                else:
                    max_idx = bisect_right(_keys[max_pos], max_key)
            else:
                max_pos = bisect_left(_maxes, max_key)

                if max_pos == len(_maxes):
                    max_pos -= 1
                    max_idx = len(_keys[max_pos])
                else:
                    max_idx = bisect_left(_keys[max_pos], max_key)

        return self._islice(min_pos, min_idx, max_pos, max_idx, reverse)

    _irange_key = irange_key

    def bisect_left(self, val):

        return self._bisect_key_left(self._key(val))

    def bisect_right(self, val):

        return self._bisect_key_right(self._key(val))

    bisect = bisect_right

    def bisect_key_left(self, key):
        
        _maxes = self._maxes

        if not _maxes:
            return 0

        pos = bisect_left(_maxes, key)

        if pos == len(_maxes):
            return self._len

        idx = bisect_left(self._keys[pos], key)

        return self._loc(pos, idx)

    _bisect_key_left = bisect_key_left

    def bisect_key_right(self, key):

        _maxes = self._maxes

        if not _maxes:
            return 0

        pos = bisect_right(_maxes, key)

        if pos == len(_maxes):
            return self._len

        idx = bisect_right(self._keys[pos], key)

        return self._loc(pos, idx)

    bisect_key = bisect_key_right
    _bisect_key_right = bisect_key_right

    def count(self, val):
        _maxes = self._maxes

        if not _maxes:
            return 0

        key = self._key(val)
        pos = bisect_left(_maxes, key)

        if pos == len(_maxes):
            return 0

        _lists = self._lists
        _keys = self._keys
        idx = bisect_left(_keys[pos], key)
        total = 0
        len_keys = len(_keys)
        len_sublist = len(_keys[pos])

        while True:
            if _keys[pos][idx] != key:
                return total
            if _lists[pos][idx] == val:
                total += 1
            idx += 1
            if idx == len_sublist:
                pos += 1
                if pos == len_keys:
                    return total
                len_sublist = len(_keys[pos])
                idx = 0

    def copy(self):
        return self.__class__(self, key=self._key)

    __copy__ = copy

    def append(self, val):

        _lists = self._lists
        _keys = self._keys
        _maxes = self._maxes
        key = self._key(val)

        if not _maxes:
            _maxes.append(key)
            _keys.append([key])
            _lists.append([val])
            self._len = 1
            return

        pos = len(_keys) - 1

        if key < _keys[pos][-1]:
            msg = '{0!r} not in sort order at index {1}'.format(val, self._len)
            raise ValueError(msg)

        _lists[pos].append(val)
        _keys[pos].append(key)
        _maxes[pos] = key
        self._len += 1
        self._expand(pos)

    def extend(self, values):

        _lists = self._lists
        _keys = self._keys
        _maxes = self._maxes
        _load = self._load

        if not isinstance(values, list):
            values = list(values)

        keys = list(map(self._key, values))

        if any(keys[pos - 1] > keys[pos]
               for pos in range(1, len(keys))):
            raise ValueError('given sequence not in sort order')

        offset = 0

        if _maxes:
            if keys[0] < _keys[-1][-1]:
                msg = '{0!r} not in sort order at index {1}'.format(values[0], self._len)
                raise ValueError(msg)

            if len(_keys[-1]) < self._half:
                _lists[-1].extend(values[:_load])
                _keys[-1].extend(keys[:_load])
                _maxes[-1] = _keys[-1][-1]
                offset = _load

        len_keys = len(_keys)

        for idx in range(offset, len(keys), _load):
            _lists.append(values[idx:(idx + _load)])
            _keys.append(keys[idx:(idx + _load)])
            _maxes.append(_keys[-1][-1])

        _index = self._index

        if len_keys == len(_keys):
            len_index = len(_index)
            if len_index > 0:
                len_values = len(values)
                child = len_index - 1
                while child:
                    _index[child] += len_values
                    child = (child - 1) >> 1
                _index[0] += len_values
        else:
            del _index[:]

        self._len += len(values)

    def insert(self, idx, val):

        _len = self._len
        _lists = self._lists
        _keys = self._keys
        _maxes = self._maxes

        if idx < 0:
            idx += _len
        if idx < 0:
            idx = 0
        if idx > _len:
            idx = _len

        key = self._key(val)

        if not _maxes:
            self._len = 1
            _lists.append([val])
            _keys.append([key])
            _maxes.append(key)
            return

        if not idx:
            if key > _keys[0][0]:
                msg = '{0!r} not in sort order at index {1}'.format(val, 0)
                raise ValueError(msg)
            else:
                self._len += 1
                _lists[0].insert(0, val)
                _keys[0].insert(0, key)
                self._expand(0)
                return

        if idx == _len:
            pos = len(_keys) - 1
            if _keys[pos][-1] > key:
                msg = '{0!r} not in sort order at index {1}'.format(val, _len)
                raise ValueError(msg)
            else:
                self._len += 1
                _lists[pos].append(val)
                _keys[pos].append(key)
                _maxes[pos] = _keys[pos][-1]
                self._expand(pos)
                return

        pos, idx = self._pos(idx)
        idx_before = idx - 1
        if idx_before < 0:
            pos_before = pos - 1
            idx_before = len(_keys[pos_before]) - 1
        else:
            pos_before = pos

        before = _keys[pos_before][idx_before]
        if before <= key <= _keys[pos][idx]:
            self._len += 1
            _lists[pos].insert(idx, val)
            _keys[pos].insert(idx, key)
            self._expand(pos)
        else:
            msg = '{0!r} not in sort order at index {1}'.format(val, idx)
            raise ValueError(msg)

    def index(self, val, start=None, stop=None):

        _len = self._len

        if not _len:
            raise ValueError('{0!r} is not in list'.format(val))

        if start is None:
            start = 0
        if start < 0:
            start += _len
        if start < 0:
            start = 0

        if stop is None:
            stop = _len
        if stop < 0:
            stop += _len
        if stop > _len:
            stop = _len

        if stop <= start:
            raise ValueError('{0!r} is not in list'.format(val))

        _maxes = self._maxes
        key = self._key(val)
        pos = bisect_left(_maxes, key)

        if pos == len(_maxes):
            raise ValueError('{0!r} is not in list'.format(val))

        stop -= 1
        _lists = self._lists
        _keys = self._keys
        idx = bisect_left(_keys[pos], key)
        len_keys = len(_keys)
        len_sublist = len(_keys[pos])

        while True:
            if _keys[pos][idx] != key:
                raise ValueError('{0!r} is not in list'.format(val))
            if _lists[pos][idx] == val:
                loc = self._loc(pos, idx)
                if start <= loc <= stop:
                    return loc
                elif loc > stop:
                    break
            idx += 1
            if idx == len_sublist:
                pos += 1
                if pos == len_keys:
                    raise ValueError('{0!r} is not in list'.format(val))
                len_sublist = len(_keys[pos])
                idx = 0

        raise ValueError('{0!r} is not in list'.format(val))

    def __add__(self, that):

        values = reduce(iadd, self._lists, [])
        values.extend(that)
        return self.__class__(values, key=self._key)

    def __mul__(self, that):

        values = reduce(iadd, self._lists, []) * that
        return self.__class__(values, key=self._key)

    def __imul__(self, that):

        values = reduce(iadd, self._lists, []) * that
        self._clear()
        self._update(values)
        return self

    @recursive_repr
    def __repr__(self):
        name = type(self).__name__
        values = list(self)
        _key = self._key
        return '{0}({1!r}, key={2!r})'.format(name, values, _key)

    def _check(self):
        try:

            assert self._load >= 4
            assert self._half == (self._load >> 1)
            assert self._dual == (self._load << 1)


            if self._maxes == []:
                assert self._keys == []
                assert self._lists == []
                return

            assert self._maxes and self._keys and self._lists


            assert all(sublist[pos - 1] <= sublist[pos]
                       for sublist in self._keys
                       for pos in range(1, len(sublist)))


            for pos in range(1, len(self._keys)):
                assert self._keys[pos - 1][-1] <= self._keys[pos][0]


            assert len(self._maxes) == len(self._lists) == len(self._keys)


            assert all(len(val_list) == len(key_list)
                       for val_list, key_list in zip(self._lists, self._keys))
            assert all(self._key(val) == key for val, key in
                       zip((_val for _val_list in self._lists for _val in _val_list),
                           (_key for _key_list in self._keys for _key in _key_list)))


            assert all(self._maxes[pos] == self._keys[pos][-1]
                       for pos in range(len(self._maxes)))


            assert all(len(sublist) <= self._dual for sublist in self._lists)


            assert all(len(self._lists[pos]) >= self._half
                       for pos in range(0, len(self._lists) - 1))


            assert self._len == sum(len(sublist) for sublist in self._lists)

            if self._index:
                assert len(self._index) == self._offset + len(self._lists)
                assert self._len == self._index[0]

                def test_offset_pos(pos):
                    from_index = self._index[self._offset + pos]
                    return from_index == len(self._lists[pos])

                assert all(test_offset_pos(pos)
                           for pos in range(len(self._lists)))

                for pos in range(self._offset):
                    child = (pos << 1) + 1
                    if self._index[pos] == 0:
                        assert child >= len(self._index)
                    elif child + 1 == len(self._index):
                        assert self._index[pos] == self._index[child]
                    else:
                        child_sum = self._index[child] + self._index[child + 1]
                        assert self._index[pos] == child_sum
        except:
            import sys
            import traceback
            traceback.print_exc(file=sys.stdout)
            print('len', self._len)
            print('load', self._load, self._half, self._dual)
            print('offset', self._offset)
            print('len_index', len(self._index))
            print('index', self._index)
            print('len_maxes', len(self._maxes))
            print('maxes', self._maxes)
            print('len_keys', len(self._keys))
            print('keys', self._keys)
            print('len_lists', len(self._lists))
            print('lists', self._lists)
            raise


from collections import Counter
m,n = map(int,input().split())
s = list(map(int,input().split()))
t = list(map(int,input().split()))
def f(num):
    res = 1
    for i in range(1,num+1):
        res *= i
        res %= mod
    return res

ans = 0
mod = 998244353
cnt1 = Counter(s)
cnt2 = Counter(t)
a = f(m)
for v in cnt1.values():
    if v > 1:
        a *= pow(f(v),mod-2,mod)
        a %= mod
d = SortedList(s)
ok = True
ta = 0
for i in range(min(m,n)-1):
    k = t[i]
    a *= pow(m-i,mod-2,mod)
    idx1 = d.bisect_left(k)
    ans += a*(idx1)
    if cnt1[k] == 0:
        ok = False
        break
    a *= cnt1[k]
    a %= mod
    cnt1[k] -= 1
    d.pop(idx1)

i = min(m,n)-1
if ok:
    if m >= n:
        a *= pow(m-i,mod-2,mod)
        a %= mod
        idx1 = d.bisect_left(t[i])
        ans += a*(idx1)
    else:
        a *= pow(m-i,mod-2,mod)
        a %= mod
        idx1 = d.bisect_right(t[i])
        ans += a*(idx1)
print(ans%mod)","['combinatorics', 'data structures', 'dp', 'math']"
4365,"Two players decided to play one interesting card game.There is a deck of $$$n$$$ cards, with values from $$$1$$$ to $$$n$$$. The values of cards are pairwise different (this means that no two different cards have equal values). At the beginning of the game, the deck is completely distributed between players such that each player has at least one card. The game goes as follows: on each turn, each player chooses one of their cards (whichever they want) and puts on the table, so that the other player doesn't see which card they chose. After that, both cards are revealed, and the player, value of whose card was larger, takes both cards in his hand. Note that as all cards have different values, one of the cards will be strictly larger than the other one. Every card may be played any amount of times. The player loses if he doesn't have any cards.For example, suppose that $$$n = 5$$$, the first player has cards with values $$$2$$$ and $$$3$$$, and the second player has cards with values $$$1$$$, $$$4$$$, $$$5$$$. Then one possible flow of the game is:The first player chooses the card $$$3$$$. The second player chooses the card $$$1$$$. As $$$3&gt;1$$$, the first player gets both cards. Now the first player has cards $$$1$$$, $$$2$$$, $$$3$$$, the second player has cards $$$4$$$, $$$5$$$.The first player chooses the card $$$3$$$. The second player chooses the card $$$4$$$. As $$$3&lt;4$$$, the second player gets both cards. Now the first player has cards $$$1$$$, $$$2$$$. The second player has cards $$$3$$$, $$$4$$$, $$$5$$$.The first player chooses the card $$$1$$$. The second player chooses the card $$$3$$$. As $$$1&lt;3$$$, the second player gets both cards. Now the first player has only the card $$$2$$$. The second player has cards $$$1$$$, $$$3$$$, $$$4$$$, $$$5$$$.The first player chooses the card $$$2$$$. The second player chooses the card $$$4$$$. As $$$2&lt;4$$$, the second player gets both cards. Now the first player is out of cards and loses. Therefore, the second player wins.Who will win if both players are playing optimally? It can be shown that one of the players has a winning strategy. NoteIn the first test case of the example, there is only one possible move for every player: the first player will put $$$2$$$, the second player will put $$$1$$$. $$$2&gt;1$$$, so the first player will get both cards and will win.In the second test case of the example, it can be shown that it is the second player who has a winning strategy. One possible flow of the game is illustrated in the statement. t=input()
for i in xrange(t):
    n,k1,k2=map(int, raw_input().split())
    a=map(int, raw_input().split())
    b=map(int, raw_input().split())
    if n in a:
        print ""YES""
    else:
        print ""NO""","['games', 'greedy', 'math']"
4234,"You are given an array of n integer numbers a0, a1, ..., an - 1. Find the distance between two closest (nearest) minimums in it. It is guaranteed that in the array a minimum occurs at least two times. nan n = int(raw_input())

a = map(int, raw_input().split())

menor = min(a)

b = []
c = []
for i in range(len(a)):
    if a[i]==menor:
        b.append(i)
    if len(b)>1:
        c.append(b[-1] - b[-2])

print min(c)",['implementation']
1268,"  William has two arrays $$$a$$$ and $$$b$$$, each consisting of $$$n$$$ items.For some segments $$$l..r$$$ of these arrays William wants to know if it is possible to equalize the values of items in these segments using a balancing operation. Formally, the values are equalized if for each $$$i$$$ from $$$l$$$ to $$$r$$$ holds $$$a_i = b_i$$$.To perform a balancing operation an even number of indices must be selected, such that $$$l \le pos_1 &lt; pos_2 &lt; \dots &lt; pos_k \le r$$$. Next the items of array a at positions $$$pos_1, pos_3, pos_5, \dots$$$ get incremented by one and the items of array b at positions $$$pos_2, pos_4, pos_6, \dots$$$ get incremented by one.William wants to find out if it is possible to equalize the values of elements in two arrays for each segment using some number of balancing operations, and what is the minimal number of operations required for that. Note that for each segment the operations are performed independently. NoteFor the first segment from $$$2$$$ to $$$6$$$ you can do one operation with $$$pos = [2, 3, 5, 6]$$$, after this operation the arrays will be: $$$a = [0, 2, 2, 9, 4, 2, 7, 5]$$$, $$$b = [2, 2, 2, 9, 4, 2, 5, 8]$$$. Arrays are equal on a segment from $$$2$$$ to $$$6$$$ after this operation.For the second segment from $$$1$$$ to $$$7$$$ you can do three following operations:   $$$pos = [1, 3, 5, 6]$$$  $$$pos = [1, 7]$$$  $$$pos = [2, 7]$$$ After these operations, the arrays will be: $$$a = [2, 2, 2, 9, 4, 2, 7, 5]$$$, $$$b = [2, 2, 2, 9, 4, 2, 7, 8]$$$. Arrays are equal on a segment from $$$1$$$ to $$$7$$$ after these operations.For the third segment from $$$2$$$ to $$$4$$$ you can do one operation with $$$pos = [2, 3]$$$, after the operation arrays will be: $$$a = [0, 2, 2, 9, 3, 2, 7, 5]$$$, $$$b = [2, 2, 2, 9, 4, 1, 5, 8]$$$. Arrays are equal on a segment from $$$2$$$ to $$$4$$$ after this operation.It is impossible to equalize the fourth and the fifth segment. import io,os
import bisect 

input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline


class segment_tree(object):

    def merge(self,num1,num2):

        maximum = max(num1[0],num2[0])
        minimum = min(num1[1],num2[1])

        return (maximum,minimum)


    def __init__(self,n,initial):

        self.n = n
        self.arr = [(0,0)]*(2*n)

        for i in range(2*n-1,0,-1):
            if i>=n:  self.arr[i] = (initial[i-n],initial[i-n])
            else:     self.arr[i] = self.merge(self.arr[2*i],self.arr[2*i+1])




    def query(self,left,right):
        i,j = self.n+left,  self.n+right+1
    
        output = (-float('inf'),float('inf'))   # initial output should be changed if you want to change the merge function

        while i<j:
            if i&1:
                output = self.merge(self.arr[i],output)
                i += 1
            if j&1:
                j -= 1
                output = self.merge(self.arr[j],output)
            i = i >> 1
            j = j >> 1
        return output




def main(t):


    n,q = map(int,input().split())
    arr1 = list(map(int,input().split()))
    arr2 = list(map(int,input().split()))

    diff = [0]*n
    for i in range(n):
        diff[i] = arr2[i] - arr1[i]

    accu = [0]*(n+1)
    accu[0] = 0

    pos = []


    for i in range(n):
        accu[i+1] = accu[i] + diff[i]
        if diff[i]!=0: pos.append(i)


 
    seg = segment_tree(n+1,accu)
    

#    print(accu)
    for _ in range(q):
        front,rear = map(int,input().split())
        front -= 1
#        print(front,rear)

        








        (maximum,minimum) = seg.query(front,rear)

        if accu[front]==minimum and accu[rear]==minimum:
            ans = maximum-minimum
        else:
            ans = -1
        print(ans)     

        



#    print(c)
#    print(cindex)
#    print(block)

    























T = 1 #int(input())
t = 1
while t<=T:
    main(t)
    t += 1
","['data structures', 'dp', 'greedy']"
2654,"A bracket sequence is a string, containing only characters ""("", "")"", ""["" and ""]"".A correct bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters ""1"" and ""+"" between the original characters of the sequence. For example, bracket sequences ""()[]"", ""([])"" are correct (the resulting expressions are: ""(1)+[1]"", ""([1+1]+1)""), and ""]("" and ""["" are not. The empty string is a correct bracket sequence by definition.A substring s[l... r] (1 ≤ l ≤ r ≤ |s|) of string s = s1s2... s|s| (where |s| is the length of string s) is the string slsl + 1... sr. The empty string is a substring of any string by definition.You are given a bracket sequence, not necessarily correct. Find its substring which is a correct bracket sequence and contains as many opening square brackets «[» as possible. nan s=raw_input()
n=len(s)
sta, top, match, ans,start, end=[0]*(n+1),1,[-1]*n, 0,0,-1
sta[0] = (0,'x')
for i, c in enumerate(s):
    if c == '(' or c == '[':
        sta[top] = (i, c); top += 1
    else:
        if (c == ')' and sta[top-1][1] == '(') or(c == ']' and sta[top-1][1] == '['):
            top -= 1; match[sta[top][0]] = i
        else: top = 1

i = 0
while i < n:
    if match[i] != -1:
        j, k = i, match[i]
        while 1:
            if match[j] + 1 >= n or match[match[j] + 1] == -1: break
            j = match[j] + 1
            if match[j] > k: k = match[j]
        cnt = 0
        for j in range(i, k):
            if s[j] == '[': cnt += 1
        if ans < cnt:
            ans, start, end = cnt, i, k
        i = k + 2
    else: i += 1
print ans
if start < end:
    print s[start:end+1]


",['data structures']
3560,"You're given two arrays $$$a[1 \dots n]$$$ and $$$b[1 \dots n]$$$, both of the same length $$$n$$$.In order to perform a push operation, you have to choose three integers $$$l, r, k$$$ satisfying $$$1 \le l \le r \le n$$$ and $$$k &gt; 0$$$. Then, you will add $$$k$$$ to elements $$$a_l, a_{l+1}, \ldots, a_r$$$.For example, if $$$a = [3, 7, 1, 4, 1, 2]$$$ and you choose $$$(l = 3, r = 5, k = 2)$$$, the array $$$a$$$ will become $$$[3, 7, \underline{3, 6, 3}, 2]$$$.You can do this operation at most once. Can you make array $$$a$$$ equal to array $$$b$$$?(We consider that $$$a = b$$$ if and only if, for every $$$1 \le i \le n$$$, $$$a_i = b_i$$$) NoteThe first test case is described in the statement: we can perform a push operation with parameters $$$(l=3, r=5, k=2)$$$ to make $$$a$$$ equal to $$$b$$$.In the second test case, we would need at least two operations to make $$$a$$$ equal to $$$b$$$.In the third test case, arrays $$$a$$$ and $$$b$$$ are already equal.In the fourth test case, it's impossible to make $$$a$$$ equal to $$$b$$$, because the integer $$$k$$$ has to be positive. t=int(input())
for r in range(t):
    n=int(input())
    l1=list(map(int,input().split()))
    l2=list(map(int,input().split()))
    flag=1
    diff=-9999999
    count=0
    count0=0
    for i in range(0,n):
        if (l1[i]-l2[i])!=diff:
            diff=l1[i]-l2[i]
            count+=1
            if (l1[i]-l2[i])==0:
                count0+=1
        if (l1[i]-l2[i])>0:
            flag=0
    if flag==1 and (count-count0)<=1:
        print(""YES"")
    else:
        print(""NO"")

        
",['implementation']
1946,"Three sons inherited from their father a rectangular corn fiend divided into n × m squares. For each square we know how many tons of corn grows on it. The father, an old farmer did not love all three sons equally, which is why he bequeathed to divide his field into three parts containing A, B and C tons of corn.The field should be divided by two parallel lines. The lines should be parallel to one side of the field and to each other. The lines should go strictly between the squares of the field. Each resulting part of the field should consist of at least one square. Your task is to find the number of ways to divide the field as is described above, that is, to mark two lines, dividing the field in three parts so that on one of the resulting parts grew A tons of corn, B on another one and C on the remaining one. NoteThe lines dividing the field can be horizontal or vertical, but they should be parallel to each other. import sys

f_read = open(""input.txt"")
f_write = open(""output.txt"", ""w"")

dimensions = [int(x) for x in f_read.readline().split()]
x_dim, y_dim = dimensions[0], dimensions[1]
grid = []

for i in range(x_dim):
    grid.append([])
    values = [int(x) for x in f_read.readline().split()]
    for value in values:
        grid[i].append(value)

targets = [int(x) for x in f_read.readline().split()]
n_ways = 0

vertical_sums, horizontal_sums = [], []
for i in range(x_dim):
    horizontal_sum = 0
    for j in range(y_dim):
        horizontal_sum += grid[i][j]
    horizontal_sums.append(horizontal_sum)

for i in range(y_dim):
    vertical_sum = 0
    for j in range(x_dim):
        vertical_sum += grid[j][i]
    vertical_sums.append(vertical_sum)

for i in range(1, x_dim-1):
    horizontal_sum_1 = 0
    for j in range(0, i):
        horizontal_sum_1 += horizontal_sums[j]
        
    for j in range(i+1, x_dim):
        horizontal_sum_2 = 0
        for k in range(i, j):
            horizontal_sum_2 += horizontal_sums[k]

        horizontal_sum_3 = 0
        for k in range(j, x_dim):
            horizontal_sum_3 += horizontal_sums[k]

        if set([horizontal_sum_1, horizontal_sum_2, horizontal_sum_3]) == set(targets):
            n_ways += 1

for i in range(1, y_dim-1):
    vertical_sum_1 = 0
    for j in range(0, i):
        vertical_sum_1 += vertical_sums[j]
        
    for j in range(i+1, y_dim):
        vertical_sum_2 = 0
        for k in range(i, j):
            vertical_sum_2 += vertical_sums[k]

        vertical_sum_3 = 0
        for k in range(j, y_dim):
            vertical_sum_3 += vertical_sums[k]

        if set([vertical_sum_1, vertical_sum_2, vertical_sum_3]) == set(targets):
            n_ways += 1

f_write.write(str(n_ways) + ""\n"")
",['brute force']
2922,"Eshag has an array $$$a$$$ consisting of $$$n$$$ integers.Eshag can perform the following operation any number of times: choose some subsequence of $$$a$$$ and delete every element from it which is strictly larger than $$$AVG$$$, where $$$AVG$$$ is the average of the numbers in the chosen subsequence.For example, if $$$a = [1 , 4 , 3 , 2 , 4]$$$ and Eshag applies the operation to the subsequence containing $$$a_1$$$, $$$a_2$$$, $$$a_4$$$ and $$$a_5$$$, then he will delete those of these $$$4$$$ elements which are larger than $$$\frac{a_1+a_2+a_4+a_5}{4} = \frac{11}{4}$$$, so after the operation, the array $$$a$$$ will become $$$a = [1 , 3 , 2]$$$.Your task is to find the maximum number of elements Eshag can delete from the array $$$a$$$ by applying the operation described above some number (maybe, zero) times.A sequence $$$b$$$ is a subsequence of an array $$$c$$$ if $$$b$$$ can be obtained from $$$c$$$ by deletion of several (possibly, zero or all) elements. NoteConsider the first test case.Initially $$$a = [1, 1, 1, 2, 2, 3]$$$.In the first operation, Eshag can choose the subsequence containing $$$a_1$$$, $$$a_5$$$ and $$$a_6$$$, their average is equal to $$$\frac{a_1 + a_5 + a_6}{3} = \frac{6}{3} = 2$$$. So $$$a_6$$$ will be deleted.After this $$$a = [1, 1, 1, 2, 2]$$$.In the second operation, Eshag can choose the subsequence containing the whole array $$$a$$$, the average of all its elements is equal to $$$\frac{7}{5}$$$. So $$$a_4$$$ and $$$a_5$$$ will be deleted.After this $$$a = [1, 1, 1]$$$.In the second test case, Eshag can't delete any element. for i in range(int(input())):
    a, b = int(input()), [int(x) for x in input().split()]
    print(a - b.count(min(b)))

","['constructive algorithms', 'greedy', 'math']"
4667,"You are policeman and you are playing a game with Slavik. The game is turn-based and each turn consists of two phases. During the first phase you make your move and during the second phase Slavik makes his move.There are $$$n$$$ doors, the $$$i$$$-th door initially has durability equal to $$$a_i$$$.During your move you can try to break one of the doors. If you choose door $$$i$$$ and its current durability is $$$b_i$$$ then you reduce its durability to $$$max(0, b_i - x)$$$ (the value $$$x$$$ is given).During Slavik's move he tries to repair one of the doors. If he chooses door $$$i$$$ and its current durability is $$$b_i$$$ then he increases its durability to $$$b_i + y$$$ (the value $$$y$$$ is given). Slavik cannot repair doors with current durability equal to $$$0$$$.The game lasts $$$10^{100}$$$ turns. If some player cannot make his move then he has to skip it.Your goal is to maximize the number of doors with durability equal to $$$0$$$ at the end of the game. You can assume that Slavik wants to minimize the number of such doors. What is the number of such doors in the end if you both play optimally? NoteClarifications about the optimal strategy will be ignored. R = lambda: map(int, raw_input().split())

n, a, b = R()
v = R()
if a > b:
  print n
else:
  c = 0
  for x in v:
    if x <= a:
      c += 1
  print(c + 1) / 2
",['games']
65,"Our old friend Alexey has finally entered the University of City N — the Berland capital. Alexey expected his father to get him a place to live in but his father said it was high time for Alexey to practice some financial independence. So, Alexey is living in a dorm. The dorm has exactly one straight dryer — a 100 centimeter long rope to hang clothes on. The dryer has got a coordinate system installed: the leftmost end of the dryer has coordinate 0, and the opposite end has coordinate 100. Overall, the university has n students. Dean's office allows i-th student to use the segment (li, ri) of the dryer. However, the dean's office actions are contradictory and now one part of the dryer can belong to multiple students!Alexey don't like when someone touch his clothes. That's why he want make it impossible to someone clothes touch his ones. So Alexey wonders: what is the total length of the parts of the dryer that he may use in a such way that clothes of the others (n - 1) students aren't drying there. Help him! Note that Alexey, as the most respected student, has number 1. NoteNote that it's not important are clothes drying on the touching segments (e.g. (0, 1) and (1, 2)) considered to be touching or not because you need to find the length of segments.In the first test sample Alexey may use the only segment (0, 1). In such case his clothes will not touch clothes on the segments (1, 6) and (2, 8). The length of segment (0, 1) is 1.In the second test sample Alexey may dry his clothes on segments (0, 1) and (5, 7). Overall length of these segments is 3. n = int(input())
seta = set()
ax,ay = map(int, input().split("" ""))
for i in range(ax,ay):
    seta.add(i+0.5)
for i in range(0,n-1):
    nx,ny = map(int, input().split("" ""))
    for j in range(nx,ny):
        seta.discard(j+0.5)
print(len(seta))",['implementation']
4630,"In a building where Polycarp lives there are equal number of flats on each floor. Unfortunately, Polycarp don't remember how many flats are on each floor, but he remembers that the flats are numbered from 1 from lower to upper floors. That is, the first several flats are on the first floor, the next several flats are on the second and so on. Polycarp don't remember the total number of flats in the building, so you can consider the building to be infinitely high (i.e. there are infinitely many floors). Note that the floors are numbered from 1.Polycarp remembers on which floors several flats are located. It is guaranteed that this information is not self-contradictory. It means that there exists a building with equal number of flats on each floor so that the flats from Polycarp's memory have the floors Polycarp remembers.Given this information, is it possible to restore the exact floor for flat n?  NoteIn the first example the 6-th flat is on the 2-nd floor, while the 7-th flat is on the 3-rd, so, the 6-th flat is the last on its floor and there are 3 flats on each floor. Thus, the 10-th flat is on the 4-th floor.In the second example there can be 3 or 4 flats on each floor, so we can't restore the floor for the 8-th flat. n,m=map(int,input().split())
k=[0]*m
f=[0]*m
l=1
r=100
for i in range(m):
    k[i],f[i]=map(int,input().split())
for i in range(m):
    fl=True
    for kol in range(l,r+1):
        ch=k[i]-(f[i]-1)*kol
        if ch>0 and ch<=kol:
            if fl:
                l=kol
                fl=False
        elif not fl:
            r=kol-1
            break
    if r-l==0:
        print((n+r-1)//r)
        break
else:
    kok=(n+r-1)//r
    for kol in range(l,r):
        if kok!=(n+kol-1)//kol:
            print(-1)
            break
    else:
        print(kok)
                
","['brute force', 'implementation']"
12,"Vasya has been playing Plane of Tanks with his friends the whole year. Now it is time to divide the participants into several categories depending on their results. A player is given a non-negative integer number of points in each round of the Plane of Tanks. Vasya wrote results for each round of the last year. He has n records in total.In order to determine a player's category consider the best result obtained by the player and the best results of other players. The player belongs to category:   ""noob"" — if more than 50% of players have better results;  ""random"" — if his result is not worse than the result that 50% of players have, but more than 20% of players have better results;  ""average"" — if his result is not worse than the result that 80% of players have, but more than 10% of players have better results;  ""hardcore"" — if his result is not worse than the result that 90% of players have, but more than 1% of players have better results;  ""pro"" — if his result is not worse than the result that 99% of players have.  When the percentage is calculated the player himself is taken into account. That means that if two players played the game and the first one gained 100 points and the second one 1000 points, then the first player's result is not worse than the result that 50% of players have, and the second one is not worse than the result that 100% of players have.Vasya gave you the last year Plane of Tanks results. Help Vasya determine each player's category. NoteIn the first example the best result, obtained by artem is not worse than the result that 25% of players have (his own result), so he belongs to category ""noob"". vasya and kolya have best results not worse than the results that 75% players have (both of them and artem), so they belong to category ""random"". igor has best result not worse than the result that 100% of players have (all other players and himself), so he belongs to category ""pro"".In the second example both players have the same amount of points, so they have results not worse than 100% players have, so they belong to category ""pro"". I=input
P=print
d={}
for _ in'0'*int(I()):a,b=I().split();d[a]=max(d.get(a,0),int(b))
v=d.values()
n=len(d)
P(n)
for k in d:
	a=b=0
	for x in v:a+=x<=d[k];b+=x>d[k]
	s='noob';a/=n;b/=n
	if a>=.5and b>=.2:s='random'
	if a>=.8and b>=.1:s='average'
	if a>=.9and b>=.01:s='hardcore'
	if a>=.99:s='pro'
	P(k,s)",['implementation']
2623,"Saitama accidentally destroyed a hotel again. To repay the hotel company, Genos has volunteered to operate an elevator in one of its other hotels. The elevator is special — it starts on the top floor, can only move down, and has infinite capacity. Floors are numbered from 0 to s and elevator initially starts on floor s at time 0.The elevator takes exactly 1 second to move down exactly 1 floor and negligible time to pick up passengers. Genos is given a list detailing when and on which floor passengers arrive. Please determine how long in seconds it will take Genos to bring all passengers to floor 0. NoteIn the first sample, it takes at least 11 seconds to bring all passengers to floor 0. Here is how this could be done:1. Move to floor 5: takes 2 seconds.2. Pick up passenger 3.3. Move to floor 3: takes 2 seconds.4. Wait for passenger 2 to arrive: takes 4 seconds.5. Pick up passenger 2.6. Go to floor 2: takes 1 second.7. Pick up passenger 1.8. Go to floor 0: takes 2 seconds.This gives a total of 2 + 2 + 4 + 1 + 2 = 11 seconds. R = lambda : map(int, input().split())

n,s=R()
m = max([sum(R()) for _ in range(n)])
print(max(m,s))

","['implementation', 'math']"
3185,"Sho has an array $$$a$$$ consisting of $$$n$$$ integers. An operation consists of choosing two distinct indices $$$i$$$ and $$$j$$$ and removing $$$a_i$$$ and $$$a_j$$$ from the array.For example, for the array $$$[2, 3, 4, 2, 5]$$$, Sho can choose to remove indices $$$1$$$ and $$$3$$$. After this operation, the array becomes $$$[3, 2, 5]$$$. Note that after any operation, the length of the array is reduced by two.After he made some operations, Sho has an array that has only distinct elements. In addition, he made operations such that the resulting array is the longest possible. More formally, the array after Sho has made his operations respects these criteria:   No pairs such that ($$$i &lt; j$$$) and $$$a_i = a_j$$$ exist.  The length of $$$a$$$ is maximized. Output the length of the final array. NoteFor the first test case Sho can perform operations as follows:   Choose indices $$$1$$$ and $$$5$$$ to remove. The array becomes $$$[2, 2, 2, 3, 3, 3] \rightarrow [2, 2, 3, 3]$$$.  Choose indices $$$1$$$ and $$$4$$$ to remove. The array becomes $$$[2, 2, 3, 3] \rightarrow [2, 3]$$$.  The final array has a length of $$$2$$$, so the answer is $$$2$$$. It can be proven that Sho cannot obtain an array with a longer length.For the second test case Sho can perform operations as follows:   Choose indices $$$3$$$ and $$$4$$$ to remove. The array becomes $$$[9, 1, 9, 9, 1] \rightarrow [9, 1, 1]$$$.  Choose indices $$$1$$$ and $$$3$$$ to remove. The array becomes $$$[9, 1, 1] \rightarrow [1]$$$.  The final array has a length of $$$1$$$, so the answer is $$$1$$$. It can be proven that Sho cannot obtain an array with a longer length. from collections import Counter

if __name__ == '__main__':
    for _ in range(int(input())):
        n = int(input())
        values = list(map(int, input().split()))
        different = set(values)
        to_remove = len(values) - len(different)

        if to_remove % 2 == 0:
            print(len(different))
        else:
            print(len(different) - 1)
","['greedy', 'sortings']"
3526,"As you probably know, Anton goes to school. One of the school subjects that Anton studies is Bracketology. On the Bracketology lessons students usually learn different sequences that consist of round brackets (characters ""("" and "")"" (without quotes)).On the last lesson Anton learned about the regular simple bracket sequences (RSBS). A bracket sequence s of length n is an RSBS if the following conditions are met:  It is not empty (that is n ≠ 0).  The length of the sequence is even.  First  charactes of the sequence are equal to ""("".  Last  charactes of the sequence are equal to "")"". For example, the sequence ""((()))"" is an RSBS but the sequences ""((())"" and ""(()())"" are not RSBS.Elena Ivanovna, Anton's teacher, gave him the following task as a homework. Given a bracket sequence s. Find the number of its distinct subsequences such that they are RSBS. Note that a subsequence of s is a string that can be obtained from s by deleting some of its elements. Two subsequences are considered distinct if distinct sets of positions are deleted.Because the answer can be very big and Anton's teacher doesn't like big numbers, she asks Anton to find the answer modulo 109 + 7.Anton thought of this task for a very long time, but he still doesn't know how to solve it. Help Anton to solve this task and write a program that finds the answer for it! NoteIn the first sample the following subsequences are possible:  If we delete characters at the positions 1 and 5 (numbering starts with one), we will get the subsequence ""(())"".  If we delete characters at the positions 1, 2, 3 and 4, we will get the subsequence ""()"".  If we delete characters at the positions 1, 2, 4 and 5, we will get the subsequence ""()"".  If we delete characters at the positions 1, 2, 5 and 6, we will get the subsequence ""()"".  If we delete characters at the positions 1, 3, 4 and 5, we will get the subsequence ""()"".  If we delete characters at the positions 1, 3, 5 and 6, we will get the subsequence ""()"". The rest of the subsequnces are not RSBS. So we got 6 distinct subsequences that are RSBS, so the answer is 6. mod = 10 ** 9 + 7

fact, inv, invfact = [1, 1], [0, 1], [1, 1]
for i in range(2, 200200):
    fact.append(fact[-1] * i % mod)
    inv.append(inv[mod % i] * (mod - mod // i) % mod)
    invfact.append(invfact[-1] * inv[-1] % mod)

def C(n, k):
    if k < 0 or k > n:
        return 0
    return fact[n] * invfact[k] * invfact[n - k] % mod

s = input()
op, cl = 0, s.count(')')
ans = 0
for x in s:
    if x == '(':
        op += 1
        cur = C(cl + op - 1, op)
        ans += cur
    else:
        cl -= 1

print(ans % mod)
","['combinatorics', 'dp', 'math', 'number theory']"
3520,"Alice and Bob play the following game. Alice has a set $$$S$$$ of disjoint ranges of integers, initially containing only one range $$$[1, n]$$$. In one turn, Alice picks a range $$$[l, r]$$$ from the set $$$S$$$ and asks Bob to pick a number in the range. Bob chooses a number $$$d$$$ ($$$l \le d \le r$$$). Then Alice removes $$$[l, r]$$$ from $$$S$$$ and puts into the set $$$S$$$ the range $$$[l, d - 1]$$$ (if $$$l \le d - 1$$$) and the range $$$[d + 1, r]$$$ (if $$$d + 1 \le r$$$). The game ends when the set $$$S$$$ is empty. We can show that the number of turns in each game is exactly $$$n$$$.After playing the game, Alice remembers all the ranges $$$[l, r]$$$ she picked from the set $$$S$$$, but Bob does not remember any of the numbers that he picked. But Bob is smart, and he knows he can find out his numbers $$$d$$$ from Alice's ranges, and so he asks you for help with your programming skill.Given the list of ranges that Alice has picked ($$$[l, r]$$$), for each range, help Bob find the number $$$d$$$ that Bob has picked.We can show that there is always a unique way for Bob to choose his number for a list of valid ranges picked by Alice. NoteIn the first test case, there is only 1 range $$$[1, 1]$$$. There was only one range $$$[1, 1]$$$ for Alice to pick, and there was only one number $$$1$$$ for Bob to pick.In the second test case, $$$n = 3$$$. Initially, the set contains only one range $$$[1, 3]$$$.   Alice picked the range $$$[1, 3]$$$. Bob picked the number $$$1$$$. Then Alice put the range $$$[2, 3]$$$ back to the set, which after this turn is the only range in the set.  Alice picked the range $$$[2, 3]$$$. Bob picked the number $$$3$$$. Then Alice put the range $$$[2, 2]$$$ back to the set.  Alice picked the range $$$[2, 2]$$$. Bob picked the number $$$2$$$. The game ended. In the fourth test case, the game was played with $$$n = 5$$$. Initially, the set contains only one range $$$[1, 5]$$$. The game's turn is described in the following table.  Game turnAlice's picked rangeBob's picked numberThe range set afterBefore the game start$$$ \{ [1, 5] \} $$$1$$$[1, 5]$$$$$$3$$$$$$ \{ [1, 2], [4, 5] \}$$$2$$$[1, 2]$$$$$$1$$$$$$ \{ [2, 2], [4, 5] \} $$$3$$$[4, 5]$$$$$$5$$$$$$ \{ [2, 2], [4, 4] \} $$$4$$$[2, 2]$$$$$$2$$$$$$ \{ [4, 4] \} $$$5$$$[4, 4]$$$$$$4$$$$$$ \{ \} $$$ (empty set)  from collections import defaultdict

t = int(input())
for _ in range(t):
    n = int(input())
    ranges = [tuple(map(int, input().split())) for _ in range(n)]
    ranges = sorted(ranges, key=lambda x: x[1] - x[0], reverse=True)
    for l, r in ranges:
        if l == r:
            print(l, r, r)
        else:
            for x, y in ranges:
                if r == y and y - x < r - l:
                    print(l, r, x - 1)
                    break
                elif l == x and y - x < r - l:
                    print(l, r, y + 1)
                    break
    print()
","['brute force', 'dfs and similar', 'implementation', 'sortings']"
3615,"Arkady is playing Battleship. The rules of this game aren't really important.There is a field of $$$n \times n$$$ cells. There should be exactly one $$$k$$$-decker on the field, i. e. a ship that is $$$k$$$ cells long oriented either horizontally or vertically. However, Arkady doesn't know where it is located. For each cell Arkady knows if it is definitely empty or can contain a part of the ship.Consider all possible locations of the ship. Find such a cell that belongs to the maximum possible number of different locations of the ship. NoteThe picture below shows the three possible locations of the ship that contain the cell $$$(3, 2)$$$ in the first sample.   #!/usr/bin/env python3
# -*- coding: utf-8 -*-
""""""
Created on Wed Apr 25 23:17:51 2018

@author: ska

965-B
""""""
import math
n,k = map(int, input().split())

f = []

score = [[0 for i in range(n)] for j in range(n)]
for i in range(n):
    f.append(input().strip())

for i in range(n):
    con = 0
    for j in range(n):
        if f[i][j] ==""."":
            con += 1
        else:
            con =0
        if con == k:
            con = k-1
            for h in range(k):
                score[i][j-h] += 1
                
            
#print(score)

for i in range(n):
    con = 0
    for j in range(n):
        if f[j][i] ==""."":
            con += 1
        else:
            con =0
        if con == k:
            con = k-1
            for h in range(k):
                score[j-h][i] +=1

#print(score)
ma = 0
row1 =0
col1 = 0
for row in range(n):
    for col in range(n):
#        print(score[row][col])
        if score[row][col] >ma:
            ma = score[row][col]
            row1 =row
            col1 =col
print(row1+1, col1+1)",['implementation']
3705,"Harry Potter and He-Who-Must-Not-Be-Named engaged in a fight to the death once again. This time they are located at opposite ends of the corridor of length l. Two opponents simultaneously charge a deadly spell in the enemy. We know that the impulse of Harry's magic spell flies at a speed of p meters per second, and the impulse of You-Know-Who's magic spell flies at a speed of q meters per second.The impulses are moving through the corridor toward each other, and at the time of the collision they turn round and fly back to those who cast them without changing their original speeds. Then, as soon as the impulse gets back to it's caster, the wizard reflects it and sends again towards the enemy, without changing the original speed of the impulse.Since Harry has perfectly mastered the basics of magic, he knows that after the second collision both impulses will disappear, and a powerful explosion will occur exactly in the place of their collision. However, the young wizard isn't good at math, so he asks you to calculate the distance from his position to the place of the second meeting of the spell impulses, provided that the opponents do not change positions during the whole fight. NoteIn the first sample the speeds of the impulses are equal, so both of their meetings occur exactly in the middle of the corridor. l=int(input())
p=int(input())
q=int(input())

print(l * p / float(p + q))
","['implementation', 'math']"
1073,"You are given a tree consisting of $$$n$$$ vertices. Some of the vertices (at least two) are black, all the other vertices are white.You place a chip on one of the vertices of the tree, and then perform the following operations:  let the current vertex where the chip is located is $$$x$$$. You choose a black vertex $$$y$$$, and then move the chip along the first edge on the simple path from $$$x$$$ to $$$y$$$. You are not allowed to choose the same black vertex $$$y$$$ in two operations in a row (i. e., for every two consecutive operations, the chosen black vertex should be different).You end your operations when the chip moves to the black vertex (if it is initially placed in a black vertex, you don't perform the operations at all), or when the number of performed operations exceeds $$$100^{500}$$$.For every vertex $$$i$$$, you have to determine if there exists a (possibly empty) sequence of operations that moves the chip to some black vertex, if the chip is initially placed on the vertex $$$i$$$. nan from sys import stdin
inp = stdin.readline

n = int(inp())

bow = [int(x) for x in inp().split()]

# tree[nr][color, [connected]]
tree = {i+1: [c, set()] for i, c in enumerate(bow)}

for i in range(n-1):
    a, b = map(int, inp().split())
    tree[a][1].add(b)
    tree[b][1].add(a)

blacks = []
for i in range(n):
    if bow[i] == 1:
        blacks.append(i+1)

blacksDone = {c: set() for c in blacks}

ans = [0 for i in range(n)]

for start in blacks:

    arr = [[start, set(tree[start][1]).difference(blacksDone[start])]]
    layer = 0
    blackNr = len(blacksDone[start])
    branch = set()
    branch2 = set()
    blackBranch = False
    blackLayer = -1

    ans[start-1] = 1
    for c in arr[0][1]:
        ans[c-1] = 1

    while True:
        # counter
        if len(arr[layer][1]) > 0:
            current = arr[layer][1].pop()
            arr.append([current, set(tree[current][1])])
            arr[-1][1].discard(arr[layer][0])
            layer += 1

            if layer > blackLayer != -1:
                branch2.add(current)
            elif layer > 1:
                branch.add(current)

            if tree[current][0] == 1 and current != start:
                if len(blacksDone[current]) >= 1:
                    blackNr = 2
                    break

                if not blackBranch:
                    blackNr += 1
                    blackBranch = True
                elif blackLayer > -1:
                    blackNr = 2
                    break

                blackLayer = layer-1
                blacksDone[current].add(arr[layer-1][0])
                arr[layer-1][1] = set(tree[arr[layer-1][0]][1])
                arr[layer-1][1].discard(arr[layer-2][0])
                arr[layer-1][1].discard(current)
                arr.pop()

                ans[arr[layer-1][0]-1] = 1
                layer -= 1

        else:
            layer -= 1

            if layer == 1:
                if not blackBranch:
                    for c in branch:
                        ans[c-1] = 1
                else:
                    blackBranch = False
                branch = set()
            elif layer == blackLayer:
                for c in branch2:
                    ans[c - 1] = 1
                branch2 = set()

            if layer < blackLayer:
                blackLayer = -1

            if layer == -1:
                break

            arr.pop()

        if blackNr > 1:
            break

    if blackNr > 1:
        break

if blackNr > 1:
    ans = [1]*n

print(*ans)

","['dfs and similar', 'greedy', 'trees']"
642,"Monocarp is a little boy who lives in Byteland and he loves programming.Recently, he found a permutation of length $$$n$$$. He has to come up with a mystic permutation. It has to be a new permutation such that it differs from the old one in each position.More formally, if the old permutation is $$$p_1,p_2,\ldots,p_n$$$ and the new one is $$$q_1,q_2,\ldots,q_n$$$ it must hold that $$$$$$p_1\neq q_1, p_2\neq q_2, \ldots ,p_n\neq q_n.$$$$$$Monocarp is afraid of lexicographically large permutations. Can you please help him to find the lexicographically minimal mystic permutation? NoteIn the first test case possible permutations that are mystic are $$$[2,3,1]$$$ and $$$[3,1,2]$$$. Lexicographically smaller of the two is $$$[2,3,1]$$$.In the second test case, $$$[1,2,3,4,5]$$$ is the lexicographically minimal permutation and it is also mystic.In third test case possible mystic permutations are $$$[1,2,4,3]$$$, $$$[1,4,2,3]$$$, $$$[1,4,3,2]$$$, $$$[3,1,4,2]$$$, $$$[3,2,4,1]$$$, $$$[3,4,2,1]$$$, $$$[4,1,2,3]$$$, $$$[4,1,3,2]$$$ and $$$[4,3,2,1]$$$. The smallest one is $$$[1,2,4,3]$$$. for i in range(int(input())):
    n=int(input())
    x=list(map(int,input().split()))
    y=sorted(x)
 
    for i in range(n):
        if(y[i]==x[i] and i!=n-1) :
            y[i],y[i+1] = y[i+1],y[i] 
     
        elif(y[i]==x[i] and i==n-1):
            y[i], y[i-1]=y[i-1],y[i] 
    
    if n!=1:   
        for i in y:
            print(i,end="" "")
        print()
    else:
        print(-1)","['data structures', 'greedy']"
3885,"A star map in Berland is a checked field n × m squares. In each square there is or there is not a star. The favourite constellation of all Berland's astronomers is the constellation of the Cross. This constellation can be formed by any 5 stars so, that for some integer x (radius of the constellation) the following is true:   the 2nd is on the same vertical line as the 1st, but x squares up  the 3rd is on the same vertical line as the 1st, but x squares down  the 4th is on the same horizontal line as the 1st, but x squares left  the 5th is on the same horizontal line as the 1st, but x squares right Such constellations can be very numerous, that's why they are numbered with integers from 1 on the following principle: when two constellations are compared, the one with a smaller radius gets a smaller index; if their radii are equal — the one, whose central star if higher than the central star of the other one; if their central stars are at the same level — the one, whose central star is to the left of the central star of the other one.Your task is to find the constellation with index k by the given Berland's star map. nan import sys
from array import array  # noqa: F401


def input():
    return sys.stdin.buffer.readline().decode('utf-8')


n, m, k = map(int, input().split())
a = [tuple(map(lambda c: c == '*', input().rstrip())) for _ in range(n)]
cnt = [0] * 400

for i in range(1, n - 1):
    for j in range(1, m - 1):
        if not a[i][j]:
            continue
        for rad, ui, di, lj, rj in zip(range(1, 400), range(i - 1, -1, -1), range(i + 1, n), range(j - 1, -1, -1), range(j + 1, m)):
            if all((a[ui][j], a[di][j], a[i][lj], a[i][rj])):
                cnt[rad] += 1

rad = -1
for i in range(300):
    cnt[i + 1] += cnt[i]
    if cnt[i] >= k:
        rad = i
        k -= cnt[i - 1]
        break
else:
    print(-1)
    exit()

for i in range(rad, n - rad):
    for j in range(rad, m - rad):
        if all((a[i][j], a[i - rad][j], a[i + rad][j], a[i][j - rad], a[i][j + rad])):
            k -= 1
            if k == 0:
                print(f'{i+1} {j+1}\n{i-rad+1} {j+1}\n{i+rad+1} {j+1}\n{i+1} {j-rad+1}\n{i+1} {j+rad+1}')
                exit()
",['implementation']
3740,"Igor found out discounts in a shop and decided to buy n items. Discounts at the store will last for a week and Igor knows about each item that its price now is ai, and after a week of discounts its price will be bi.Not all of sellers are honest, so now some products could be more expensive than after a week of discounts.Igor decided that buy at least k of items now, but wait with the rest of the week in order to save money as much as possible. Your task is to determine the minimum money that Igor can spend to buy all n items. NoteIn the first example Igor should buy item 3 paying 6. But items 1 and 2 he should buy after a week. He will pay 3 and 1 for them. So in total he will pay 6 + 3 + 1 = 10.In the second example Igor should buy right now items 1, 2, 4 and 5, paying for them 3, 4, 10 and 3, respectively. Item 3 he should buy after a week of discounts, he will pay 5 for it. In total he will spend 3 + 4 + 10 + 3 + 5 = 25. n, k = map(int, input().split())
a = [int(x) for x in input().split()]
b = [int(x) for x in input().split()]
d = []
for i in range(n):
    d.append((a[i]-b[i], i, a[i], b[i]))
d.sort()
total = 0
for i in range(n):
    if k>0 or d[i][0]<=0:
        total += d[i][2]
        k -= 1
    else:
        total += d[i][3]
print(total)","['constructive algorithms', 'greedy', 'sortings']"
812,"Peter decided to lay a parquet in the room of size n × m, the parquet consists of tiles of size 1 × 2. When the workers laid the parquet, it became clear that the tiles pattern looks not like Peter likes, and workers will have to re-lay it.The workers decided that removing entire parquet and then laying it again is very difficult task, so they decided to make such an operation every hour: remove two tiles, which form a 2 × 2 square, rotate them 90 degrees and put them back on the same place.  They have no idea how to obtain the desired configuration using these operations, and whether it is possible at all.Help Peter to make a plan for the workers or tell that it is impossible. The plan should contain at most 100 000 commands. NoteIn the first sample test first operation is to rotate two rightmost tiles, after this all tiles lie vertically. Second operation is to rotate two leftmost tiles, after this we will get desired configuration.   #!/usr/bin/env python3

board = []
n, m = 0, 0

def rotate(x, y):
    if board[x][y] == 'L':
        board[x][y] = board[x][y+1] = 'U'
        board[x+1][y] = board[x+1][y+1] = 'D'
    else:
        board[x][y] = board[x+1][y] = 'L'
        board[x][y+1] = board[x+1][y+1] = 'R'

def fix(x, y, moves):
    if board[x+1][y] == 'U':
        if board[x+1][y+1] == 'L':
            fix(x+1, y+1, moves)
        rotate(x+1, y)
        moves.append((x+2, y+1))
    rotate(x, y)
    moves.append((x+1, y+1))

def solve_board(moves):
    global board, n, m
    board = []
    for _ in range(n):
        board.append(list(input()))
    for i in range(n-1):
        for j in range(m):
            if board[i][j] == 'L':
                fix(i, j, moves)

def main():
    global n, m
    n, m = map(int, input().split())
    moves1 = []; moves2 = []
    solve_board(moves1)
    solve_board(moves2)
    print(len(moves1) + len(moves2))
    for move in moves1:
        print(str(move[0]) + ' ' + str(move[1]))
    for move in reversed(moves2):
        print(str(move[0]) + ' ' + str(move[1]))

if  __name__ == '__main__':
    main()",['constructive algorithms']
4062,"Nezzar has a binary string $$$s$$$ of length $$$n$$$ that he wants to share with his best friend, Nanako. Nanako will spend $$$q$$$ days inspecting the binary string. At the same time, Nezzar wants to change the string $$$s$$$ into string $$$f$$$ during these $$$q$$$ days, because it looks better.It is known that Nanako loves consistency so much. On the $$$i$$$-th day, Nanako will inspect a segment of string $$$s$$$ from position $$$l_i$$$ to position $$$r_i$$$ inclusive. If the segment contains both characters '0' and '1', Nanako becomes unhappy and throws away the string.After this inspection, at the $$$i$$$-th night, Nezzar can secretly change strictly less than half of the characters in the segment from $$$l_i$$$ to $$$r_i$$$ inclusive, otherwise the change will be too obvious.Now Nezzar wonders, if it is possible to avoid Nanako being unhappy and at the same time have the string become equal to the string $$$f$$$ at the end of these $$$q$$$ days and nights. NoteIn the first test case, $$$\underline{00000} \rightarrow \underline{000}11 \rightarrow 00111$$$ is one of the possible sequences of string changes.In the second test case, it can be shown that it is impossible to have the string $$$f$$$ at the end. 
#from bisect import *
#from collections import *
#from math import gcd,ceil,sqrt,floor,inf
#from heapq import *
#from itertools import *
#from operator import add,mul,sub,xor,truediv,floordiv
#from functools import *

#------------------------------------------------------------------------
import os
import sys

from io import BytesIO, IOBase
# region fastio
 
BUFSIZE = 8192
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
 

#------------------------------------------------------------------------
def RL(): return map(int, sys.stdin.readline().split())
def RLL(): return list(map(int, sys.stdin.readline().split()))
def N(): return int(input())
#------------------------------------------------------------------------


class SMT:
    def __init__(self,arr):
        self.n=len(arr)-1
        l=(n-1).bit_length()
        self.arr=[0]*(1<<(l+1))
        self.lazy=[-1]*(1<<(l+1))
        def Build(l,r,rt):
            if l==r:
                self.arr[rt]=arr[l]
                return
            m=(l+r)>>1
            Build(l,m,rt<<1)
            Build(m+1,r,rt<<1|1)
            self.pushup(rt)
        Build(1,self.n,1)
 
    def pushup(self,rt):
        self.arr[rt]=self.arr[rt<<1]+self.arr[rt<<1|1]
 
    def pushdown(self,rt,ln,rn):#lr,rn表区间数字数
        if self.lazy[rt]!=-1:
            self.lazy[rt<<1]=self.lazy[rt]
            self.lazy[rt<<1|1]=self.lazy[rt]
            self.arr[rt<<1]=self.lazy[rt]*ln
            self.arr[rt<<1|1]=self.lazy[rt]*rn
            self.lazy[rt]=-1
            
    def update(self,L,R,c,l=1,r=None,rt=1):#L,R表示操作区间
        if r==None: r=self.n
        if L<=l and r<=R:
            self.arr[rt]=c*(r-l+1)
            self.lazy[rt]=c
            return
        m=(l+r)>>1
        self.pushdown(rt,m-l+1,r-m)
        if L<=m: self.update(L,R,c,l,m,rt<<1)
        if R>m: self.update(L,R,c,m+1,r,rt<<1|1)
        self.pushup(rt)
 
    def query(self,L,R,l=1,r=None,rt=1):
        if r==None: r=self.n
        if L<=l and R>=r:
            return self.arr[rt]
        m=(l+r)>>1
        self.pushdown(rt,m-l+1,r-m)
        ans=0
        if L<=m: ans+=self.query(L,R,l,m,rt<<1)
        if R>m: ans+=self.query(L,R,m+1,r,rt<<1|1)
        return ans
    
    def dfs(self,t,l=1,r=None,rt=1):
        if r==None: r=self.n
        if l==r:
            return t[l-1]==self.arr[rt]
        m=(l+r)>>1
        self.pushdown(rt,m-l+1,r-m)
        return self.dfs(t,l,m,rt<<1) and self.dfs(t,m+1,r,rt<<1|1)


t=N()
for i in range(t):
    n,q=RL()
    s=input()
    f=input()
    s=[int(ch) for ch in s]
    f=[0]+[int(ch) for ch in f]
    smt=SMT(f)
    ans=True
    l=[0]*q
    r=[0]*q
    for i in range(q):
        l[i],r[i]=RL()
    for i in range(q-1,-1,-1):
        leng=r[i]-l[i]+1
        cur=smt.query(l[i],r[i])
        if cur*2==leng:
            ans=False
            break
        elif cur*2<leng:
            smt.update(l[i],r[i],0)
        else:
            smt.update(l[i],r[i],1)
    ans=ans and smt.dfs(s)
    ans=""YES"" if ans else ""NO""
    print(ans)
            
","['data structures', 'greedy']"
944,"Simon has a prime number x and an array of non-negative integers a1, a2, ..., an.Simon loves fractions very much. Today he wrote out number  on a piece of paper. After Simon led all fractions to a common denominator and summed them up, he got a fraction: , where number t equals xa1 + a2 + ... + an. Now Simon wants to reduce the resulting fraction. Help him, find the greatest common divisor of numbers s and t. As GCD can be rather large, print it as a remainder after dividing it by number 1000000007 (109 + 7). NoteIn the first sample . Thus, the answer to the problem is 8.In the second sample, . The answer to the problem is 27, as 351 = 13·27, 729 = 27·27.In the third sample the answer to the problem is 1073741824 mod 1000000007 = 73741817.In the fourth sample . Thus, the answer to the problem is 1. def matome_num():
    global num
    ans = num[0][0]
    for i in range(len(num)-1):
        if num[i][1] == num[i+1][1]:
            ans += num[i+1][0]
        else:
            num = [(ans,num[0][1])] + num[i+1:]
            return

    num = [(ans,num[0][1])]


n,x = map(int,raw_input().split())
old_num = map(int,raw_input().split())
mysum = sum(old_num)
num = [(1,mysum-old_num[n-i]) for i in range(1,n+1)]
ans = num[0][1]
while len(num) != 1:
    matome_num()
    if num[0][0] % x == 0:
        num[0] = (num[0][0]/x,num[0][1] + 1) 
    else:
        ans = num[0][1]
        break

if len(num) == 1:
    ans = num[0][1]
    y = num[0][0]
    while y % x == 0:
        y /= x
        ans += 1

INF = 1000000007

print pow(x,min(ans,mysum),INF)



","['math', 'number theory']"
3349,"According to rules of the Berland fashion, a jacket should be fastened by all the buttons except only one, but not necessarily it should be the last one. Also if the jacket has only one button, it should be fastened, so the jacket will not swinging open.You are given a jacket with n buttons. Determine if it is fastened in a right way. nan #!/usr/bin/env python
#-*- coding:utf-8 -*-

import sys, math, random, operator
from string import ascii_lowercase
from string import ascii_uppercase
from fractions import Fraction, gcd
from decimal import Decimal, getcontext
from itertools import product, permutations, combinations
from Queue import Queue, PriorityQueue
from collections import deque, defaultdict, Counter
getcontext().prec = 100

MOD = 10**9 + 7
INF = float(""+inf"")

if sys.subversion[0] != ""CPython"":  # PyPy?
    raw_input = lambda: sys.stdin.readline().rstrip()
pr = lambda *args: sys.stdout.write("" "".join(str(x) for x in args) + ""\n"")
epr = lambda *args: sys.stderr.write("" "".join(str(x) for x in args) + ""\n"")
die = lambda *args: pr(*args) ^ exit(0)

read_str = raw_input
read_strs = lambda: raw_input().split()
read_int = lambda: int(raw_input())
read_ints = lambda: map(int, raw_input().split())
read_float = lambda: float(raw_input())
read_floats = lambda: map(float, raw_input().split())

""---------------------------------------------------------------""

# abcdefghijklmnopqrstuvwxyz
# ABCDEFGHIJKLMNOPQRSTUVWXYZ
# pairs = ""bd
# sym = ""AHIMOTUVWXYilmn

n = read_int()
arr = read_ints()
if arr == [1] or len(arr) > 1 and sum(arr) == len(arr) - 1:
    print ""YES""
else:
    print ""NO""

",['implementation']
2671,"Makes solves problems on Decoforces and lots of other different online judges. Each problem is denoted by its difficulty — a positive integer number. Difficulties are measured the same across all the judges (the problem with difficulty d on Decoforces is as hard as the problem with difficulty d on any other judge). Makes has chosen n problems to solve on Decoforces with difficulties a1, a2, ..., an. He can solve these problems in arbitrary order. Though he can solve problem i with difficulty ai only if he had already solved some problem with difficulty  (no matter on what online judge was it).Before starting this chosen list of problems, Makes has already solved problems with maximum difficulty k.With given conditions it's easy to see that Makes sometimes can't solve all the chosen problems, no matter what order he chooses. So he wants to solve some problems on other judges to finish solving problems from his list. For every positive integer y there exist some problem with difficulty y on at least one judge besides Decoforces.Makes can solve problems on any judge at any time, it isn't necessary to do problems from the chosen list one right after another.Makes doesn't have too much free time, so he asked you to calculate the minimum number of problems he should solve on other judges in order to solve all the chosen problems from Decoforces. NoteIn the first example Makes at first solves problems 1 and 2. Then in order to solve the problem with difficulty 9, he should solve problem with difficulty no less than 5. The only available are difficulties 5 and 6 on some other judge. Solving any of these will give Makes opportunity to solve problem 3.In the second example he can solve every problem right from the start. n, k = map(int, input().split())
a = sorted(map(int, input().split()))

ans = 0
from math import log

for i in a:
	if k * 2 >= i:
		k = max(k, i)
	else:
		while k * 2 < i:
			k *= 2
			ans += 1
		k = max(k, i)

print(ans)","['greedy', 'implementation']"
3414,"You are given an array $$$a$$$ that contains $$$n$$$ integers. You can choose any proper subsegment $$$a_l, a_{l + 1}, \ldots, a_r$$$ of this array, meaning you can choose any two integers $$$1 \le l \le r \le n$$$, where $$$r - l + 1 &lt; n$$$. We define the beauty of a given subsegment as the value of the following expression:$$$$$$\max(a_{1}, a_{2}, \ldots, a_{l-1}, a_{r+1}, a_{r+2}, \ldots, a_{n}) - \min(a_{1}, a_{2}, \ldots, a_{l-1}, a_{r+1}, a_{r+2}, \ldots, a_{n}) + \max(a_{l}, \ldots, a_{r}) - \min(a_{l}, \ldots, a_{r}).$$$$$$Please find the maximum beauty among all proper subsegments. NoteIn the first test case, the optimal segment is $$$l = 7$$$, $$$r = 8$$$. The beauty of this segment equals to $$$(6 - 1) + (5 - 1) = 9$$$.In the second test case, the optimal segment is $$$l = 2$$$, $$$r = 4$$$. The beauty of this segment equals $$$(100 - 2) + (200 - 1) = 297$$$. t = int(input())
for _ in range(t):
    n = int(input())
    a = list(map(int,input().split()))
    maxpos=0
    minpos=1
    ans=0
    for i in range(n):
        if a[i]>=a[maxpos]:
            maxpos=i
        if a[i]<=a[minpos]:
            minpos=i
    min1=999999999999999
    max1=0    
    #print(maxpos,minpos)
    for i in range(min(minpos,maxpos)):
        if a[i]<min1:
            min1=a[i]
        if a[i]>max1:
            max1=a[i]
    min2=999999999999999
    max2=0    
    for i in range(min(minpos,maxpos)+1,max(minpos,maxpos)):
        if a[i]<min2:
            min2=a[i]
        if a[i]>max2:
            max2=a[i]
    min3=9999999999999
    max3=0   
    for i in range(max(minpos,maxpos)+1,n):
        if a[i]<min3:
            min3=a[i]
        if a[i]>max3:
            max3=a[i]
    
    mina = min(min1,min2,min3)
    maxa = max(max1,max2,max3)
    ans = a[maxpos]-a[minpos]+maxa-mina
    print(ans)
    ","['brute force', 'data structures', 'greedy', 'math', 'sortings']"
2110,"There is a weighted tree with $$$n$$$ nodes and $$$n-1$$$ edges. The nodes are conveniently labeled from $$$1$$$ to $$$n$$$. The weights are positive integers at most $$$100$$$. Define the distance between two nodes to be the sum of edges on the unique path between the nodes. You would like to find the diameter of the tree. Diameter is the maximum distance between a pair of nodes.Unfortunately, the tree isn't given to you, but you can ask some questions about it. In one question, you can specify two nonempty disjoint sets of nodes $$$p$$$ and $$$q$$$, and the judge will return the maximum distance between a node in $$$p$$$ and a node in $$$q$$$. In the words, maximum distance between $$$x$$$ and $$$y$$$, where $$$x \in p$$$ and $$$y \in q$$$. After asking not more than $$$9$$$ questions, you must report the maximum distance between any pair of nodes. NoteIn the first example, the first tree looks as follows: In the first question, we have $$$p = {1}$$$, and $$$q = {2, 3, 4, 5}$$$. The maximum distance between a node in $$$p$$$ and a node in $$$q$$$ is $$$9$$$ (the distance between nodes $$$1$$$ and $$$5$$$).The second tree is a tree with two nodes with an edge with weight $$$99$$$ between them. import sys
t=int(input())

for _ in range(t):
    n=int(input())
    max_dist=0 
    for bit in range(7):
        a=[]
        b=[]        
        for i in range(1,n+1):
            if (i>>bit)%2:
                a.append(i)
            else:
                b.append(i)

        if len(a)==0 or len(b)==0:
            continue

        l=[len(a),len(b)]+a+b
        out="" "".join(map(str,l))
        print(out+""\n"")

        #print(len(a), len(b), *(a+b))
        sys.stdout.flush()
        d=int(input())
        if d>max_dist:
            max_dist=d        
    print(""-1 ""+str(max_dist))","['bitmasks', 'graphs', 'interactive']"
1813,"In the army, it isn't easy to form a group of soldiers that will be effective on the battlefield. The communication is crucial and thus no two soldiers should share a name (what would happen if they got an order that Bob is a scouter, if there are two Bobs?).A group of soldiers is effective if and only if their names are different. For example, a group (John, Bob, Limak) would be effective, while groups (Gary, Bob, Gary) and (Alice, Alice) wouldn't.You are a spy in the enemy's camp. You noticed n soldiers standing in a row, numbered 1 through n. The general wants to choose a group of k consecutive soldiers. For every k consecutive soldiers, the general wrote down whether they would be an effective group or not.You managed to steal the general's notes, with n - k + 1 strings s1, s2, ..., sn - k + 1, each either ""YES"" or ""NO"".   The string s1 describes a group of soldiers 1 through k (""YES"" if the group is effective, and ""NO"" otherwise).  The string s2 describes a group of soldiers 2 through k + 1.  And so on, till the string sn - k + 1 that describes a group of soldiers n - k + 1 through n. Your task is to find possible names of n soldiers. Names should match the stolen notes. Each name should be a string that consists of between 1 and 10 English letters, inclusive. The first letter should be uppercase, and all other letters should be lowercase. Names don't have to be existing names — it's allowed to print ""Xyzzzdj"" or ""T"" for example.Find and print any solution. It can be proved that there always exists at least one solution. NoteIn the first sample, there are 8 soldiers. For every 3 consecutive ones we know whether they would be an effective group. Let's analyze the provided sample output:  First three soldiers (i.e. Adam, Bob, Bob) wouldn't be an effective group because there are two Bobs. Indeed, the string s1 is ""NO"".  Soldiers 2 through 4 (Bob, Bob, Cpqepqwer) wouldn't be effective either, and the string s2 is ""NO"".  Soldiers 3 through 5 (Bob, Cpqepqwer, Limak) would be effective, and the string s3 is ""YES"".  ...,  Soldiers 6 through 8 (Adam, Bob, Adam) wouldn't be effective, and the string s6 is ""NO"".  n,k = map(int,input().split())
a = list(input().split())

mem = []
mem2 = []
for i in 'abcdefghijklmnopqrstuvwxyz':
    mem.append(i)
    mem.append('a'+i)
    mem2.append('b'+i)
    mem2.append('c'+i)
dp = [-1]*(n)
c = 0
c2 = 0
for i in range(len(a)):
    if a[i] == ""NO"":
        if dp[i] == -1:
            dp[i] = mem2[c2]
            dp[i+k-1] = mem2[c2]
        else:    
            dp[i+k-1] = dp[i]
        c2 += 1
    else:
        for j in range(i,i+k):
            if (dp[j] == -1):
                dp[j] = mem[c]
                c += 1

for i in range(n):
    if dp[i] == -1:
        dp[i] = 'a'
            
for i in dp:
    print(i[0].upper()+i[1:],end=' ')
","['constructive algorithms', 'greedy']"
2810,"In this problem, a $$$n \times m$$$ rectangular matrix $$$a$$$ is called increasing if, for each row of $$$i$$$, when go from left to right, the values strictly increase (that is, $$$a_{i,1}&lt;a_{i,2}&lt;\dots&lt;a_{i,m}$$$) and for each column $$$j$$$, when go from top to bottom, the values strictly increase (that is, $$$a_{1,j}&lt;a_{2,j}&lt;\dots&lt;a_{n,j}$$$).In a given matrix of non-negative integers, it is necessary to replace each value of $$$0$$$ with some positive integer so that the resulting matrix is increasing and the sum of its elements is maximum, or find that it is impossible.It is guaranteed that in a given value matrix all values of $$$0$$$ are contained only in internal cells (that is, not in the first or last row and not in the first or last column). NoteIn the first example, the resulting matrix is as follows: 1 3 5 6 73 6 7 8 95 7 8 9 108 9 10 11 12In the second example, the value $$$3$$$ must be put in the middle cell.In the third example, the desired resultant matrix does not exist. n,m=map(int,input().split())
l=[list(map(int,input().split())) for _ in range(n)]
ans=0
for i in range(n-1,-1,-1):
    for j in range(m-1, -1, -1):
        if l[i][j]==0:
            mr=l[i][j+1]-1
            mc=l[i+1][j]-1
            l[i][j]=min(mr,mc)
            ans+=l[i][j]
        else:
            ans+=l[i][j]

ch=0
for i in range(n):
    dic={}
    for j in range(m):
        if l[i][j] not in dic:
            dic[l[i][j]]=1
            if j>0:
                if l[i][j]<=l[i][j-1]:
                    ch=1
                    break
        else:
            ch=1
            break
    if ch:
        break
if not ch:
    for j in range(m):
        dic={}
        for i in range(n):
            if l[i][j] not in dic:
                dic[l[i][j]]=1
                if i >0:
                    if l[i][j]<=l[i-1][j]:
                        ch=1
                        break
            else:
                ch=1
                break
        if ch:
            break
if ch:
    print(-1)
else:
    print(ans)",['greedy']
4446,"Treeland is a country in which there are n towns connected by n - 1 two-way road such that it's possible to get from any town to any other town. In Treeland there are 2k universities which are located in different towns. Recently, the president signed the decree to connect universities by high-speed network.The Ministry of Education understood the decree in its own way and decided that it was enough to connect each university with another one by using a cable. Formally, the decree will be done! To have the maximum sum in the budget, the Ministry decided to divide universities into pairs so that the total length of the required cable will be maximum. In other words, the total distance between universities in k pairs should be as large as possible. Help the Ministry to find the maximum total distance. Of course, each university should be present in only one pair. Consider that all roads have the same length which is equal to 1.  NoteThe figure below shows one of possible division into pairs in the first test. If you connect universities number 1 and 6 (marked in red) and universities number 2 and 5 (marked in blue) by using the cable, the total distance will equal 6 which will be the maximum sum in this example.    from collections import defaultdict
from sys import stdin

def put(): return map(int, stdin.readline().split())

def dfs():
    s = [(1,0)]
    ans = 0
    vis = [0]*(n+1)
    while s:
        i,p = s.pop()
        if vis[i]==0:
            vis[i]=1
            s.append((i,p))
            for j in tree[i]:
                if j!=p:
                    s.append((j,i))
        elif vis[i]==1:
            vis[i]=2
            for j in tree[i]:
                if j != p:
                    mark[i]+= mark[j]
            ans += min(mark[i], 2*k - mark[i])
    print(ans)
        




n,k = put()
l = list(put())

edge = defaultdict()
tree = [[] for i in range(n+1)]
mark = [0]*(n+1)
for i in l:
    mark[i]=1
for _ in range(n-1):
    x,y = put()
    tree[x].append(y)
    tree[y].append(x)
dfs()","['dfs and similar', 'dp', 'graphs', 'trees']"
1784,"You are given an array $$$a_1, a_2, \dots, a_n$$$, consisting of $$$n$$$ integers. You are also given an integer value $$$x$$$.Let $$$f(k)$$$ be the maximum sum of a contiguous subarray of $$$a$$$ after applying the following operation: add $$$x$$$ to the elements on exactly $$$k$$$ distinct positions. An empty subarray should also be considered, it has sum $$$0$$$.Note that the subarray doesn't have to include all of the increased elements.Calculate the maximum value of $$$f(k)$$$ for all $$$k$$$ from $$$0$$$ to $$$n$$$ independently. NoteIn the first testcase, it doesn't matter which elements you add $$$x$$$ to. The subarray with the maximum sum will always be the entire array. If you increase $$$k$$$ elements by $$$x$$$, $$$k \cdot x$$$ will be added to the sum.In the second testcase:   For $$$k = 0$$$, the empty subarray is the best option.  For $$$k = 1$$$, it's optimal to increase the element at position $$$3$$$. The best sum becomes $$$-1 + 5 = 4$$$ for a subarray $$$[3, 3]$$$.  For $$$k = 2$$$, it's optimal to increase the element at position $$$3$$$ and any other element. The best sum is still $$$4$$$ for a subarray $$$[3, 3]$$$.  For $$$k = 3$$$, you have to increase all elements. The best sum becomes $$$(-2 + 5) + (-7 + 5) + (-1 + 5) = 5$$$ for a subarray $$$[1, 3]$$$.  from heapq import heapify, heappush, heappop
from collections import Counter, defaultdict, deque
from queue import PriorityQueue
from itertools import combinations, product, permutations
from bisect import bisect_left, bisect_right
from functools import lru_cache
from sys import stdin, stdout # for input /output
import copy
import math

import sys
sys.setrecursionlimit(100000)
####################
# stdin = open(""testcase.txt"")
# def input():
	# 	return stdin.readline().strip()

#####################################################################

class FastIO:

	@classmethod
	def input(cls):
		from sys import stdin
		x = stdin.buffer.readline().decode().strip()
		return x

	@classmethod
	def integer_list(cls):
		return list(map(int, cls.input().split()))

	@classmethod
	def print(cls, s = """", end = ""\n""):
		from sys import stdout
		stdout.write(str(s) + end)

	@classmethod
	def flush(cls):
		from sys import stdout
		stdout.flush()


####################################################################

class SegmentTree:
	def __init__(self, data, default=0, func=lambda a, b: a + b):
		""""""initialize the segment tree with data""""""
		"""""" initial default value for each node """"""
		"""""" func which you want to apply to range """"""
		self._default = default
		self._func = func
		self._len = len(data)
		self._size = _size = 1 << (self._len - 1).bit_length()
 
		self.data = [default] * (2 * _size)
		self.data[_size:_size + self._len] = data
		for i in reversed(range(_size)):
			self.data[i] = func(self.data[2*i], self.data[2*i + 1])
 
	def __delitem__(self, idx):
		"""""" delete item set item value to its default """"""
		self[idx] = self._default
 
	def __getitem__(self, idx):
		"""""" geting item by inx """"""
		return self.data[idx + self._size]
 
	def __setitem__(self, idx, value):
		"""""" changing seting value to given index""""""
		"""""" apply function to range """"""
		idx += self._size
		self.data[idx] = value
		idx >>= 1
		while idx:
			self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
			idx >>= 1
 
	def __len__(self):
		return self._len
 
	def query(self, start, stop):
		""""""func of data[start, stop)""""""
		start += self._size
		stop += self._size
 
		res_left = res_right = self._default
		while start < stop:
			if start & 1:
				res_left = self._func(res_left, self.data[start])
				start += 1
			if stop & 1:
				stop -= 1
				res_right = self._func(self.data[stop], res_right)
			start >>= 1
			stop >>= 1
 
		return self._func(res_left, res_right)
 
	def __repr__(self):
		return ""SegmentTree({0})"".format(self.data)

#####################################################################
class BinaryIndexTree(object):
	"""""" use one indexing """"""
	def __init__(self, nums):
		n = len(nums)
		self._len = len(nums)
		self.nums = [0 for _ in range(n+1)]
		self.N = [0 for _ in range(n+1)]
		for i, v in enumerate(nums):
			self.__setitem__(i+1, v)

	def _lowbit(self, a):
		return a & -a

	def  __setitem__(self, i, val):
		diff = val - self.nums[i]
		self.nums[i] = val
		while i < len(self.N):
			self.N[i] += diff
			i += self._lowbit(i)

	def __getitem__(self, i):
		# return sum up 0 to i
		ret = 0
		while i > 0:
			ret += self.N[i]
			i -= self._lowbit(i)

		return ret


#######################################################################

def integer_list():
	return list(map(int, input().split()))

def pprint(matrix):
	for i in range(len(matrix)):
		print(*matrix[i])


#####################################################
#test case section 
""""""  
0 < k < n
add x to k disti ele
 x> = 0 

add x --> 0
add x --> 1

""""""       
#############################################################
# for manipulating 0 for runing to your system 1 for online 

def solve(lst, k, n):


	res = 0
	for i in range(k):
		res += lst[i]


	curr_sum = res 
	for i in range(k, n):
		curr_sum += lst[i] - lst[i-k]
		res = max(res, curr_sum)
	return res
	

MOD = 10**9+7

ONLINE_JUDGE = 1


def main():
	t = int(input())
	# t = 1
	for _ in range(t):
		n, x = integer_list()
		lst = integer_list()
		
		track = [0]
		max_sum = 0
		max_k = 0
		for k in range(1,n+1):
			x1 = solve(lst, k, n)
			track.append(x1)
	

		track[0] = max(lst)
		ans = [0]*(n+1)
		for k in range(n+1):
			temp = 0
			for i in range(n+1):
				temp = max(temp, track[i] + min(k, i)*x)
			ans[k] = temp
		
		
		
		# print(track, max_sum)
		print(*ans)
	
		


###############################################

if ONLINE_JUDGE:
	input = lambda : stdin.buffer.readline().decode().strip()
else:
	stdin = open(""testcase.txt"")
	input = lambda : stdin.readline().strip()
	

main()		
	



","['brute force', 'dp', 'greedy', 'implementation']"
4581,"Recently Vasya got interested in finding extra-terrestrial intelligence. He made a simple extra-terrestrial signals’ receiver and was keeping a record of the signals for n days in a row. Each of those n days Vasya wrote a 1 in his notebook if he had received a signal that day and a 0 if he hadn’t. Vasya thinks that he has found extra-terrestrial intelligence if there is a system in the way the signals has been received, i.e. if all the intervals between successive signals are equal. Otherwise, Vasya thinks that the signals were sent by some stupid aliens no one cares about. Help Vasya to deduce from the information given by the receiver if he has found extra-terrestrial intelligence or not. nan inp = open('input.txt', 'r')
out = open('output.txt', 'w')
n=int(inp.readline())
a=inp.readline()
ans=[]
for i in range(len(a)):
    if a[i]=='1': ans.append(i)
flag=0
d=ans[1]-ans[0]
for i in range(len(ans)-1):
    if ans[i+1]-ans[i]!=d:
        flag=1
out.write('YES' if flag==0 else 'NO')
        
        ",['implementation']
3883,"As a German University in Cairo (GUC) student and a basketball player, Herr Wafa was delighted once he heard the news. GUC is finally participating in the Annual Basketball Competition (ABC). A team is to be formed of n players, all of which are GUC students. However, the team might have players belonging to different departments. There are m departments in GUC, numbered from 1 to m. Herr Wafa's department has number h. For each department i, Herr Wafa knows number si — how many students who play basketball belong to this department.Herr Wafa was also able to guarantee a spot on the team, using his special powers. But since he hates floating-point numbers, he needs your help at finding the probability that he will have at least one teammate belonging to his department. Note that every possible team containing Herr Wafa is equally probable. Consider all the students different from each other. NoteIn the first example all 3 players (2 from department 1 and 1 from department 2) must be chosen for the team. Both players from Wafa's departments will be chosen, so he's guaranteed to have a teammate from his department.In the second example, there are not enough players.In the third example, there are three possibilities to compose the team containing Herr Wafa. In two of them the other player from Herr Wafa's department is part of the team. from fractions import *

def C(n, k):
  res = 1
  for i in xrange(1, k+1):
    res = res*(n-i+1)/i
  return res

def calc(a, b, n):
  s = a + b
  if s < n:
    return -1
  if b == 0:
    return 0

  good = 0
  for i in xrange(0, min(a+1, n)):
    good += C(a, i)*C(b, n-i) 
  return float(Fraction(good, C(s, n)))


n, m, h = map(int, raw_input().split(' '))
c = map(int, raw_input().split(' '))

print calc(sum(c)-c[h-1], c[h-1]-1, n-1)","['combinatorics', 'dp', 'math', 'probabilities']"
544,"ВКонтакте открыла второй штаб в Санкт-Петербурге! Вы не преминули возможностью сменить обстановку и решили переехать из офиса в Доме Зингера в офис на Красном мосту.Для комфортной работы вам потребуются два монитора с одинаковой высотой, чтобы изображение на них выглядело единым целым. На складе офиса на Красном мосту есть $$$n$$$ мониторов, $$$i$$$-й из них имеет ширину $$$w_i$$$ и высоту $$$h_i$$$. Любой монитор можно повернуть на 90 градусов, и тогда он будет иметь ширину $$$h_i$$$ и высоту $$$w_i$$$.Назовём неупорядоченную пару из двух различных мониторов подходящей, если можно их повернуть так, чтобы они имели одинаковую высоту. Любой из мониторов в паре можно как повернуть относительно исходной ориентации, так и не поворачивать.Подсчитайте подходящие пары мониторов. ПримечаниеВ первом примере подходящими являются пары мониторов с номерами $$$(1, 2)$$$, $$$(1, 4)$$$, $$$(1, 5)$$$, $$$(3, 4)$$$, $$$(4, 5)$$$.Во втором примере все пары мониторов — подходящие. n = int(input())
s = []
for i in range(n):
    s.append([int(j) for j in input().split()])
symcnt = {}
double = {}
for now in s:
    stroka1 = str(now)
    el1 = int(stroka1[1:stroka1.find("","")])
    el2 = int(stroka1[stroka1.find("","")+2:len(stroka1)-1])
    if el1 > el2:
        stroka1 = ""["" + str(el2) + "", "" + str(el1) + ""]""
    if el1 != el2:
        if stroka1 not in double:
            double[stroka1] = 0
        double[stroka1] += 1
    if el1 not in symcnt:
        symcnt[el1] = 0
    symcnt[el1] += 1
    if int(el1) != int(el2):
        if el2 not in symcnt:
            symcnt[el2] = 0
        symcnt[el2] += 1
s2 = list(double.values())
res1 = 0
for l in s2:
    if l > 1:
        for j in range(l):
            res1 += j
s1 = list(symcnt.values())
k = 0
for i in s1:
    for j in range(i):
        k += j
print(k - res1)",['other']
677,"For he knew every Who down in Whoville beneath, Was busy now, hanging a mistletoe wreath. ""And they're hanging their stockings!"" he snarled with a sneer, ""Tomorrow is Christmas! It's practically here!""Dr. Suess, How The Grinch Stole ChristmasChristmas celebrations are coming to Whoville. Cindy Lou Who and her parents Lou Lou Who and Betty Lou Who decided to give sweets to all people in their street. They decided to give the residents of each house on the street, one kilogram of sweets. So they need as many kilos of sweets as there are homes on their street.The street, where the Lou Who family lives can be represented as n consecutive sections of equal length. You can go from any section to a neighbouring one in one unit of time. Each of the sections is one of three types: an empty piece of land, a house or a shop. Cindy Lou and her family can buy sweets in a shop, but no more than one kilogram of sweets in one shop (the vendors care about the residents of Whoville not to overeat on sweets).After the Lou Who family leave their home, they will be on the first section of the road. To get to this section of the road, they also require one unit of time. We can assume that Cindy and her mom and dad can carry an unlimited number of kilograms of sweets. Every time they are on a house section, they can give a kilogram of sweets to the inhabitants of the house, or they can simply move to another section. If the family have already given sweets to the residents of a house, they can't do it again. Similarly, if they are on the shop section, they can either buy a kilo of sweets in it or skip this shop. If they've bought a kilo of sweets in a shop, the seller of the shop remembered them and the won't sell them a single candy if they come again. The time to buy and give sweets can be neglected. The Lou Whos do not want the people of any house to remain without food.The Lou Whos want to spend no more than t time units of time to give out sweets, as they really want to have enough time to prepare for the Christmas celebration. In order to have time to give all the sweets, they may have to initially bring additional k kilos of sweets.Cindy Lou wants to know the minimum number of k kilos of sweets they need to take with them, to have time to give sweets to the residents of each house in their street.Your task is to write a program that will determine the minimum possible value of k. NoteIn the first example, there are as many stores, as houses. If the family do not take a single kilo of sweets from home, in order to treat the inhabitants of the first house, they will need to make at least one step back, and they have absolutely no time for it. If they take one kilogram of sweets, they won't need to go back.In the second example, the number of shops is equal to the number of houses and plenty of time. Available at all stores passing out candy in one direction and give them when passing in the opposite direction.In the third example, the shops on the street are fewer than houses. The Lou Whos have to take the missing number of kilograms of sweets with them from home. import sys
def RedirectIO():
    sys.stdin=open(""test.in"",""r"")
#    sys.stdout=open(""output.txt"",""w"")
#RedirectIO()
def calcTime(sections,x,sum):
    ans=0
    start=x
    houres=shops=0
    for i in xrange(x,len(sections)):
        if sum==0: break
        ans+=1
        if sections[i]=='H':
            if shops:
                shops-=1
                sum-=1
            else:
                if houres==0:
                    start=i
                houres+=1
        elif sections[i]=='S':
            shops+=1
            if shops==houres:
                sum-=shops
                shops=houres=0
                if sum:
                    if (i-start)*2>=len(sections)-start-1:
                        ans+=len(sections)-i-1+len(sections)-start-1
                        break
                    ans+=(i-start)*2
                else:
                    ans+=(i-start)
    return ans
def check(sections,k,t,sum):
#    print k,
    i=0
    for ch in sections:
        if sum==0:
            return True
        if ch=='H':
            if k:
                k-=1
                sum-=1
            else:
                break
        elif ch=='S':
            k+=1
        i+=1
    ans=i+calcTime(sections,i,sum)
#    print i,ans-i
    return ans<=t
def main():    
    n,t=map(int,raw_input().split())
    sections=raw_input()
    houres=shops=need=cur=last=i=0
    for ch in sections:
        i+=1
        if ch=='H':
            if cur:
                cur-=1
            else:
                need+=1
            houres+=1
            last=i
        elif ch=='S':
            cur+=1
            shops+=1
    if last>t:
        print -1
        return
    l=max(houres-shops,0)
    r=need
    while l<r:
        m=(l+r)>>1
        if check(sections,m,t,houres)==False:
            l=m+1
        else:
            r=m
    print l
main()
","['binary search', 'greedy', 'implementation']"
624,"Nudist Beach is planning a military operation to attack the Life Fibers. In this operation, they will attack and capture several cities which are currently under the control of the Life Fibers.There are n cities, labeled from 1 to n, and m bidirectional roads between them. Currently, there are Life Fibers in every city. In addition, there are k cities that are fortresses of the Life Fibers that cannot be captured under any circumstances. So, the Nudist Beach can capture an arbitrary non-empty subset of cities with no fortresses.After the operation, Nudist Beach will have to defend the captured cities from counterattack. If they capture a city and it is connected to many Life Fiber controlled cities, it will be easily defeated. So, Nudist Beach would like to capture a set of cities such that for each captured city the ratio of Nudist Beach controlled neighbors among all neighbors of that city is as high as possible. More formally, they would like to capture a non-empty set of cities S with no fortresses of Life Fibers. The strength of a city  is defined as (number of neighbors of x in S) / (total number of neighbors of x). Here, two cities are called neighbors if they are connnected with a road. The goal is to maximize the strength of the weakest city in S.Given a description of the graph, and the cities with fortresses, find a non-empty subset that maximizes the strength of the weakest city.  NoteThe first example case achieves a strength of 1/2. No other subset is strictly better.The second example case achieves a strength of 1. Note that the subset doesn't necessarily have to be connected. import heapq

def read_data():
    '''
    n: number of cities
    m: number of roads
    k: initial numuber of fortresses of Life Fibers
    Es: list of edges
    fs: fs[i] = True -> city i is under control of Life Fibers
    gs: gs[i] number of edges connected to city i
    hs: hs[i] number of adjacent cities under control of Life Fibers
    '''
    n, m, k = map(int, input().split())
    Es = [[] for i in range(n)]
    fs = [False] * n
    gs = [0.0] * n
    hs = [0.0] * n
    fortresses = list(map(int, input().split()))
    for f in fortresses:
        fs[f-1] = True
    for i in range(m):
        a, b = map(int, input().split())
        a -= 1
        b -= 1
        Es[a].append(b)
        Es[b].append(a)
        gs[a] += 1
        gs[b] += 1
        hs[a] += fs[b]
        hs[b] += fs[a]
    return n, m, k, fs, gs, hs, Es


def solve(n, m, k, fs, gs, hs, Es):
    hq = [(-h/g, i) for i, (g, h) in enumerate(zip(gs, hs))]
    hq.sort()
    f_diff = set()
    while hq:
        p, i = heapq.heappop(hq)
        if fs[i] or i in f_diff:
            continue
        update_fs(fs, f_diff)
        f_diff = set()
        dfs(p, i, hq, f_diff, fs, gs, hs, Es)
    return [i + 1 for i, f in enumerate(fs) if not f]


def update_fs(fs, f_diff):
    for f in f_diff:
        fs[f] = True


def dfs(p, i, hq, f_diff, fs, gs, hs, Es):
    fifo = [i]
    f_diff.add(i)
    while fifo:
        i = fifo.pop(-1)
        for j in Es[i]:
            if fs[j] or j in f_diff:
                continue
            hs[j] += 1
            pj = -hs[j]/gs[j]
            if pj > p:
                heapq.heappush(hq, (pj, j))
            else:
                fifo.append(j)
                f_diff.add(j)


if __name__ == '__main__':
    n, m, k, fs, gs, hs, Es = read_data()
    beaches = solve(n, m, k, fs, gs, hs, Es)
    print(len(beaches))
    print(*beaches)","['binary search', 'graphs', 'greedy']"
2178,"You are given two arrays $$$a$$$ and $$$b$$$, both of length $$$n$$$. All elements of both arrays are from $$$0$$$ to $$$n-1$$$.You can reorder elements of the array $$$b$$$ (if you want, you may leave the order of elements as it is). After that, let array $$$c$$$ be the array of length $$$n$$$, the $$$i$$$-th element of this array is $$$c_i = (a_i + b_i) \% n$$$, where $$$x \% y$$$ is $$$x$$$ modulo $$$y$$$.Your task is to reorder elements of the array $$$b$$$ to obtain the lexicographically minimum possible array $$$c$$$.Array $$$x$$$ of length $$$n$$$ is lexicographically less than array $$$y$$$ of length $$$n$$$, if there exists such $$$i$$$ ($$$1 \le i \le n$$$), that $$$x_i &lt; y_i$$$, and for any $$$j$$$ ($$$1 \le j &lt; i$$$) $$$x_j = y_j$$$. nan #!/usr/bin/env python
from __future__ import division, print_function

import os
import sys
from io import BytesIO, IOBase

if sys.version_info[0] < 3:
    from __builtin__ import xrange as range
    from future_builtins import ascii, filter, hex, map, oct, zip
else:
    _str = str
    str = lambda x=b"""": x if type(x) is bytes else _str(x).encode()


class SegmentTree:
    def __init__(self, data, default=0, func=lambda x, y: max(x, y)):
        """"""initialize the segment tree with data""""""
        self._len = _len = len(data)
        self._size = _size = 1 << (_len - 1).bit_length()
        self._data = _data = [default] * (2 * _size)
        self._default = default
        self._func = func
        _data[_size:_size + _len] = data
        for i in reversed(range(_size)):
            _data[i] = func(_data[2 * i], _data[2 * i + 1])

    def __delitem__(self, key):
        self[key] = self._default

    def __getitem__(self, key):
        return self._data[key + self._size]

    def __setitem__(self, key, value):
        key += self._size
        self._data[key] = value
        key >>= 1
        while key:
            self._data[key] = self._func(self._data[2 * key], self._data[2 * key + 1])
            key >>= 1

    def __len__(self):
        return self._len

    def bisect_left(self, value):
        i = 1
        while i < self._size:
            i = 2 * i + 1 if value > self._data[2 * i] else 2 * i
        return i - self._size

    def bisect_right(self, value):
        i = 1
        while i < self._size:
            i = 2 * i + 1 if value >= self._data[2 * i] else 2 * i
        return i - self._size

    bisect = bisect_right

    def query(self, begin, end):
        begin += self._size
        end += self._size
        res = self._default

        while begin < end:
            if begin & 1:
                res = self._func(res, self._data[begin])
                begin += 1
            if end & 1:
                end -= 1
                res = self._func(res, self._data[end])
            begin >>= 1
            end >>= 1

        return res


def main():
    n = int(readline())
    a = map(int, input().split())
    b = SegmentTree(sorted(map(int, input().split())), -1)

    start = 0
    for ai in a:
        idx = b.bisect_left(n - ai)
        if b[idx] < n - ai:
            idx = start
            while b[idx] == -1:
                idx += 1
            start = idx
        cout << (b[idx] + ai) % n << ' '
        del b[idx]
    cout << '\n'


# region template

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._buffer = BytesIO()
        self._fd = file.fileno()
        self._writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self._buffer.write if self._writable else None

    def read(self):
        if self._buffer.tell():
            return self._buffer.read()
        return os.read(self._fd, os.fstat(self._fd).st_size)

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self._buffer.tell()
            self._buffer.seek(0, 2), self._buffer.write(b), self._buffer.seek(ptr)
        self.newlines -= 1
        return self._buffer.readline()

    def flush(self):
        if self._writable:
            os.write(self._fd, self._buffer.getvalue())
            self._buffer.truncate(0), self._buffer.seek(0)


class ostream:
    def __lshift__(self, a):
        if a is endl:
            sys.stdout.write(b""\n"")
            sys.stdout.flush()
        else:
            sys.stdout.write(str(a))
        return self


def print(*args, **kwargs):
    sep, file = kwargs.pop(""sep"", b"" ""), kwargs.pop(""file"", sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop(""end"", b""\n""))
    if kwargs.pop(""flush"", False):
        file.flush()


sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)
cout, endl = ostream(), object()

readline = sys.stdin.readline
readlist = lambda var=int: [var(n) for n in readline().split()]
input = lambda: readline().rstrip(b""\r\n"")

# endregion

if __name__ == ""__main__"":
    main()
","['binary search', 'data structures', 'greedy']"
465,"This is the hard version of the problem. You can find the easy version in the Div. 2 contest. Both versions only differ in the number of times you can ask your friend to taste coffee.This is an interactive problem.You're considering moving to another city, where one of your friends already lives. There are $$$n$$$ cafés in this city, where $$$n$$$ is a power of two. The $$$i$$$-th café produces a single variety of coffee $$$a_i$$$. As you're a coffee-lover, before deciding to move or not, you want to know the number $$$d$$$ of distinct varieties of coffees produced in this city.You don't know the values $$$a_1, \ldots, a_n$$$. Fortunately, your friend has a memory of size $$$k$$$, where $$$k$$$ is a power of two.Once per day, you can ask him to taste a cup of coffee produced by the café $$$c$$$, and he will tell you if he tasted a similar coffee during the last $$$k$$$ days.You can also ask him to take a medication that will reset his memory. He will forget all previous cups of coffee tasted. You can reset his memory at most $$$30\ 000$$$ times.More formally, the memory of your friend is a queue $$$S$$$. Doing a query on café $$$c$$$ will:   Tell you if $$$a_c$$$ is in $$$S$$$;  Add $$$a_c$$$ at the back of $$$S$$$;  If $$$|S| &gt; k$$$, pop the front element of $$$S$$$. Doing a reset request will pop all elements out of $$$S$$$.Your friend can taste at most $$$\dfrac{3n^2}{2k}$$$ cups of coffee in total. Find the diversity $$$d$$$ (number of distinct values in the array $$$a$$$).Note that asking your friend to reset his memory does not count towards the number of times you ask your friend to taste a cup of coffee.In some test cases the behavior of the interactor is adaptive. It means that the array $$$a$$$ may be not fixed before the start of the interaction and may depend on your queries. It is guaranteed that at any moment of the interaction, there is at least one array $$$a$$$ consistent with all the answers given so far. NoteIn the first example, the array is $$$a = [1, 4, 1, 3]$$$. The city produces $$$3$$$ different varieties of coffee ($$$1$$$, $$$3$$$ and $$$4$$$).The successive varieties of coffee tasted by your friend are $$$1, 4, \textbf{1}, 3, 3, 1, 4$$$ (bold answers correspond to Y answers). Note that between the two ? 4 asks, there is a reset memory request R, so the answer to the second ? 4 ask is N. Had there been no reset memory request, the answer to the second ? 4 ask is Y.In the second example, the array is $$$a = [1, 2, 3, 4, 5, 6, 6, 6]$$$. The city produces $$$6$$$ different varieties of coffee.The successive varieties of coffee tasted by your friend are $$$2, 6, 4, 5, \textbf{2}, \textbf{5}$$$. import sys
range = xrange
input = sys.stdin.readline

n, k = [int(x) for x in input().split()]
k += 1

unique = [1]*n
def check(i):
    if unique[i]:
        print '?', i + 1
        sys.stdout.flush()
        if input()[0] == 'Y':
            unique[i] = 0

def reset():
    print 'R'

def ans():
    print '!', sum(unique)

def solve(A):
    if len(A) <= k:
        for a in A:
            check(a)
        return

    B = []
    while A:
        B.append(A[-(k//2):])
        del A[-(k//2):]
    m = len(B)
    for i in range(m):
        j = i + 1
        while j < m:
            for b in B[j]:
                check(b)
            j += 1
            for b in B[i]:
                check(b)
            if j < m:
                for b in B[j]:
                    check(b)
                j += 1
            reset()

solve(list(range(n)))
ans()
","['constructive algorithms', 'graphs', 'interactive']"
3613,"You desperately need to build some string t. For that you've got n more strings s1, s2, ..., sn. To build string t, you are allowed to perform exactly |t| (|t| is the length of string t) operations on these strings. Each operation looks like that:  choose any non-empty string from strings s1, s2, ..., sn;  choose an arbitrary character from the chosen string and write it on a piece of paper;  remove the chosen character from the chosen string. Note that after you perform the described operation, the total number of characters in strings s1, s2, ..., sn decreases by 1. We are assumed to build string t, if the characters, written on the piece of paper, in the order of performed operations form string t.There are other limitations, though. For each string si you know number ai — the maximum number of characters you are allowed to delete from string si. You also know that each operation that results in deleting a character from string si, costs i rubles. That is, an operation on string s1 is the cheapest (it costs 1 ruble), and the operation on string sn is the most expensive one (it costs n rubles).Your task is to count the minimum amount of money (in rubles) you will need to build string t by the given rules. Consider the cost of building string t to be the sum of prices of the operations you use. NoteNotes to the samples:In the first sample from the first string you should take characters ""b"" and ""z"" with price 1 ruble, from the second string characters ""a"", ""e"" и ""b"" with price 2 rubles. The price of the string t in this case is 2·1 + 3·2 = 8.In the second sample from the first string you should take two characters ""a"" with price 1 ruble, from the second string character ""c"" with price 2 rubles, from the third string two characters ""a"" with price 3 rubles, from the fourth string two characters ""b"" with price 4 rubles. The price of the string t in this case is 2·1 + 1·2 + 2·3 + 2·4 = 18.In the third sample the solution doesn't exist because there is no character ""y"" in given strings. class Edge:
    def __init__(self, to, cost, capacity, next_edge):
        self.to = to
        self.cost = cost
        self.origin_cost = cost
        self.capacity = capacity
        self.next_edge = next_edge
        self.pair = None


class MinCostMaxFlow:
    def __init__(self, max_node):
        self.null = Edge(0, 0, 0, None)
        self.max_node = max_node + 3
        self.total_cost = 0
        self.current_cost = 0
        self.visited = [False] * self.max_node
        self.arc_list = []
        self.edge_head = [self.null] * self.max_node
        self.source = max_node + 1
        self.sink = max_node + 2

    def AddArcWithCapacityAndUnitCost(self, start_node, end_node, capacity, cost):
        self.edge_head[start_node] = Edge(end_node, cost, capacity, self.edge_head[start_node])
        self.edge_head[end_node] = Edge(start_node, -cost, 0, self.edge_head[end_node])
        self.edge_head[start_node].pair = self.edge_head[end_node]
        self.edge_head[end_node].pair = self.edge_head[start_node]
        if start_node != self.source and start_node != self.sink and end_node != self.source and end_node != self.sink:
            self.arc_list.append(self.edge_head[end_node])

    def NumArcs(self):
        return len(self.arc_list)

    def Tail(self, index):
        return self.arc_list[index].to

    def Head(self, index):
        return self.arc_list[index].pair.to

    def UnitCost(self, index):
        return self.arc_list[index].pair.origin_cost

    def Flow(self, index):
        return self.arc_list[index].capacity

    def OptimalFlow(self):
        edge = self.edge_head[self.sink]
        total_flow = 0
        while id(edge) != id(self.null):
            total_flow += edge.capacity
            edge = edge.next_edge
        return total_flow

    def OptimalCost(self):
        return self.total_cost

    def SetNodeSupply(self, node, supply):
        if supply > 0:
            self.AddArcWithCapacityAndUnitCost(self.source, node, supply, 0)
        elif supply < 0:
            self.AddArcWithCapacityAndUnitCost(node, self.sink, -supply, 0)

    def aug(self, node_id, total_flow):
        if node_id == self.sink:
            self.total_cost += self.current_cost * total_flow
            return total_flow
        self.visited[node_id] = True
        flow = total_flow
        edge = self.edge_head[node_id]
        while id(edge) != id(self.null):
            if edge.capacity > 0 and edge.cost == 0 and not self.visited[edge.to]:
                delta = self.aug(edge.to, min(flow, edge.capacity))
                edge.capacity -= delta
                edge.pair.capacity += delta
                flow -= delta
                if flow == 0:
                    return total_flow
            edge = edge.next_edge
        return total_flow - flow

    def modify_label(self):
        min_cost = 1 << 63
        for node_id in range(0, self.max_node):
            if not self.visited[node_id]:
                continue
            edge = self.edge_head[node_id]
            while id(edge) != id(self.null):
                if edge.capacity > 0 and not self.visited[edge.to] and edge.cost < min_cost:
                    min_cost = edge.cost
                edge = edge.next_edge
        if min_cost == 1 << 63:
            return False
        for node_id in range(0, self.max_node):
            if not self.visited[node_id]:
                continue
            edge = self.edge_head[node_id]
            while id(edge) != id(self.null):
                edge.cost -= min_cost
                edge.pair.cost += min_cost
                edge = edge.next_edge
        self.current_cost += min_cost
        return True

    def Solve(self):
        while True:
            while True:
                self.visited = [False] * self.max_node
                if self.aug(self.source, 1 << 63) == 0:
                    break
            if not self.modify_label():
                break
        return self.total_cost


def main():
    s = input()
    n = int(input())
    source = 0
    sink = n + 26 + 1
    mcmf = MinCostMaxFlow(n + 28)
    length = len(s)
    num = [0] * 29
    for i in range(0, length):
        num[ord(s[i]) - ord('a') + 1] += 1
    for i in range(1, 27):
        if num[i] > 0:
            mcmf.AddArcWithCapacityAndUnitCost(i, sink, num[i], 0)
    for i in range(1, n + 1):
        s, used = input().split(' ')
        mcmf.AddArcWithCapacityAndUnitCost(source, 26 + i, int(used), 0)
        num = [0] * 29
        for j in range(0, len(s)):
            num[ord(s[j]) - ord('a') + 1] += 1
        for j in range(1, 27):
            if num[j] > 0:
                mcmf.AddArcWithCapacityAndUnitCost(26 + i, j, num[j], i)
    mcmf.SetNodeSupply(source, 1 << 63)
    mcmf.SetNodeSupply(sink, -(1 << 63))
    mcmf.Solve()
    if mcmf.OptimalFlow() != length:
        print(""-1"")
    else:
        print(mcmf.OptimalCost())


if __name__ == '__main__':
    main()
","['graphs', 'other']"
1338,"Alice has a very important message M consisting of some non-negative integers that she wants to keep secret from Eve. Alice knows that the only theoretically secure cipher is one-time pad. Alice generates a random key K of the length equal to the message's length. Alice computes the bitwise xor of each element of the message and the key (, where  denotes the bitwise XOR operation) and stores this encrypted message A. Alice is smart. Be like Alice.For example, Alice may have wanted to store a message M = (0, 15, 9, 18). She generated a key K = (16, 7, 6, 3). The encrypted message is thus A = (16, 8, 15, 17).Alice realised that she cannot store the key with the encrypted message. Alice sent her key K to Bob and deleted her own copy. Alice is smart. Really, be like Alice.Bob realised that the encrypted message is only secure as long as the key is secret. Bob thus randomly permuted the key before storing it. Bob thinks that this way, even if Eve gets both the encrypted message and the key, she will not be able to read the message. Bob is not smart. Don't be like Bob.In the above example, Bob may have, for instance, selected a permutation (3, 4, 1, 2) and stored the permuted key P = (6, 3, 16, 7).One year has passed and Alice wants to decrypt her message. Only now Bob has realised that this is impossible. As he has permuted the key randomly, the message is lost forever. Did we mention that Bob isn't smart?Bob wants to salvage at least some information from the message. Since he is not so smart, he asks for your help. You know the encrypted message A and the permuted key P. What is the lexicographically smallest message that could have resulted in the given encrypted text?More precisely, for given A and P, find the lexicographically smallest message O, for which there exists a permutation π such that  for every i.Note that the sequence S is lexicographically smaller than the sequence T, if there is an index i such that Si &lt; Ti and for all j &lt; i the condition Sj = Tj holds.  NoteIn the first case, the solution is (10, 3, 28), since ,  and . Other possible permutations of key yield messages (25, 6, 10), (25, 3, 15), (10, 21, 10), (15, 21, 15) and (15, 6, 28), which are all lexicographically larger than the solution. def add(x):
    global tree
    now = 0
    tree[now][2] += 1
    for i in range(29, -1, -1):
        bit = (x>>i)&1
        if tree[now][bit]==0:
            tree[now][bit]=len(tree)
            tree.append([0, 0, 0])
        now = tree[now][bit]
        tree[now][2] += 1

def find_min(x):
    global tree
    now = ans = 0
    for i in range(29, -1, -1):
        bit = (x>>i)&1
        if tree[now][bit] and tree[tree[now][bit]][2]:
            now = tree[now][bit]
        else:
            now = tree[now][bit^1]
            ans |= (1<<i)
        tree[now][2] -= 1
    return ans

tree = [[0, 0, 0]]
n = int(input())
a = list(map(int, input().split()))
list(map(add, map(int, input().split())))
[print(x, end=' ') for x in list(map(find_min, a))]","['data structures', 'greedy', 'strings', 'trees']"
4201,"You are given a matrix with $$$n$$$ rows (numbered from $$$1$$$ to $$$n$$$) and $$$m$$$ columns (numbered from $$$1$$$ to $$$m$$$). A number $$$a_{i, j}$$$ is written in the cell belonging to the $$$i$$$-th row and the $$$j$$$-th column, each number is either $$$0$$$ or $$$1$$$.A chip is initially in the cell $$$(1, 1)$$$, and it will be moved to the cell $$$(n, m)$$$. During each move, it either moves to the next cell in the current row, or in the current column (if the current cell is $$$(x, y)$$$, then after the move it can be either $$$(x + 1, y)$$$ or $$$(x, y + 1)$$$). The chip cannot leave the matrix.Consider each path of the chip from $$$(1, 1)$$$ to $$$(n, m)$$$. A path is called palindromic if the number in the first cell is equal to the number in the last cell, the number in the second cell is equal to the number in the second-to-last cell, and so on.Your goal is to change the values in the minimum number of cells so that every path is palindromic. NoteThe resulting matrices in the first three test cases: $$$\begin{pmatrix} 1 &amp; 1\\ 0 &amp; 1 \end{pmatrix}$$$  $$$\begin{pmatrix} 0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0 \end{pmatrix}$$$  $$$\begin{pmatrix} 1 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1\\ 0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 0\\ 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 1 \end{pmatrix}$$$  # import sys
# sys.stdin = open('inputf.in','r')
#sys.stdout = open('outputf.in','w')
t = int(input())
while(t):
	t -= 1
	n,m = map(int, input().split(' '))
	d0 = {}
	d1 = {}
	for i in range(1, n + 1):
		l = list(map(int, input().split(' ')))
		for j in range(1, m + 1):
			x = i + j
			if x not in d0:
				d0[x] = 0
			if x not in d1:
				d1[x] = 0
			d0[x] += (l[j - 1] == 0)
			d1[x] += (l[j - 1] == 1)
	ans = 0
	i = 2
	j = n + m
	while(i < j):
   		x1 = d1[i] + d1[j]
   		x2 = d0[i] + d0[j]
   		i += 1
   		j -= 1
   		ans += min(x1, x2)
	print(ans)","['greedy', 'math']"
3794,"You have an array $$$a_1, a_2, \dots, a_n$$$ consisting of $$$n$$$ distinct integers. You are allowed to perform the following operation on it:  Choose two elements from the array $$$a_i$$$ and $$$a_j$$$ ($$$i \ne j$$$) such that $$$\gcd(a_i, a_j)$$$ is not present in the array, and add $$$\gcd(a_i, a_j)$$$ to the end of the array. Here $$$\gcd(x, y)$$$ denotes greatest common divisor (GCD) of integers $$$x$$$ and $$$y$$$. Note that the array changes after each operation, and the subsequent operations are performed on the new array.What is the maximum number of times you can perform the operation on the array? NoteIn the first example, one of the ways to perform maximum number of operations on the array is:   Pick $$$i = 1, j= 5$$$ and add $$$\gcd(a_1, a_5) = \gcd(4, 30) = 2$$$ to the array.  Pick $$$i = 2, j= 4$$$ and add $$$\gcd(a_2, a_4) = \gcd(20, 25) = 5$$$ to the array.  Pick $$$i = 2, j= 5$$$ and add $$$\gcd(a_2, a_5) = \gcd(20, 30) = 10$$$ to the array. It can be proved that there is no way to perform more than $$$3$$$ operations on the original array.In the second example one can add $$$3$$$, then $$$1$$$, then $$$5$$$, and $$$2$$$. # import sys, os
# if not os.environ.get(""ONLINE_JUDGE""):
#     sys.stdin = open('in.txt', 'r')
#     sys.stdout = open('out.txt', 'w')



import sys
import io, os
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
import math

n = int(input())
arr = list(map(int, input().split()))

m = max(arr)
avail = {i:False for i in range(1, m+1)}
for i in arr:
    avail[i] = True
ans = 0
for i in range(1, m+1):
    if not avail[i]:
        g = 0
        for j in range(2*i, m+1, i):
            if avail[j]:
                g = math.gcd(g, j)
        if g == i:
            ans += 1
print(ans)","['brute force', 'dp', 'math', 'number theory']"
3838,"  Before becoming a successful trader William got a university degree. During his education an interesting situation happened, after which William started to listen to homework assignments much more attentively. What follows is the correct formal description of the homework assignment:You are given a string $$$s$$$ of length $$$n$$$ only consisting of characters ""a"", ""b"" and ""c"". There are $$$q$$$ queries of format ($$$pos, c$$$), meaning replacing the element of string $$$s$$$ at position $$$pos$$$ with character $$$c$$$. After each query you must output the minimal number of characters in the string, which have to be replaced, so that the string doesn't contain string ""abc"" as a substring. A valid replacement of a character is replacing it with ""a"", ""b"" or ""c"".A string $$$x$$$ is a substring of a string $$$y$$$ if $$$x$$$ can be obtained from $$$y$$$ by deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end. NoteLet's consider the state of the string after each query:   $$$s =$$$ ""abcabcabc"". In this case $$$3$$$ replacements can be performed to get, for instance, string $$$s =$$$ ""bbcaccabb"". This string does not contain ""abc"" as a substring. $$$s =$$$ ""bbcabcabc"". In this case $$$2$$$ replacements can be performed to get, for instance, string $$$s =$$$ ""bbcbbcbbc"". This string does not contain ""abc"" as a substring. $$$s =$$$ ""bccabcabc"". In this case $$$2$$$ replacements can be performed to get, for instance, string $$$s =$$$ ""bccbbcbbc"". This string does not contain ""abc"" as a substring. $$$s =$$$ ""bcaabcabc"". In this case $$$2$$$ replacements can be performed to get, for instance, string $$$s =$$$ ""bcabbcbbc"". This string does not contain ""abc"" as a substring. $$$s =$$$ ""bcabbcabc"". In this case $$$1$$$ replacements can be performed to get, for instance, string $$$s =$$$ ""bcabbcabb"". This string does not contain ""abc"" as a substring. $$$s =$$$ ""bcabccabc"". In this case $$$2$$$ replacements can be performed to get, for instance, string $$$s =$$$ ""bcabbcabb"". This string does not contain ""abc"" as a substring. $$$s =$$$ ""bcabccaac"". In this case $$$1$$$ replacements can be performed to get, for instance, string $$$s =$$$ ""bcabbcaac"". This string does not contain ""abc"" as a substring. $$$s =$$$ ""bcabccaab"". In this case $$$1$$$ replacements can be performed to get, for instance, string $$$s =$$$ ""bcabbcaab"". This string does not contain ""abc"" as a substring. $$$s =$$$ ""ccabccaab"". In this case $$$1$$$ replacements can be performed to get, for instance, string $$$s =$$$ ""ccabbcaab"". This string does not contain ""abc"" as a substring. $$$s =$$$ ""ccaaccaab"". In this case the string does not contain ""abc"" as a substring and no replacements are needed. from sys import stdin,stdout
import re
n,m=map(int,input().split())
s=list(input())
k="""".join(s)
l=k.count(""abc"")
for i in range(m):
    j,x=map(str,input().split())
    j=int(j)-1
    if(s[j]==x):
        stdout.write(str(l)+""\n"")
        continue
    if(j+2<n and s[j]==""a"" and s[j+1]==""b"" and s[j+2]==""c""):
        l-=1
    elif(1<j+1<n and s[j-1]==""a"" and s[j]==""b"" and s[j+1]==""c""):
        l-=1
    elif(1<j and s[j-2]==""a"" and s[j-1]==""b"" and s[j]==""c""):
        l-=1
    s[j]=x
    if(j+2<n and s[j]==""a"" and s[j+1]==""b"" and s[j+2]==""c""):
        l+=1
    elif(1<j+1<n and s[j-1]==""a"" and s[j]==""b"" and s[j+1]==""c""):
        l+=1
    elif(1<j and s[j-2]==""a"" and s[j-1]==""b"" and s[j]==""c""):
        l+=1
    if(l<=0):
        l=0
    stdout.write(str(l)+""\n"")
","['implementation', 'strings']"
3081,"A penguin Rocher has $$$n$$$ sticks. He has exactly one stick with length $$$i$$$ for all $$$1 \le i \le n$$$.He can connect some sticks. If he connects two sticks that have lengths $$$a$$$ and $$$b$$$, he gets one stick with length $$$a + b$$$. Two sticks, that were used in the operation disappear from his set and the new connected stick appears in his set and can be used for the next connections.He wants to create the maximum number of sticks that have the same length. It is not necessary to make all sticks have the same length, some sticks can have the other length. How many sticks with the equal length he can create? NoteIn the third case, he can connect two sticks with lengths $$$1$$$ and $$$2$$$ and he will get one stick with length $$$3$$$. So, he will have two sticks with lengths $$$3$$$.In the fourth case, he can connect two sticks with lengths $$$1$$$ and $$$3$$$ and he will get one stick with length $$$4$$$. After that, he will have three sticks with lengths $$$\{2, 4, 4\}$$$, so two sticks have the same length, and one stick has the other length. n=input("""")
cases=[]
for _ in range(int(n)):
    t=input("""")
    cases.append(int(t))
answers=[]

def f(n):
    if n%2==0:
        return n//2
    else:
        return (n//2) +1

for case in cases:
    answers.append(f(case))

for a in answers:
    print(a)
",['math']
3161,"Recently, you found a bot to play ""Rock paper scissors"" with. Unfortunately, the bot uses quite a simple algorithm to play: he has a string $$$s = s_1 s_2 \dots s_{n}$$$ of length $$$n$$$ where each letter is either R, S or P.While initializing, the bot is choosing a starting index $$$pos$$$ ($$$1 \le pos \le n$$$), and then it can play any number of rounds. In the first round, he chooses ""Rock"", ""Scissors"" or ""Paper"" based on the value of $$$s_{pos}$$$:   if $$$s_{pos}$$$ is equal to R the bot chooses ""Rock"";  if $$$s_{pos}$$$ is equal to S the bot chooses ""Scissors"";  if $$$s_{pos}$$$ is equal to P the bot chooses ""Paper""; In the second round, the bot's choice is based on the value of $$$s_{pos + 1}$$$. In the third round — on $$$s_{pos + 2}$$$ and so on. After $$$s_n$$$ the bot returns to $$$s_1$$$ and continues his game.You plan to play $$$n$$$ rounds and you've already figured out the string $$$s$$$ but still don't know what is the starting index $$$pos$$$. But since the bot's tactic is so boring, you've decided to find $$$n$$$ choices to each round to maximize the average number of wins.In other words, let's suggest your choices are $$$c_1 c_2 \dots c_n$$$ and if the bot starts from index $$$pos$$$ then you'll win in $$$win(pos)$$$ rounds. Find $$$c_1 c_2 \dots c_n$$$ such that $$$\frac{win(1) + win(2) + \dots + win(n)}{n}$$$ is maximum possible. NoteIn the first test case, the bot (wherever it starts) will always choose ""Rock"", so we can always choose ""Paper"". So, in any case, we will win all $$$n = 4$$$ rounds, so the average is also equal to $$$4$$$.In the second test case:   if bot will start from $$$pos = 1$$$, then $$$(s_1, c_1)$$$ is draw, $$$(s_2, c_2)$$$ is draw and $$$(s_3, c_3)$$$ is draw, so $$$win(1) = 0$$$;  if bot will start from $$$pos = 2$$$, then $$$(s_2, c_1)$$$ is win, $$$(s_3, c_2)$$$ is win and $$$(s_1, c_3)$$$ is win, so $$$win(2) = 3$$$;  if bot will start from $$$pos = 3$$$, then $$$(s_3, c_1)$$$ is lose, $$$(s_1, c_2)$$$ is lose and $$$(s_2, c_3)$$$ is lose, so $$$win(3) = 0$$$;  The average is equal to $$$\frac{0 + 3 + 0}{3} = 1$$$ and it can be proven that it's the maximum possible average.A picture from Wikipedia explaining ""Rock paper scissors"" game:    for _ in range(int(input())):
    n=input();r,s,p=0,0,0
    for i in  n:
        if i==""R"":r+=1 
        elif i==""P"":p+=1 
        else:s+=1 
    if max(r,s,p)==r:
        print(""P""*len(n))
    elif max(r,p,s)==p:
        print(""S""*len(n))
    else:
        print(""R""*len(n))",['greedy']
149,"Vasya has a sequence of cubes and exactly one integer is written on each cube. Vasya exhibited all his cubes in a row. So the sequence of numbers written on the cubes in the order from the left to the right equals to a1, a2, ..., an.While Vasya was walking, his little brother Stepan played with Vasya's cubes and changed their order, so now the sequence of numbers written on the cubes became equal to b1, b2, ..., bn. Stepan said that he swapped only cubes which where on the positions between l and r, inclusive, and did not remove or add any other cubes (i. e. he said that he reordered cubes between positions l and r, inclusive, in some way).Your task is to determine if it is possible that Stepan said the truth, or it is guaranteed that Stepan deceived his brother. NoteIn the first example there is a situation when Stepan said the truth. Initially the sequence of integers on the cubes was equal to [3, 4, 2, 3, 1]. Stepan could at first swap cubes on positions 2 and 3 (after that the sequence of integers on cubes became equal to [3, 2, 4, 3, 1]), and then swap cubes in positions 3 and 4 (after that the sequence of integers on cubes became equal to [3, 2, 3, 4, 1]).In the second example it is not possible that Stepan said truth because he said that he swapped cubes only between positions 1 and 2, but we can see that it is guaranteed that he changed the position of the cube which was on the position 3 at first. So it is guaranteed that Stepan deceived his brother.In the third example for any values l and r there is a situation when Stepan said the truth. nlr=(raw_input()).split()
a=(raw_input()).split()
b=(raw_input()).split()
n=int(nlr[0])
l=int(nlr[1])
r=int(nlr[2])
al=a[0:l-1]
am=a[l-1:r]
ar=a[r:n]
bl=b[0:l-1]
bm=b[l-1:r]
br=b[r:n]
am=sorted(am)
bm=sorted(bm)
if al==bl and am==bm and ar==br:
  print ""TRUTH""
else:
  print ""LIE""","['implementation', 'other', 'sortings']"
4675,"Gardener Alexey teaches competitive programming to high school students. To congratulate Alexey on the Teacher's Day, the students have gifted him a collection of wooden sticks, where every stick has an integer length. Now Alexey wants to grow a tree from them.The tree looks like a polyline on the plane, consisting of all sticks. The polyline starts at the point $$$(0, 0)$$$. While constructing the polyline, Alexey will attach sticks to it one by one in arbitrary order. Each stick must be either vertical or horizontal (that is, parallel to $$$OX$$$ or $$$OY$$$ axis). It is not allowed for two consecutive sticks to be aligned simultaneously horizontally or simultaneously vertically. See the images below for clarification.Alexey wants to make a polyline in such a way that its end is as far as possible from $$$(0, 0)$$$. Please help him to grow the tree this way.Note that the polyline defining the form of the tree may have self-intersections and self-touches, but it can be proved that the optimal answer does not contain any self-intersections or self-touches. NoteThe following pictures show optimal trees for example tests. The squared distance in the first example equals $$$5 \cdot 5 + 1 \cdot 1 = 26$$$, and in the second example $$$4 \cdot 4 + 2 \cdot 2 = 20$$$.     n = int(input())
line = input().split()
arr = []
for i in range(n):
    arr.append(int(line[i]))
arr.sort(reverse = True)
import math
x = sum(arr[:math.ceil(n/2)])
# print(x)
y = sum(arr[math.ceil(n/2):])
# print(y)
print((x**2) + (y**2))
        ","['greedy', 'math', 'sortings']"
626,"You are given a set of n elements indexed from 1 to n. The weight of i-th element is wi. The weight of some subset of a given set is denoted as . The weight of some partition R of a given set into k subsets is  (recall that a partition of a given set is a set of its subsets such that every element of the given set belongs to exactly one subset in partition).Calculate the sum of weights of all partitions of a given set into exactly k non-empty subsets, and print it modulo 109 + 7. Two partitions are considered different iff there exist two elements x and y such that they belong to the same set in one of the partitions, and to different sets in another partition. NotePossible partitions in the first sample:  {{1, 2, 3}, {4}}, W(R) = 3·(w1 + w2 + w3) + 1·w4 = 24;  {{1, 2, 4}, {3}}, W(R) = 26;  {{1, 3, 4}, {2}}, W(R) = 24;  {{1, 2}, {3, 4}}, W(R) = 2·(w1 + w2) + 2·(w3 + w4) = 20;  {{1, 3}, {2, 4}}, W(R) = 20;  {{1, 4}, {2, 3}}, W(R) = 20;  {{1}, {2, 3, 4}}, W(R) = 26; Possible partitions in the second sample:  {{1, 2, 3, 4}, {5}}, W(R) = 45;  {{1, 2, 3, 5}, {4}}, W(R) = 48;  {{1, 2, 4, 5}, {3}}, W(R) = 51;  {{1, 3, 4, 5}, {2}}, W(R) = 54;  {{2, 3, 4, 5}, {1}}, W(R) = 57;  {{1, 2, 3}, {4, 5}}, W(R) = 36;  {{1, 2, 4}, {3, 5}}, W(R) = 37;  {{1, 2, 5}, {3, 4}}, W(R) = 38;  {{1, 3, 4}, {2, 5}}, W(R) = 38;  {{1, 3, 5}, {2, 4}}, W(R) = 39;  {{1, 4, 5}, {2, 3}}, W(R) = 40;  {{2, 3, 4}, {1, 5}}, W(R) = 39;  {{2, 3, 5}, {1, 4}}, W(R) = 40;  {{2, 4, 5}, {1, 3}}, W(R) = 41;  {{3, 4, 5}, {1, 2}}, W(R) = 42.  n, k = map(int, input().split())

MOD = 10**9+7


def fast_modinv(up_to, M):
    ''' Fast modular inverses of 1..up_to   modulo M. '''
    modinv = [-1 for _ in range(up_to + 1)]
    modinv[1] = 1
    for x in range(2, up_to + 1):
        modinv[x] = (-(M//x) * modinv[M%x])%M
    return modinv

maxn = 2*10**5 + 10
modinv = fast_modinv(maxn, MOD)
fact, factinv = [1], [1]
for i in range(1, maxn):
    fact.append(fact[-1]*i % MOD)
    factinv.append(factinv[-1]*modinv[i] % MOD)


def Stirling(n, k):
    '''The Stirling number of second kind (number of nonempty partitions). '''
    if k > n:
        return 0
    result = 0
    for j in range(k+1):
        result += (-1 if (k-j)&1 else 1) * fact[k] * factinv[j] * factinv[k - j] * pow(j, n, MOD) % MOD
        result %= MOD
    result *= factinv[k]
    return result % MOD

W = sum(map(int, input().split())) % MOD
print((Stirling(n, k) + (n - 1) * Stirling(n - 1, k))* W % MOD)
","['combinatorics', 'math', 'number theory']"
1691,"You all know that the Library of Bookland is the largest library in the world. There are dozens of thousands of books in the library.Some long and uninteresting story was removed...The alphabet of Bookland is so large that its letters are denoted by positive integers. Each letter can be small or large, the large version of a letter x is denoted by x'. BSCII encoding, which is used everywhere in Bookland, is made in that way so that large letters are presented in the order of the numbers they are denoted by, and small letters are presented in the order of the numbers they are denoted by, but all large letters are before all small letters. For example, the following conditions hold: 2 &lt; 3, 2' &lt; 3', 3' &lt; 2.A word x1, x2, ..., xa is not lexicographically greater than y1, y2, ..., yb if one of the two following conditions holds:   a ≤ b and x1 = y1, ..., xa = ya, i.e. the first word is the prefix of the second word;  there is a position 1 ≤ j ≤ min(a, b), such that x1 = y1, ..., xj - 1 = yj - 1 and xj &lt; yj, i.e. at the first position where the words differ the first word has a smaller letter than the second word has.  For example, the word ""3' 7 5"" is before the word ""2 4' 6"" in lexicographical order. It is said that sequence of words is in lexicographical order if each word is not lexicographically greater than the next word in the sequence.Denis has a sequence of words consisting of small letters only. He wants to change some letters to large (let's call this process a capitalization) in such a way that the sequence of words is in lexicographical order. However, he soon realized that for some reason he can't change a single letter in a single word. He only can choose a letter and change all of its occurrences in all words to large letters. He can perform this operation any number of times with arbitrary letters of Bookland's alphabet.Help Denis to choose which letters he needs to capitalize (make large) in order to make the sequence of words lexicographically ordered, or determine that it is impossible.Note that some words can be equal. NoteIn the first example after Denis makes letters 2 and 3 large, the sequence looks like the following:  2'  1  1 3' 2'  1 1 The condition 2' &lt; 1 holds, so the first word is not lexicographically larger than the second word. The second word is the prefix of the third word, so the are in lexicographical order. As the first letters of the third and the fourth words are the same, and 3' &lt; 1, then the third word is not lexicographically larger than the fourth word.In the second example the words are in lexicographical order from the beginning, so Denis can do nothing.In the third example there is no set of letters such that if Denis capitalizes them, the sequence becomes lexicographically ordered. from collections import defaultdict, deque

def main():
    n,m = map(int, input().split())
    cap = [None]*(m+1)
    same_cap = defaultdict(list)
    q = deque()

    def apply_cap(a, c):
        if cap[a] is not None:
            return cap[a] == c
        q.append((a,c))
        while q:
            b = q.pop()
            if b[1] == c:
                if cap[b[0]] is None:
                    cap[b[0]] = c
                    q.extend(same_cap[b[0]])
                    same_cap[b[0]] = []
                elif cap[b[0]]!=c:
                    return False

        return True

    def same(a,b):
        same_cap[b].append((a,True))
        same_cap[a].append((b,False))

        if cap[a] == False:
            return apply_cap(b, False)

        if cap[b] == True:
            return apply_cap(a, True)

        return True

    def process(p,c):
        lp = p[0]
        lc = c[0]
        for i in range(1, min(lp,lc)+1):
            if p[i]>c[i]:
                return apply_cap(p[i], True) and apply_cap(c[i], False)
            if p[i]<c[i]:
                return same(p[i], c[i])
        return lp<=lc

    p = list(map(int, input().split()))
    for i in range(n-1):
        c = list(map(int, input().split()))
        if not process(p, c):
            print ('No')
            break
        p = c
    else:
        print ('Yes')
        res = []
        for i,b in enumerate(cap):
            if b:
                res.append(i)
        print(len(res))
        print(' '.join(map(str,res)))

main()","['dfs and similar', 'graphs', 'implementation', 'other']"
1322,"You are given array consisting of n integers. Your task is to find the maximum length of an increasing subarray of the given array.A subarray is the sequence of consecutive elements of the array. Subarray is called increasing if each element of this subarray strictly greater than previous. nan size = int(raw_input())
arr = map(int, raw_input().split(' '))
arr = [int(i) for i in arr]
maximum =1
series =1
for i in range(1,size):
    if arr[i-1] < arr[i]:
        series += 1
        if maximum<series:
            maximum=series
    else:
        series=1
   
print maximum","['dp', 'greedy', 'implementation']"
4347,"There are $$$n$$$ TV shows you want to watch. Suppose the whole time is split into equal parts called ""minutes"". The $$$i$$$-th of the shows is going from $$$l_i$$$-th to $$$r_i$$$-th minute, both ends inclusive.You need a TV to watch a TV show and you can't watch two TV shows which air at the same time on the same TV, so it is possible you will need multiple TVs in some minutes. For example, if segments $$$[l_i, r_i]$$$ and $$$[l_j, r_j]$$$ intersect, then shows $$$i$$$ and $$$j$$$ can't be watched simultaneously on one TV.Once you start watching a show on some TV it is not possible to ""move"" it to another TV (since it would be too distracting), or to watch another show on the same TV until this show ends.There is a TV Rental shop near you. It rents a TV for $$$x$$$ rupees, and charges $$$y$$$ ($$$y &lt; x$$$) rupees for every extra minute you keep the TV. So in order to rent a TV for minutes $$$[a; b]$$$ you will need to pay $$$x + y \cdot (b - a)$$$. You can assume, that taking and returning of the TV doesn't take any time and doesn't distract from watching other TV shows. Find the minimum possible cost to view all shows. Since this value could be too large, print it modulo $$$10^9 + 7$$$. NoteIn the first example, the optimal strategy would be to rent $$$3$$$ TVs to watch:  Show $$$[1, 2]$$$ on the first TV, Show $$$[4, 10]$$$ on the second TV, Shows $$$[2, 4], [5, 9], [10, 11]$$$ on the third TV. This way the cost for the first TV is $$$4 + 3 \cdot (2 - 1) = 7$$$, for the second is $$$4 + 3 \cdot (10 - 4) = 22$$$ and for the third is $$$4 + 3 \cdot (11 - 2) = 31$$$, which gives $$$60$$$ int total.In the second example, it is optimal watch each show on a new TV.In third example, it is optimal to watch both shows on a new TV. Note that the answer is to be printed modulo $$$10^9 + 7$$$. #!/usr/bin/env python
""""""
This file is part of https://github.com/Cheran-Senthil/PyRival.

Copyright 2018 Cheran Senthilkumar all rights reserved,
Cheran Senthilkumar <hello@cheran.io>
Permission to use, modify, and distribute this software is given under the
terms of the MIT License.

""""""
from __future__ import division, print_function

import cmath
import itertools
import math
import operator as op
# import random
import sys
from atexit import register
from bisect import bisect_left, bisect_right
# from collections import Counter, MutableSequence, defaultdict, deque
# from copy import deepcopy
# from decimal import Decimal
# from difflib import SequenceMatcher
# from fractions import Fraction
# from heapq import heappop, heappush

if sys.version_info[0] < 3:
    # from cPickle import dumps
    from io import BytesIO as stream
    # from Queue import PriorityQueue, Queue
else:
    # from functools import reduce
    from io import StringIO as stream
    from math import gcd
    # from pickle import dumps
    # from queue import PriorityQueue, Queue


if sys.version_info[0] < 3:
    class dict(dict):
        """"""dict() -> new empty dictionary""""""
        def items(self):
            """"""D.items() -> a set-like object providing a view on D's items""""""
            return dict.iteritems(self)

        def keys(self):
            """"""D.keys() -> a set-like object providing a view on D's keys""""""
            return dict.iterkeys(self)

        def values(self):
            """"""D.values() -> an object providing a view on D's values""""""
            return dict.itervalues(self)

    def gcd(x, y):
        """"""gcd(x, y) -> int
        greatest common divisor of x and y
        """"""
        while y:
            x, y = y, x % y
        return x

    input = raw_input
    range = xrange

    filter = itertools.ifilter
    map = itertools.imap
    zip = itertools.izip


def sync_with_stdio(sync=True):
    """"""Set whether the standard Python streams are allowed to buffer their I/O.

    Args:
        sync (bool, optional): The new synchronization setting.

    """"""
    global input, flush

    if sync:
        flush = sys.stdout.flush
    else:
        sys.stdin = stream(sys.stdin.read())
        input = lambda: sys.stdin.readline().rstrip('\r\n')

        sys.stdout = stream()
        register(lambda: sys.__stdout__.write(sys.stdout.getvalue()))


def main():
    n, x, y = map(int, input().split(' '))

    l, r, v = [0] * n, [0] * n, [0]*n

    res = 0
    for i in range(n):
        l[i], r[i] = map(int, input().split(' '))
        res += x + (r[i] - l[i]) * y

    l.sort()
    r.sort()

    for i in range(n - 1, -1, -1):
        k = bisect_right(l, r[i])
        while (k < n) and (v[k] == 1) and ((l[k] - r[i]) * y < x):
            k += 1

        if k == n:
            continue

        if (l[k] - r[i]) * y < x:
            v[k] = 1
            res += (l[k] - r[i]) * y - x

    print(res % 1000000007)


if __name__ == '__main__':
    sync_with_stdio(False)
    main()
","['data structures', 'greedy', 'implementation', 'sortings']"
168,"One day n students come to the stadium. They want to play football, and for that they need to split into teams, the teams must have an equal number of people.We know that this group of people has archenemies. Each student has at most two archenemies. Besides, if student A is an archenemy to student B, then student B is an archenemy to student A.The students want to split so as no two archenemies were in one team. If splitting in the required manner is impossible, some students will have to sit on the bench.Determine the minimum number of students you will have to send to the bench in order to form the two teams in the described manner and begin the game at last. nan #
# Author: eloyhz
# Date: Sep/09/2020
#

def form_teams(g, colors, c, s):
#    print(f'{s = }, {c = }')
    colors[s] = c
    for v in g[s]:
        if colors[v] is None:
            form_teams(g, colors, 1 - c, v)
        elif colors[v] == c:
            colors[s] = -1


def solve(n, m, g):
    colors = [None] * (n + 1)
    for i in range(1, n + 1):
        if colors[i] == None:
            form_teams(g, colors, 0, i)
#    print(colors)
    cont = colors.count(-1)
    if (n - cont) % 2 == 0:
        return cont
    else:
        return cont + 1


if __name__ == '__main__':
    n, m = [int(x) for x in input().split()]
    g = [[] for _ in range(n + 1)]
    for _ in range(m):
        a, b = [int(x) for x in input().split()]
        g[a].append(b)
        g[b].append(a)
    print(solve(n, m, g))

","['dfs and similar', 'implementation']"
1235,"Nick is attracted by everything unconventional. He doesn't like decimal number system any more, and he decided to study other number systems. A number system with base b caught his attention. Before he starts studying it, he wants to write in his notepad all the numbers of length n without leading zeros in this number system. Each page in Nick's notepad has enough space for c numbers exactly. Nick writes every suitable number only once, starting with the first clean page and leaving no clean spaces. Nick never writes number 0 as he has unpleasant memories about zero divide.Would you help Nick find out how many numbers will be written on the last page. NoteIn both samples there are exactly 4 numbers of length 3 in binary number system. In the first sample Nick writes 3 numbers on the first page and 1 on the second page. In the second sample all the 4 numbers can be written on the first page. #!/usr/bin/python

primes = [
        2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 
     31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 
     73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 
    127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 
    179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 
    233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 
    283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 
    353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 
    419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 
    467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 
    547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 
    607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 
    661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 
    739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 
    811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 
    877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 
    947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 
   1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 
   1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 
   1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 
   1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 
   1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 
   1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 
   1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 
   1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 
   1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 
   1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 
   1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 
   1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 
   1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 
   1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 
   2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 
   2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 
   2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 
   2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 
   2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 
   2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 
   2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 
   2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 
   2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 
   2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 
   2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 
   2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 
   3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 
   3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 
   3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 
   3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 
   3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 
   3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 
   3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 
   3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 
   3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 
   3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 
   3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 
   3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 
   4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 
   4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 
   4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 
   4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 
   4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 
   4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 
   4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 
   4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 
   4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 
   4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 
   4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 
   4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 
   5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 
   5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 
   5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 
   5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 
   5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 
   5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 
   5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 
   5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 
   5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 
   5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 
   5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 
   5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 
   6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 
   6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 
   6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 
   6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 
   6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 
   6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 
   6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 
   6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 
   6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 
   6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 
   6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 
   7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 
   7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 
   7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 
   7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 
   7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 
   7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 
   7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 
   7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 
   7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 
   7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 
   7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 
   8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 
   8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 
   8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 
   8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 
   8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 
   8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 
   8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 
   8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 
   8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 
   8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 
   8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 
   9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 
   9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 
   9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 
   9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 
   9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 
   9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 
   9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 
   9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 
   9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 
   9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 
   9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973, 10007, 
  10009, 10037, 10039, 10061, 10067, 10069, 10079, 10091, 10093, 10099, 
  10103, 10111, 10133, 10139, 10141, 10151, 10159, 10163, 10169, 10177, 
  10181, 10193, 10211, 10223, 10243, 10247, 10253, 10259, 10267, 10271, 
  10273, 10289, 10301, 10303, 10313, 10321, 10331, 10333, 10337, 10343, 
  10357, 10369, 10391, 10399, 10427, 10429, 10433, 10453, 10457, 10459, 
  10463, 10477, 10487, 10499, 10501, 10513, 10529, 10531, 10559, 10567, 
  10589, 10597, 10601, 10607, 10613, 10627, 10631, 10639, 10651, 10657, 
  10663, 10667, 10687, 10691, 10709, 10711, 10723, 10729, 10733, 10739, 
  10753, 10771, 10781, 10789, 10799, 10831, 10837, 10847, 10853, 10859, 
  10861, 10867, 10883, 10889, 10891, 10903, 10909, 10937, 10939, 10949, 
  10957, 10973, 10979, 10987, 10993, 11003, 11027, 11047, 11057, 11059, 
  11069, 11071, 11083, 11087, 11093, 11113, 11117, 11119, 11131, 11149, 
  11159, 11161, 11171, 11173, 11177, 11197, 11213, 11239, 11243, 11251, 
  11257, 11261, 11273, 11279, 11287, 11299, 11311, 11317, 11321, 11329, 
  11351, 11353, 11369, 11383, 11393, 11399, 11411, 11423, 11437, 11443, 
  11447, 11467, 11471, 11483, 11489, 11491, 11497, 11503, 11519, 11527, 
  11549, 11551, 11579, 11587, 11593, 11597, 11617, 11621, 11633, 11657, 
  11677, 11681, 11689, 11699, 11701, 11717, 11719, 11731, 11743, 11777, 
  11779, 11783, 11789, 11801, 11807, 11813, 11821, 11827, 11831, 11833, 
  11839, 11863, 11867, 11887, 11897, 11903, 11909, 11923, 11927, 11933, 
  11939, 11941, 11953, 11959, 11969, 11971, 11981, 11987, 12007, 12011, 
  12037, 12041, 12043, 12049, 12071, 12073, 12097, 12101, 12107, 12109, 
  12113, 12119, 12143, 12149, 12157, 12161, 12163, 12197, 12203, 12211, 
  12227, 12239, 12241, 12251, 12253, 12263, 12269, 12277, 12281, 12289, 
  12301, 12323, 12329, 12343, 12347, 12373, 12377, 12379, 12391, 12401, 
  12409, 12413, 12421, 12433, 12437, 12451, 12457, 12473, 12479, 12487, 
  12491, 12497, 12503, 12511, 12517, 12527, 12539, 12541, 12547, 12553, 
  12569, 12577, 12583, 12589, 12601, 12611, 12613, 12619, 12637, 12641, 
  12647, 12653, 12659, 12671, 12689, 12697, 12703, 12713, 12721, 12739, 
  12743, 12757, 12763, 12781, 12791, 12799, 12809, 12821, 12823, 12829, 
  12841, 12853, 12889, 12893, 12899, 12907, 12911, 12917, 12919, 12923, 
  12941, 12953, 12959, 12967, 12973, 12979, 12983, 13001, 13003, 13007, 
  13009, 13033, 13037, 13043, 13049, 13063, 13093, 13099, 13103, 13109, 
  13121, 13127, 13147, 13151, 13159, 13163, 13171, 13177, 13183, 13187, 
  13217, 13219, 13229, 13241, 13249, 13259, 13267, 13291, 13297, 13309, 
  13313, 13327, 13331, 13337, 13339, 13367, 13381, 13397, 13399, 13411, 
  13417, 13421, 13441, 13451, 13457, 13463, 13469, 13477, 13487, 13499, 
  13513, 13523, 13537, 13553, 13567, 13577, 13591, 13597, 13613, 13619, 
  13627, 13633, 13649, 13669, 13679, 13681, 13687, 13691, 13693, 13697, 
  13709, 13711, 13721, 13723, 13729, 13751, 13757, 13759, 13763, 13781, 
  13789, 13799, 13807, 13829, 13831, 13841, 13859, 13873, 13877, 13879, 
  13883, 13901, 13903, 13907, 13913, 13921, 13931, 13933, 13963, 13967, 
  13997, 13999, 14009, 14011, 14029, 14033, 14051, 14057, 14071, 14081, 
  14083, 14087, 14107, 14143, 14149, 14153, 14159, 14173, 14177, 14197, 
  14207, 14221, 14243, 14249, 14251, 14281, 14293, 14303, 14321, 14323, 
  14327, 14341, 14347, 14369, 14387, 14389, 14401, 14407, 14411, 14419, 
  14423, 14431, 14437, 14447, 14449, 14461, 14479, 14489, 14503, 14519, 
  14533, 14537, 14543, 14549, 14551, 14557, 14561, 14563, 14591, 14593, 
  14621, 14627, 14629, 14633, 14639, 14653, 14657, 14669, 14683, 14699, 
  14713, 14717, 14723, 14731, 14737, 14741, 14747, 14753, 14759, 14767, 
  14771, 14779, 14783, 14797, 14813, 14821, 14827, 14831, 14843, 14851, 
  14867, 14869, 14879, 14887, 14891, 14897, 14923, 14929, 14939, 14947, 
  14951, 14957, 14969, 14983, 15013, 15017, 15031, 15053, 15061, 15073, 
  15077, 15083, 15091, 15101, 15107, 15121, 15131, 15137, 15139, 15149, 
  15161, 15173, 15187, 15193, 15199, 15217, 15227, 15233, 15241, 15259, 
  15263, 15269, 15271, 15277, 15287, 15289, 15299, 15307, 15313, 15319, 
  15329, 15331, 15349, 15359, 15361, 15373, 15377, 15383, 15391, 15401, 
  15413, 15427, 15439, 15443, 15451, 15461, 15467, 15473, 15493, 15497, 
  15511, 15527, 15541, 15551, 15559, 15569, 15581, 15583, 15601, 15607, 
  15619, 15629, 15641, 15643, 15647, 15649, 15661, 15667, 15671, 15679, 
  15683, 15727, 15731, 15733, 15737, 15739, 15749, 15761, 15767, 15773, 
  15787, 15791, 15797, 15803, 15809, 15817, 15823, 15859, 15877, 15881, 
  15887, 15889, 15901, 15907, 15913, 15919, 15923, 15937, 15959, 15971, 
  15973, 15991, 16001, 16007, 16033, 16057, 16061, 16063, 16067, 16069, 
  16073, 16087, 16091, 16097, 16103, 16111, 16127, 16139, 16141, 16183, 
  16187, 16189, 16193, 16217, 16223, 16229, 16231, 16249, 16253, 16267, 
  16273, 16301, 16319, 16333, 16339, 16349, 16361, 16363, 16369, 16381, 
  16411, 16417, 16421, 16427, 16433, 16447, 16451, 16453, 16477, 16481, 
  16487, 16493, 16519, 16529, 16547, 16553, 16561, 16567, 16573, 16603, 
  16607, 16619, 16631, 16633, 16649, 16651, 16657, 16661, 16673, 16691, 
  16693, 16699, 16703, 16729, 16741, 16747, 16759, 16763, 16787, 16811, 
  16823, 16829, 16831, 16843, 16871, 16879, 16883, 16889, 16901, 16903, 
  16921, 16927, 16931, 16937, 16943, 16963, 16979, 16981, 16987, 16993, 
  17011, 17021, 17027, 17029, 17033, 17041, 17047, 17053, 17077, 17093, 
  17099, 17107, 17117, 17123, 17137, 17159, 17167, 17183, 17189, 17191, 
  17203, 17207, 17209, 17231, 17239, 17257, 17291, 17293, 17299, 17317, 
  17321, 17327, 17333, 17341, 17351, 17359, 17377, 17383, 17387, 17389, 
  17393, 17401, 17417, 17419, 17431, 17443, 17449, 17467, 17471, 17477, 
  17483, 17489, 17491, 17497, 17509, 17519, 17539, 17551, 17569, 17573, 
  17579, 17581, 17597, 17599, 17609, 17623, 17627, 17657, 17659, 17669, 
  17681, 17683, 17707, 17713, 17729, 17737, 17747, 17749, 17761, 17783, 
  17789, 17791, 17807, 17827, 17837, 17839, 17851, 17863, 17881, 17891, 
  17903, 17909, 17911, 17921, 17923, 17929, 17939, 17957, 17959, 17971, 
  17977, 17981, 17987, 17989, 18013, 18041, 18043, 18047, 18049, 18059, 
  18061, 18077, 18089, 18097, 18119, 18121, 18127, 18131, 18133, 18143, 
  18149, 18169, 18181, 18191, 18199, 18211, 18217, 18223, 18229, 18233, 
  18251, 18253, 18257, 18269, 18287, 18289, 18301, 18307, 18311, 18313, 
  18329, 18341, 18353, 18367, 18371, 18379, 18397, 18401, 18413, 18427, 
  18433, 18439, 18443, 18451, 18457, 18461, 18481, 18493, 18503, 18517, 
  18521, 18523, 18539, 18541, 18553, 18583, 18587, 18593, 18617, 18637, 
  18661, 18671, 18679, 18691, 18701, 18713, 18719, 18731, 18743, 18749, 
  18757, 18773, 18787, 18793, 18797, 18803, 18839, 18859, 18869, 18899, 
  18911, 18913, 18917, 18919, 18947, 18959, 18973, 18979, 19001, 19009, 
  19013, 19031, 19037, 19051, 19069, 19073, 19079, 19081, 19087, 19121, 
  19139, 19141, 19157, 19163, 19181, 19183, 19207, 19211, 19213, 19219, 
  19231, 19237, 19249, 19259, 19267, 19273, 19289, 19301, 19309, 19319, 
  19333, 19373, 19379, 19381, 19387, 19391, 19403, 19417, 19421, 19423, 
  19427, 19429, 19433, 19441, 19447, 19457, 19463, 19469, 19471, 19477, 
  19483, 19489, 19501, 19507, 19531, 19541, 19543, 19553, 19559, 19571, 
  19577, 19583, 19597, 19603, 19609, 19661, 19681, 19687, 19697, 19699, 
  19709, 19717, 19727, 19739, 19751, 19753, 19759, 19763, 19777, 19793, 
  19801, 19813, 19819, 19841, 19843, 19853, 19861, 19867, 19889, 19891, 
  19913, 19919, 19927, 19937, 19949, 19961, 19963, 19973, 19979, 19991, 
  19993, 19997, 20011, 20021, 20023, 20029, 20047, 20051, 20063, 20071, 
  20089, 20101, 20107, 20113, 20117, 20123, 20129, 20143, 20147, 20149, 
  20161, 20173, 20177, 20183, 20201, 20219, 20231, 20233, 20249, 20261, 
  20269, 20287, 20297, 20323, 20327, 20333, 20341, 20347, 20353, 20357, 
  20359, 20369, 20389, 20393, 20399, 20407, 20411, 20431, 20441, 20443, 
  20477, 20479, 20483, 20507, 20509, 20521, 20533, 20543, 20549, 20551, 
  20563, 20593, 20599, 20611, 20627, 20639, 20641, 20663, 20681, 20693, 
  20707, 20717, 20719, 20731, 20743, 20747, 20749, 20753, 20759, 20771, 
  20773, 20789, 20807, 20809, 20849, 20857, 20873, 20879, 20887, 20897, 
  20899, 20903, 20921, 20929, 20939, 20947, 20959, 20963, 20981, 20983, 
  21001, 21011, 21013, 21017, 21019, 21023, 21031, 21059, 21061, 21067, 
  21089, 21101, 21107, 21121, 21139, 21143, 21149, 21157, 21163, 21169, 
  21179, 21187, 21191, 21193, 21211, 21221, 21227, 21247, 21269, 21277, 
  21283, 21313, 21317, 21319, 21323, 21341, 21347, 21377, 21379, 21383, 
  21391, 21397, 21401, 21407, 21419, 21433, 21467, 21481, 21487, 21491, 
  21493, 21499, 21503, 21517, 21521, 21523, 21529, 21557, 21559, 21563, 
  21569, 21577, 21587, 21589, 21599, 21601, 21611, 21613, 21617, 21647, 
  21649, 21661, 21673, 21683, 21701, 21713, 21727, 21737, 21739, 21751, 
  21757, 21767, 21773, 21787, 21799, 21803, 21817, 21821, 21839, 21841, 
  21851, 21859, 21863, 21871, 21881, 21893, 21911, 21929, 21937, 21943, 
  21961, 21977, 21991, 21997, 22003, 22013, 22027, 22031, 22037, 22039, 
  22051, 22063, 22067, 22073, 22079, 22091, 22093, 22109, 22111, 22123, 
  22129, 22133, 22147, 22153, 22157, 22159, 22171, 22189, 22193, 22229, 
  22247, 22259, 22271, 22273, 22277, 22279, 22283, 22291, 22303, 22307, 
  22343, 22349, 22367, 22369, 22381, 22391, 22397, 22409, 22433, 22441, 
  22447, 22453, 22469, 22481, 22483, 22501, 22511, 22531, 22541, 22543, 
  22549, 22567, 22571, 22573, 22613, 22619, 22621, 22637, 22639, 22643, 
  22651, 22669, 22679, 22691, 22697, 22699, 22709, 22717, 22721, 22727, 
  22739, 22741, 22751, 22769, 22777, 22783, 22787, 22807, 22811, 22817, 
  22853, 22859, 22861, 22871, 22877, 22901, 22907, 22921, 22937, 22943, 
  22961, 22963, 22973, 22993, 23003, 23011, 23017, 23021, 23027, 23029, 
  23039, 23041, 23053, 23057, 23059, 23063, 23071, 23081, 23087, 23099, 
  23117, 23131, 23143, 23159, 23167, 23173, 23189, 23197, 23201, 23203, 
  23209, 23227, 23251, 23269, 23279, 23291, 23293, 23297, 23311, 23321, 
  23327, 23333, 23339, 23357, 23369, 23371, 23399, 23417, 23431, 23447, 
  23459, 23473, 23497, 23509, 23531, 23537, 23539, 23549, 23557, 23561, 
  23563, 23567, 23581, 23593, 23599, 23603, 23609, 23623, 23627, 23629, 
  23633, 23663, 23669, 23671, 23677, 23687, 23689, 23719, 23741, 23743, 
  23747, 23753, 23761, 23767, 23773, 23789, 23801, 23813, 23819, 23827, 
  23831, 23833, 23857, 23869, 23873, 23879, 23887, 23893, 23899, 23909, 
  23911, 23917, 23929, 23957, 23971, 23977, 23981, 23993, 24001, 24007, 
  24019, 24023, 24029, 24043, 24049, 24061, 24071, 24077, 24083, 24091, 
  24097, 24103, 24107, 24109, 24113, 24121, 24133, 24137, 24151, 24169, 
  24179, 24181, 24197, 24203, 24223, 24229, 24239, 24247, 24251, 24281, 
  24317, 24329, 24337, 24359, 24371, 24373, 24379, 24391, 24407, 24413, 
  24419, 24421, 24439, 24443, 24469, 24473, 24481, 24499, 24509, 24517, 
  24527, 24533, 24547, 24551, 24571, 24593, 24611, 24623, 24631, 24659, 
  24671, 24677, 24683, 24691, 24697, 24709, 24733, 24749, 24763, 24767, 
  24781, 24793, 24799, 24809, 24821, 24841, 24847, 24851, 24859, 24877, 
  24889, 24907, 24917, 24919, 24923, 24943, 24953, 24967, 24971, 24977, 
  24979, 24989, 25013, 25031, 25033, 25037, 25057, 25073, 25087, 25097, 
  25111, 25117, 25121, 25127, 25147, 25153, 25163, 25169, 25171, 25183, 
  25189, 25219, 25229, 25237, 25243, 25247, 25253, 25261, 25301, 25303, 
  25307, 25309, 25321, 25339, 25343, 25349, 25357, 25367, 25373, 25391, 
  25409, 25411, 25423, 25439, 25447, 25453, 25457, 25463, 25469, 25471, 
  25523, 25537, 25541, 25561, 25577, 25579, 25583, 25589, 25601, 25603, 
  25609, 25621, 25633, 25639, 25643, 25657, 25667, 25673, 25679, 25693, 
  25703, 25717, 25733, 25741, 25747, 25759, 25763, 25771, 25793, 25799, 
  25801, 25819, 25841, 25847, 25849, 25867, 25873, 25889, 25903, 25913, 
  25919, 25931, 25933, 25939, 25943, 25951, 25969, 25981, 25997, 25999, 
  26003, 26017, 26021, 26029, 26041, 26053, 26083, 26099, 26107, 26111, 
  26113, 26119, 26141, 26153, 26161, 26171, 26177, 26183, 26189, 26203, 
  26209, 26227, 26237, 26249, 26251, 26261, 26263, 26267, 26293, 26297, 
  26309, 26317, 26321, 26339, 26347, 26357, 26371, 26387, 26393, 26399, 
  26407, 26417, 26423, 26431, 26437, 26449, 26459, 26479, 26489, 26497, 
  26501, 26513, 26539, 26557, 26561, 26573, 26591, 26597, 26627, 26633, 
  26641, 26647, 26669, 26681, 26683, 26687, 26693, 26699, 26701, 26711, 
  26713, 26717, 26723, 26729, 26731, 26737, 26759, 26777, 26783, 26801, 
  26813, 26821, 26833, 26839, 26849, 26861, 26863, 26879, 26881, 26891, 
  26893, 26903, 26921, 26927, 26947, 26951, 26953, 26959, 26981, 26987, 
  26993, 27011, 27017, 27031, 27043, 27059, 27061, 27067, 27073, 27077, 
  27091, 27103, 27107, 27109, 27127, 27143, 27179, 27191, 27197, 27211, 
  27239, 27241, 27253, 27259, 27271, 27277, 27281, 27283, 27299, 27329, 
  27337, 27361, 27367, 27397, 27407, 27409, 27427, 27431, 27437, 27449, 
  27457, 27479, 27481, 27487, 27509, 27527, 27529, 27539, 27541, 27551, 
  27581, 27583, 27611, 27617, 27631, 27647, 27653, 27673, 27689, 27691, 
  27697, 27701, 27733, 27737, 27739, 27743, 27749, 27751, 27763, 27767, 
  27773, 27779, 27791, 27793, 27799, 27803, 27809, 27817, 27823, 27827, 
  27847, 27851, 27883, 27893, 27901, 27917, 27919, 27941, 27943, 27947, 
  27953, 27961, 27967, 27983, 27997, 28001, 28019, 28027, 28031, 28051, 
  28057, 28069, 28081, 28087, 28097, 28099, 28109, 28111, 28123, 28151, 
  28163, 28181, 28183, 28201, 28211, 28219, 28229, 28277, 28279, 28283, 
  28289, 28297, 28307, 28309, 28319, 28349, 28351, 28387, 28393, 28403, 
  28409, 28411, 28429, 28433, 28439, 28447, 28463, 28477, 28493, 28499, 
  28513, 28517, 28537, 28541, 28547, 28549, 28559, 28571, 28573, 28579, 
  28591, 28597, 28603, 28607, 28619, 28621, 28627, 28631, 28643, 28649, 
  28657, 28661, 28663, 28669, 28687, 28697, 28703, 28711, 28723, 28729, 
  28751, 28753, 28759, 28771, 28789, 28793, 28807, 28813, 28817, 28837, 
  28843, 28859, 28867, 28871, 28879, 28901, 28909, 28921, 28927, 28933, 
  28949, 28961, 28979, 29009, 29017, 29021, 29023, 29027, 29033, 29059, 
  29063, 29077, 29101, 29123, 29129, 29131, 29137, 29147, 29153, 29167, 
  29173, 29179, 29191, 29201, 29207, 29209, 29221, 29231, 29243, 29251, 
  29269, 29287, 29297, 29303, 29311, 29327, 29333, 29339, 29347, 29363, 
  29383, 29387, 29389, 29399, 29401, 29411, 29423, 29429, 29437, 29443, 
  29453, 29473, 29483, 29501, 29527, 29531, 29537, 29567, 29569, 29573, 
  29581, 29587, 29599, 29611, 29629, 29633, 29641, 29663, 29669, 29671, 
  29683, 29717, 29723, 29741, 29753, 29759, 29761, 29789, 29803, 29819, 
  29833, 29837, 29851, 29863, 29867, 29873, 29879, 29881, 29917, 29921, 
  29927, 29947, 29959, 29983, 29989, 30011, 30013, 30029, 30047, 30059, 
  30071, 30089, 30091, 30097, 30103, 30109, 30113, 30119, 30133, 30137, 
  30139, 30161, 30169, 30181, 30187, 30197, 30203, 30211, 30223, 30241, 
  30253, 30259, 30269, 30271, 30293, 30307, 30313, 30319, 30323, 30341, 
  30347, 30367, 30389, 30391, 30403, 30427, 30431, 30449, 30467, 30469, 
  30491, 30493, 30497, 30509, 30517, 30529, 30539, 30553, 30557, 30559, 
  30577, 30593, 30631, 30637, 30643, 30649, 30661, 30671, 30677, 30689, 
  30697, 30703, 30707, 30713, 30727, 30757, 30763, 30773, 30781, 30803, 
  30809, 30817, 30829, 30839, 30841, 30851, 30853, 30859, 30869, 30871, 
  30881, 30893, 30911, 30931, 30937, 30941, 30949, 30971, 30977, 30983, 
  31013, 31019, 31033, 31039, 31051, 31063, 31069, 31079, 31081, 31091, 
  31121, 31123, 31139, 31147, 31151, 31153, 31159, 31177, 31181, 31183, 
  31189, 31193, 31219, 31223, 31231, 31237, 31247, 31249, 31253, 31259, 
  31267, 31271, 31277, 31307, 31319, 31321, 31327, 31333, 31337, 31357, 
  31379, 31387, 31391, 31393, 31397, 31469, 31477, 31481, 31489, 31511, 
  31513, 31517, 31531, 31541, 31543, 31547, 31567, 31573, 31583, 31601, 
  31607, 31627, 31643, 31649, 31657, 31663, 31667, 31687, 31699, 31721, 
  ]

# can calculate for n up to 10^9
def phi(n):
    n0 = n
    result = n
    for p in primes:
        if n == 1:
            break
        if n % p != 0:
            continue
        while n % p == 0:
            n /= p
        result = result * (p-1) / p
    if n0 == n:
        return n-1
    else:
        return result

def modExp(a, b, n):
    c = 0
    d = 1
    bRep = []
    bp = b
    while bp > 0:
        bRep.append(bp & 1)
        bp = bp >> 1
    for bi in reversed(bRep):
        c *= 2
        d = (d * d) % n
        if bi == 1:
            c += 1
            d = (d * a) % n
    return d

def gcd(a, b):
    if b == 0:
        return a
    else:
        return gcd(b, a % b)

def ext_gcd(a, b):
    if b == 0:
        return (a, 1, 0)
    (dp, xp, yp) = ext_gcd(b, a % b)
    return (dp, yp, xp - a//b * yp)

def mod_solve(a, b, n):
    (d, xp, yp) = ext_gcd(a, n)
    if b % d == 0:
        x0 = xp * (b/d) % n
        return x0
    else:
        return None

def chinese_remainder(a, n):
    N = reduce(lambda x, y: x * y, n, 1)
    m = map(lambda x: N/x, n)
    c = map(lambda (x, y): x * mod_solve(x, 1, y), zip(m, n))
    result = 0
    for i in xrange(len(a)):
        result += c[i] * a[i]
    return result % N

######################
def get_prime_exp(b, p):
    exp = 0
    while b % p == 0:
        b = b / p
        exp += 1
    return exp

def mod_exp0(b, n, c):
    r = 1
    for i in xrange(n):
        r = r * b % c
    return r

def mod_large(n, c):
    nLen = len(n)
    LEN = 9
    factor = 10 ** LEN
    nslots = nLen // LEN if nLen % LEN == 0 else nLen // LEN + 1
    cRemainder = [None for i in xrange(nslots)]
    cRemainder[0] = 1
    for i in xrange(1, nslots):
        cRemainder[i] = cRemainder[i-1] * factor % c

    result = 0
    for i in xrange(nslots-1):
        if i > 0:
            result += cRemainder[i] * int(n[(i+1)*LEN-1:i*LEN-1:-1])
        else:
            result += cRemainder[i] * int(n[(i+1)*LEN-1::-1])
        result %= c
    if nslots > 1:
        result += cRemainder[nslots-1] * int(n[nLen:(nslots-1)*LEN-1:-1])
    else:
        result += cRemainder[nslots-1] * int(n[nLen::-1])
    result %= c
    return result


# find (b ** n) mod (p ** m), where p is a prime
def mod_exp_prime_power(b, n, p, m):
    c = p ** m
    if b % p == 0:
        k = get_prime_exp(b, p)
        if len(n) > 9 or k * int(n[::-1]) >= m:
            return 0
        else:
            return modExp(b, int(n[::-1]), c)
    else:
        phic = c * (p-1) / p;
        n = mod_large(n, phic)
        return modExp(b, n, c)

# calculates (b ** n) mod c using Chinese remainder theorem
def mod_exp(b, n, c):
    if b == 0:
        return 0 if n != '0' else 1

    pr = [] # primes
    ex = [] # exponentials
    cp = c
    for p in primes:
        if cp == 1:
            break
        if cp % p == 0:
            pr.append(p)
            exp = get_prime_exp(cp, p)
            cp = cp / (p ** exp)
            ex.append(exp)

    # cp is a prime itself
    if cp != 1:
        pr.append(cp)
        ex.append(1)

    ni = map(lambda (x, y): x ** y, zip(pr, ex))
    ai = []
    for i in xrange(len(pr)):
        ai.append(mod_exp_prime_power(b, n, pr[i], ex[i]))

    return chinese_remainder(ai, ni)

def decrementAndReverse(n):
    n = list(n[::-1])
    for i in xrange(len(n)):
        if n[i] != '0':
            n[i] = str(int(n[i])-1)
            break
        else:
            n[i] = '9'
    n = """".join(n).rstrip('0')
    if len(n) == 0:
        n = '0'
    return n

def solve():
    b, n, c = raw_input().split()
    b = b[::-1]
    n = decrementAndReverse(n)
    c = int(c)

    b = mod_large(b, c)
    r = (b + c - 1) * mod_exp(b, n, c) % c
    return r if r > 0 else c

print solve()
",['number theory']
132,"Polycarp wants to cook a soup. To do it, he needs to buy exactly $$$n$$$ liters of water.There are only two types of water bottles in the nearby shop — $$$1$$$-liter bottles and $$$2$$$-liter bottles. There are infinitely many bottles of these two types in the shop.The bottle of the first type costs $$$a$$$ burles and the bottle of the second type costs $$$b$$$ burles correspondingly.Polycarp wants to spend as few money as possible. Your task is to find the minimum amount of money (in burles) Polycarp needs to buy exactly $$$n$$$ liters of water in the nearby shop if the bottle of the first type costs $$$a$$$ burles and the bottle of the second type costs $$$b$$$ burles. You also have to answer $$$q$$$ independent queries. nan q=int(input())
for x in range(q):
	price=0
	arr = [int(xx) for xx in input().split()]
	if arr[1]>=arr[2]:
		if arr[0]%2==0:
			price=(arr[0]/2)*arr[2]
		else:
			price=((arr[0]-1)/2)*arr[2]+arr[1]
	else:
		if arr[0]%2==0:
			if arr[0]*arr[1]<=(arr[0]/2)*arr[2]:
				price=arr[0]*arr[1]
			else:
				price=(arr[0]/2)*arr[2]
		else:
			if arr[0]*arr[1]<=((arr[0]-1)/2)*arr[2]+arr[1]:
				price=arr[0]*arr[1]
			else:
				price=((arr[0]-1)/2)*arr[2]+arr[1]
	print(int(price))			
				
				




",['math']
3690,"Consider every tree (connected undirected acyclic graph) with $$$n$$$ vertices ($$$n$$$ is odd, vertices numbered from $$$1$$$ to $$$n$$$), and for each $$$2 \le i \le n$$$ the $$$i$$$-th vertex is adjacent to exactly one vertex with a smaller index.For each $$$i$$$ ($$$1 \le i \le n$$$) calculate the number of trees for which the $$$i$$$-th vertex will be the centroid. The answer can be huge, output it modulo $$$998\,244\,353$$$.A vertex is called a centroid if its removal splits the tree into subtrees with at most $$$(n-1)/2$$$ vertices each. NoteExample $$$1$$$: there are two possible trees: with edges $$$(1-2)$$$, and $$$(1-3)$$$ — here the centroid is $$$1$$$; and with edges $$$(1-2)$$$, and $$$(2-3)$$$ — here the centroid is $$$2$$$. So the answer is $$$1, 1, 0$$$.Example $$$2$$$: there are $$$24$$$ possible trees, for example with edges $$$(1-2)$$$, $$$(2-3)$$$, $$$(3-4)$$$, and $$$(4-5)$$$. Here the centroid is $$$3$$$. 
def divisors(M):
    d=[]
    i=1
    while M>=i**2:
        if M%i==0:
            d.append(i)
            if i**2!=M:
                d.append(M//i)
        i=i+1
    return d

def popcount(x):
    x = x - ((x >> 1) & 0x55555555)
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)
    x = (x + (x >> 4)) & 0x0f0f0f0f
    x = x + (x >> 8)
    x = x + (x >> 16)
    return x & 0x0000007f

def eratosthenes(n):
    res=[0 for i in range(n+1)]
    prime=set([])
    for i in range(2,n+1):
        if not res[i]:
            prime.add(i)
            for j in range(1,n//i+1):
                res[i*j]=1
    return prime

def factorization(n):
    res=[]
    for p in prime:
        if n%p==0:
            while n%p==0:
                n//=p
            res.append(p)
    if n!=1:
        res.append(n)
    return res

def euler_phi(n):
    res = n
    for x in range(2,n+1):
        if x ** 2 > n:
            break
        if n%x==0:
            res = res//x * (x-1)
            while n%x==0:
                n //= x
    if n!=1:
        res = res//n * (n-1)
    return res

def ind(b,n):
    res=0
    while n%b==0:
        res+=1
        n//=b
    return res

def isPrimeMR(n):
    d = n - 1
    d = d // (d & -d)
    L = [2, 3, 5, 7, 11, 13, 17]
    for a in L:
        t = d
        y = pow(a, t, n)
        if y == 1: continue
        while y != n - 1:
            y = (y * y) % n
            if y == 1 or t == n - 1: return 0
            t <<= 1
    return 1
def findFactorRho(n):
    from math import gcd
    m = 1 << n.bit_length() // 8
    for c in range(1, 99):
        f = lambda x: (x * x + c) % n
        y, r, q, g = 2, 1, 1, 1
        while g == 1:
            x = y
            for i in range(r):
                y = f(y)
            k = 0
            while k < r and g == 1:
                ys = y
                for i in range(min(m, r - k)):
                    y = f(y)
                    q = q * abs(x - y) % n
                g = gcd(q, n)
                k += m
            r <<= 1
        if g == n:
            g = 1
            while g == 1:
                ys = f(ys)
                g = gcd(abs(x - ys), n)
        if g < n:
            if isPrimeMR(g): return g
            elif isPrimeMR(n // g): return n // g
            return findFactorRho(g)
def primeFactor(n):
    i = 2
    ret = {}
    rhoFlg = 0
    while i*i <= n:
        k = 0
        while n % i == 0:
            n //= i
            k += 1
        if k: ret[i] = k
        i += 1 + i % 2
        if i == 101 and n >= 2 ** 20:
            while n > 1:
                if isPrimeMR(n):
                    ret[n], n = 1, 1
                else:
                    rhoFlg = 1
                    j = findFactorRho(n)
                    k = 0
                    while n % j == 0:
                        n //= j
                        k += 1
                    ret[j] = k

    if n > 1: ret[n] = 1
    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}
    return ret

def divisors(n):
    res = [1]
    prime = primeFactor(n)
    for p in prime:
        newres = []
        for d in res:
            for j in range(prime[p]+1):
                newres.append(d*p**j)
        res = newres
    res.sort()
    return res

def xorfactorial(num):
    if num==0:
        return 0
    elif num==1:
        return 1
    elif num==2:
        return 3
    elif num==3:
        return 0
    else:
        x=baseorder(num)
        return (2**x)*((num-2**x+1)%2)+function(num-2**x)

def xorconv(n,X,Y):
    if n==0:
        res=[(X[0]*Y[0])%mod]
        return res
    x=[X[i]+X[i+2**(n-1)] for i in range(2**(n-1))]
    y=[Y[i]+Y[i+2**(n-1)] for i in range(2**(n-1))]
    z=[X[i]-X[i+2**(n-1)] for i in range(2**(n-1))]
    w=[Y[i]-Y[i+2**(n-1)] for i in range(2**(n-1))]
    res1=xorconv(n-1,x,y)
    res2=xorconv(n-1,z,w)
    former=[(res1[i]+res2[i])*inv for i in range(2**(n-1))]
    latter=[(res1[i]-res2[i])*inv for i in range(2**(n-1))]
    former=list(map(lambda x:x%mod,former))
    latter=list(map(lambda x:x%mod,latter))
    return former+latter

def merge_sort(A,B):
    pos_A,pos_B = 0,0
    n,m = len(A),len(B)
    res = []
    while pos_A < n and pos_B < m:
        a,b = A[pos_A],B[pos_B]
        if a < b:
            res.append(a)
            pos_A += 1
        else:
            res.append(b)
            pos_B += 1
    res += A[pos_A:]
    res += B[pos_B:]
    return res

class UnionFindVerSize():
    def __init__(self, N):
        self._parent = [n for n in range(0, N)]
        self._size = [1] * N
        self.group = N

    def find_root(self, x):
        if self._parent[x] == x: return x
        self._parent[x] = self.find_root(self._parent[x])
        stack = [x]
        while self._parent[stack[-1]]!=stack[-1]:
            stack.append(self._parent[stack[-1]])
        for v in stack:
            self._parent[v] = stack[-1]
        return self._parent[x]

    def unite(self, x, y):
        gx = self.find_root(x)
        gy = self.find_root(y)
        if gx == gy: return

        self.group -= 1

        if self._size[gx] < self._size[gy]:
            self._parent[gx] = gy
            self._size[gy] += self._size[gx]
        else:
            self._parent[gy] = gx
            self._size[gx] += self._size[gy]

    def get_size(self, x):
        return self._size[self.find_root(x)]

    def is_same_group(self, x, y):
        return self.find_root(x) == self.find_root(y)

class WeightedUnionFind():
    def __init__(self,N):
        self.parent = [i for i in range(N)]
        self.size = [1 for i in range(N)]
        self.val = [0 for i in range(N)]
        self.flag = True
        self.edge = [[] for i in range(N)]

    def dfs(self,v,pv):
        stack = [(v,pv)]
        new_parent = self.parent[pv]
        while stack:
            v,pv = stack.pop()
            self.parent[v] = new_parent
            for nv,w in self.edge[v]:
                if nv!=pv:
                    self.val[nv] = self.val[v] + w
                    stack.append((nv,v))

    def unite(self,x,y,w):
        if not self.flag:
            return
        if self.parent[x]==self.parent[y]:
            self.flag = (self.val[x] - self.val[y] == w)
            return

        if self.size[self.parent[x]]>self.size[self.parent[y]]:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[x] += self.size[y]
            self.val[y] = self.val[x] - w
            self.dfs(y,x)
        else:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[y] += self.size[x]
            self.val[x] = self.val[y] + w
            self.dfs(x,y)

class Dijkstra():
    class Edge():
        def __init__(self, _to, _cost):
            self.to = _to
            self.cost = _cost

    def __init__(self, V):
        self.G = [[] for i in range(V)]
        self._E = 0
        self._V = V

    @property
    def E(self):
        return self._E

    @property
    def V(self):
        return self._V

    def add_edge(self, _from, _to, _cost):
        self.G[_from].append(self.Edge(_to, _cost))
        self._E += 1

    def shortest_path(self, s):
        import heapq
        que = []
        d = [10**15] * self.V
        d[s] = 0
        heapq.heappush(que, (0, s))

        while len(que) != 0:
            cost, v = heapq.heappop(que)
            if d[v] < cost: continue

            for i in range(len(self.G[v])):
                e = self.G[v][i]
                if d[e.to] > d[v] + e.cost:
                    d[e.to] = d[v] + e.cost
                    heapq.heappush(que, (d[e.to], e.to))
        return d

#Z[i]:length of the longest list starting from S[i] which is also a prefix of S
#O(|S|)
def Z_algorithm(s):
    N = len(s)
    Z_alg = [0]*N

    Z_alg[0] = N
    i = 1
    j = 0
    while i < N:
        while i+j < N and s[j] == s[i+j]:
            j += 1
        Z_alg[i] = j
        if j == 0:
            i += 1
            continue
        k = 1
        while i+k < N and k + Z_alg[k]<j:
            Z_alg[i+k] = Z_alg[k]
            k += 1
        i += k
        j -= k
    return Z_alg

class BIT():
    def __init__(self,n,mod=0):
        self.BIT = [0]*(n+1)
        self.num = n
        self.mod = mod

    def query(self,idx):
        res_sum = 0
        mod = self.mod
        while idx > 0:
            res_sum += self.BIT[idx]
            if mod:
                res_sum %= mod
            idx -= idx&(-idx)
        return res_sum

    #Ai += x O(logN)
    def update(self,idx,x):
        mod = self.mod
        while idx <= self.num:
            self.BIT[idx] += x
            if mod:
                self.BIT[idx] %= mod
            idx += idx&(-idx)
        return

class dancinglink():
    def __init__(self,n,debug=False):
        self.n = n
        self.debug = debug
        self._left = [i-1 for i in range(n)]
        self._right = [i+1 for i in range(n)]
        self.exist = [True for i in range(n)]

    def pop(self,k):
        if self.debug:
            assert self.exist[k]
        L = self._left[k]
        R = self._right[k]
        if L!=-1:
            if R!=self.n:
                self._right[L],self._left[R] = R,L
            else:
                self._right[L] = self.n
        elif R!=self.n:
            self._left[R] = -1
        self.exist[k] = False

    def left(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._left[res]
            if res==-1:
                break
            k -= 1
        return res

    def right(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._right[res]
            if res==self.n:
                break
            k -= 1
        return res

class SparseTable():
    def __init__(self,A,merge_func,ide_ele):
        N = len(A)
 
        self.merge_func = merge_func
 
        self.lg = [0]*(N + 1)
        for i in range(2, N+1):
            self.lg[i] = self.lg[i >> 1] + 1
        self.pow_2 = [pow(2,i) for i in range(20)]
 
        self.table = [None]*(self.lg[N] + 1)
        st0 = self.table[0] = [a for a in A]
        b = 1
        for i in range(self.lg[N]):
            st0 = self.table[i+1] = [self.merge_func(u,v) for u, v in zip(st0, st0[b:])]
            b <<= 1
 
    def query(self,s,t):
        b = t-s+1
        m = self.lg[b]
        return self.merge_func(self.table[m][s],self.table[m][t-self.pow_2[m]+1])
 

class BinaryTrie:
    class node:
        def __init__(self,val):
            self.left = None
            self.right = None
            self.max = val

    def __init__(self):
        self.root = self.node(-10**15)

    def append(self,key,val):
        pos = self.root
        for i in range(29,-1,-1):
            pos.max = max(pos.max,val)
            if key>>i & 1:
                if pos.right is None:
                    pos.right = self.node(val)
                    pos = pos.right
                else:
                    pos = pos.right
            else:
                if pos.left is None:
                    pos.left = self.node(val)
                    pos = pos.left
                else:
                    pos = pos.left
        pos.max = max(pos.max,val)

    def search(self,M,xor):
        res = -10**15
        pos = self.root
        for i in range(29,-1,-1):
            if pos is None:
                break

            if M>>i & 1:
                if xor>>i & 1:
                    if pos.right:
                        res = max(res,pos.right.max)
                    pos = pos.left
                else:
                    if pos.left:
                        res = max(res,pos.left.max)
                    pos = pos.right
            else:
                if xor>>i & 1:
                    pos = pos.right
                else:
                    pos = pos.left

        if pos:
            res = max(res,pos.max)
        return res

def solveequation(edge,ans,n,m):
    #edge=[[to,dire,id]...]
    def dfs(v):
        used[v]=True
        r=ans[v]
        for to,dire,id in edge[v]:
            if used[to]:
                continue
            y=dfs(to)
            if dire==-1:
                x[id]=y
            else:
                x[id]=-y
            r+=y
        return r
        
    x=[0]*m
    used=[False]*n
    for v in range(n):
        if used[v]:
            continue
        y = dfs(v)
        if y!=0:
            return False
    return x

    

class slope_trick():
    def __init__(self):
        self.L = [10**17]
        self.R = [10**17]
        self.min_f = 0

        self.x_left = 0
        self.x_right = 0

    def add_right(self,a):
        a -= self.x_left
        l0 = -self.L[0]
        self.min_f  = self.min_f + max(0,l0-a)
        if l0 <= a:
            a += self.x_left
            a -= self.x_right
            heappush(self.R,a)
        else:
            heappush(self.L,-a)
            a = -heappop(self.L)
            a += self.x_left
            a -= self.x_right
            heappush(self.R,a)

        #self.min_f  = self.min_f + max(0,l0-a)

    def add_left(self,a):
        a -= self.x_right
        r0 = self.R[0]
        self.min_f = self.min_f + max(0,a-r0)

        if a <= r0:
            a += self.x_right
            a -= self.x_left
            heappush(self.L,-a)
        else:
            heappush(self.R,a)
            a = heappop(self.R)
            a += self.x_right
            a -= self.x_left
            heappush(self.L,-a)

        #self.min_f = self.min_f + max(0,a-r0)

    def add_abs(self,a):
        self.add_left(a)
        self.add_right(a)

    def change_min_slide(self,a,b):
        self.x_left += a
        self.x_right += b
    
    def get_val(self,x):
        L = [-l+self.x_left for l in self.L]
        L.sort()
        R = [r+self.x_right for r in self.R]
        R.sort()

        res = self.min_f

        if 0 < L[-1]:
            L = L[::-1]
            n = len(L)
            for i in range(n):
                c0 = L[i]
                c1 = L[i+1]
        
                if c1 <= x <= c0:
                    res += (i+1) * (c0-x)
                    break
                else:
                    res += (i+1) * (c0-c1)
            return res
        elif L[-1] <= x <= R[0]:
            return res
        else:
            n = len(R)
            for i in range(n):
                c0 = R[i]
                c1 = R[i+1]
                if c0 <= x <= c1:
                    res += (i+1) * (x-c0)
                    break
                else:
                    res += (i+1) * (c1-c0)
            return res

class SegmentTree:
    def __init__(self, init_val, segfunc, ide_ele):
        n = len(init_val)
        self.segfunc = segfunc
        self.ide_ele = ide_ele
        self.num = 1 << (n - 1).bit_length()
        self.tree = [ide_ele] * 2 * self.num
        self.size = n
        for i in range(n):
            self.tree[self.num + i] = init_val[i]
        for i in range(self.num - 1, 0, -1):
            self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])

    def update(self, k, x):
        k += self.num
        self.tree[k] = x
        while k > 1:
            k >>= 1
            self.tree[k] = self.segfunc(self.tree[2*k], self.tree[2*k+1])

    def query(self, l, r):
        if r==self.size:
            r = self.num

        res = self.ide_ele

        l += self.num
        r += self.num
        right = []
        while l < r:
            if l & 1:
                res = self.segfunc(res, self.tree[l])
                l += 1
            if r & 1:
                right.append(self.tree[r-1])
            l >>= 1
            r >>= 1

        for e in right[::-1]:
            res = self.segfunc(res,e)
        return res

    def bisect_l(self,l,r,x):
        l += self.num
        r += self.num
        Lmin = -1
        Rmin = -1
        while l<r:
            if l & 1:
                if self.tree[l] <= x and Lmin==-1:
                    Lmin = l
                l += 1
            if r & 1:
                if self.tree[r-1] <=x:
                    Rmin = r-1
            l >>= 1
            r >>= 1

        if Lmin != -1:
            pos = Lmin
            while pos<self.num:
                if self.tree[2 * pos] <=x:
                    pos = 2 * pos
                else:
                    pos = 2 * pos +1
            return pos-self.num
        elif Rmin != -1:
            pos = Rmin
            while pos<self.num:
                if self.tree[2 * pos] <=x:
                    pos = 2 * pos
                else:
                    pos = 2 * pos +1
            return pos-self.num
        else:
            return -1

import sys,random,bisect
from collections import deque,defaultdict
from heapq import heapify,heappop,heappush
from itertools import permutations
from math import gcd,log

input = lambda :sys.stdin.readline().rstrip()
mi = lambda :map(int,input().split())
li = lambda :list(mi())

def cmb(n, r, mod):
    if ( r<0 or r>n ):
        return 0
    return (g1[n] * g2[r] % mod) * g2[n-r] % mod

mod = 998244353
N = 2*10**5
g1 = [1]*(N+1)
g2 = [1]*(N+1)
inverse = [1]*(N+1)

for i in range( 2, N + 1 ):
    g1[i]=( ( g1[i-1] * i ) % mod )
    inverse[i]=( ( -inverse[mod % i] * (mod//i) ) % mod )
    g2[i]=( (g2[i-1] * inverse[i]) % mod )
inverse[0]=0

n = int(input())
ans = [0] * n

pre = [(g1[n-i]*g1[i-2] % mod)*cmb((n-1)//2,i-1,mod)%mod for i in range(n+1)]
for i in range(1,n+1):
    pre[i] += pre[i-1]
    pre[i] %= mod

for i in range(1,n+1):
    """"""
    部分木にある
    """"""

    res = (g1[n-1] - (pre[n]-pre[i])) % mod
    
    
        

    """"""
    自分の木が小さすぎる
    """"""

    if i!=1:

        res -= (g1[n-i] * g1[i-2] % mod) * (((cmb(n-1,i-1,mod)-cmb((n-1)//2,i-1,mod)) % mod) * (i-1) % mod) % mod
        res %= mod
        
    
    ans[i-1] = res

print(*ans)
","['combinatorics', 'dp', 'math', 'other']"
1564,"There are $$$n$$$ quests. If you complete the $$$i$$$-th quest, you will gain $$$a_i$$$ coins. You can only complete at most one quest per day. However, once you complete a quest, you cannot do the same quest again for $$$k$$$ days. (For example, if $$$k=2$$$ and you do quest $$$1$$$ on day $$$1$$$, then you cannot do it on day $$$2$$$ or $$$3$$$, but you can do it again on day $$$4$$$.)You are given two integers $$$c$$$ and $$$d$$$. Find the maximum value of $$$k$$$ such that you can gain at least $$$c$$$ coins over $$$d$$$ days. If no such $$$k$$$ exists, output Impossible. If $$$k$$$ can be arbitrarily large, output Infinity. NoteIn the first test case, one way to earn $$$5$$$ coins over $$$4$$$ days with $$$k=2$$$ is as follows:   Day 1: do quest 2, and earn $$$2$$$ coins.  Day 2: do quest 1, and earn $$$1$$$ coin.  Day 3: do nothing.  Day 4: do quest 2, and earn $$$2$$$ coins.  In total, we earned $$$2+1+2=5$$$ coins.In the second test case, we can make over $$$20$$$ coins on the first day itself by doing the first quest to earn $$$100$$$ coins, so the value of $$$k$$$ can be arbitrarily large, since we never need to do another quest.In the third test case, no matter what we do, we can't earn $$$100$$$ coins over $$$3$$$ days. t = int(input())
 
def possible(k, n, c, d, nums):
    ssum = 0
    for i in range(d):
        try:
            a = nums[i%(k+1)]
        except:
            a = 0
        ssum += a
    return ssum >= c
 
 
def solve():
    n, c, d = [int(x) for x in input().split()]
    nums = [int(x) for x in input().split()]
    nums.sort(reverse=True)
    
    l = 0
    r = d-1
    
    
    if sum(nums[:min(d,n, len(nums) )]) >= c:
        print(""Infinity"")
        return
    
    #print(sum(nums[:min(d,n, len(nums) )]))
    #print(nums)
    #print(n, c, d)
    #print(possible(1, n, c, d, nums))
    #quit()
 
    while True:
        if r - l <= 3:
            for k in range(r, l-1, -1):
                if possible(k, n, c, d, nums):
                    print(k)
                    return
            print(""Impossible"")
            return
        
        k = (l + r) // 2
        pos = possible(k, n, c, d, nums)
        if pos:
            l = k
        else:
            r = k-1
        
 
    
for _ in range(t):
    solve()","['binary search', 'greedy', 'sortings']"
1860,"A well-known art union called ""Kalevich is Alive!"" manufactures objects d'art (pictures). The union consists of n painters who decided to organize their work as follows.Each painter uses only the color that was assigned to him. The colors are distinct for all painters. Let's assume that the first painter uses color 1, the second one uses color 2, and so on. Each picture will contain all these n colors. Adding the j-th color to the i-th picture takes the j-th painter tij units of time.Order is important everywhere, so the painters' work is ordered by the following rules:  Each picture is first painted by the first painter, then by the second one, and so on. That is, after the j-th painter finishes working on the picture, it must go to the (j + 1)-th painter (if j &lt; n);  each painter works on the pictures in some order: first, he paints the first picture, then he paints the second picture and so on;  each painter can simultaneously work on at most one picture. However, the painters don't need any time to have a rest;  as soon as the j-th painter finishes his part of working on the picture, the picture immediately becomes available to the next painter. Given that the painters start working at time 0, find for each picture the time when it is ready for sale. nan import sys
from math import *

def minp():
	return sys.stdin.readline().strip()

def mint():
	return int(minp())

def mints():
	return map(int, minp().split())

m,n = mints()
a = [0]*n
for i in range(m):
	z = list(mints())
	a[0] += z[0]
	for j in range(1,n):
		a[j] = max(a[j-1], a[j]) + z[j]
	print(a[-1], end=' ')
","['brute force', 'dp', 'implementation']"
4694,"AmShZ has traveled to Italy from Iran for the Thom Yorke concert. There are $$$n$$$ cities in Italy indexed from $$$1$$$ to $$$n$$$ and $$$m$$$ directed roads indexed from $$$1$$$ to $$$m$$$. Initially, Keshi is located in the city $$$1$$$ and wants to go to AmShZ's house in the city $$$n$$$. Since Keshi doesn't know the map of Italy, AmShZ helps him to see each other as soon as possible.In the beginning of each day, AmShZ can send one of the following two messages to Keshi: AmShZ sends the index of one road to Keshi as a blocked road. Then Keshi will understand that he should never use that road and he will remain in his current city for the day. AmShZ tells Keshi to move. Then, Keshi will randomly choose one of the cities reachable from his current city and move there. (city $$$B$$$ is reachable from city $$$A$$$ if there's an out-going road from city $$$A$$$ to city $$$B$$$ which hasn't become blocked yet). If there are no such cities, Keshi will remain in his current city.Note that AmShZ always knows Keshi's current location. AmShZ and Keshi want to find the smallest possible integer $$$d$$$ for which they can make sure that they will see each other after at most $$$d$$$ days. Help them find $$$d$$$. NoteIn the first sample, it's enough for AmShZ to send the second type of message.In the second sample, on the first day, AmShZ blocks the first road. So the only reachable city from city $$$1$$$ will be city $$$4$$$. Hence on the second day, AmShZ can tell Keshi to move and Keshi will arrive at AmShZ's house.It's also possible for AmShZ to tell Keshi to move for two days. import heapq as hq
#from collections import defaultdict as dd
#import collections as coll #deque  e.g. coll.deque
import sys
input = sys.stdin.readline

############ ---- Input Functions ---- ############
#def inp():
#    return(int(input()))
def inlt():
    return(list(map(int,input().split())))
#def insr():
#    s = input()
#    return(list(s[:len(s) - 1]))
#def invr():
#    return(map(int,input().split()))
#1) inp — For taking integer inputs.
#
#2) inlt — For taking List inputs.
#
#3) insr — For taking string inputs. Actually it returns a List of Characters, instead of a string, which is easier to use in Python, because in Python, Strings are Immutable.
#
#4) invr — For taking space seperated integer variable inputs.


#t = int(input())
#for tc in range(t):
n,m = map(int, input().split())
#roads=[]
coming=dict();going=[0]*(n+1)
for i in range(n+1):coming[i]=[]
for i in range(m):
    tmp=inlt()
#    roads.append(tmp)
    coming[tmp[-1]].append(tmp[0])
    going[tmp[0]]+=1

dg=[999999]*(n+1);dg[n]=0;
todo=[(0,n)];chkd=[0]*(n+1)


while todo:
    #### find x with min dg in todo
    _,x=hq.heappop(todo)
    if chkd[x]:continue
    for i in coming[x]:going[i]-=1
    for i in coming[x]:
        tmp=1+dg[x]+going[i]
        if tmp<dg[i]:
            dg[i]=tmp
            hq.heappush(todo,(dg[i],i))
    #Dijkstra algorithm
    chkd[x]=1

print(dg[1])



",['shortest paths']
3833,"An integer array $$$a$$$ of length $$$n$$$ is said to be a PalindORme if ($$$a_{1}$$$ $$$|$$$ $$$a_{2} $$$ $$$|$$$ $$$ \ldots $$$ $$$|$$$ $$$ a_{i}) = (a_{{n - i + 1}} $$$ $$$|$$$ $$$ \ldots $$$ $$$|$$$ $$$ a_{{n - 1}} $$$ $$$|$$$ $$$ a_{n}) $$$ for all $$$ 1 \leq i \leq n$$$, where $$$|$$$ denotes the bitwise OR operation.An integer array $$$a$$$ of length $$$n$$$ is considered to be good if its elements can be rearranged to form a PalindORme. Formally, array $$$a$$$ is good if there exists a permutation $$$p_1, p_2, \ldots p_n$$$ (an array where each integer from $$$1$$$ to $$$n$$$ appears exactly once) for which $$$a_{p_1}, a_{p_2}, \ldots a_{p_n}$$$ is a PalindORme.Find the number of good arrays of length $$$n$$$, consisting only of integers in the range $$$[0, 2^{k} - 1]$$$, and print it modulo some prime $$$m$$$.Two arrays $$$a_1, a_2, \ldots, a_n$$$ and $$$b_1, b_2, \ldots, b_n$$$ are considered to be different if there exists any $$$i$$$ $$$(1 \leq i \leq n)$$$ such that $$$a_i \ne b_i$$$. NoteIn the first sample, both the possible arrays $$$[0]$$$ and $$$[1]$$$ are good.In the second sample, some examples of good arrays are: $$$[2, 1, 2]$$$ because it is already PalindORme. $$$[1, 1, 0]$$$ because it can rearranged to $$$[1, 0, 1]$$$ which is PalindORmeNote that $$$[1, 1, 0]$$$, $$$[1, 0, 1]$$$ and $$$[0, 1, 1]$$$ are all good arrays and are considered to be different according to the definition in the statement.In the third sample, an example of a good array is $$$[1, 0, 1, 4, 2, 5, 4]$$$. It can be rearranged to an array $$$b = [1, 5, 0, 2, 4, 4, 1]$$$ which is a PalindORme because: $$$\mathrm{OR}(1, 1)$$$ = $$$\mathrm{OR}(7, 7)$$$ = $$$1$$$ $$$\mathrm{OR}(1, 2)$$$ = $$$\mathrm{OR}(6, 7)$$$ = $$$5$$$ $$$\mathrm{OR}(1, 3)$$$ = $$$\mathrm{OR}(5, 7)$$$ = $$$5$$$ $$$\mathrm{OR}(1, 4)$$$ = $$$\mathrm{OR}(4, 7)$$$ = $$$7$$$ $$$\mathrm{OR}(1, 5)$$$ = $$$\mathrm{OR}(3, 7)$$$ = $$$7$$$ $$$\mathrm{OR}(1, 6)$$$ = $$$\mathrm{OR}(2, 7)$$$ = $$$7$$$ $$$\mathrm{OR}(1, 7)$$$ = $$$\mathrm{OR}(1, 7)$$$ = $$$7$$$Here $$$\mathrm{OR}(l, r)$$$ denotes $$$b_{l}$$$ $$$|$$$ $$$b_{l+1} $$$ $$$|$$$ $$$ \ldots $$$ $$$|$$$ $$$ b_{r}$$$ def solution():
    def nPr(n, k):
        return reduce(lambda x, y: (x*y)%m, (i for i in xrange(n-k+1, n+1)), 1)

    n, k, m = map(int, raw_input().strip().split())
    pow2 = [1]*(n*k+1)
    for i in xrange(1, n*k+1):
        pow2[i] = pow2[i-1]*2 % m
    C = [[0]*(max(n, k)+1) for _ in xrange(max(n, k)+1)]
    for i in xrange(max(n, k)+1):
        C[i][0] = 1
        for j in xrange(1, max(n, k)+1):
            C[i][j] = (C[i-1][j]+C[i-1][j-1]) % m
    total, distinct_positive = [[[0]*(k+1) for _ in xrange(n+1)] for _ in xrange(2)]
    for i in xrange(n+1):
        for j in xrange(k+1):
            for l in xrange(j+1):
                total[i][j] = (total[i][j] + (-1 if ((j-l)%2) else 1)*(C[j][l]*pow2[i*l] % m)) % m
                distinct_positive[i][j] = (distinct_positive[i][j] + (-1 if ((j-l)%2) else 1)*(C[j][l]*nPr(pow2[l]-1, i) % m)) % m
    bad = [[0]*(k+1) for _ in xrange(n+1)]
    for i in xrange(1, n+1):
        for j in xrange(k+1):
            for a in xrange(i):
                for b in xrange(j):
                    if n%2 and a == n-1:
                        continue
                    bad[i][j] = (bad[i][j] + ((((C[i][a] * C[j][b] % m) * distinct_positive[i-a][j-b]) % m) * ((((total[a][b]-bad[a][b]) % m) * pow2[(i-a)*b]) % m)) % m) % m
    return reduce(lambda x, y: (x+y)%m, (C[k][i] * (total[n][i]-bad[n][i]) % m for i in xrange(k+1)))

print '%s' % solution()
","['combinatorics', 'dp']"
4223,"Andrew and Jerry are playing a game with Harry as the scorekeeper. The game consists of three rounds. In each round, Andrew and Jerry draw randomly without replacement from a jar containing n balls, each labeled with a distinct positive integer. Without looking, they hand their balls to Harry, who awards the point to the player with the larger number and returns the balls to the jar. The winner of the game is the one who wins at least two of the three rounds.Andrew wins rounds 1 and 2 while Jerry wins round 3, so Andrew wins the game. However, Jerry is unhappy with this system, claiming that he will often lose the match despite having the higher overall total. What is the probability that the sum of the three balls Jerry drew is strictly higher than the sum of the three balls Andrew drew? NoteIn the first case, there are only two balls. In the first two rounds, Andrew must have drawn the 2 and Jerry must have drawn the 1, and vice versa in the final round. Thus, Andrew's sum is 5 and Jerry's sum is 4, so Jerry never has a higher total.In the second case, each game could've had three outcomes — 10 - 2, 10 - 1, or 2 - 1. Jerry has a higher total if and only if Andrew won 2 - 1 in both of the first two rounds, and Jerry drew the 10 in the last round. This has probability . n , m = input() , map(int,raw_input().split())
a = {}
for i in xrange(n-1):
	for j in xrange(i+1,n):
		x = abs(m[i]-m[j])
		if x in a:
			a[x]+=1
		else:
			a[x]=1

d = [i for i in a]
b = [0]*10005
for i in xrange(len(d)):
	for j in xrange(i,len(d)):
		if d[i]==d[j]:
			b[d[i]+d[j]] += a[d[i]]*a[d[j]]
 		else:
			b[d[i]+d[j]] += a[d[i]]*a[d[j]]*2

for i in xrange(1,len(b)): b[i]=b[i]+b[i-1]
ans=0
for i in xrange(n-1):
	for j in xrange(i+1,n):
		ans+=b[abs(m[i]-m[j])-1]

den = (n*(n-1)/2)**3
print ans/float(den)","['brute force', 'combinatorics', 'dp', 'probabilities']"
3574,"There is a square field of size $$$n \times n$$$ in which two cells are marked. These cells can be in the same row or column.You are to mark two more cells so that they are the corners of a rectangle with sides parallel to the coordinate axes.For example, if $$$n=4$$$ and a rectangular field looks like this (there are asterisks in the marked cells):$$$$$$ \begin{matrix} . &amp; . &amp; * &amp; . \\ . &amp; . &amp; . &amp; . \\ * &amp; . &amp; . &amp; . \\ . &amp; . &amp; . &amp; . \\ \end{matrix} $$$$$$Then you can mark two more cells as follows$$$$$$ \begin{matrix} * &amp; . &amp; * &amp; . \\ . &amp; . &amp; . &amp; . \\ * &amp; . &amp; * &amp; . \\ . &amp; . &amp; . &amp; . \\ \end{matrix} $$$$$$If there are several possible solutions, then print any of them. nan # coding=utf-8
import sys, math
#sys.setrecursionlimit(10**6)
INF = float('inf')
mod = 10**9 + 70
#mod = 998244353
input = lambda: sys.stdin.readline().rstrip()
li = lambda: list(map(int, input().split()))
 
t = int(input())
output = []
 
def taikaku(p1, p2):
    if p1[0] > p2[0] and p1[1] > p2[1]:
        return 1
    elif p1[0] > p2[0] and p2[1] > p1[1]:
        return 1
    return 0
 
def yoko(p1, p2):
    return p1[0] == p2[0]
 
for _ in range(t):
    N = int(input())
    grid = [list(input()) for _ in range(N)]
    P = []
    for h in range(N):
        for w in range(N):
            if grid[h][w] == '*':
                P.append((h, w))
    
    p1 = P[0]; p2 = P[1]
    if taikaku(p1, p2) or taikaku(p2, p1):
        p3 = (p1[0], p2[1])
        p4 = (p2[0], p1[1])
        #print(p3, p4)
    elif yoko(p1, p2):
        h = p1[0]
        if h != 0:
            h -= 1
        else:
            h += 1
        p3 = (h, p1[1])
        p4 = (h, p2[1])
    else:
        w = p1[1]
        if w != 0:
            w -= 1
        else:
            w += 1
        p3 = (p1[0], w)
        p4 = (p2[0], w)
    grid[p3[0]][p3[1]] = '*'
    grid[p4[0]][p4[1]] = '*'
    for i in grid:
        output.append(''.join(i)) 
for a in output:
    print(a)
  				 		   	  				 		  	 	 		",['implementation']
1419,"The statement of this problem is the same as the statement of problem C1. The only difference is that, in problem C1, $$$n$$$ is always even, and in C2, $$$n$$$ is always odd.You are given a regular polygon with $$$2 \cdot n$$$ vertices (it's convex and has equal sides and equal angles) and all its sides have length $$$1$$$. Let's name it as $$$2n$$$-gon.Your task is to find the square of the minimum size such that you can embed $$$2n$$$-gon in the square. Embedding $$$2n$$$-gon in the square means that you need to place $$$2n$$$-gon in the square in such way that each point which lies inside or on a border of $$$2n$$$-gon should also lie inside or on a border of the square.You can rotate $$$2n$$$-gon and/or the square. nan from math import sin,radians
def C2(n):
    interiorangle = 360/(2*n)
    side = sin(radians(45))
    angle = 45
    number = (n-1)/2
    for i in range(int(number)):
        angle += interiorangle
        if angle > 90:
            angle = 180 - angle
            side += sin(radians(angle))
            angle = 180 - angle
        else:
            side += sin(radians(angle))
    angle = 45
    for i in range(int(number)):
        angle -= interiorangle
        if angle < 0:
            angle = -1 * angle
            side += sin(radians(angle))
            angle = -1 * angle
        else:
            side += sin(radians(angle))

    print(float(side))

a = int(input())
for _ in range(a):
    x = int(input())
    C2(x)","['binary search', 'brute force', 'geometry', 'math']"
4638,"Alice has written a program and now tries to improve its readability. One of the ways to improve readability is to give sensible names to the variables, so now Alice wants to rename some variables in her program. In her IDE there is a command called ""massive refactoring"", which can replace names of many variable in just one run. To use it, Alice needs to select two strings $$$s$$$ and $$$t$$$ and after that for each variable the following algorithm is performed: if the variable's name contains $$$s$$$ as a substring, then the first (and only first) occurrence of $$$s$$$ is replaced with $$$t$$$. If the name doesn't contain $$$s$$$, then this variable's name stays the same.The list of variables is known and for each variable both the initial name and the name Alice wants this variable change to are known. Moreover, for each variable the lengths of the initial name and the target name are equal (otherwise the alignment of the code could become broken). You need to perform renaming of all variables in exactly one run of the massive refactoring command or determine that it is impossible. nan from __future__ import division
from fileinput import input
from itertools import izip

class KMP:
    def __init__(self, pattern):
        pass

    def KnuthMorrisPratt(self, text, pattern):
        '''Yields all starting positions of copies of the pattern in the text.
    Calling conventions are similar to string.find, but its arguments can be
    lists or iterators, not just strings, it returns all matches, not just
    the first one, and it does not need the whole text in memory at once.
    Whenever it yields, it will have read the text exactly up to and including
    the match that caused the yield.'''

        # allow indexing into pattern and protect against change during yield
        pattern = list(pattern)

        # build table of shift amounts
        shifts = [1] * (len(pattern) + 1)
        shift = 1
        for pos in range(len(pattern)):
            while shift <= pos and pattern[pos] != pattern[pos-shift]:
                shift += shifts[pos-shift]
            shifts[pos+1] = shift

        # do the actual search
        startPos = 0
        matchLen = 0
        for c in text:
            while matchLen == len(pattern) or \
                  matchLen >= 0 and pattern[matchLen] != c:
                startPos += shifts[matchLen]
                matchLen -= shifts[matchLen]
            matchLen += 1
            if matchLen == len(pattern):
                return startPos
        return -1


def alleq(li):
    for c in li[1:]:
        if c != li[0]:
            return False
    return True

def mkst(r):
    out = """"
    for c in r:
        out += c
    return out

def solve():
    inp = input()
    n = int(inp.readline())
    fro = []
    for _ in xrange(n):
        line = inp.readline().rstrip(""\n"")
        fro.append(line)
    to = []
    for _ in xrange(n):
        line = inp.readline().rstrip(""\n"")
        to.append(line)

    changefrom = """"
    changeto = """"
    nochange = []
    changearr = []
    fronts = []
    backs = []
    for f, t in zip(fro, to):
        errors = -1
        errore = -1
        for i in xrange(len(f)):
            if f[i] != t[i]:
                if errors == -1:
                    errors = i
                errore = i
        if errors == -1:
            nochange.append(f)
            continue
        cf = f[errors:errore + 1]
        ct = t[errors:errore + 1]

        if changefrom == """":
            changefrom = cf
            changeto = ct
        else:
            if cf != changefrom or ct != changeto:
                return ""NO""
        changearr.append((f, errors,errore, t))
        fronts.append(f[0:errors])
        backs.append(f[errore + 1:])
    front = """"
    i = 1
    cont = True
    while cont:
        if i > len(fronts[0]):
            break
        else:
            th = fronts[0][-i]
        for st in fronts:
            if i > len(st):
                cont = False
                break
            if st[-i] != th:
                cont = False
                break
        else:
            front += th
        i += 1

    front = mkst(reversed(front))

    back = """"
    for cs in izip(*backs):
        if alleq(cs):
            back += cs[0]
        else:
            break
    changefrom = front + changefrom + back

    ford, errors, errore, toord = changearr[0]
    changeto = toord[errors - len(front): errors] + changeto + toord[errore + 1: errore + 1 + len(back)]
    kmp = KMP(changefrom)
    for f, errors, errore, t in changearr:
        if kmp.KnuthMorrisPratt(f, changefrom) + len(front) != errors:
             return ""NO""

    for st in nochange:
        if kmp.KnuthMorrisPratt(st, changefrom) != -1:
            return ""NO""
    return ""YES\n"" + changefrom + ""\n"" + changeto


print solve()
","['greedy', 'implementation', 'strings']"
1055,"Asya loves animals very much. Recently, she purchased $$$n$$$ kittens, enumerated them from $$$1$$$ and $$$n$$$ and then put them into the cage. The cage consists of one row of $$$n$$$ cells, enumerated with integers from $$$1$$$ to $$$n$$$ from left to right. Adjacent cells had a partially transparent partition wall between them, hence there were $$$n - 1$$$ partitions originally. Initially, each cell contained exactly one kitten with some number.Observing the kittens, Asya noticed, that they are very friendly and often a pair of kittens in neighboring cells wants to play together. So Asya started to remove partitions between neighboring cells. In particular, on the day $$$i$$$, Asya:  Noticed, that the kittens $$$x_i$$$ and $$$y_i$$$, located in neighboring cells want to play together.  Removed the partition between these two cells, efficiently creating a single cell, having all kittens from two original cells. Since Asya has never putted partitions back, after $$$n - 1$$$ days the cage contained a single cell, having all kittens.For every day, Asya remembers numbers of kittens $$$x_i$$$ and $$$y_i$$$, who wanted to play together, however she doesn't remember how she placed kittens in the cage in the beginning. Please help her and find any possible initial arrangement of the kittens into $$$n$$$ cells. NoteThe answer for the example contains one of several possible initial arrangements of the kittens.The picture below shows how the cells were united for this initial arrangement. Note, that the kittens who wanted to play together on each day were indeed in adjacent cells.   # AC
import sys


class Main:
    def __init__(self):
        self.buff = None
        self.index = 0

    def next(self):
        if self.buff is None or self.index == len(self.buff):
            self.buff = sys.stdin.readline().split()
            self.index = 0
        val = self.buff[self.index]
        self.index += 1
        return val

    def next_int(self):
        return int(self.next())

    def solve(self):
        n = self.next_int()
        fa = [-1 for _ in range(0, n)]
        nx = [i for i in range(0, n)]
        la = [i for i in range(0, n)]
        for _ in range(1, n):
            a = self.find(self.next_int() - 1, fa)
            b = self.find(self.next_int() - 1, fa)
            fa[a] = b
            nx[la[b]] = a
            la[b] = la[a]
        ii = 0
        while fa[ii] != -1:
            ii += 1
        ans = []
        for _ in range(0, n):
            ans.append(str(ii + 1))
            ii = nx[ii]
        print(' '.join(ans))

    def find(self, k, fa):
        if fa[k] == -1:
            return k
        fa[k] = self.find(fa[k], fa)
        return fa[k]


if __name__ == '__main__':
    Main().solve()
","['constructive algorithms', 'dsu']"
1878,"Jeff got 2n real numbers a1, a2, ..., a2n as a birthday present. The boy hates non-integer numbers, so he decided to slightly ""adjust"" the numbers he's got. Namely, Jeff consecutively executes n operations, each of them goes as follows:  choose indexes i and j (i ≠ j) that haven't been chosen yet;  round element ai to the nearest integer that isn't more than ai (assign to ai: ⌊ ai ⌋);  round element aj to the nearest integer that isn't less than aj (assign to aj: ⌈ aj ⌉). Nevertheless, Jeff doesn't want to hurt the feelings of the person who gave him the sequence. That's why the boy wants to perform the operations so as to make the absolute value of the difference between the sum of elements before performing the operations and the sum of elements after performing the operations as small as possible. Help Jeff find the minimum absolute value of the difference. NoteIn the first test case you need to perform the operations as follows: (i = 1, j = 4), (i = 2, j = 3), (i = 5, j = 6). In this case, the difference will equal |(0 + 0.5 + 0.75 + 1 + 2 + 3) - (0 + 0 + 1 + 1 + 2 + 3)| = 0.25.  n = int(raw_input())

r = [int(x.split('.')[1]) for x in raw_input().split()]
r_n, s = r.count(0), sum(r)

res = min(abs(s - i * 1000) for i in range(max(0, n - r_n), min(2 * n - r_n, n) + 1) )
print '%.3f' % (res/1000.0)","['dp', 'greedy', 'implementation', 'math']"
4562,"oolimry has an array $$$a$$$ of length $$$n$$$ which he really likes. Today, you have changed his array to $$$b$$$, a permutation of $$$a$$$, to make him sad.Because oolimry is only a duck, he can only perform the following operation to restore his array:   Choose two integers $$$i,j$$$ such that $$$1 \leq i,j \leq n$$$.  Swap $$$b_i$$$ and $$$b_j$$$. The sadness of the array $$$b$$$ is the minimum number of operations needed to transform $$$b$$$ into $$$a$$$.Given the arrays $$$a$$$ and $$$b$$$, where $$$b$$$ is a permutation of $$$a$$$, determine if $$$b$$$ has the maximum sadness over all permutations of $$$a$$$. NoteIn the first test case, the array $$$[1,2]$$$ has sadness $$$1$$$. We can transform $$$[1,2]$$$ into $$$[2,1]$$$ using one operation with $$$(i,j)=(1,2)$$$.In the second test case, the array $$$[3,3,2,1]$$$ has sadness $$$2$$$. We can transform $$$[3,3,2,1]$$$ into $$$[1,2,3,3]$$$ with two operations with $$$(i,j)=(1,4)$$$ and $$$(i,j)=(2,3)$$$ respectively.In the third test case, the array $$$[2,1]$$$ has sadness $$$0$$$.In the fourth test case, the array $$$[3,2,3,1]$$$ has sadness $$$1$$$. 
def divisors(M):
    d=[]
    i=1
    while M>=i**2:
        if M%i==0:
            d.append(i)
            if i**2!=M:
                d.append(M//i)
        i=i+1
    return d

def popcount(x):
    x = x - ((x >> 1) & 0x55555555)
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)
    x = (x + (x >> 4)) & 0x0f0f0f0f
    x = x + (x >> 8)
    x = x + (x >> 16)
    return x & 0x0000007f

def eratosthenes(n):
    res=[0 for i in range(n+1)]
    prime=set([])
    for i in range(2,n+1):
        if not res[i]:
            prime.add(i)
            for j in range(1,n//i+1):
                res[i*j]=1
    return prime

def factorization(n):
    res=[]
    for p in prime:
        if n%p==0:
            while n%p==0:
                n//=p
            res.append(p)
    if n!=1:
        res.append(n)
    return res

def euler_phi(n):
    res = n
    for x in range(2,n+1):
        if x ** 2 > n:
            break
        if n%x==0:
            res = res//x * (x-1)
            while n%x==0:
                n //= x
    if n!=1:
        res = res//n * (n-1)
    return res

def ind(b,n):
    res=0
    while n%b==0:
        res+=1
        n//=b
    return res

def isPrimeMR(n):
    d = n - 1
    d = d // (d & -d)
    L = [2, 3, 5, 7, 11, 13, 17]
    for a in L:
        t = d
        y = pow(a, t, n)
        if y == 1: continue
        while y != n - 1:
            y = (y * y) % n
            if y == 1 or t == n - 1: return 0
            t <<= 1
    return 1
def findFactorRho(n):
    from math import gcd
    m = 1 << n.bit_length() // 8
    for c in range(1, 99):
        f = lambda x: (x * x + c) % n
        y, r, q, g = 2, 1, 1, 1
        while g == 1:
            x = y
            for i in range(r):
                y = f(y)
            k = 0
            while k < r and g == 1:
                ys = y
                for i in range(min(m, r - k)):
                    y = f(y)
                    q = q * abs(x - y) % n
                g = gcd(q, n)
                k += m
            r <<= 1
        if g == n:
            g = 1
            while g == 1:
                ys = f(ys)
                g = gcd(abs(x - ys), n)
        if g < n:
            if isPrimeMR(g): return g
            elif isPrimeMR(n // g): return n // g
            return findFactorRho(g)
def primeFactor(n):
    i = 2
    ret = {}
    rhoFlg = 0
    while i*i <= n:
        k = 0
        while n % i == 0:
            n //= i
            k += 1
        if k: ret[i] = k
        i += 1 + i % 2
        if i == 101 and n >= 2 ** 20:
            while n > 1:
                if isPrimeMR(n):
                    ret[n], n = 1, 1
                else:
                    rhoFlg = 1
                    j = findFactorRho(n)
                    k = 0
                    while n % j == 0:
                        n //= j
                        k += 1
                    ret[j] = k

    if n > 1: ret[n] = 1
    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}
    return ret

def divisors(n):
    res = [1]
    prime = primeFactor(n)
    for p in prime:
        newres = []
        for d in res:
            for j in range(prime[p]+1):
                newres.append(d*p**j)
        res = newres
    res.sort()
    return res

def xorfactorial(num):
    if num==0:
        return 0
    elif num==1:
        return 1
    elif num==2:
        return 3
    elif num==3:
        return 0
    else:
        x=baseorder(num)
        return (2**x)*((num-2**x+1)%2)+function(num-2**x)

def xorconv(n,X,Y):
    if n==0:
        res=[(X[0]*Y[0])%mod]
        return res
    x=[X[i]+X[i+2**(n-1)] for i in range(2**(n-1))]
    y=[Y[i]+Y[i+2**(n-1)] for i in range(2**(n-1))]
    z=[X[i]-X[i+2**(n-1)] for i in range(2**(n-1))]
    w=[Y[i]-Y[i+2**(n-1)] for i in range(2**(n-1))]
    res1=xorconv(n-1,x,y)
    res2=xorconv(n-1,z,w)
    former=[(res1[i]+res2[i])*inv for i in range(2**(n-1))]
    latter=[(res1[i]-res2[i])*inv for i in range(2**(n-1))]
    former=list(map(lambda x:x%mod,former))
    latter=list(map(lambda x:x%mod,latter))
    return former+latter

def merge_sort(A,B):
    pos_A,pos_B = 0,0
    n,m = len(A),len(B)
    res = []
    while pos_A < n and pos_B < m:
        a,b = A[pos_A],B[pos_B]
        if a < b:
            res.append(a)
            pos_A += 1
        else:
            res.append(b)
            pos_B += 1
    res += A[pos_A:]
    res += B[pos_B:]
    return res

class UnionFindVerSize():
    def __init__(self, N):
        self._parent = [n for n in range(0, N)]
        self._size = [1] * N
        self.group = N

    def find_root(self, x):
        if self._parent[x] == x: return x
        self._parent[x] = self.find_root(self._parent[x])
        stack = [x]
        while self._parent[stack[-1]]!=stack[-1]:
            stack.append(self._parent[stack[-1]])
        for v in stack:
            self._parent[v] = stack[-1]
        return self._parent[x]

    def unite(self, x, y):
        gx = self.find_root(x)
        gy = self.find_root(y)
        if gx == gy: return

        self.group -= 1

        if self._size[gx] < self._size[gy]:
            self._parent[gx] = gy
            self._size[gy] += self._size[gx]
        else:
            self._parent[gy] = gx
            self._size[gx] += self._size[gy]

    def get_size(self, x):
        return self._size[self.find_root(x)]

    def is_same_group(self, x, y):
        return self.find_root(x) == self.find_root(y)

class WeightedUnionFind():
    def __init__(self,N):
        self.parent = [i for i in range(N)]
        self.size = [1 for i in range(N)]
        self.val = [0 for i in range(N)]
        self.flag = True
        self.edge = [[] for i in range(N)]

    def dfs(self,v,pv):
        stack = [(v,pv)]
        new_parent = self.parent[pv]
        while stack:
            v,pv = stack.pop()
            self.parent[v] = new_parent
            for nv,w in self.edge[v]:
                if nv!=pv:
                    self.val[nv] = self.val[v] + w
                    stack.append((nv,v))

    def unite(self,x,y,w):
        if not self.flag:
            return
        if self.parent[x]==self.parent[y]:
            self.flag = (self.val[x] - self.val[y] == w)
            return

        if self.size[self.parent[x]]>self.size[self.parent[y]]:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[x] += self.size[y]
            self.val[y] = self.val[x] - w
            self.dfs(y,x)
        else:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[y] += self.size[x]
            self.val[x] = self.val[y] + w
            self.dfs(x,y)

class Dijkstra():
    class Edge():
        def __init__(self, _to, _cost):
            self.to = _to
            self.cost = _cost

    def __init__(self, V):
        self.G = [[] for i in range(V)]
        self._E = 0
        self._V = V

    @property
    def E(self):
        return self._E

    @property
    def V(self):
        return self._V

    def add_edge(self, _from, _to, _cost):
        self.G[_from].append(self.Edge(_to, _cost))
        self._E += 1

    def shortest_path(self, s):
        import heapq
        que = []
        d = [10**15] * self.V
        d[s] = 0
        heapq.heappush(que, (0, s))

        while len(que) != 0:
            cost, v = heapq.heappop(que)
            if d[v] < cost: continue

            for i in range(len(self.G[v])):
                e = self.G[v][i]
                if d[e.to] > d[v] + e.cost:
                    d[e.to] = d[v] + e.cost
                    heapq.heappush(que, (d[e.to], e.to))
        return d

#Z[i]:length of the longest list starting from S[i] which is also a prefix of S
#O(|S|)
def Z_algorithm(s):
    N = len(s)
    Z_alg = [0]*N

    Z_alg[0] = N
    i = 1
    j = 0
    while i < N:
        while i+j < N and s[j] == s[i+j]:
            j += 1
        Z_alg[i] = j
        if j == 0:
            i += 1
            continue
        k = 1
        while i+k < N and k + Z_alg[k]<j:
            Z_alg[i+k] = Z_alg[k]
            k += 1
        i += k
        j -= k
    return Z_alg

class BIT():
    def __init__(self,n,mod=0):
        self.BIT = [0]*(n+1)
        self.num = n
        self.mod = mod

    def query(self,idx):
        res_sum = 0
        mod = self.mod
        while idx > 0:
            res_sum += self.BIT[idx]
            if mod:
                res_sum %= mod
            idx -= idx&(-idx)
        return res_sum

    #Ai += x O(logN)
    def update(self,idx,x):
        mod = self.mod
        while idx <= self.num:
            self.BIT[idx] += x
            if mod:
                self.BIT[idx] %= mod
            idx += idx&(-idx)
        return

class dancinglink():
    def __init__(self,n,debug=False):
        self.n = n
        self.debug = debug
        self._left = [i-1 for i in range(n)]
        self._right = [i+1 for i in range(n)]
        self.exist = [True for i in range(n)]

    def pop(self,k):
        if self.debug:
            assert self.exist[k]
        L = self._left[k]
        R = self._right[k]
        if L!=-1:
            if R!=self.n:
                self._right[L],self._left[R] = R,L
            else:
                self._right[L] = self.n
        elif R!=self.n:
            self._left[R] = -1
        self.exist[k] = False

    def left(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._left[res]
            if res==-1:
                break
            k -= 1
        return res

    def right(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._right[res]
            if res==self.n:
                break
            k -= 1
        return res

class SparseTable():
    def __init__(self,A,merge_func,ide_ele):
        N = len(A)
 
        self.merge_func = merge_func
 
        self.lg = [0]*(N + 1)
        for i in range(2, N+1):
            self.lg[i] = self.lg[i >> 1] + 1
        self.pow_2 = [pow(2,i) for i in range(20)]
 
        self.table = [None]*(self.lg[N] + 1)
        st0 = self.table[0] = [a for a in A]
        b = 1
        for i in range(self.lg[N]):
            st0 = self.table[i+1] = [self.merge_func(u,v) for u, v in zip(st0, st0[b:])]
            b <<= 1
 
    def query(self,s,t):
        b = t-s+1
        m = self.lg[b]
        return self.merge_func(self.table[m][s],self.table[m][t-self.pow_2[m]+1])
 

class BinaryTrie:
    class node:
        def __init__(self,val):
            self.left = None
            self.right = None
            self.max = val

    def __init__(self):
        self.root = self.node(-10**15)

    def append(self,key,val):
        pos = self.root
        for i in range(29,-1,-1):
            pos.max = max(pos.max,val)
            if key>>i & 1:
                if pos.right is None:
                    pos.right = self.node(val)
                    pos = pos.right
                else:
                    pos = pos.right
            else:
                if pos.left is None:
                    pos.left = self.node(val)
                    pos = pos.left
                else:
                    pos = pos.left
        pos.max = max(pos.max,val)

    def search(self,M,xor):
        res = -10**15
        pos = self.root
        for i in range(29,-1,-1):
            if pos is None:
                break

            if M>>i & 1:
                if xor>>i & 1:
                    if pos.right:
                        res = max(res,pos.right.max)
                    pos = pos.left
                else:
                    if pos.left:
                        res = max(res,pos.left.max)
                    pos = pos.right
            else:
                if xor>>i & 1:
                    pos = pos.right
                else:
                    pos = pos.left

        if pos:
            res = max(res,pos.max)
        return res

def solveequation(edge,ans,n,m):
    #edge=[[to,dire,id]...]
    def dfs(v):
        used[v]=True
        r=ans[v]
        for to,dire,id in edge[v]:
            if used[to]:
                continue
            y=dfs(to)
            if dire==-1:
                x[id]=y
            else:
                x[id]=-y
            r+=y
        return r
        
    x=[0]*m
    used=[False]*n
    for v in range(n):
        if used[v]:
            continue
        y = dfs(v)
        if y!=0:
            return False
    return x

    

class slope_trick():
    def __init__(self):
        self.L = [10**17]
        self.R = [10**17]
        self.min_f = 0

        self.x_left = 0
        self.x_right = 0

    def add_right(self,a):
        a -= self.x_left
        l0 = -self.L[0]
        self.min_f  = self.min_f + max(0,l0-a)
        if l0 <= a:
            a += self.x_left
            a -= self.x_right
            heappush(self.R,a)
        else:
            heappush(self.L,-a)
            a = -heappop(self.L)
            a += self.x_left
            a -= self.x_right
            heappush(self.R,a)

        #self.min_f  = self.min_f + max(0,l0-a)

    def add_left(self,a):
        a -= self.x_right
        r0 = self.R[0]
        self.min_f = self.min_f + max(0,a-r0)

        if a <= r0:
            a += self.x_right
            a -= self.x_left
            heappush(self.L,-a)
        else:
            heappush(self.R,a)
            a = heappop(self.R)
            a += self.x_right
            a -= self.x_left
            heappush(self.L,-a)

        #self.min_f = self.min_f + max(0,a-r0)

    def add_abs(self,a):
        self.add_left(a)
        self.add_right(a)

    def change_min_slide(self,a,b):
        self.x_left += a
        self.x_right += b
    
    def get_val(self,x):
        L = [-l+self.x_left for l in self.L]
        L.sort()
        R = [r+self.x_right for r in self.R]
        R.sort()

        res = self.min_f

        if 0 < L[-1]:
            L = L[::-1]
            n = len(L)
            for i in range(n):
                c0 = L[i]
                c1 = L[i+1]
        
                if c1 <= x <= c0:
                    res += (i+1) * (c0-x)
                    break
                else:
                    res += (i+1) * (c0-c1)
            return res
        elif L[-1] <= x <= R[0]:
            return res
        else:
            n = len(R)
            for i in range(n):
                c0 = R[i]
                c1 = R[i+1]
                if c0 <= x <= c1:
                    res += (i+1) * (x-c0)
                    break
                else:
                    res += (i+1) * (c1-c0)
            return res

class SegmentTree:
    def __init__(self, init_val, segfunc, ide_ele):
        n = len(init_val)
        self.segfunc = segfunc
        self.ide_ele = ide_ele
        self.num = 1 << (n - 1).bit_length()
        self.tree = [ide_ele] * 2 * self.num
        self.size = n
        for i in range(n):
            self.tree[self.num + i] = init_val[i]
        for i in range(self.num - 1, 0, -1):
            self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])

    def update(self, k, x):
        k += self.num
        self.tree[k] = x
        while k > 1:
            k >>= 1
            self.tree[k] = self.segfunc(self.tree[2*k], self.tree[2*k+1])

    def query(self, l, r):
        if r==self.size:
            r = self.num

        res = self.ide_ele

        l += self.num
        r += self.num
        right = []
        while l < r:
            if l & 1:
                res = self.segfunc(res, self.tree[l])
                l += 1
            if r & 1:
                right.append(self.tree[r-1])
            l >>= 1
            r >>= 1

        for e in right[::-1]:
            res = self.segfunc(res,e)
        return res

    def bisect_l(self,l,r,x):
        l += self.num
        r += self.num
        Lmin = -1
        Rmin = -1
        while l<r:
            if l & 1:
                if self.tree[l] <= x and Lmin==-1:
                    Lmin = l
                l += 1
            if r & 1:
                if self.tree[r-1] <=x:
                    Rmin = r-1
            l >>= 1
            r >>= 1

        if Lmin != -1:
            pos = Lmin
            while pos<self.num:
                if self.tree[2 * pos] <=x:
                    pos = 2 * pos
                else:
                    pos = 2 * pos +1
            return pos-self.num
        elif Rmin != -1:
            pos = Rmin
            while pos<self.num:
                if self.tree[2 * pos] <=x:
                    pos = 2 * pos
                else:
                    pos = 2 * pos +1
            return pos-self.num
        else:
            return -1

import sys,random,bisect
from collections import deque,defaultdict
from heapq import heapify,heappop,heappush
from itertools import permutations
from math import gcd,log

input = lambda :sys.stdin.buffer.readline()
mi = lambda :map(int,input().split())
li = lambda :list(mi())

for _ in range(int(input())):
    n = int(input())
    A = li()
    B = li()

    A = [a-1 for a in A]
    B = [b-1 for b in B]
    
    cnt = [0] * n
    for a in A:
        cnt[a] += 1
    M = max(cnt)
    bye = cnt.index(M)

    edge = [[] for v in range(n)]
    deg = [0] * n
    for i in range(n):
        if A[i]!=bye and B[i]!=bye:
            edge[A[i]].append(B[i])
            deg[B[i]] += 1
    
    deq = deque([v for v in range(n) if deg[v]==0])
    while deq:
        v = deq.popleft()
        for nv in edge[v]:
            deg[nv] -= 1
            if deg[nv]==0:
                deq.append(nv)
    
    if sum(deg) > 0:
        print(""WA"")
    else:
        print(""AC"")","['constructive algorithms', 'dfs and similar', 'graphs']"
297,"It seems that Borya is seriously sick. He is going visit n doctors to find out the exact diagnosis. Each of the doctors needs the information about all previous visits, so Borya has to visit them in the prescribed order (i.e. Borya should first visit doctor 1, then doctor 2, then doctor 3 and so on). Borya will get the information about his health from the last doctor.Doctors have a strange working schedule. The doctor i goes to work on the si-th day and works every di day. So, he works on days si, si + di, si + 2di, ....The doctor's appointment takes quite a long time, so Borya can not see more than one doctor per day. What is the minimum time he needs to visit all doctors? NoteIn the first sample case, Borya can visit all doctors on days 2, 3 and 4.In the second sample case, Borya can visit all doctors on days 10 and 11. n = int(input())
s, d = map(int, input().split())
min_d = s

for i in range(n - 1):
	s, d = map(int, input().split())

	while s <= min_d:
		s += d

	min_d += s - min_d

print(min_d)",['implementation']
4408,"Petya loves lucky numbers very much. Everybody knows that lucky numbers are positive integers whose decimal record contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.Petya loves long lucky numbers very much. He is interested in the minimum lucky number d that meets some condition. Let cnt(x) be the number of occurrences of number x in number d as a substring. For example, if d = 747747, then cnt(4) = 2, cnt(7) = 4, cnt(47) = 2, cnt(74) = 2. Petya wants the following condition to fulfil simultaneously: cnt(4) = a1, cnt(7) = a2, cnt(47) = a3, cnt(74) = a4. Petya is not interested in the occurrences of other numbers. Help him cope with this task. nan a, b, c, d = map(int, input().split(' '))

if (a+b) - (c+d) < 1:
    print(-1)
    quit()


if c == d:

    if a == c:
        if (b-a < 0):
            print(-1)
            quit()
        print('74' * d + '7' * (b-a))
        quit()

    if ((b-c) < 0 or (a-c-1) < 0):
        print(-1)
        quit()
    print('4' * (a-c-1) + '47' * c + '7' * (b - c) + '4')
    quit()
    
if c + 1 == d:
    if (a-c-1 < 0 or b-c-1 < 0):
        print(-1)
        quit()
        
    print('7' + '4' * (a-c-1) + '47' * c + '7' * (b-1-c) + '4')
    quit()
    
if d + 1 == c:
    if a-c < 0 or b-c < 0:
        print(-1)
        quit()
    print('4'*(a-c) + '47' * (c) + '7' * (b-c))
    quit()
    
print(-1)
quit()
","['brute force', 'constructive algorithms', 'implementation']"
3899,"Do you know what tubular bells are? They are a musical instrument made up of cylindrical metal tubes. In an orchestra, tubular bells are used to mimic the ringing of bells.Mike has tubular bells, too! They consist of $$$n$$$ tubes, and each of the tubes has a length that can be expressed by a integer from $$$l$$$ to $$$r$$$ inclusive. It is clear that the lengths of all the tubes are different (it makes no sense to make the same tubes). It is also known that $$$r-l+1 = n$$$.Formally, we can say that Mike's tubular bells are described by a permutation $$$a$$$ of length $$$n$$$ that contains all numbers from $$$l$$$ to $$$r$$$ inclusive, with $$$a_i$$$ denoting the length of the $$$i$$$-th tube.You are offered an interesting task: to guess what Mike's instrument looks like. Simply, you must guess the permutation.Mike won't tell you $$$l$$$ or $$$r$$$. He will only tell you $$$n$$$, and will allow you to ask no more than $$$n + 5000$$$ queries.In each query, you name two positive integers $$$x$$$, $$$y$$$ such that $$$1 \le x, y \le n, x \neq y$$$. In response to this query, the program written by Mike will give you $$$\mathrm{lcm}(a_x, a_y)$$$, where $$$\mathrm{lcm}(c,d)$$$ denotes the least common multiple of $$$c$$$ and $$$d$$$.Solve Mike's problem! nan import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0
    
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

from random import shuffle, randint

from math import gcd


def lcm(a, b): return (a * b) // gcd(a, b)


from collections import Counter


def gcd(x, y):
    """"""greatest common divisor of x and y""""""
    while y:
        x, y = y, x % y
    return x


def memodict(f):
    """"""memoization decorator for a function taking a single argument""""""
    
    class memodict(dict):
        def __missing__(self, key):
            ret = self[key] = f(key)
            return ret
    
    return memodict().__getitem__


def pollard_rho(n):
    """"""returns a random factor of n""""""
    if n & 1 == 0:
        return 2
    if n % 3 == 0:
        return 3
    
    s = ((n - 1) & (1 - n)).bit_length() - 1
    d = n >> s
    for a in [2, 325, 9375, 28178, 450775, 9780504, 1795265022]:
        p = pow(a, d, n)
        if p == 1 or p == n - 1 or a % n == 0:
            continue
        for _ in range(s):
            prev = p
            p = (p * p) % n
            if p == 1:
                return gcd(prev - 1, n)
            if p == n - 1:
                break
        else:
            for i in range(2, n):
                x, y = i, (i * i + 1) % n
                f = gcd(abs(x - y), n)
                while f == 1:
                    x, y = (x * x + 1) % n, (y * y + 1) % n
                    y = (y * y + 1) % n
                    f = gcd(abs(x - y), n)
                if f != n:
                    return f
    return n


@memodict
def prime_factors(n):
    """"""returns a Counter of the prime factorization of n""""""
    if n <= 1:
        return Counter()
    f = pollard_rho(n)
    return Counter([n]) if f == n else prime_factors(f) + prime_factors(n // f)


def distinct_factors(n):
    """"""returns a list of all distinct factors of n""""""
    factors = [1]
    for p, exp in prime_factors(n).items():
        factors += [p ** i * factor for factor in factors for i in range(1, exp + 1)]
    return factors


def all_factors(n):
    """"""returns a sorted list of all distinct factors of n""""""
    small, large = [], []
    for i in range(1, int(n ** 0.5) + 1, 2 if n & 1 else 1):
        if not n % i:
            small.append(i)
            large.append(n // i)
    if small[-1] == large[-1]:
        large.pop()
    large.reverse()
    small.extend(large)
    return small


def get_prime_factors(n, isPrime):
    """"""Returns prime factorisation of n!""""""
    if n < 2:
        return []
    result = []
    while isPrime[n] != 1:
        result += [isPrime[n]]
        n //= isPrime[n]
    result += [n]
    return result


for _ in range(int(input())):
    n = int(input())
    
    
    def query(i, j):
        print(""?"", i + 1, j + 1, flush=True)
        return int(input())
    
    
    if (n * (n - 1)) // 2 <= n + 5000:
        a = ['!']
        qx = {}
        for i in range(n):
            g = 0
            for j in range(n):
                if i == j: continue
                if j > i:
                    qx[i, j] = query(i, j)
                    g = gcd(g, qx[(i, j)])
                else:
                    g = gcd(g, qx[(j, i)])
            a += [g]
        if n == 3:
            d = False
            for i in range(1, 4):
                for j in range(1, 4):
                    if i == j: continue
                    if abs(a[i] - a[j]) == 2:
                        k = 1 + 2 + 3 - i - j
                        a[k] = (a[i] + a[j]) // 2
                        d = True
                        break
                if d: break
        print(*a, flush=True)
        continue
    
    a = [-1] * n
    indexes = list(range(n))
    shuffle(indexes)
    mx = 0
    if n <= 9999:
        di = {}
        while indexes:
            i = indexes.pop()
            if not indexes:
                j = n - 1 - i
            else:
                j = indexes.pop()
            q = max(prime_factors(query(i, j)))
            mx = max(mx, q)
            di[q] = (i, j)
        p, q = di[mx]
        for i in range(n):
            if i == p or i == q: continue
            if query(i, q) % mx == 0:
                p = q
            break
        a[p] = mx
        for i in range(n):
            if i != p:
                a[i] = query(i, p) // mx
        print(*['!'] + a, flush=True)
        continue
    idx2 = list(range(n))
    shuffle(idx2)
    while 1:
        i = idx2.pop()
        j = idx2.pop()
        o = query(i, j)
        pf = prime_factors(o)
        if len(pf) == 2 and min(pf) ** 2 > 200000:
            mx = max(pf)
            p, q = i, j
            for qq in range(30):
                i = p
                while i == p or i == q:
                    i = idx2.pop()
                if query(i, p) % mx:
                    p = q
                    break
            break
    a[p] = mx
    mx2 = (mx, p)
    for i in range(n):
        if i != p:
            a[i] = query(i, p) // mx
            if a[i] * a[i] <= 220000:
                a[i] = -1
            else:
                mp = max(prime_factors(a[i]))
                if mp != a[i]: continue
                if mp > mx2[0]:
                    mx2 = (mp, i)
    for i in range(n):
        if a[i] == -1:
            a[i] = query(i, mx2[1]) // mx2[0]
    
    print(*['!'] + a, flush=True)
    continue","['interactive', 'math', 'number theory', 'probabilities']"
4791,"You are the head of a large enterprise. $$$n$$$ people work at you, and $$$n$$$ is odd (i. e. $$$n$$$ is not divisible by $$$2$$$).You have to distribute salaries to your employees. Initially, you have $$$s$$$ dollars for it, and the $$$i$$$-th employee should get a salary from $$$l_i$$$ to $$$r_i$$$ dollars. You have to distribute salaries in such a way that the median salary is maximum possible.To find the median of a sequence of odd length, you have to sort it and take the element in the middle position after sorting. For example:  the median of the sequence $$$[5, 1, 10, 17, 6]$$$ is $$$6$$$,  the median of the sequence $$$[1, 2, 1]$$$ is $$$1$$$. It is guaranteed that you have enough money to pay the minimum salary, i.e $$$l_1 + l_2 + \dots + l_n \le s$$$.Note that you don't have to spend all your $$$s$$$ dollars on salaries.You have to answer $$$t$$$ test cases. NoteIn the first test case, you can distribute salaries as follows: $$$sal_1 = 12, sal_2 = 2, sal_3 = 11$$$ ($$$sal_i$$$ is the salary of the $$$i$$$-th employee). Then the median salary is $$$11$$$.In the second test case, you have to pay $$$1337$$$ dollars to the only employee.In the third test case, you can distribute salaries as follows: $$$sal_1 = 4, sal_2 = 3, sal_3 = 6, sal_4 = 6, sal_5 = 7$$$. Then the median salary is $$$6$$$. from sys import stdin
input = stdin.readline
q = int(input())
for rwre in range(q):
	n, s = map(int,input().split())
	przed = [list(map(int,input().split())) for i in range(n)]
	przed.sort()
	przed.reverse()
	l = 1
	p = 10 ** 9
	while abs(p - l) > 0:
		mozna = 1
		sr = (p + l + 1) // 2
		#try to make median >= sr
		duze = [przed[i] for i in range(n) if przed[i][1] >= sr ]
		male = [przed[i] for i in range(n) if przed[i][1] < sr ]
		if len(duze) <= n // 2:
			mozna = 0
		else:
			spent = 0
			dudes = 0
			for i in range(n//2 + 1):
				spent += max(sr, duze[i][0])
			dudes = n//2 + 1
			duze = duze[(n//2+1):]
			for du in duze:
				spent += du[0]
			for ma in male:
				spent += ma[0]
			if spent > s:
				mozna = 0
		if mozna == 1:
			l = sr
		else:
			p = sr - 1
	print((p+l)//2)
						
					
				
		","['binary search', 'greedy', 'sortings']"
2515,"You are given a multiset $$$S$$$ initially consisting of $$$n$$$ distinct non-negative integers. A multiset is a set, that can contain some elements multiple times.You will perform the following operation $$$k$$$ times:   Add the element $$$\lceil\frac{a+b}{2}\rceil$$$ (rounded up) into $$$S$$$, where $$$a = \operatorname{mex}(S)$$$ and $$$b = \max(S)$$$. If this number is already in the set, it is added again. Here $$$\operatorname{max}$$$ of a multiset denotes the maximum integer in the multiset, and $$$\operatorname{mex}$$$ of a multiset denotes the smallest non-negative integer that is not present in the multiset. For example:    $$$\operatorname{mex}(\{1,4,0,2\})=3$$$;   $$$\operatorname{mex}(\{2,5,1\})=0$$$. Your task is to calculate the number of distinct elements in $$$S$$$ after $$$k$$$ operations will be done. NoteIn the first test case, $$$S=\{0,1,3,4\}$$$, $$$a=\operatorname{mex}(S)=2$$$, $$$b=\max(S)=4$$$, $$$\lceil\frac{a+b}{2}\rceil=3$$$. So $$$3$$$ is added into $$$S$$$, and $$$S$$$ becomes $$$\{0,1,3,3,4\}$$$. The answer is $$$4$$$.In the second test case, $$$S=\{0,1,4\}$$$, $$$a=\operatorname{mex}(S)=2$$$, $$$b=\max(S)=4$$$, $$$\lceil\frac{a+b}{2}\rceil=3$$$. So $$$3$$$ is added into $$$S$$$, and $$$S$$$ becomes $$$\{0,1,3,4\}$$$. The answer is $$$4$$$. def ceil(a,b):
    return ((a+b-1)//b)
for _ in range(int(input())):
    n,k = map(int,input().split())
    a = set(map(int,input().split()))
    if k==0:
        print(len(a))
        continue
    maxi = max(a)
    for i in range(maxi+2):
        if i not in a:
            mex = i
            break
    length = len(a)
    if mex<maxi:
        new_one = ceil(mex+maxi,2)
        if new_one not in a:
            print(length+1)
        else:
            print(length)
    else:
        print(length+k)
",['math']
2585,"You are given the strings $$$a$$$ and $$$b$$$, consisting of lowercase Latin letters. You can do any number of the following operations in any order:   if $$$|a| &gt; 0$$$ (the length of the string $$$a$$$ is greater than zero), delete the first character of the string $$$a$$$, that is, replace $$$a$$$ with $$$a_2 a_3 \ldots a_n$$$;  if $$$|a| &gt; 0$$$, delete the last character of the string $$$a$$$, that is, replace $$$a$$$ with $$$a_1 a_2 \ldots a_{n-1}$$$;  if $$$|b| &gt; 0$$$ (the length of the string $$$b$$$ is greater than zero), delete the first character of the string $$$b$$$, that is, replace $$$b$$$ with $$$b_2 b_3 \ldots b_n$$$;  if $$$|b| &gt; 0$$$, delete the last character of the string $$$b$$$, that is, replace $$$b$$$ with $$$b_1 b_2 \ldots b_{n-1}$$$. Note that after each of the operations, the string $$$a$$$ or $$$b$$$ may become empty.For example, if $$$a=$$$""hello"" and $$$b=$$$""icpc"", then you can apply the following sequence of operations:   delete the first character of the string $$$a$$$ $$$\Rightarrow$$$ $$$a=$$$""ello"" and $$$b=$$$""icpc"";  delete the first character of the string $$$b$$$ $$$\Rightarrow$$$ $$$a=$$$""ello"" and $$$b=$$$""cpc"";  delete the first character of the string $$$b$$$ $$$\Rightarrow$$$ $$$a=$$$""ello"" and $$$b=$$$""pc"";  delete the last character of the string $$$a$$$ $$$\Rightarrow$$$ $$$a=$$$""ell"" and $$$b=$$$""pc"";  delete the last character of the string $$$b$$$ $$$\Rightarrow$$$ $$$a=$$$""ell"" and $$$b=$$$""p"". For the given strings $$$a$$$ and $$$b$$$, find the minimum number of operations for which you can make the strings $$$a$$$ and $$$b$$$ equal. Note that empty strings are also equal. nan import sys

def stringComparator(a, b):
    n = len(a)
    m = len(b)
    size = 0

    for i in range(1, min(n,m) + 1):
        for j in range(0, n - i + 1):
            for k in range(0, m - i + 1):
                if (a[j: j + i] == b[k: k + i]):
                    size = max(size, i)

    #print(""final size:"",size)                
    return((len(a) + len(b)) - (size * 2))
    

if __name__ == '__main__':
    n = int(sys.stdin.readline())
    arr = []
    for i in range (0, n):
        a = input()
        b = input()
        arr.append(stringComparator(a, b))
    for i in range(0, len(arr)):
        print(arr[i])
    ","['brute force', 'implementation', 'strings']"
3101,"Shuseki Kingdom is the world's leading nation for innovation and technology. There are n cities in the kingdom, numbered from 1 to n.Thanks to Mr. Kitayuta's research, it has finally become possible to construct teleportation pipes between two cities. A teleportation pipe will connect two cities unidirectionally, that is, a teleportation pipe from city x to city y cannot be used to travel from city y to city x. The transportation within each city is extremely developed, therefore if a pipe from city x to city y and a pipe from city y to city z are both constructed, people will be able to travel from city x to city z instantly.Mr. Kitayuta is also involved in national politics. He considers that the transportation between the m pairs of city (ai, bi) (1 ≤ i ≤ m) is important. He is planning to construct teleportation pipes so that for each important pair (ai, bi), it will be possible to travel from city ai to city bi by using one or more teleportation pipes (but not necessarily from city bi to city ai). Find the minimum number of teleportation pipes that need to be constructed. So far, no teleportation pipe has been constructed, and there is no other effective transportation between cities. NoteFor the first sample, one of the optimal ways to construct pipes is shown in the image below:   For the second sample, one of the optimal ways is shown below:    def main():
    n, m = map(int, input().split())
    n += 1
    cluster, dest, ab = list(range(n)), [0] * n, [[] for _ in range(n)]

    def root(x):
        if x != cluster[x]:
            cluster[x] = x = root(cluster[x])
        return x

    for _ in range(m):
        a, b = map(int, input().split())
        ab[a].append(b)
        dest[b] += 1
        cluster[root(a)] = root(b)
    pool = [a for a, f in enumerate(dest) if not f]
    for a in pool:
        for b in ab[a]:
            dest[b] -= 1
            if not dest[b]:
                pool.append(b)
    ab = [True] * n
    for a, f in enumerate(dest):
        if f:
            ab[root(a)] = False
    print(n - sum(f and a == c for a, c, f in zip(range(n), cluster, ab)))


if __name__ == '__main__':
    from sys import setrecursionlimit

    setrecursionlimit(100500)
    main()
",['dfs and similar']
2093,"You are given $$$n$$$ objects. Each object has two integer properties: $$$val_i$$$ — its price — and $$$mask_i$$$. It is guaranteed that the sum of all prices is initially non-zero.You want to select a positive integer $$$s$$$. All objects will be modified after that. The $$$i$$$-th object will be modified using the following procedure:   Consider $$$mask_i$$$ and $$$s$$$ in binary notation,  Compute the bitwise AND of $$$s$$$ and $$$mask_i$$$ ($$$s \,\&amp;\, mask_i$$$),  If ($$$s \,\&amp;\, mask_i$$$) contains an odd number of ones, replace the $$$val_i$$$ with $$$-val_i$$$. Otherwise do nothing with the $$$i$$$-th object. You need to find such an integer $$$s$$$ that when the modification above is done the sum of all prices changes sign (if it was negative, it should become positive, and vice-versa; it is not allowed for it to become zero). The absolute value of the sum can be arbitrary. NoteIn the first test sample all objects will change their prices except for the object with mask $$$151$$$. So their total sum will change its sign: initially $$$24$$$, after modifications — $$$-28$$$.In the second test sample the only object will change its price. So the total sum will change its sign.  import fileinput
def D(a):print(a)
def S(s,I):return int(s.split("" "")[I])
def bt(a):
    S=0
    while(a>0):
        S+=a%2
        a/=2
    return S;
def main():
    z=0
    N=0
    A=0
    B=0
    M=0
    S=0
    T=0
    for l in fileinput.input():
        z+=1
        if(z<2):
            N=int(l);
            A=[0]*N
            B=[0]*N
            M=[0]*N
            continue
        A[z-2]=int(l.split("" "")[0])
        M[z-2]=int(l.split("" "")[1])
    for i in A:S+=i
    if(S>0):
        for i in range(N):A[i]=-A[i]
    for i in range(N):B[i]=M[i].bit_length()-1
    for i in range(62):
        X=0
        for j in range(N):
            if(B[j]==i):
                if(bt(M[j]&T)%2==1):X-=A[j]
                else: X+=A[j]
        if(X<0):T|=1<<i
    D(T)
main()
","['bitmasks', 'constructive algorithms']"
2229,"Once Divan analyzed a sequence $$$a_1, a_2, \ldots, a_n$$$ consisting of $$$n$$$ non-negative integers as follows. He considered each non-empty subsequence of the sequence $$$a$$$, computed the bitwise XOR of its elements and added up all the XORs, obtaining the coziness of the sequence $$$a$$$.A sequence $$$c$$$ is a subsequence of a sequence $$$d$$$ if $$$c$$$ can be obtained from $$$d$$$ by deletion of several (possibly, zero or all) elements. For example, $$$[1, \, 2, \, 3, \, 4]$$$, $$$[2, \, 4]$$$, and $$$[2]$$$ are subsequences of $$$[1, \, 2, \, 3, \, 4]$$$, but $$$[4, \, 3]$$$ and $$$[0]$$$ are not.Divan was very proud of his analysis, but now he lost the sequence $$$a$$$, and also the coziness value! However, Divan remembers the value of bitwise OR on $$$m$$$ contiguous subsegments of the sequence $$$a$$$. It turns out that each element of the original sequence is contained in at least one of these $$$m$$$ segments.Divan asks you to help find the coziness of the sequence $$$a$$$ using the information he remembers. If several coziness values are possible, print any.As the result can be very large, print the value modulo $$$10^9 + 7$$$. NoteIn first example, one of the sequences that fits the constraints is $$$[0, 2]$$$. Consider all its non-empty subsequences:  $$$[0]$$$: the bitwise XOR of this subsequence is $$$0$$$;  $$$[2]$$$: the bitwise XOR of this subsequence is $$$2$$$;  $$$[0, 2]$$$: the bitwise XOR of this subsequence is $$$2$$$. The sum of all results is $$$4$$$, so it is the answer.In second example, one of the sequences that fits the constraints is $$$[0, \, 5, \, 5]$$$.In third example, one of the sequences that fits the constraints is $$$[5, \, 6, \, 7, \, 0, \, 2]$$$. from sys import stdin
import math
from collections import deque
from heapq import heapify, heappop, heappush
from bisect import bisect_left, bisect_right

input = stdin.readline

power, mod = {}, 1000000007
def getpower(k):
	if(k == 0):return 1
	if(k == 1):return 2
	if(k in power):
		return power[k]
	power[k] = (getpower(k // 2) * getpower(k - k // 2)) % mod
	return power[k]

for _ in range(int(input())):
	n, m = map(int, input().split())
	arr, mod, easy = [], 1000000007, [0] * 30
	powerval = getpower(n - 1)
	easy = 0
	for _ in range(m):
		l, r, x = map(int, input().split())
		easy = easy | x

	value, total = 1, 0
	for i in range(30):
		if(easy % 2 == 0):
			value = (value * 2) % mod
			easy = easy // 2
			continue
		total += value
		total = total % mod
		value = value * 2
		value = value % mod
		easy = easy // 2

	print((total * powerval)%mod)","['bitmasks', 'combinatorics', 'constructive algorithms', 'dp', 'math']"
1436,"Let's suppose you have an array a, a stack s (initially empty) and an array b (also initially empty).You may perform the following operations until both a and s are empty:  Take the first element of a, push it into s and remove it from a (if a is not empty);  Take the top element from s, append it to the end of array b and remove it from s (if s is not empty). You can perform these operations in arbitrary order.If there exists a way to perform the operations such that array b is sorted in non-descending order in the end, then array a is called stack-sortable.For example, [3, 1, 2] is stack-sortable, because b will be sorted if we perform the following operations:  Remove 3 from a and push it into s;  Remove 1 from a and push it into s;  Remove 1 from s and append it to the end of b;  Remove 2 from a and push it into s;  Remove 2 from s and append it to the end of b;  Remove 3 from s and append it to the end of b. After all these operations b = [1, 2, 3], so [3, 1, 2] is stack-sortable. [2, 3, 1] is not stack-sortable.You are given k first elements of some permutation p of size n (recall that a permutation of size n is an array of size n where each integer from 1 to n occurs exactly once). You have to restore the remaining n - k elements of this permutation so it is stack-sortable. If there are multiple answers, choose the answer such that p is lexicographically maximal (an array q is lexicographically greater than an array p iff there exists some integer k such that for every i &lt; k qi = pi, and qk &gt; pk). You may not swap or change any of first k elements of the permutation.Print the lexicographically maximal permutation p you can obtain.If there exists no answer then output -1. nan # https://codeforces.com/problemset/problem/911/E

n, k = map(int, input().split())
p    = list(map(int, input().split()))
d    = {x:1 for x in p}

def solve(p, d, n):
    add  = []
    s    = []
    
    for x in range(1, n+1):
        if x not in d:
            while len(p) > 0:
                s.append(p.pop(0))
                
                if len(s) >= 2 and s[-1] > s[-2]:
                    return False, None
                
            # len(p)=0
            if len(s) == 0 or s[-1] != x:
                up = n if len(s) == 0 else s[-1]-1
            
                for y in range(up, x-1, -1):
                    add.append(y)
                    s.append(y)
                    d[y]=1
            s.pop()
        else:
            if len(s) == 0 or s[-1] != x:
                while len(p) > 0:
                    s.append(p.pop(0))
                
                    if len(s) >= 2 and s[-1] > s[-2]:
                        return False, None
                
                    if s[-1] == x:
                        break
            s.pop()
    return True, add

ans =  [x for x in p]
flg, add = solve(p, d, n)
if flg==False:
    print(-1)
else:
    print(' '.join([str(x) for x in ans+add]))","['constructive algorithms', 'data structures', 'greedy', 'implementation']"
691,"You are given a picture consisting of $$$n$$$ rows and $$$m$$$ columns. Rows are numbered from $$$1$$$ to $$$n$$$ from the top to the bottom, columns are numbered from $$$1$$$ to $$$m$$$ from the left to the right. Each cell is painted either black or white. You think that this picture is not interesting enough. You consider a picture to be interesting if there is at least one cross in it. A cross is represented by a pair of numbers $$$x$$$ and $$$y$$$, where $$$1 \le x \le n$$$ and $$$1 \le y \le m$$$, such that all cells in row $$$x$$$ and all cells in column $$$y$$$ are painted black.For examples, each of these pictures contain crosses:  The fourth picture contains 4 crosses: at $$$(1, 3)$$$, $$$(1, 5)$$$, $$$(3, 3)$$$ and $$$(3, 5)$$$.Following images don't contain crosses:  You have a brush and a can of black paint, so you can make this picture interesting. Each minute you may choose a white cell and paint it black.What is the minimum number of minutes you have to spend so the resulting picture contains at least one cross?You are also asked to answer multiple independent queries. NoteThe example contains all the pictures from above in the same order.The first 5 pictures already contain a cross, thus you don't have to paint anything.You can paint $$$(1, 3)$$$, $$$(3, 1)$$$, $$$(5, 3)$$$ and $$$(3, 5)$$$ on the $$$6$$$-th picture to get a cross in $$$(3, 3)$$$. That'll take you $$$4$$$ minutes.You can paint $$$(1, 2)$$$ on the $$$7$$$-th picture to get a cross in $$$(4, 2)$$$.You can paint $$$(2, 2)$$$ on the $$$8$$$-th picture to get a cross in $$$(2, 2)$$$. You can, for example, paint $$$(1, 3)$$$, $$$(3, 1)$$$ and $$$(3, 3)$$$ to get a cross in $$$(3, 3)$$$ but that will take you $$$3$$$ minutes instead of $$$1$$$.There are 9 possible crosses you can get in minimum time on the $$$9$$$-th picture. One of them is in $$$(1, 1)$$$: paint $$$(1, 2)$$$ and $$$(2, 1)$$$. #import resource
import sys
#resource.setrlimit(resource.RLIMIT_STACK, [0x100000000, resource.RLIM_INFINITY])
#import threading
#threading.Thread(target=main).start()
#threading.stack_size(2**26)
#sys.setrecursionlimit(10**6)
mod=(10**9)+7
#fact=[1]
#for i in range(1,100001):
#    fact.append((fact[-1]*i)%mod)
#ifact=[0]*100001
#ifact[100000]=pow(fact[100000],mod-2,mod)
#for i in range(100000,0,-1):
#    ifact[i-1]=(i*ifact[i])%mod
from sys import stdin, stdout
import bisect
from bisect import bisect_left as bl
from bisect import bisect_right as br
import itertools
import collections
import math
import heapq
#from random import randint as rn
#from Queue import Queue as Q
def modinv(n,p):
    return pow(n,p-2,p)
def ncr(n,r,p):
    t=((fact[n])*((ifact[r]*ifact[n-r])%p))%p
    return t
def ain():
    return map(int,sin().split())
def sin():
    return stdin.readline().strip()
def GCD(x,y):
    while(y):
        x, y = y, x % y
    return x
def isprime(x):
    if(x==1):
        return False
    elif(x<4):
        return True
    for i in range(2,int(math.sqrt(x))+1):
        if(x%i==0):
            return False
    return True
""""""**************************************************************************""""""
ans=[]
for _ in range(input()):
    n,m=ain()
    f1=[]
    f2=[]
    b=[]
    for i in range(n):
        b.append(sin())
        s=0
        for j in range(m):
            if(b[-1][j]=="".""):
                s+=1
        f1.append(s)
    for i in range(m):
        s=0
        for j in range(n):
            if(b[j][i]=="".""):
                s+=1
        f2.append(s)
    k=n*m
    for i in range(n):
        for j in range(m):
            x=f1[i]+f2[j]
            if(b[i][j]=="".""):
                x-=1
            k=min(k,x)
    ans.append(str(k))
stdout.write(""\n"".join(ans))
",['implementation']
2742,"Little Dima has two sequences of points with integer coordinates: sequence (a1, 1), (a2, 2), ..., (an, n) and sequence (b1, 1), (b2, 2), ..., (bn, n).Now Dima wants to count the number of distinct sequences of points of length 2·n that can be assembled from these sequences, such that the x-coordinates of points in the assembled sequence will not decrease. Help him with that. Note that each element of the initial sequences should be used exactly once in the assembled sequence.Dima considers two assembled sequences (p1, q1), (p2, q2), ..., (p2·n, q2·n) and (x1, y1), (x2, y2), ..., (x2·n, y2·n) distinct, if there is such i (1 ≤ i ≤ 2·n), that (pi, qi) ≠ (xi, yi).As the answer can be rather large, print the remainder from dividing the answer by number m. NoteIn the first sample you can get only one sequence: (1, 1), (2, 1). In the second sample you can get such sequences : (1, 1), (2, 2), (2, 1), (3, 2); (1, 1), (2, 1), (2, 2), (3, 2). Thus, the answer is 2. from sys import stdin
n = int(stdin.readline())
a = map(int, stdin.readline().split())
b = map(int, stdin.readline().split())
f = {}
for x in a:
    f[x] = f[x] + 1 if f.has_key(x) else 1
for x in b:
    f[x] = f[x] + 1 if f.has_key(x) else 1
same = 0
for i in range(len(a)):
    if a[i] == b[i]: same+=1
m = int(stdin.readline())
r=1
for x in f.values():
    for i in range(2, x+1):
        k = i
        while same > 0 and k%2==0:
            same-=1
            k /= 2
        r=(r*k)%m
print(r)
",['combinatorics']
4541,"Lee just became Master in Codeforces, and so, he went out to buy some gifts for his friends. He bought $$$n$$$ integers, now it's time to distribute them between his friends rationally...Lee has $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ in his backpack and he has $$$k$$$ friends. Lee would like to distribute all integers in his backpack between his friends, such that the $$$i$$$-th friend will get exactly $$$w_i$$$ integers and each integer will be handed over to exactly one friend.Let's define the happiness of a friend as the sum of the maximum and the minimum integer he'll get.Lee would like to make his friends as happy as possible, in other words, he'd like to maximize the sum of friends' happiness. Now he asks you to calculate the maximum sum of friends' happiness. NoteIn the first test case, Lee should give the greatest integer to the first friend (his happiness will be $$$17 + 17$$$) and remaining integers to the second friend (his happiness will be $$$13 + 1$$$).In the second test case, Lee should give $$$\{10, 10, 11\}$$$ to the first friend and to the second friend, so the total happiness will be equal to $$$(11 + 10) + (11 + 10)$$$In the third test case, Lee has four friends and four integers, it doesn't matter how he distributes the integers between his friends. t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    w = list(map(int, input().split()))
    a.sort(reverse = True)
    w.sort()
    ii = k
    l, r = 0, n - 1
    ans = 0
    for i in range(k):
        if w[i] == 1:
            ans += a[l] * 2
            l += 1
        else:
            ii = i
            break
    for i in range(k-1, ii-1, -1):
        ans += a[l] + a[r]
        l += 1
        r -= (w[i] - 1)
    print(ans)","['greedy', 'math', 'sortings', 'two pointers']"
893,"Polycarp found on the street an array $$$a$$$ of $$$n$$$ elements.Polycarp invented his criterion for the beauty of an array. He calls an array $$$a$$$ beautiful if at least one of the following conditions must be met for each different pair of indices $$$i \ne j$$$:   $$$a_i$$$ is divisible by $$$a_j$$$;  or $$$a_j$$$ is divisible by $$$a_i$$$. For example, if:   $$$n=5$$$ and $$$a=[7, 9, 3, 14, 63]$$$, then the $$$a$$$ array is not beautiful (for $$$i=4$$$ and $$$j=2$$$, none of the conditions above is met);  $$$n=3$$$ and $$$a=[2, 14, 42]$$$, then the $$$a$$$ array is beautiful;  $$$n=4$$$ and $$$a=[45, 9, 3, 18]$$$, then the $$$a$$$ array is not beautiful (for $$$i=1$$$ and $$$j=4$$$ none of the conditions above is met); Ugly arrays upset Polycarp, so he wants to remove some elements from the array $$$a$$$ so that it becomes beautiful. Help Polycarp determine the smallest number of elements to remove to make the array $$$a$$$ beautiful. NoteIn the first test case, removing $$$7$$$ and $$$14$$$ will make array $$$a$$$ beautiful.In the second test case, the array $$$a$$$ is already beautiful.In the third test case, removing one of the elements $$$45$$$ or $$$18$$$ will make the array $$$a$$$ beautiful.In the fourth test case, the array $$$a$$$ is beautiful. import os,sys
from random import randint, shuffle
from io import BytesIO, IOBase

from collections import defaultdict,deque,Counter
from bisect import bisect_left,bisect_right
from heapq import heappush,heappop
from functools import lru_cache
from itertools import accumulate, permutations
import math

# Fast IO Region
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# for _ in range(int(input())):
#     n = int(input())
#     a = list(map(int, input().split()))

# for _ in range(int(input())):
#     n = int(input())
#     while n % 2 == 0:
#         n //= 2
#     if n == 1:
#         print('NO')
#     else:
#         print('YES')

# for _ in range(int(input())):
#     n = int(input())
#     k = n // 2020
#     res = n % 2020
#     if res <= k:
#         print('YES')
#     else:
#         print('NO')

# for _ in range(int(input())):
#     a, b, k = list(map(int, input().split()))
#     c = list(map(int, input().split()))
#     d = list(map(int, input().split()))
#     cnt1 = [0] * (a + 1)
#     cnt2 = [0] * (b + 1)
#     for i in range(k):
#         cnt1[c[i]] += 1
#         cnt2[d[i]] += 1
#     ans = k * (k - 1) // 2
#     for i in range(a + 1):
#         ans -= cnt1[i] * (cnt1[i] - 1) // 2
#     for i in range(b + 1):
#         ans -= cnt2[i] * (cnt2[i] - 1) // 2
#     cnt = Counter()
#     for i in range(k):
#         cnt[(c[i], d[i])] += 1
#     for i in cnt:
#         ans += (cnt[i] - 1) * cnt[i] // 2
#     print(ans)

# mod = 10 ** 9 + 7
# N = 500010
# fac = [1] * N
# for i in range(2, N):
#     fac[i] = fac[i - 1] * i % mod
# invfac = [1] * N
# invfac[N - 1] = pow(fac[N - 1], mod - 2, mod)
# for i in range(N - 1)[::-1]:
#     invfac[i] = invfac[i + 1] * (i + 1) % mod
# def c(i, j):
#     if i < j: return 0
#     return fac[i] * invfac[j] * invfac[i - j] % mod

# for _ in range(int(input())):
#     n, k = list(map(int, input().split()))
#     a = list(map(int, input().split()))
#     a.sort(reverse=True)
#     x = y = 0
#     for i in range(n):
#         if a[i] == a[k - 1]:
#             if i < k:
#                 x += 1
#             else:
#                 y += 1
#     print(c(x + y, x))

# for _ in range(int(input())):
#     n, m = list(map(int, input().split()))
#     a = list(map(int, input().split()))
#     b = list(map(int, input().split()))
#     if sum(a) < m:
#         print(-1)
#         continue
#     c, d = [], []
#     for i in range(n):
#         if b[i] == 1:
#             c.append(a[i])
#         else:
#             d.append(a[i])
#     c.sort(reverse=True)
#     d.sort(reverse=True)
#     if not c:
#         t = 0
#         ans = 0
#         for i in range(n):
#             t += d[i]
#             ans += 2
#             if t >= m:
#                 print(ans)
#                 break
#     elif not d:
#         t = 0
#         ans = 0
#         for i in range(n):
#             t += c[i]
#             ans += 1
#             if t >= m:
#                 print(ans)
#                 break
#     else:
#         j = len(d) - 1
#         ans = len(d) * 2
#         t = sum(d)
#         while j >= 0 and t - d[j] >= m:
#             t -= d[j]
#             ans -= 2
#             j -= 1
#         mn = float('inf')
#         if t >= m:
#             mn = ans
#         for i in range(len(c)):
#             t += c[i]
#             ans += 1
#             while j >= 0 and t - d[j] >= m:
#                 t -= d[j]
#                 ans -= 2
#                 j -= 1
#             if t >= m:
#                 mn = min(ans, mn)
#         print(mn)

# for _ in range(int(input())):
#     n = int(input())
#     a = [list(map(int, input())) for _ in range(n)]
#     input()
#     b = [list(map(int, input())) for _ in range(n)]
#     for i in range(n):
#         for j in range(n):
#             if b[i][j]:
#                 b[i][j] = 0
#                 a[i][j] ^= 1
#     for i in range(n):
#         if a[i][0] == 1:
#             for j in range(n):
#                 a[i][j] ^= 1
#     for j in range(n):
#         if a[0][j] == 1:
#             for i in range(n):
#                 a[i][j] ^= 1
#     if a == b:
#         print('YES')
#     else:
#         print('NO')

N = 200005
for _ in range(int(input())):
    n = int(input())
    a = list(map(int, input().split()))
    mx = max(a) + 1
    cnt = [0] * mx
    for i in range(n):
        cnt[a[i]] += 1
    dp = [0] * mx
    for i in range(1, mx):
        dp[i] += cnt[i]
        for j in range(2 * i, mx, i):
            dp[j] = max(dp[j], dp[i])
    print(n - max(dp))


","['dp', 'math', 'number theory', 'sortings']"
4227,"Gianni, SWERC's chief judge, received a huge amount of high quality problems from the judges and now he has to choose a problem set for SWERC.He received $$$n$$$ problems and he assigned a beauty score and a difficulty to each of them. The $$$i$$$-th problem has beauty score equal to $$$b_i$$$ and difficulty equal to $$$d_i$$$. The beauty and the difficulty are integers between $$$1$$$ and $$$10$$$. If there are no problems with a certain difficulty (the possible difficulties are $$$1,2,\dots,10$$$) then Gianni will ask for more problems to the judges.Otherwise, for each difficulty between $$$1$$$ and $$$10$$$, he will put in the problem set one of the most beautiful problems with such difficulty (so the problem set will contain exactly $$$10$$$ problems with distinct difficulties). You shall compute the total beauty of the problem set, that is the sum of the beauty scores of the problems chosen by Gianni. NoteIn the first test case, Gianni has received only $$$3$$$ problems, with difficulties $$$3, 4, 7$$$ which are not sufficient to create a problem set (for example because there is not a problem with difficulty $$$1$$$).In the second test case, Gianni will create a problem set by taking the problems $$$2$$$, $$$3$$$, $$$4$$$, $$$5$$$, $$$7$$$, $$$8$$$, $$$9$$$, $$$10$$$, $$$11$$$ (which have beauty equal to $$$10$$$ and all difficulties from $$$1$$$ to $$$9$$$) and one of the problems $$$1$$$ and $$$6$$$ (which have both beauty $$$3$$$ and difficulty $$$10$$$). The total beauty of the resulting problem set is $$$10\cdot 9 + 3 = 93$$$. nopr = ""MOREPROBLEMS""

def orgSwerc(problemsList):
    chosen = {}

    for c in problemsList:
        if c[0] in chosen:
            if c[1] > chosen[c[0]]:
                chosen[c[0]] = c[1]
        else:
            chosen[c[0]] = c[1]
    
    for i in range(1, 11):
        if i not in chosen:
            return nopr
    
    return str(sum(chosen.values()))


n_test = int(input())

for _ in range(n_test):
    n_ch = int(input())
    challenges = []
    for _ in range(n_ch):
        a, b = input().split("" "")
        challenges.append((int(b),int(a)))

    print(orgSwerc(challenges))

","['brute force', 'implementation']"
2757,"You are given an array a consisting of positive integers and q queries to this array. There are two types of queries:   1 l r x — for each index i such that l ≤ i ≤ r set ai = x.  2 l r — find the minimum among such ai that l ≤ i ≤ r. We decided that this problem is too easy. So the array a is given in a compressed form: there is an array b consisting of n elements and a number k in the input, and before all queries a is equal to the concatenation of k arrays b (so the size of a is n·k). nan from sys import stdin, stdout


n, k = map(int, stdin.readline().split())
values = [0] + list(map(int, stdin.readline().split()))
m = int(stdin.readline())
questions = []
ar = set()

for i in range(m):
    questions.append(tuple(map(int, stdin.readline().strip().split())))
    ar.add(int(questions[-1][1]))
    ar.add(int(questions[-1][2]))
    

compress = [0]
ar = sorted(list(ar))

pw = 1
while (2 ** pw < n):
    pw += 1

sparse = [[float('inf') for j in range(len(values))] for i in range(pw)]
sparse[0] = values

for i in range(1, pw):
    for j in range(1, n - 2 ** i + 2):
        sparse[i][j] = min(sparse[i - 1][j], sparse[i - 1][j + 2 ** (i - 1)])


mn = min(values[1:])


def getmin(first, second):
    if second - first + 1 >= n:
        return mn
    else:
        second = second % n + n * (not(second % n))
        first = first % n + n * (not(first % n))
        
        if second < first:
            return min(getmin(1, second), getmin(first, n))
        else:
            length = second - first + 1
            pw = 0
    
            while 2 ** pw <= length:
                pw += 1
            
            pw -= 1
            
            return min(sparse[pw][first], sparse[pw][second - 2 ** pw + 1])


counting = {}
d = {}


for i in range(len(ar)):
    compress.append(ar[i])
    d[ar[i]] = len(compress) - 1
    
    if i != len(ar) - 1 and ar[i + 1] - ar[i] > 1:
        compress.append(ar[i] + 1)
        counting[len(compress) - 1] = float('inf')
        d[ar[i] + 1] = len(compress) - 1

for ind in counting:
    counting[ind] = getmin(compress[ind - 1] + 1, compress[ind + 1] - 1)
        
    

def update(l, r, ind, lb, rb, value):
        
        
    if updating[ind] and ind * 2 < len(tree):
        
        if (not updating[ind * 2] or (updating[ind * 2][1] < updating[ind][1])):
            tree[ind * 2] = updating[ind][0]
            updating[ind * 2] = updating[ind][::]
            
        if (not updating[ind * 2 + 1] or (updating[ind * 2 + 1][1] < updating[ind][1])):
            tree[ind * 2 + 1] = updating[ind][0]
            updating[ind * 2 + 1] = updating[ind][::]        
        
    updating[ind] = 0
        
        
    if (l == lb and r == rb):
        tree[ind] = value
        
        if (ind * 2 < len(tree)):
            tree[ind * 2], tree[ind * 2 + 1] = value, value
            updating[ind * 2], updating[ind * 2 + 1] = (value, time), (value, time)
        
        
        while ind != 1:
            ind //= 2
            tree[ind] = min(tree[ind * 2], tree[ind * 2 + 1])
        
    else:
        m = (lb + rb) // 2
        
        if (l <= m):
            update(l, min(m, r), ind * 2, lb, m, value)
        
        if (r > m):
            update(max(l, m + 1), r, ind * 2 + 1, m + 1, rb, value)
        
        
def get(l, r, ind, lb, rb):
        
        
    if updating[ind] and ind * 2 < len(tree):
        
        if (not updating[ind * 2] or (updating[ind * 2][1] < updating[ind][1])):
            tree[ind * 2] = updating[ind][0]
            updating[ind * 2] = updating[ind][::]
        
        if (not updating[ind * 2 + 1] or (updating[ind * 2 + 1][1] < updating[ind][1])):
            tree[ind * 2 + 1] = updating[ind][0]
            updating[ind * 2 + 1] = updating[ind][::]
        
    updating[ind] = 0
        
        
    if (l == lb and r == rb):
        return tree[ind]
    else:
        m = (lb + rb) // 2
        ans = float('inf')
        
        if (l <= m):
            ans = get(l, min(m, r), ind * 2, lb, m)
                    
        if (r > m):
            ans = min(ans, get(max(l, m + 1), r, ind * 2 + 1, m + 1, rb))
        
        
        return ans



def getvalue(ind):
    if (ind < len(compress)):
        return (values[compress[ind] % n + n * (not(compress[ind] % n))])
    else:
        return 0
    
    
size = 1
while (size < len(ar) * 2):
    size *= 2

tree = [float('inf') for i in range(2 * size)]
updating = [0 for i in range (2 * size)]

for i in range(size, 2 * size):
    if i - size + 1 in counting:
        tree[i] = counting[i - size + 1]
    else:
        tree[i] = getvalue(i - size + 1)

for i in range(size - 1, 0, -1):
    tree[i] = min(tree[i * 2], tree[i * 2 + 1])
    

for time in range(m):
    if questions[time][0] == 1:
        update(d[questions[time][1]], d[questions[time][2]], 1, 1, size, questions[time][-1])
    else:
        stdout.write(str(get(d[questions[time][1]], d[questions[time][2]], 1, 1, size)) + '\n')
        






'''
3 2
1 2 3
5
2 4 4
1 4 4 5
2 4 4
1 1 6 1
2 6 6
'''",['data structures']
3225,"There are n cities in Berland. Each city has its index — an integer number from 1 to n. The capital has index r1. All the roads in Berland are two-way. The road system is such that there is exactly one path from the capital to each city, i.e. the road map looks like a tree. In Berland's chronicles the road map is kept in the following way: for each city i, different from the capital, there is kept number pi — index of the last city on the way from the capital to i.Once the king of Berland Berl XXXIV decided to move the capital from city r1 to city r2. Naturally, after this the old representation of the road map in Berland's chronicles became incorrect. Please, help the king find out a new representation of the road map in the way described above. nan import sys
import os
import string
(n,r1,r2)=[int(x) for x in raw_input().split()]
line=[int(x) for x in raw_input().split()]
fa=[0]*(n+1)
j=0
for i in xrange(1,n+1):
    if (i==r1):
        continue;
    fa[i]=line[j]
    j+=1
ans=fa[:]
p=r2
while p!=r1:
    ans[fa[p]]=p
    p=fa[p]
ans[r2]=-1
for t in [str(x) for x in ans if x>0]:
    print t,","['dfs and similar', 'graphs']"
952,"Codefortia is a small island country located somewhere in the West Pacific. It consists of $$$n$$$ settlements connected by $$$m$$$ bidirectional gravel roads. Curiously enough, the beliefs of the inhabitants require the time needed to pass each road to be equal either to $$$a$$$ or $$$b$$$ seconds. It's guaranteed that one can go between any pair of settlements by following a sequence of roads.Codefortia was recently struck by the financial crisis. Therefore, the king decided to abandon some of the roads so that:  it will be possible to travel between each pair of cities using the remaining roads only,  the sum of times required to pass each remaining road will be minimum possible (in other words, remaining roads must form minimum spanning tree, using the time to pass the road as its weight),  among all the plans minimizing the sum of times above, the time required to travel between the king's residence (in settlement $$$1$$$) and the parliament house (in settlement $$$p$$$) using the remaining roads only will be minimum possible. The king, however, forgot where the parliament house was. For each settlement $$$p = 1, 2, \dots, n$$$, can you tell what is the minimum time required to travel between the king's residence and the parliament house (located in settlement $$$p$$$) after some roads are abandoned? NoteThe minimum possible sum of times required to pass each road in the first example is $$$85$$$ — exactly one of the roads with passing time $$$25$$$ must be abandoned. Note that after one of these roads is abandoned, it's now impossible to travel between settlements $$$1$$$ and $$$3$$$ in time $$$50$$$. import heapq
n,m,a,b=map(int,raw_input().split())
graph={i:[] for i in range(n)}
for i in range(m):
    u,v,w=map(int,raw_input().split())
    graph[u-1].append((v-1,w))
    graph[v-1].append((u-1,w))
components=[-1]*n
comp=-1
for i in range(n):
    if components[i]==-1:
        comp+=1
        components[i]=comp
        prev=[]
        layer=[i]
        while layer!=[]:
            newlayer=[]
            for guy in layer:
                for guy1 in graph[guy]:
                    if guy1[1]==a and components[guy1[0]]==-1:
                        newlayer.append(guy1[0])
                        components[guy1[0]]=comp
            prev=layer[:]
            layer=newlayer[:]
useless=[]
for guy in graph:
    for neigh in graph[guy]:
        if components[guy]==components[neigh[0]] and neigh[1]==b:
            useless.append((guy,neigh))
for guy in useless:
    graph[guy[0]].remove(guy[1])
counts=[0]*(comp+1)
for i in range(n):
    counts[components[i]]+=1
bad=[]
for i in range(comp+1):
    if counts[i]<=3:
        bad.append(i)
        for j in range(n):
            if components[j]==i:
                components[j]=-1
for guy in bad[::-1]:
    for i in range(n):
        if components[i]>guy:
            components[i]-=1
comp-=len(bad)
comp+=1
dists=[[float(""inf"") for i in range(2**comp)] for j in range(n)]
dists[0][0]=0
pq=[]
heapq.heappush(pq,[0,0,0])
remaining=n
visited=[0]*n
while len(pq)>0 and remaining>0:
    dist,vert,mask=heapq.heappop(pq)
    if visited[vert]==0:
        visited[vert]=1
        remaining-=1
    for neigh in graph[vert]:
        if neigh[1]==b:
            if components[vert]==components[neigh[0]] and components[vert]!=-1:
                continue
            if components[neigh[0]]!=-1:
                if mask & (2**components[neigh[0]])>0:
                    continue
            if components[vert]!=-1:
                maskn=mask+2**(components[vert])
            else:
                maskn=mask
        else:
            maskn=mask
        if dist+neigh[1]<dists[neigh[0]][maskn]:
            dists[neigh[0]][maskn]=dist+neigh[1]
            heapq.heappush(pq,[dist+neigh[1],neigh[0],maskn])
optimal=[str(min(dists[i])) for i in range(n)]
print("" "".join(optimal))","['brute force', 'dp', 'graphs', 'greedy']"
2827,"Polycarp has invited $$$n$$$ friends to celebrate the New Year. During the celebration, he decided to take a group photo of all his friends. Each friend can stand or lie on the side.Each friend is characterized by two values $$$h_i$$$ (their height) and $$$w_i$$$ (their width). On the photo the $$$i$$$-th friend will occupy a rectangle $$$h_i \times w_i$$$ (if they are standing) or $$$w_i \times h_i$$$ (if they are lying on the side).The $$$j$$$-th friend can be placed in front of the $$$i$$$-th friend on the photo if his rectangle is lower and narrower than the rectangle of the $$$i$$$-th friend. Formally, at least one of the following conditions must be fulfilled:  $$$h_j &lt; h_i$$$ and $$$w_j &lt; w_i$$$ (both friends are standing or both are lying);  $$$w_j &lt; h_i$$$ and $$$h_j &lt; w_i$$$ (one of the friends is standing and the other is lying). For example, if $$$n = 3$$$, $$$h=[3,5,3]$$$ and $$$w=[4,4,3]$$$, then:  the first friend can be placed in front of the second: $$$w_1 &lt; h_2$$$ and $$$h_1 &lt; w_2$$$ (one of the them is standing and the other one is lying);  the third friend can be placed in front of the second: $$$h_3 &lt; h_2$$$ and $$$w_3 &lt; w_2$$$ (both friends are standing or both are lying). In other cases, the person in the foreground will overlap the person in the background.Help Polycarp for each $$$i$$$ find any $$$j$$$, such that the $$$j$$$-th friend can be located in front of the $$$i$$$-th friend (i.e. at least one of the conditions above is fulfilled).Please note that you do not need to find the arrangement of all people for a group photo. You just need to find for each friend $$$i$$$ any other friend $$$j$$$ who can be located in front of him. Think about it as you need to solve $$$n$$$ separate independent subproblems. NoteThe first test case is described in the statement.In the third test case, the following answers are also correct:   $$$[-1, -1, 1, 2]$$$;  $$$[-1, -1, 1, 1]$$$;  $$$[-1, -1, 2, 1]$$$.  def corrPlace(allPoint):
    n = len(allPoint)
    ans = [-1] * n
    allPoint.sort(reverse=True)
    message = [allPoint[-1]]
    for i in range(n-2, -1, -1):
        if message[-1][0] != allPoint[i][0] and message[-1][1] > allPoint[i][1]:
            message.append(allPoint[i])
    cachePlace = len(message)-1
    for imess in allPoint:
        ai = imess[0]
        bi = imess[1]
        while cachePlace != 0 and message[cachePlace][0] >= ai:
            cachePlace -= 1
        if message[cachePlace][0] < ai and message[cachePlace][1] < bi:
            ans[imess[2]-1] = message[cachePlace][2]
    return ans


t = int(input())
for qwq in range(t):
    n = int(input())
    allPoint = []
    for i in range(n):
        l = list(map(int, input().split()))
        allPoint.append((max(l), min(l), i + 1))
    ans = corrPlace(allPoint)
    for i in ans:
        print(i, end=' ')
    print()","['binary search', 'data structures', 'dp', 'sortings', 'two pointers']"
2439,"Alice and Bob are playing a game on a matrix, consisting of $$$2$$$ rows and $$$m$$$ columns. The cell in the $$$i$$$-th row in the $$$j$$$-th column contains $$$a_{i, j}$$$ coins in it.Initially, both Alice and Bob are standing in a cell $$$(1, 1)$$$. They are going to perform a sequence of moves to reach a cell $$$(2, m)$$$.The possible moves are:   Move right — from some cell $$$(x, y)$$$ to $$$(x, y + 1)$$$;  Move down — from some cell $$$(x, y)$$$ to $$$(x + 1, y)$$$. First, Alice makes all her moves until she reaches $$$(2, m)$$$. She collects the coins in all cells she visit (including the starting cell).When Alice finishes, Bob starts his journey. He also performs the moves to reach $$$(2, m)$$$ and collects the coins in all cells that he visited, but Alice didn't.The score of the game is the total number of coins Bob collects.Alice wants to minimize the score. Bob wants to maximize the score. What will the score of the game be if both players play optimally? NoteThe paths for the testcases are shown on the following pictures. Alice's path is depicted in red and Bob's path is depicted in blue.   for _ in range(int(input())):
    m = int(input())
    f_row = list(map(int, input().split()))
    s_row = list(map(int, input().split()))
    fsumarr = []
    ssumarr = [0]
    prev = 0
    for val in (f_row):
        x = val+prev
        fsumarr.append(x)
        prev = x
    prev = 0
    for val in (s_row):
        x = val+prev
        ssumarr.append(x)
        prev = x
    fsum = sum(f_row)
    ssum = sum(s_row)
    bob = float(""inf"")
    for i in range(m):
        a_f = fsumarr[i]
        a_s = ssum - ssumarr[i]
        x = max(fsum-a_f, ssum-a_s)
        bob = min(bob, x)
    print(bob)","['brute force', 'constructive algorithms', 'dp', 'implementation']"
3982,"For months Maxim has been coming to work on his favorite bicycle. And quite recently he decided that he is ready to take part in a cyclists' competitions.He knows that this year n competitions will take place. During the i-th competition the participant must as quickly as possible complete a ride along a straight line from point si to point fi (si &lt; fi).Measuring time is a complex process related to usage of a special sensor and a time counter. Think of the front wheel of a bicycle as a circle of radius r. Let's neglect the thickness of a tire, the size of the sensor, and all physical effects. The sensor is placed on the rim of the wheel, that is, on some fixed point on a circle of radius r. After that the counter moves just like the chosen point of the circle, i.e. moves forward and rotates around the center of the circle.At the beginning each participant can choose any point bi, such that his bike is fully behind the starting line, that is, bi &lt; si - r. After that, he starts the movement, instantly accelerates to his maximum speed and at time tsi, when the coordinate of the sensor is equal to the coordinate of the start, the time counter starts. The cyclist makes a complete ride, moving with his maximum speed and at the moment the sensor's coordinate is equal to the coordinate of the finish (moment of time tfi), the time counter deactivates and records the final time. Thus, the counter records that the participant made a complete ride in time tfi - tsi.  Maxim is good at math and he suspects that the total result doesn't only depend on his maximum speed v, but also on his choice of the initial point bi. Now Maxim is asking you to calculate for each of n competitions the minimum possible time that can be measured by the time counter. The radius of the wheel of his bike is equal to r. nan from math import cos,pi

def g(t):
	return t+cos(t)

def solve(y):
	assert(y>=1 and y<2*pi+1)
	low = 0.
	high = 2*pi+1
	for k in range(64):
		mid = (low+high)/2
		if g(mid) > y:
			high = mid
		else:
			low = mid
	return low

def bestTime(s,f,r,v):
	m = int((2.+float(f-s)/r)/pi-0.1)
	if (m%2 == 0): m += 1
	res = None
	for i in range(3):
		try:
			t = solve((m*pi-float(f-s)/r)/2)
			cand = (m*pi-2*t)*r/v
			if res==None or cand < res:
					res = cand
		except:
			pass
		m += 2
	return res

n,r,v = map(int,raw_input().split())
for i in range(n):
	s,f = map(int,raw_input().split())
	print bestTime(s,f,r,v)
","['binary search', 'geometry']"
2534,"The only difference between the easy and the hard versions is the maximum value of $$$k$$$.You are given an infinite sequence of form ""112123123412345$$$\dots$$$"" which consist of blocks of all consecutive positive integers written one after another. The first block consists of all numbers from $$$1$$$ to $$$1$$$, the second one — from $$$1$$$ to $$$2$$$, the third one — from $$$1$$$ to $$$3$$$, $$$\dots$$$, the $$$i$$$-th block consists of all numbers from $$$1$$$ to $$$i$$$. So the first $$$56$$$ elements of the sequence are ""11212312341234512345612345671234567812345678912345678910"". Elements of the sequence are numbered from one. For example, the $$$1$$$-st element of the sequence is $$$1$$$, the $$$3$$$-rd element of the sequence is $$$2$$$, the $$$20$$$-th element of the sequence is $$$5$$$, the $$$38$$$-th element is $$$2$$$, the $$$56$$$-th element of the sequence is $$$0$$$.Your task is to answer $$$q$$$ independent queries. In the $$$i$$$-th query you are given one integer $$$k_i$$$. Calculate the digit at the position $$$k_i$$$ of the sequence. NoteAnswers on queries from the first example are described in the problem statement. word = ''
arr = [0]
for i in range(1,22000):
    word = word + str(i)
    arr.append(arr[-1] + len(word))
    
def sol(k):
    d = 0
    for i in range(1,22000):
        if arr[i] > k:
            d = i - 1
            break
    
    k = k - arr[d]
    if k == 0:
        return str(d)[-1]
    else:
        return word[k - 1]
    
for i in range(int(input())):
    print(sol(int(input())))","['binary search', 'brute force', 'math']"
1244,"There are $$$n$$$ boxes with different quantities of candies in each of them. The $$$i$$$-th box has $$$a_i$$$ candies inside.You also have $$$n$$$ friends that you want to give the candies to, so you decided to give each friend a box of candies. But, you don't want any friends to get upset so you decided to eat some (possibly none) candies from each box so that all boxes have the same quantity of candies in them. Note that you may eat a different number of candies from different boxes and you cannot add candies to any of the boxes.What's the minimum total number of candies you have to eat to satisfy the requirements? NoteFor the first test case, you can eat $$$1$$$ candy from the second box, $$$2$$$ candies from the third box, $$$3$$$ candies from the fourth box and $$$4$$$ candies from the fifth box. Now the boxes have $$$[1, 1, 1, 1, 1]$$$ candies in them and you ate $$$0 + 1 + 2 + 3 + 4 = 10$$$ candies in total so the answer is $$$10$$$.For the second test case, the best answer is obtained by making all boxes contain $$$5$$$ candies in them, thus eating $$$995 + 995 + 0 + 995 + 995 + 995 = 4975$$$ candies in total. 

test_cases = int(input())
 
for i in range(test_cases):
    l = int(input())
    arr = list(map(int, input().split()))
    arr.sort()
    print(sum(arr) - (arr[0]*l))","['greedy', 'math', 'sortings']"
1020,"It is nighttime and Joe the Elusive got into the country's main bank's safe. The safe has n cells positioned in a row, each of them contains some amount of diamonds. Let's make the problem more comfortable to work with and mark the cells with positive numbers from 1 to n from the left to the right.Unfortunately, Joe didn't switch the last security system off. On the plus side, he knows the way it works.Every minute the security system calculates the total amount of diamonds for each two adjacent cells (for the cells between whose numbers difference equals 1). As a result of this check we get an n - 1 sums. If at least one of the sums differs from the corresponding sum received during the previous check, then the security system is triggered.Joe can move the diamonds from one cell to another between the security system's checks. He manages to move them no more than m times between two checks. One of the three following operations is regarded as moving a diamond: moving a diamond from any cell to any other one, moving a diamond from any cell to Joe's pocket, moving a diamond from Joe's pocket to any cell. Initially Joe's pocket is empty, and it can carry an unlimited amount of diamonds. It is considered that before all Joe's actions the system performs at least one check.In the morning the bank employees will come, which is why Joe has to leave the bank before that moment. Joe has only k minutes left before morning, and on each of these k minutes he can perform no more than m operations. All that remains in Joe's pocket, is considered his loot.Calculate the largest amount of diamonds Joe can carry with him. Don't forget that the security system shouldn't be triggered (even after Joe leaves the bank) and Joe should leave before morning. NoteIn the second sample Joe can act like this:The diamonds' initial positions are 4 1 3.During the first period of time Joe moves a diamond from the 1-th cell to the 2-th one and a diamond from the 3-th cell to his pocket.By the end of the first period the diamonds' positions are 3 2 2. The check finds no difference and the security system doesn't go off.During the second period Joe moves a diamond from the 3-rd cell to the 2-nd one and puts a diamond from the 1-st cell to his pocket.By the end of the second period the diamonds' positions are 2 3 1. The check finds no difference again and the security system doesn't go off.Now Joe leaves with 2 diamonds in his pocket. n, m, k = map(int, input().split())
a = list(map(int, input().split()))

if n % 2 == 0:
    print('0')
else:
    print(min(m // (n // 2 + 1) * k, min(a[::2])))




# Made By Mostafa_Khaled","['greedy', 'math']"
2644,"Let's call some square matrix with integer values in its cells palindromic if it doesn't change after the order of rows is reversed and it doesn't change after the order of columns is reversed.For example, the following matrices are palindromic:  The following matrices are not palindromic because they change after the order of rows is reversed:  The following matrices are not palindromic because they change after the order of columns is reversed:  You are given $$$n^2$$$ integers. Put them into a matrix of $$$n$$$ rows and $$$n$$$ columns so that each number is used exactly once, each cell contains exactly one number and the resulting matrix is palindromic. If there are multiple answers, print any. If there is no solution, print ""NO"". NoteNote that there exist multiple answers for the first two examples. from sys  import stdin,stdout
from collections  import *
from math import gcd,floor,ceil
st=lambda:list(stdin.readline().strip())
li=lambda:list(map(int,stdin.readline().split()))
mp=lambda:map(int,stdin.readline().split())
inp=lambda:int(stdin.readline())
pr=lambda n: stdout.write(str(n)+""\n"")

mod=1000000007
INF=float('inf')

def solve():
    
    n=inp()
    l=li()
    d=Counter(l)
    ele=-1
    odd=0
    v,o=[],[]
    for i in d:
        if d[i]&1:
            if n%2==0:
                pr('NO')
                return 
            else:
                odd+=1
                ele=i
                if odd>1:
                    pr('NO')
                    return 
        if d[i]%2 == 0:
            v.append(i)
            if d[i]%4==2:
                o.append(i)
    if (d[ele]-1)%2==0:
        v.append(ele)
        if (d[ele]-1)%4==2:
            o.append(ele)
    i=0
    #print(d)
    v.sort(key = lambda x:d[x],reverse=True)
    ans=[[0 for i in range(n)] for j in range(n)]
    if n&1:
        ans[n//2][n//2]=ele
        d[ele]-=1
        j,k=n//2,0
        i=0
        while k<n//2 and i<len(o):
            ans[j][k]=o[i]
            ans[j][n-1-k]=o[i]
            k+=1
            d[o[i]]-=2
            i+=1
        j,k=0,n//2
        while j<n//2 and i<len(o):
            ans[j][k]=o[i]
            ans[n-1-j][k]=o[i]
            d[o[i]]-=2
            i+=1
            j+=1
        i=0
        j,k=n//2,0
        while i<len(v) :
            while k<n//2 and d[v[i]] >0:
                if ans[j][k]==0:
                    ans[j][k]=v[i]
                    ans[j][n-1-k]=v[i]
                    d[v[i]]-=2
                k+=1
                
            i+=1
        i=0
        j,k=0,n//2
        while i<len(v):
            while j<n//2 and d[v[i]]>0:
                if ans[j][k]==0:
                    ans[j][k]=v[i]
                    ans[n-1-j][k]=v[i]
                    d[v[i]]-=2
                j+=1
                
            i+=1 
    #for i in ans:
    #    print(*i)
    #rint(d)
    x=[[d[i],i] for i in d if d[i]]
    #print(x)
    p,q=0,0
    i=0
    while i<len(x):
        a,b=x[i]
        if a%4:
            pr('NO')
            return
        if p<n//2:
            while a>0:
                ans[p][q]=b
                ans[p][n-1-q]=b
                ans[n-1-p][q]=b
                ans[n-1-p][n-1-q]=b
                a-=4
                if a>0 and a%4==0:
                    p+=1
                    if p==n//2:
                        p=0
                        q+=1
                    
            p+=1
            if p==n//2:
                p=0
                q+=1

        i+=1
    pr('YES')
    for i in ans:
        print(*i)


solve()

'''
5
3 3 4 4 5 5 5 6 6 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2
'''","['constructive algorithms', 'implementation']"
3515,"God's Blessing on This PermutationForces!A Random PebbleYou are given a permutation $$$p_1,p_2,\ldots,p_n$$$ of length $$$n$$$ and a positive integer $$$k \le n$$$. In one operation you can choose two indices $$$i$$$ and $$$j$$$ ($$$1 \le i &lt; j \le n$$$) and swap $$$p_i$$$ with $$$p_j$$$.Find the minimum number of operations needed to make the sum $$$p_1 + p_2 + \ldots + p_k$$$ as small as possible.A permutation is an array consisting of $$$n$$$ distinct integers from $$$1$$$ to $$$n$$$ in arbitrary order. For example, $$$[2,3,1,5,4]$$$ is a permutation, but $$$[1,2,2]$$$ is not a permutation ($$$2$$$ appears twice in the array) and $$$[1,3,4]$$$ is also not a permutation ($$$n=3$$$ but there is $$$4$$$ in the array). NoteIn the first test case, the value of $$$p_1 + p_2 + \ldots + p_k$$$ is initially equal to $$$2$$$, but the smallest possible value is $$$1$$$. You can achieve it by swapping $$$p_1$$$ with $$$p_3$$$, resulting in the permutation $$$[1, 3, 2]$$$.In the second test case, the sum is already as small as possible, so the answer is $$$0$$$. t = int(input())
for elem in range(t):
    n, k = map(int, input().split())
    l = [int(el) for el in input().split()]
    c = 0
    for i in range(k):
        if (l[i] > k):
            c += 1
    print(c)","['greedy', 'implementation']"
1149,"This is the easy version of this problem. In this version, we do not have queries. Note that we have multiple test cases in this version. You can make hacks only if both versions of the problem are solved.An array $$$b$$$ of length $$$m$$$ is good if for all $$$i$$$ the $$$i$$$-th element is greater than or equal to $$$i$$$. In other words, $$$b$$$ is good if and only if $$$b_i \geq i$$$ for all $$$i$$$ ($$$1 \leq i \leq m$$$).You are given an array $$$a$$$ consisting of $$$n$$$ positive integers. Find the number of pairs of indices $$$(l, r)$$$, where $$$1 \le l \le r \le n$$$, such that the array $$$[a_l, a_{l+1}, \ldots, a_r]$$$ is good. NoteIn the first test case, all subarrays of $$$a$$$ are good, so all pairs are suitable.In the second test case, the pairs $$$(1, 1)$$$, $$$(2, 2)$$$, and $$$(3, 3)$$$ are suitable. For example, when $$$(l, r) = (1, 2)$$$, the array $$$b=[1,1]$$$ is not good because $$$b_2 &lt; 2$$$. import sys
input= sys.stdin.readline
for j in range(int(input())):
    n = int(input())
    arr = list(map(int, input().split(' ')))

    ans, val = 0, 1
    for i in range(n):
        if arr[i] >= val:
            ans += val
            val += 1
        else:
            ans += arr[i]
            val = arr[i] + 1

    print(ans)","['binary search', 'data structures', 'other', 'two pointers']"
1822,"A bracket sequence is a string containing only characters ""("" and "")"". A regular bracket sequence (or, shortly, an RBS) is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters ""1"" and ""+"" between the original characters of the sequence. For example:  bracket sequences ""()()"" and ""(())"" are regular (the resulting expressions are: ""(1)+(1)"" and ""((1+1)+1)"");  bracket sequences "")("", ""("" and "")"" are not. There was an RBS. Some brackets have been replaced with question marks. Is it true that there is a unique way to replace question marks with brackets, so that the resulting sequence is an RBS? NoteIn the first testcase, the only possible original RBS is ""(())"".In the second testcase, there are multiple ways to recover an RBS.In the third and the fourth testcases, the only possible original RBS is ""()"".In the fifth testcase, the original RBS can be either ""((()()))"" or ""(())()()"". #!/usr/bin/env python
from __future__ import division, print_function

import os
import sys
from io import BytesIO, IOBase

if sys.version_info[0] < 3:
    from __builtin__ import xrange as range
    from future_builtins import ascii, filter, hex, map, oct, zip

def solve(s):
    from collections import Counter
    c = Counter(s)
    a = (c['?'] + c[')'] - c['(']) // 2
    b = c['?'] - a

    q = 0
    l = r = None
    for i, c in enumerate(s):
        if c == '?':
            if q < a:
                l = i
            elif r is None:
                r = i
            q += 1
    if l is None or r is None:
        return 'YES'

    check = 0
    for i, c in enumerate(s):
        if c == '(':
            check += 1
        elif c == ')':
            check -= 1
        elif i < l:
            check += 1
        elif i == l:
            check -= 1
        elif i == r:
            check += 1
        else:
            check -= 1
        if check < 0:
            return 'YES'
    if check != 0:
        return 'YES'
    return 'NO'

def main():
    t = int(input())
    for _ in range(t):
        s = input()
        print(solve(s))


# region fastio

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


def print(*args, **kwargs):
    """"""Prints the values to a stream, or to sys.stdout by default.""""""
    sep, file = kwargs.pop(""sep"", "" ""), kwargs.pop(""file"", sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop(""end"", ""\n""))
    if kwargs.pop(""flush"", False):
        file.flush()


if sys.version_info[0] < 3:
    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

input = lambda: sys.stdin.readline().rstrip(""\r\n"")
inputarr = lambda: [int(x) for x in input().split()]

# endregion

if __name__ == ""__main__"":
    main()
","['constructive algorithms', 'greedy', 'implementation', 'strings']"
794,"Petya is preparing for his birthday. He decided that there would be $$$n$$$ different dishes on the dinner table, numbered from $$$1$$$ to $$$n$$$. Since Petya doesn't like to cook, he wants to order these dishes in restaurants.Unfortunately, all dishes are prepared in different restaurants and therefore Petya needs to pick up his orders from $$$n$$$ different places. To speed up this process, he wants to order courier delivery at some restaurants. Thus, for each dish, there are two options for Petya how he can get it:  the dish will be delivered by a courier from the restaurant $$$i$$$, in this case the courier will arrive in $$$a_i$$$ minutes,  Petya goes to the restaurant $$$i$$$ on his own and picks up the dish, he will spend $$$b_i$$$ minutes on this. Each restaurant has its own couriers and they start delivering the order at the moment Petya leaves the house. In other words, all couriers work in parallel. Petya must visit all restaurants in which he has not chosen delivery, he does this consistently.For example, if Petya wants to order $$$n = 4$$$ dishes and $$$a = [3, 7, 4, 5]$$$, and $$$b = [2, 1, 2, 4]$$$, then he can order delivery from the first and the fourth restaurant, and go to the second and third on your own. Then the courier of the first restaurant will bring the order in $$$3$$$ minutes, the courier of the fourth restaurant will bring the order in $$$5$$$ minutes, and Petya will pick up the remaining dishes in $$$1 + 2 = 3$$$ minutes. Thus, in $$$5$$$ minutes all the dishes will be at Petya's house.Find the minimum time after which all the dishes can be at Petya's home. nan import sys
def get_ints(): return map(int, sys.stdin.readline().strip().split())
 
for _ in range(int(input())):
   
   
 
	n=get_ints()
	a=list(get_ints())
	b=list(get_ints())
	if n==1:
		print(min(a[-1],b[-1]))
		continue
	suffixsum=[]
	new=[]
	for i in range(len(a)):
		new.append((a[i],b[i]))
	new.sort()
	suffix=[]
	sum1=0
	for i in range(len(new)-1,-1,-1):
		sum1+=new[i][-1]
		suffix.append(sum1)
	suffix.reverse()
 
	def binary(low,high):
		mid=(low+high)//2
		if low>high:
			return mid
		
		try:
			if new[mid][0]<suffix[mid+1]:
				return binary(mid+1,high)
			else:
				if low==mid:
					return mid
				return binary(low,mid)
		except:
			return mid
	x=binary(0,len(new)-1)
	
	try:
		ans=min(new[x][0],suffix[x])
	except:
		ans=new[x][0]
	print(ans)","['binary search', 'greedy', 'sortings']"
3887,"You are given a string $$$s$$$ of even length $$$n$$$. String $$$s$$$ is binary, in other words, consists only of 0's and 1's.String $$$s$$$ has exactly $$$\frac{n}{2}$$$ zeroes and $$$\frac{n}{2}$$$ ones ($$$n$$$ is even).In one operation you can reverse any substring of $$$s$$$. A substring of a string is a contiguous subsequence of that string.What is the minimum number of operations you need to make string $$$s$$$ alternating? A string is alternating if $$$s_i \neq s_{i + 1}$$$ for all $$$i$$$. There are two types of alternating strings in general: 01010101... or 10101010... NoteIn the first test case, string 10 is already alternating.In the second test case, we can, for example, reverse the last two elements of $$$s$$$ and get: 0110 $$$\rightarrow$$$ 0101.In the third test case, we can, for example, make the following two operations:   11101000 $$$\rightarrow$$$ 10101100;  10101100 $$$\rightarrow$$$ 10101010.  for _ in range(int(input())):
    n = int(input())
    s = input()
    zo, oz = s.count(""01""),  s.count(""10"")
    t = n - 2 * max(zo, oz)
    print(t // 2)
","['constructive algorithms', 'greedy']"
2964,"Vasya and Petya take part in a Codeforces round. The round lasts for two hours and contains five problems.For this round the dynamic problem scoring is used. If you were lucky not to participate in any Codeforces round with dynamic problem scoring, here is what it means. The maximum point value of the problem depends on the ratio of the number of participants who solved the problem to the total number of round participants. Everyone who made at least one submission is considered to be participating in the round.Pay attention to the range bounds. For example, if 40 people are taking part in the round, and 10 of them solve a particular problem, then the solvers fraction is equal to 1 / 4, and the problem's maximum point value is equal to 1500.If the problem's maximum point value is equal to x, then for each whole minute passed from the beginning of the contest to the moment of the participant's correct submission, the participant loses x / 250 points. For example, if the problem's maximum point value is 2000, and the participant submits a correct solution to it 40 minutes into the round, this participant will be awarded with 2000·(1 - 40 / 250) = 1680 points for this problem.There are n participants in the round, including Vasya and Petya. For each participant and each problem, the number of minutes which passed between the beginning of the contest and the submission of this participant to this problem is known. It's also possible that this participant made no submissions to this problem.With two seconds until the end of the round, all participants' submissions have passed pretests, and not a single hack attempt has been made. Vasya believes that no more submissions or hack attempts will be made in the remaining two seconds, and every submission will pass the system testing.Unfortunately, Vasya is a cheater. He has registered 109 + 7 new accounts for the round. Now Vasya can submit any of his solutions from these new accounts in order to change the maximum point values of the problems. Vasya can also submit any wrong solutions to any problems. Note that Vasya can not submit correct solutions to the problems he hasn't solved.Vasya seeks to score strictly more points than Petya in the current round. Vasya has already prepared the scripts which allow to obfuscate his solutions and submit them into the system from any of the new accounts in just fractions of seconds. However, Vasya doesn't want to make his cheating too obvious, so he wants to achieve his goal while making submissions from the smallest possible number of new accounts.Find the smallest number of new accounts Vasya needs in order to beat Petya (provided that Vasya's assumptions are correct), or report that Vasya can't achieve his goal. NoteIn the first example, Vasya's optimal strategy is to submit the solutions to the last three problems from two new accounts. In this case the first two problems will have the maximum point value of 1000, while the last three problems will have the maximum point value of 500. Vasya's score will be equal to 980 + 940 + 420 + 360 + 270 = 2970 points, while Petya will score just 800 + 820 + 420 + 440 + 470 = 2950 points.In the second example, Vasya has to make a single unsuccessful submission to any problem from two new accounts, and a single successful submission to the first problem from the third new account. In this case, the maximum point values of the problems will be equal to 500, 1500, 1000, 1500, 3000. Vasya will score 2370 points, while Petya will score just 2294 points.In the third example, Vasya can achieve his goal by submitting the solutions to the first four problems from 27 new accounts. The maximum point values of the problems will be equal to 500, 500, 500, 500, 2000. Thanks to the high cost of the fifth problem, Vasya will manage to beat Petya who solved the first four problems very quickly, but couldn't solve the fifth one. #!/usr/bin/python3
# Copyright (C) 2017 Sayutin Dmitry.
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation; version 3
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; If not, see <http://www.gnu.org/licenses/>.

def get_price(a, b):
    # a / b
    if 2 * a > b:
        return 500
    if 4 * a > b:
        return 1000
    if 8 * a > b:
        return 1500
    if 16 * a > b:
        return 2000
    if 32 * a > b:
        return 2500
    return 3000

def main():
    n = int(input())
    we = list(map(int, input().split()))
    fr = list(map(int, input().split()))

    ratio = [0, 0, 0, 0, 0]
    for i in range(5):
        if we[i] != -1:
            ratio[i] += 1
        else:
            we[i] = 250
        
        if fr[i] != -1:
            ratio[i] += 1
        else:
            fr[i] = 250

    for part in range(n - 2):
        lst = list(map(int, input().split()))
        for i in range(5):
            if lst[i] != -1:
                ratio[i] += 1

                
    for mi in range(0, 4500):
        s1 = 0
        s2 = 0

        for i in range(5):
            if we[i] < fr[i]:
               pr = get_price(ratio[i] + 0, n + mi)
               
               s1 += pr - pr * we[i] // 250
               s2 += pr - pr * fr[i] // 250
            elif we[i] > fr[i] and we[i] != 250: # submit as much OK as we can
                pr = get_price(ratio[i] + mi, n + mi)

                s1 += pr - pr * we[i] // 250
                s2 += pr - pr * fr[i] // 250
            elif we[i] > fr[i] and we[i] == 250:
                pr = get_price(ratio[i] + 0, n + mi)

                s1 += pr - pr * we[i] // 250
                s2 += pr - pr * fr[i] // 250
                
        if s1 > s2:
            print(mi)
            return

    lo = 4450
    hi = 10 ** 9 + 8 # OK

    while hi - lo > 1:
        mi = lo + (hi - lo) // 2
        
        s1 = 0
        s2 = 0

        for i in range(5):
            if we[i] < fr[i]:
               pr = get_price(ratio[i] + 0, n + mi)
               
               s1 += pr - pr * we[i] // 250
               s2 += pr - pr * fr[i] // 250
            elif we[i] > fr[i] and we[i] != 250: # submit as much OK as we can
                pr = get_price(ratio[i] + mi, n + mi)

                s1 += pr - pr * we[i] // 250
                s2 += pr - pr * fr[i] // 250
            elif we[i] > fr[i] and we[i] == 250:
                pr = get_price(ratio[i] + 0, n + mi)

                s1 += pr - pr * we[i] // 250
                s2 += pr - pr * fr[i] // 250
                
        if s1 > s2:
            hi = mi
        else:
            lo = mi
    
    print(-1 if hi == 10 ** 9 + 8 else hi)
main()
","['brute force', 'greedy']"
1669,"Little Susie loves strings. Today she calculates distances between them. As Susie is a small girl after all, her strings contain only digits zero and one. She uses the definition of Hamming distance:We will define the distance between two strings s and t of the same length consisting of digits zero and one as the number of positions i, such that si isn't equal to ti. As besides everything else Susie loves symmetry, she wants to find for two strings s and t of length n such string p of length n, that the distance from p to s was equal to the distance from p to t.It's time for Susie to go to bed, help her find such string p or state that it is impossible. NoteIn the first sample different answers are possible, namely — 0010, 0011, 0110, 0111, 1000, 1001, 1100, 1101. a = list(input())
b = list(input())
nums = []
ras = 0
for i in range(len(a)):
    if not a[i] == b[i]:
        ras += 1
        nums.append(i)
if ras%2:
    print(""impossible"")
else:
    for i in range(ras//2):
        if a[nums[i]] == '1':
            a[nums[i]] = '0'
        else:
            a[nums[i]] = '1'
    print("""".join(a))
",['greedy']
4165,"Vasya has recently learned at school what a number's divisor is and decided to determine a string's divisor. Here is what he came up with.String a is the divisor of string b if and only if there exists a positive integer x such that if we write out string a consecutively x times, we get string b. For example, string ""abab"" has two divisors — ""ab"" and ""abab"".Now Vasya wants to write a program that calculates the number of common divisors of two strings. Please help him. NoteIn first sample the common divisors are strings ""abcd"" and ""abcdabcd"".In the second sample the common divisor is a single string ""a"". String ""aa"" isn't included in the answer as it isn't a divisor of string ""aaa"". 
from math import sqrt
from collections import defaultdict
from bisect import bisect_right
def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,
                      p - 2, p)) % p

from sys import stdin
def ret(s):
    n = len(s)
    j = 1
    i = 0
    start = -1
    flag = 0
    while j<n:

        if s[i] == s[j]:
# /,/            print(j)

            i+=1
            if flag == 0:
                flag = 1
                start = j
            j+=1

        else:
            start = -1
            i = 0
            if flag == 0:
              j+=1
            flag = 0



    if start == -1 or n%len(s[:start])!=0:
        return s
    else:
        return s[:start]

def cal(n):
    seti = set()
    for i in range(1,int(sqrt(n))+1):
        if n%i == 0:
            seti.add(n//i)
            seti.add(i)


    return seti


def solve():

    s1 = input()
    s2 = input()
    n1,n2 = len(s1),len(s2)
    z1,z2 = ret(s1),ret(s2)
    # print(z1,z2)
    if z1 == z2:
        k1,k2 = cal(n1//len(z1)),cal(n2//(len(z2)))
        print(len(k1.intersection(k2)))


    else:
        print(0)





# t = int(stdin.readline())
# for _ in range(t):
solve()





","['brute force', 'hashing', 'implementation', 'math', 'strings']"
2807,"A student's life is fraught with complications. Some Berland University students know this only too well. Having studied for two years, they contracted strong antipathy towards the chairperson of some department. Indeed, the person in question wasn't the kindest of ladies to begin with: prone to reforming groups, banning automatic passes and other mean deeds. At last the students decided that she just can't get away with all this anymore...The students pulled some strings on the higher levels and learned that the next University directors' meeting is going to discuss n orders about the chairperson and accept exactly p of them. There are two values assigned to each order: ai is the number of the chairperson's hairs that turn grey if she obeys the order and bi — the displeasement of the directors if the order isn't obeyed. The students may make the directors pass any p orders chosen by them. The students know that the chairperson will obey exactly k out of these p orders. She will pick the orders to obey in the way that minimizes first, the directors' displeasement and second, the number of hairs on her head that turn grey.The students want to choose p orders in the way that maximizes the number of hairs on the chairperson's head that turn grey. If there are multiple ways to accept the orders, then the students are keen on maximizing the directors' displeasement with the chairperson's actions. Help them. NoteIn the first sample one of optimal solutions is to pass orders 1, 2, 3. In this case the chairperson obeys orders number 1 and 2. She gets 10 new grey hairs in the head and the directors' displeasement will equal 3. Note that the same result can be achieved with order 4 instead of order 3.In the second sample, the chairperson can obey all the orders, so the best strategy for the students is to pick the orders with the maximum sum of ai values. The chairperson gets 58 new gray hairs and the directors' displeasement will equal 0. n, p, k = map(int, raw_input().split(' '));
v = [map(int, raw_input().split(' ')) + [i] for i in range(n)];
v1 = sorted(v, key = lambda x : (x[1], -x[0]));
v2 = sorted([v1[i] + [i] for i in range(p - k, n)], key = lambda x : (-x[0], -x[3]));
min_id = n + 1;
for x in v2[:k]:
    print x[2] + 1, ;
    min_id = min(min_id, x[3]);
for x in v1[min_id - (p - k) : min_id]:
    print x[2] + 1, ;

","['data structures', 'greedy', 'sortings']"
2351,"Motorist Kojiro spent 10 years saving up for his favorite car brand, Furrari. Finally Kojiro's dream came true! Kojiro now wants to get to his girlfriend Johanna to show off his car to her.Kojiro wants to get to his girlfriend, so he will go to her along a coordinate line. For simplicity, we can assume that Kojiro is at the point f of a coordinate line, and Johanna is at point e. Some points of the coordinate line have gas stations. Every gas station fills with only one type of fuel: Regular-92, Premium-95 or Super-98. Thus, each gas station is characterized by a pair of integers ti and xi — the number of the gas type and its position.One liter of fuel is enough to drive for exactly 1 km (this value does not depend on the type of fuel). Fuels of three types differ only in quality, according to the research, that affects the lifetime of the vehicle motor. A Furrari tank holds exactly s liters of fuel (regardless of the type of fuel). At the moment of departure from point f Kojiro's tank is completely filled with fuel Super-98. At each gas station Kojiro can fill the tank with any amount of fuel, but of course, at no point in time, the amount of fuel in the tank can be more than s liters. Note that the tank can simultaneously have different types of fuel. The car can moves both left and right.To extend the lifetime of the engine Kojiro seeks primarily to minimize the amount of fuel of type Regular-92. If there are several strategies to go from f to e, using the minimum amount of fuel of type Regular-92, it is necessary to travel so as to minimize the amount of used fuel of type Premium-95.Write a program that can for the m possible positions of the start fi minimize firstly, the amount of used fuel of type Regular-92 and secondly, the amount of used fuel of type Premium-95. nan #!/usr/bin/env python
from sys import stdin as cin

def read_input():
    e, s, n, m = map(int, next(cin).split())
    txs = [map(int, next(cin).split()) for _ in range(n)]
    fs = map(int, next(cin).split())

    txs = [(t, e-x) for t,x in txs if e>x]
    fs = [e-f for f in fs]

    return s, txs, fs


def solve_positive(capacity, gas_stations, starts):
    segments = [ [0, 0], [3, capacity] ]
    for gs in sorted(gas_stations, key=lambda e: e[1]):
        if gs[1] > segments[-1][1]: # this and all further gas stations are unreachable
            break
        while gs[0] >= segments[-1][0] and gs[1] <= segments[-2][1]: # last gas station useless
            segments.pop()
        if gs[0] > segments[-1][0]: # new gas station is better than previous one
            segments[-1][1] = gs[1]
        segments.append([gs[0], gs[1]+capacity])

    cnt = [0] * 4
    answer = {}
    seg_it = iter(segments)
    seg = next(seg_it)
    seg_start = 0
    try:
        for start in sorted(starts):
            while start > seg[1]:
                cnt[seg[0]] += seg[1] - seg_start
                seg_start = seg[1]
                seg = next(seg_it)
            answer[start] = cnt[:]
            answer[start][seg[0]] += start - seg_start
    except StopIteration: pass

    return answer


def main():
    capacity, gas_stations, starts = read_input()

    answer = solve_positive(capacity, gas_stations, starts)

    return [answer.get(start, [-1]*4) for start in starts]


print '\n'.join(map('{0[1]} {0[2]}'.format, main()))
","['dp', 'greedy']"
2780,"  William is not only interested in trading but also in betting on sports matches. $$$n$$$ teams participate in each match. Each team is characterized by strength $$$a_i$$$. Each two teams $$$i &lt; j$$$ play with each other exactly once. Team $$$i$$$ wins with probability $$$\frac{a_i}{a_i + a_j}$$$ and team $$$j$$$ wins with probability $$$\frac{a_j}{a_i + a_j}$$$.The team is called a winner if it directly or indirectly defeated all other teams. Team $$$a$$$ defeated (directly or indirectly) team $$$b$$$ if there is a sequence of teams $$$c_1$$$, $$$c_2$$$, ... $$$c_k$$$ such that $$$c_1 = a$$$, $$$c_k = b$$$ and team $$$c_i$$$ defeated team $$$c_{i + 1}$$$ for all $$$i$$$ from $$$1$$$ to $$$k - 1$$$. Note that it is possible that team $$$a$$$ defeated team $$$b$$$ and in the same time team $$$b$$$ defeated team $$$a$$$.William wants you to find the expected value of the number of winners. NoteTo better understand in which situation several winners are possible let's examine the second test:One possible result of the tournament is as follows ($$$a \rightarrow b$$$ means that $$$a$$$ defeated $$$b$$$):  $$$1 \rightarrow 2$$$  $$$2 \rightarrow 3$$$  $$$3 \rightarrow 1$$$  $$$1 \rightarrow 4$$$  $$$1 \rightarrow 5$$$  $$$2 \rightarrow 4$$$  $$$2 \rightarrow 5$$$  $$$3 \rightarrow 4$$$  $$$3 \rightarrow 5$$$  $$$4 \rightarrow 5$$$ Or more clearly in the picture:  In this case every team from the set $$$\{ 1, 2, 3 \}$$$ directly or indirectly defeated everyone. I.e.:  $$$1$$$st defeated everyone because they can get to everyone else in the following way $$$1 \rightarrow 2$$$, $$$1 \rightarrow 2 \rightarrow 3$$$, $$$1 \rightarrow 4$$$, $$$1 \rightarrow 5$$$.  $$$2$$$nd defeated everyone because they can get to everyone else in the following way $$$2 \rightarrow 3$$$, $$$2 \rightarrow 3 \rightarrow 1$$$, $$$2 \rightarrow 4$$$, $$$2 \rightarrow 5$$$.  $$$3$$$rd defeated everyone because they can get to everyone else in the following way $$$3 \rightarrow 1$$$, $$$3 \rightarrow 1 \rightarrow 2$$$, $$$3 \rightarrow 4$$$, $$$3 \rightarrow 5$$$. Therefore the total number of winners is $$$3$$$. import sys,random,bisect
from collections import deque,defaultdict
from heapq import heapify,heappop,heappush
from itertools import cycle, permutations
from math import log,gcd

input = lambda :sys.stdin.readline().rstrip()
mi = lambda :map(int,input().split())
li = lambda :list(mi())

mod = 10**9 + 7
N = 2*10**6
inverse = [1]*(N+1)

for i in range( 2, N + 1 ):
    inverse[i]=( ( -inverse[mod % i] * (mod//i) ) % mod )
inverse[0]=0

N = int(input())
A = li()

win_prop = [[1 for S in range(1<<N)] for i in range(N)]
for i in range(N):
    for n in range(N):
        t = 1<<n
        for S in range(1<<n,1<<(n+1)):
            win_prop[i][S] = win_prop[i][S-t] * (A[i] * inverse[A[i]+A[n]] % mod) % mod

dp = [1 for i in range(1<<N)]
for S in range(1,1<<N):
    tmp = (S-1)&S
    while tmp:
        T,U = tmp,S-tmp

        val = dp[T]
        for i in range(N):
            if T>>i & 1:
                val *= win_prop[i][U]
                val %= mod
        dp[S] -= val
        dp[S] %= mod
        tmp = (tmp-1)&S

res = 0
for S in range(1,1<<N):
    n = bin(S).count(""1"")
    prop = dp[S]
    for i in range(N):
        for j in range(N):
            if S>>i & 1 and (not S>>j & 1):
                prop *= A[i] * inverse[A[i]+A[j]]
                prop %= mod
    res += n * prop
    res %= mod

print(res)


","['bitmasks', 'combinatorics', 'dp', 'graphs', 'math', 'probabilities']"
1513,"Igor had a sequence $$$d_1, d_2, \dots, d_n$$$ of integers. When Igor entered the classroom there was an integer $$$x$$$ written on the blackboard.Igor generated sequence $$$p$$$ using the following algorithm:   initially, $$$p = [x]$$$;  for each $$$1 \leq i \leq n$$$ he did the following operation $$$|d_i|$$$ times:   if $$$d_i \geq 0$$$, then he looked at the last element of $$$p$$$ (let it be $$$y$$$) and appended $$$y + 1$$$ to the end of $$$p$$$;  if $$$d_i &lt; 0$$$, then he looked at the last element of $$$p$$$ (let it be $$$y$$$) and appended $$$y - 1$$$ to the end of $$$p$$$.  For example, if $$$x = 3$$$, and $$$d = [1, -1, 2]$$$, $$$p$$$ will be equal $$$[3, 4, 3, 4, 5]$$$.Igor decided to calculate the length of the longest increasing subsequence of $$$p$$$ and the number of them.A sequence $$$a$$$ is a subsequence of a sequence $$$b$$$ if $$$a$$$ can be obtained from $$$b$$$ by deletion of several (possibly, zero or all) elements.A sequence $$$a$$$ is an increasing sequence if each element of $$$a$$$ (except the first one) is strictly greater than the previous element.For $$$p = [3, 4, 3, 4, 5]$$$, the length of longest increasing subsequence is $$$3$$$ and there are $$$3$$$ of them: $$$[\underline{3}, \underline{4}, 3, 4, \underline{5}]$$$, $$$[\underline{3}, 4, 3, \underline{4}, \underline{5}]$$$, $$$[3, 4, \underline{3}, \underline{4}, \underline{5}]$$$. NoteThe first test case was explained in the statement.In the second test case $$$p = [100, 101, 102, 103, 104, 105, 104, 103, 102, 103, 104, 105, 106, 107, 108]$$$.In the third test case $$$p = [1, 2, \ldots, 2000000000]$$$. import sys, io, os

if os.environ['USERNAME']=='kissz':
    inp=open('in55.txt','r').readline
    def debug(*args):
        print(*args,file=sys.stderr)
else:
    inp=io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
    def debug(*args):
        pass

def mexp(size,power):
    A=[]
    for i in range(size):
        A.append([int(j<=(i//2)*2) for j in range(size)])
    powers={1: A}
    p=1
    while p*2<=power:
        powers[p*2]=mmmult(powers[p],powers[p])
        p*=2
    A=powers[p]
    power-=p
    while power>0:
        p=p//2
        if p<=power:
            A=mmmult(A,powers[p])
            power-=p
    return A                

def mvmult(A,V):
    res=[]
    for i in range(len(A)):
        res.append(sum(a*v for a,v in zip(A[i],V)) % 998244353 )
    return res

def mmmult(A,B):
    res=[]
    for i in range(len(A)):
        res.append([sum(a*B[j][k] for j,a in enumerate(A[i])) for k in range(len(B[0]))])
    return res

def get_rep(corners):
    corners[0]-=1
    corners[-1]+=1
    bps=sorted(list(set(corners)))
    m=len(bps)
    X=[1]
    active=[1]
    for i in range(1,m):
        x,y=bps[i-1],bps[i]
        d=y-x
        A=mexp(len(active),d)
        X=mvmult(A,X)
        #debug(active,X)
        #debug(A)     
        if i<m-1:
            for j,c in enumerate(corners):
                if c==y:
                    if j%2: # top: j and j+1 in active
                        idx=active.index(j)
                        X[idx+2]+=X[idx]
                        active.pop(idx)
                        active.pop(idx)
                        X.pop(idx)
                        X.pop(idx)
                    else: # bottom
                        active+=[j,j+1]
                        active.sort()
                        idx=active.index(j)
                        X=X[:idx]+[0,X[idx-1]]+X[idx:]
        else:
            return X[0]
        
n=int(inp())
inp()
d,*D=map(int,inp().split())
if d==0 and all(dd==0 for dd in D):
    print(1,1)
else:
    while d==0: d,*D=D
    up=(d>=0)
    corners=[0,d]
    for d in D:
        x=corners[-1]+d
        if up==(d>=0):
            corners[-1]=x
        if up!=(d>=0):
            up=(d>=0)
            corners.append(x)
    debug(corners)
    
    cands=[(-1,0,0)]
    low=(0,0)
    maxdiff=(0,0,0)
    for i,corner in enumerate(corners):
        if corner<low[0]: low=(corner,i)
        if corner-low[0]>=cands[0][0]:
            if corner-low[0]==cands[0][0] and low[1]>cands[0][1]:
                cands+=[(corner-low[0],low[1],i)]
            else:
                cands=[(corner-low[0],low[1],i)]
    
    L=cands[0][0]+1
    if L>1:
        X=0
        debug(cands)
        for _, starti, endi in cands:
            #debug(corners[starti:endi+1])
            X+=get_rep(corners[starti:endi+1])
    else:
        X=1-corners[-1]
    print(L,X % 998244353)


    



","['dp', 'math', 'other']"
4333,"The semester is already ending, so Danil made an effort and decided to visit a lesson on harmony analysis to know how does the professor look like, at least. Danil was very bored on this lesson until the teacher gave the group a simple task: find 4 vectors in 4-dimensional space, such that every coordinate of every vector is 1 or  - 1 and any two vectors are orthogonal. Just as a reminder, two vectors in n-dimensional space are considered to be orthogonal if and only if their scalar product is equal to zero, that is: .Danil quickly managed to come up with the solution for this problem and the teacher noticed that the problem can be solved in a more general case for 2k vectors in 2k-dimensinoal space. When Danil came home, he quickly came up with the solution for this problem. Can you cope with it? NoteConsider all scalar products in example:  Vectors 1 and 2: ( + 1)·( + 1) + ( + 1)·( - 1) + ( - 1)·( + 1) + ( - 1)·( - 1) = 0  Vectors 1 and 3: ( + 1)·( + 1) + ( + 1)·( + 1) + ( - 1)·( + 1) + ( - 1)·( + 1) = 0  Vectors 1 and 4: ( + 1)·( + 1) + ( + 1)·( - 1) + ( - 1)·( - 1) + ( - 1)·( + 1) = 0  Vectors 2 and 3: ( + 1)·( + 1) + ( - 1)·( + 1) + ( + 1)·( + 1) + ( - 1)·( + 1) = 0  Vectors 2 and 4: ( + 1)·( + 1) + ( - 1)·( - 1) + ( + 1)·( - 1) + ( - 1)·( + 1) = 0  Vectors 3 and 4: ( + 1)·( + 1) + ( + 1)·( - 1) + ( + 1)·( - 1) + ( + 1)·( + 1) = 0  inv=lambda t:''.join('*'if u=='+'else'+'for u in t)
n=int(input())
r=['+']
for _ in range(n):
	r=[r[i] * 2 for i in range(len(r))] + [r[i]+inv(r[i]) for i in range(len(r))]
print(*r,sep='\n')",['constructive algorithms']
4697,"Ivan wants to write a letter to his friend. The letter is a string s consisting of lowercase Latin letters.Unfortunately, when Ivan started writing the letter, he realised that it is very long and writing the whole letter may take extremely long time. So he wants to write the compressed version of string s instead of the string itself.The compressed version of string s is a sequence of strings c1, s1, c2, s2, ..., ck, sk, where ci is the decimal representation of number ai (without any leading zeroes) and si is some string consisting of lowercase Latin letters. If Ivan writes string s1 exactly a1 times, then string s2 exactly a2 times, and so on, the result will be string s.The length of a compressed version is |c1| + |s1| + |c2| + |s2|... |ck| + |sk|. Among all compressed versions Ivan wants to choose a version such that its length is minimum possible. Help Ivan to determine minimum possible length. NoteIn the first example Ivan will choose this compressed version: c1 is 10, s1 is a.In the second example Ivan will choose this compressed version: c1 is 1, s1 is abcab.In the third example Ivan will choose this compressed version: c1 is 2, s1 is c, c2 is 1, s2 is z, c3 is 4, s3 is ab. def prefix(s):
    p = [0]
    for i in range(1, len(s)):
        j = p[-1]
        while j > 0 and s[j] != s[i]:
            j = p[j - 1]
        if s[i] == s[j]:
            j += 1
        p.append(j)
    return p


s = input()
n = len(s)
ans = [0] * (n + 1)
i = n - 1

while i >= 0:
    p = prefix(s[i:])
    ans[i] = 2 + ans[i + 1]
    for j in range(len(p)):
        z = 1
        if (j + 1) % (j + 1 - p[j]) == 0:
            z = (j + 1) // (j + 1 - p[j])
        res = len(str(z)) + (j + 1) // z + ans[i + j + 1]
        ans[i] = min(ans[i], res)
    i -= 1

print(ans[0])
","['dp', 'hashing', 'other', 'strings']"
290,"Lindsey Buckingham told Stevie Nicks ""Go your own way"". Nicks is now sad and wants to go away as quickly as possible, but she lives in a 2D hexagonal world.Consider a hexagonal tiling of the plane as on the picture below.  Nicks wishes to go from the cell marked $$$(0, 0)$$$ to a certain cell given by the coordinates. She may go from a hexagon to any of its six neighbors you want, but there is a cost associated with each of them. The costs depend only on the direction in which you travel. Going from $$$(0, 0)$$$ to $$$(1, 1)$$$ will take the exact same cost as going from $$$(-2, -1)$$$ to $$$(-1, 0)$$$. The costs are given in the input in the order $$$c_1$$$, $$$c_2$$$, $$$c_3$$$, $$$c_4$$$, $$$c_5$$$, $$$c_6$$$ as in the picture below.  Print the smallest cost of a path from the origin which has coordinates $$$(0, 0)$$$ to the given cell. NoteThe picture below shows the solution for the first sample. The cost $$$18$$$ is reached by taking $$$c_3$$$ 3 times and $$$c_2$$$ once, amounting to $$$5+5+5+3=18$$$.   import sys
input = sys.stdin.readline

def main():
    x, y = map(int, input().split())
    clst = list(map(int, input().split()))
    clst[0] = min(clst[0], clst[5] + clst[1])
    clst[1] = min(clst[1], clst[0] + clst[2])
    clst[2] = min(clst[2], clst[1] + clst[3])
    clst[3] = min(clst[3], clst[2] + clst[4])
    clst[4] = min(clst[4], clst[3] + clst[5])
    clst[5] = min(clst[5], clst[4] + clst[0])
    directions = [(1, 1), (0, 1), (-1, 0), (-1, -1), (0, -1), (1, 0)]
    ans = 10 ** 20
    for i in range(6):
        dx1, dy1 = directions[i]
        dx2, dy2 = directions[(i + 1) % 6]
        a = (x * dy2 - y * dx2) // (dx1 * dy2 - dy1 * dx2)
        b = (x * dy1 - y * dx1) // (dx2 * dy1 - dy2 * dx1)
        if a < 0 or b < 0:
            continue
        ans = min(ans, clst[i] * a + clst[(i + 1) % 6] * b)
    print(ans)
    
for _ in range(int(input())):
    main()
","['brute force', 'constructive algorithms', 'greedy', 'implementation', 'math', 'shortest paths']"
765,"You are given two integers $$$a$$$ and $$$b$$$. You can perform a sequence of operations: during the first operation you choose one of these numbers and increase it by $$$1$$$; during the second operation you choose one of these numbers and increase it by $$$2$$$, and so on. You choose the number of these operations yourself.For example, if $$$a = 1$$$ and $$$b = 3$$$, you can perform the following sequence of three operations:   add $$$1$$$ to $$$a$$$, then $$$a = 2$$$ and $$$b = 3$$$;  add $$$2$$$ to $$$b$$$, then $$$a = 2$$$ and $$$b = 5$$$;  add $$$3$$$ to $$$a$$$, then $$$a = 5$$$ and $$$b = 5$$$. Calculate the minimum number of operations required to make $$$a$$$ and $$$b$$$ equal.  NoteFirst test case considered in the statement.In the second test case integers $$$a$$$ and $$$b$$$ are already equal, so you don't need to perform any operations.In the third test case you have to apply the first, the second, the third and the fourth operation to $$$b$$$ ($$$b$$$ turns into $$$20 + 1 + 2 + 3 + 4 = 30$$$). import sys
import collections
from collections import Counter
import itertools
import math
import timeit

#input = sys.stdin.readline

#########################
# imgur.com/Pkt7iIf.png #
#########################

def sieve(n):
    if n < 2: return list()
    prime = [True for _ in range(n + 1)]
    p = 3
    while p * p <= n:
        if prime[p]:
            for i in range(p * 2, n + 1, p):
                prime[i] = False
        p += 2
    r = [2]
    for p in range(3, n + 1, 2):
        if prime[p]:
            r.append(p)
    return r

def divs(n, start=1):
    divisors = []
    for i in range(start, int(math.sqrt(n) + 1)):
        if n % i == 0:
            if n / i == i:
                divisors.append(i)
            else:
                divisors.extend([i, n // i])
    return divisors

def divn(n, primes):
    divs_number = 1
    for i in primes:
        if n == 1:
            return divs_number
        t = 1
        while n % i == 0:
            t += 1
            n //= i
        divs_number *= t

def flin(d, x, default = -1):
    left = right = -1
    for i in range(len(d)):
        if d[i] == x:
            if left == -1: left = i
            right = i
    if left == -1:
        return (default, default)
    else:
        return (left, right)

def ceil(n, k): return int(n // k + (n % k != 0))
def ii(): return int(input())
def mi(): return map(int, input().split())
def li(): return list(map(int, input().split()))
def lcm(a, b): return abs(a * b) // math.gcd(a, b)
def prr(a, sep=' '): print(sep.join(map(str, a)))
def dd(): return collections.defaultdict(int)
def ddl(): return collections.defaultdict(list)


t = ii()
for _ in range(t):
    a, b = mi()
    m = abs(a - b)
    x = ceil(math.sqrt(8*m + 1) - 1, 2)
    r = x * (x + 1) // 2
    if r == m or (r - m) % 2 == 0:
        print(x)
    elif (r - m) % 2 and x % 2 == 0:
        print(x + 1)
    else:
        print(x + 2)
","['greedy', 'math']"
252,"Mahmoud and Ehab are in the fourth stage now.Dr. Evil has a hidden binary string of length n. He guarantees that there is at least one '0' symbol and at least one '1' symbol in it. Now he wants Mahmoud and Ehab to find a position of any '0' symbol and any '1' symbol. In order to do this, Mahmoud and Ehab can ask Dr. Evil up to 15 questions. They tell Dr. Evil some binary string of length n, and Dr. Evil tells the Hamming distance between these two strings. Hamming distance between 2 binary strings of the same length is the number of positions in which they have different symbols. You can find the definition of Hamming distance in the notes section below.Help Mahmoud and Ehab find these two positions.You will get Wrong Answer verdict if   Your queries doesn't satisfy interaction protocol described below.  You ask strictly more than 15 questions and your program terminated after exceeding queries limit. Please note, that you can do up to 15 ask queries and one answer query.  Your final answer is not correct.  You will get Idleness Limit Exceeded if you don't print anything or if you forget to flush the output, including for the final answer (more info about flushing output below).If you exceed the maximum number of queries, You should terminate with 0, In this case you'll get Wrong Answer, If you don't terminate you may receive any verdict because you'll be reading from a closed stream . NoteHamming distance definition: https://en.wikipedia.org/wiki/Hamming_distanceIn the first test case the hidden binary string is 101, The first query is 000, so the Hamming distance is 2. In the second query the hidden string is still 101 and query is 001, so the Hamming distance is 1.After some queries you find that symbol at position 2 is '0' and symbol at position 1 is '1', so you print ""! 2 1"". from sys import *
n = int(input())
print(""?"",""0""*n)
stdout.flush() 
cnt = int(input())
low = 1
high = n
one = zero = -1
while low <= high:
  mid = (low+high)//2
  s = ""? ""
  for i in range(1,n+1):
    if(low <= i <= mid): s += ""1""
    else: s += ""0""
  print(s)
  stdout.flush() 
  x = int(input())
  tot = mid-low+1
  if cnt-x == tot: #all ones
    # print(""all ones"",low,mid,high)
    one = low
    low = mid+1
  elif x-cnt == tot: #all zeros
    # print(""all zeros"",low,mid,high)
    zero = low
    low = mid+1
  else:
    high = mid
print(""!"",zero,one)    
stdout.flush() 
    
    ","['binary search', 'divide and conquer', 'interactive']"
3182,"You are given two strings $$$x$$$ and $$$y$$$, both consist only of lowercase Latin letters. Let $$$|s|$$$ be the length of string $$$s$$$.Let's call a sequence $$$a$$$ a merging sequence if it consists of exactly $$$|x|$$$ zeros and exactly $$$|y|$$$ ones in some order.A merge $$$z$$$ is produced from a sequence $$$a$$$ by the following rules:   if $$$a_i=0$$$, then remove a letter from the beginning of $$$x$$$ and append it to the end of $$$z$$$;  if $$$a_i=1$$$, then remove a letter from the beginning of $$$y$$$ and append it to the end of $$$z$$$. Two merging sequences $$$a$$$ and $$$b$$$ are different if there is some position $$$i$$$ such that $$$a_i \neq b_i$$$.Let's call a string $$$z$$$ chaotic if for all $$$i$$$ from $$$2$$$ to $$$|z|$$$ $$$z_{i-1} \neq z_i$$$.Let $$$s[l,r]$$$ for some $$$1 \le l \le r \le |s|$$$ be a substring of consecutive letters of $$$s$$$, starting from position $$$l$$$ and ending at position $$$r$$$ inclusive.Let $$$f(l_1, r_1, l_2, r_2)$$$ be the number of different merging sequences of $$$x[l_1,r_1]$$$ and $$$y[l_2,r_2]$$$ that produce chaotic merges. Note that only non-empty substrings of $$$x$$$ and $$$y$$$ are considered.Calculate $$$\sum \limits_{1 \le l_1 \le r_1 \le |x| \\ 1 \le l_2 \le r_2 \le |y|} f(l_1, r_1, l_2, r_2)$$$. Output the answer modulo $$$998\,244\,353$$$. NoteIn the first example there are:   $$$6$$$ pairs of substrings ""a"" and ""b"", each with valid merging sequences ""01"" and ""10"";  $$$3$$$ pairs of substrings ""a"" and ""bb"", each with a valid merging sequence ""101"";  $$$4$$$ pairs of substrings ""aa"" and ""b"", each with a valid merging sequence ""010"";  $$$2$$$ pairs of substrings ""aa"" and ""bb"", each with valid merging sequences ""0101"" and ""1010"";  $$$2$$$ pairs of substrings ""aaa"" and ""b"", each with no valid merging sequences;  $$$1$$$ pair of substrings ""aaa"" and ""bb"" with a valid merging sequence ""01010""; Thus, the answer is $$$6 \cdot 2 + 3 \cdot 1 + 4 \cdot 1 + 2 \cdot 2 + 2 \cdot 0 + 1 \cdot 1 = 24$$$. 

s=[0]+list(input())
t=[0]+list(input())
n=len(s)-1
m=len(t)-1
mod=998244353
for i in range(1,n+1):
    s[i]=ord(s[i])-96
for i in range(1,m+1):
    t[i]=ord(t[i])-96
def _(i,j,fs,ft,al):
    if min(i,j)<0:return -1
    return (((i*(m+1)+j)*2+fs)*2+ft)*2+al
dp=[0]*(n+3)*(m+3)*2*2*2

for i in range(n+1):
    for j in range(m+1):
        for bit in range(4):
            fs=(bit>>0)&1
            ft=(bit>>1)&1
            if fs==ft==0:continue
            if fs==1 and ft==0:
                if s[i]!=s[i-1]:
                    dp[_(i,j,1,0,0)]+=dp[_(i-1,j,1,0,0)]
                    dp[_(i,j,1,0,0)]%=mod
                if i>=1:dp[_(i,j,1,0,0)]+=1
            elif fs==0 and ft==1:
                if t[j]!=t[j-1]:
                    dp[_(i,j,0,1,1)]+=dp[_(i,j-1,0,1,1)]
                    dp[_(i,j,0,1,1)]%=mod
                if j>=1:dp[_(i,j,0,1,1)]+=1
            else:
                if s[i]!=s[i-1]:
                    dp[_(i,j,1,1,0)]+=dp[_(i-1,j,1,1,0)]
                if s[i]!=t[j]:
                    dp[_(i,j,1,1,0)]+=dp[_(i-1,j,1,1,1)]+dp[_(i-1,j,0,1,1)]
                dp[_(i,j,1,1,0)]%=mod
                if t[j]!=t[j-1]:
                    dp[_(i,j,1,1,1)]+=dp[_(i,j-1,1,1,1)]
                if t[j]!=s[i]:
                    dp[_(i,j,1,1,1)]+=dp[_(i,j-1,1,1,0)]+dp[_(i,j-1,1,0,0)]
                dp[_(i,j,1,1,1)]%=mod

ans=0
for i in range(1,n+1):
    for j in range(1,m+1):
        ans+=dp[_(i,j,1,1,1)]+dp[_(i,j,1,1,0)]
        ans%=mod
print(ans)



","['combinatorics', 'dp', 'math', 'strings']"
3528,"This is an interactive problem.Little Dormi was faced with an awkward problem at the carnival: he has to guess the edges of an unweighted tree of $$$n$$$ nodes! The nodes of the tree are numbered from $$$1$$$ to $$$n$$$.The game master only allows him to ask one type of question: Little Dormi picks a node $$$r$$$ ($$$1 \le r \le n$$$), and the game master will reply with an array $$$d_1, d_2, \ldots, d_n$$$, where $$$d_i$$$ is the length of the shortest path from node $$$r$$$ to $$$i$$$, for all $$$1 \le i \le n$$$.Additionally, to make the game unfair challenge Little Dormi the game master will allow at most $$$\lceil\frac{n}{2}\rceil$$$ questions, where $$$\lceil x \rceil$$$ denotes the smallest integer greater than or equal to $$$x$$$.Faced with the stomach-churning possibility of not being able to guess the tree, Little Dormi needs your help to devise a winning strategy!Note that the game master creates the tree before the game starts, and does not change it during the game. NoteHere is the tree from the first example.  Notice that the edges can be output in any order.Additionally, here are the answers for querying every single node in example $$$1$$$: $$$1$$$: $$$[0,1,2,2]$$$  $$$2$$$: $$$[1,0,1,1]$$$  $$$3$$$: $$$[2,1,0,2]$$$  $$$4$$$: $$$[2,1,2,0]$$$Below is the tree from the second example interaction.  Lastly, here are the answers for querying every single node in example $$$2$$$: $$$1$$$: $$$[0,4,1,3,2]$$$  $$$2$$$: $$$[4,0,3,1,2]$$$  $$$3$$$: $$$[1,3,0,2,1]$$$  $$$4$$$: $$$[3,1,2,0,1]$$$  $$$5$$$: $$$[2,2,1,1,0]$$$ 

import sys
from sys import stdout

input = sys.stdin.readline
inf = float('inf')


def getInt():
    return int(input())


def getStr():
    return input().strip()


def getList(split=True):
    s = getStr()
    if split:
        s = s.split()
    return map(int, s)


# t = getInt()
t = 1


def p(*args, **kwargs):
    print(*args, **kwargs)
    stdout.flush()


def solve():
    n = getInt()
    e = [[0] * (n+1) for _ in range(n+1)]

    def ask(i):
        p(""?"", i)
        return list(getList())
    level = ask(1)

    def assign(i, a):
        for j, x in enumerate(a, 1):
            if x == 1:
                e[i][j] = e[j][i] = 1

    assign(1, level)
    l = max(level)
    color = [0, 0]
    for j in level:
        color[j & 1] += 1

    # color tree black and white, only query the color with the small nodes
    # which is <= n /2
    # we can color the graph by block and white nodes, odd level is black, even level is white
    # we notice that min(black, white) <= n / 2
    # hence we just need to query level of the min color
    who = color[1] < color[0]
    w = [[] for _ in range(l+1)]
    for i, j in enumerate(level, 1):
        w[j].append(i)
    for i in range(1, l+1):
        if i & 1 == who:
            for j in w[i]:
                assign(j, ask(j))

    p(""!"")
    for i in range(1, n+1):
        for j in range(1, i):
            if e[i][j]:
                p(i, j)


for _ in range(t):
    solve()
","['constructive algorithms', 'interactive', 'trees']"
721,"DZY loves chemistry, and he enjoys mixing chemicals.DZY has n chemicals, and m pairs of them will react. He wants to pour these chemicals into a test tube, and he needs to pour them in one by one, in any order. Let's consider the danger of a test tube. Danger of an empty test tube is 1. And every time when DZY pours a chemical, if there are already one or more chemicals in the test tube that can react with it, the danger of the test tube will be multiplied by 2. Otherwise the danger remains as it is.Find the maximum possible danger after pouring all the chemicals one by one in optimal order. NoteIn the first sample, there's only one way to pour, and the danger won't increase.In the second sample, no matter we pour the 1st chemical first, or pour the 2nd chemical first, the answer is always 2.In the third sample, there are four ways to achieve the maximum possible danger: 2-1-3, 2-3-1, 1-2-3 and 3-2-1 (that is the numbers of the chemicals in order of pouring). def dfs (a, vis, mr):
    mr[0]+=1
    vis[a]=1
    for g in range (0,len(r[a])):
        if (vis[r[a][g]]==1):
            continue
        dfs(r[a][g], vis, mr)
        
x=input("""").split(' ')
nodes=int(x[0])
paths=int(x[1])
r=[]
for g in range (3000):
    r.append([])
vis=[0]*3000
for g in range (paths):
    m=input("""").split(' ')
    rrr=int(m[0])
    rr=int(m[1])
    r[rrr].append(rr)
    r[rr].append(rrr)
ans=1
for g in range (1,nodes+1):
    mr=[0]
    if (vis[g]==1):
        continue
    l=dfs(g, vis,mr)
    ans*=pow(2,mr[0]-1)
print(ans)
    ","['dfs and similar', 'dsu', 'greedy']"
90,"While Mike was walking in the subway, all the stuff in his back-bag dropped on the ground. There were several fax messages among them. He concatenated these strings in some order and now he has string s.  He is not sure if this is his own back-bag or someone else's. He remembered that there were exactly k messages in his own bag, each was a palindrome string and all those strings had the same length.He asked you to help him and tell him if he has worn his own back-bag. Check if the given string s is a concatenation of k palindromes of the same length. NotePalindrome is a string reading the same forward and backward.In the second sample, the faxes in his back-bag can be ""saddas"" and ""tavvat"". st = str(raw_input())
n = int(raw_input())
size = len(st)/n
def is_palindrome(seq):
    return seq == seq[::-1]
if n <= len(st):
 cnt = 0
 for i in range(0,len(st),size):
    if  is_palindrome(st[i:size+i].lower()):
        cnt += 1
    else:
        cnt -=1

 if cnt == n:
    print ""YES""
 else:
    print ""NO""
else:
    print ""NO""","['brute force', 'implementation', 'strings']"
1499,"You have $$$r$$$ red and $$$b$$$ blue beans. You'd like to distribute them among several (maybe, one) packets in such a way that each packet:   has at least one red bean (or the number of red beans $$$r_i \ge 1$$$);  has at least one blue bean (or the number of blue beans $$$b_i \ge 1$$$);  the number of red and blue beans should differ in no more than $$$d$$$ (or $$$|r_i - b_i| \le d$$$) Can you distribute all beans? NoteIn the first test case, you can form one packet with $$$1$$$ red and $$$1$$$ blue bean. The absolute difference $$$|1 - 1| = 0 \le d$$$.In the second test case, you can form two packets: $$$1$$$ red and $$$4$$$ blue beans in the first packet and $$$1$$$ red and $$$3$$$ blue beans in the second one.In the third test case, since $$$b = 1$$$, you can form only one packet with $$$6$$$ red and $$$1$$$ blue beans. The absolute difference $$$|6 - 1| = 5 &gt; d$$$.In the fourth test case, since $$$d = 0$$$ so each packet should contain the same number of red and blue beans, but $$$r \neq b$$$. for i in range(int(input())):
    arr = [int(_) for _ in input().split()]

    if abs(arr[0] / min(arr[:2]) - arr[1] / min(arr[:2])) <= arr[2]:
        print('YES')
    else:
        print('NO')

# val = abs(arr[0] / 2 - arr[1] / 2) <= arr[2]
",['math']
2767,"Carol is currently curling.She has n disks each with radius r on the 2D plane. Initially she has all these disks above the line y = 10100.She then will slide the disks towards the line y = 0 one by one in order from 1 to n. When she slides the i-th disk, she will place its center at the point (xi, 10100). She will then push it so the disk’s y coordinate continuously decreases, and x coordinate stays constant. The disk stops once it touches the line y = 0 or it touches any previous disk. Note that once a disk stops moving, it will not move again, even if hit by another disk. Compute the y-coordinates of centers of all the disks after all disks have been pushed. NoteThe final positions of the disks will look as follows:  In particular, note the position of the last disk.  import sys
from collections import *
from string import *
from itertools import *
from math import *

def dist(x1,y1,x2,y2):
    return sqrt((y1-y2)**2 + (x1-x2)**2)

def f(x1,y1,x2):
    return sqrt(4*r**2-(x2-x1)**2)+y1

centers = defaultdict(list)   
n,r = map(int,raw_input().strip().split())
r = float(r)
xi = map(float,raw_input().strip().split())
for i in xrange(n):
    centers[i] = [xi[i],10**100]
miny = r
centers[0] = [xi[0],r]
for i in xrange(1,n):
    maxy = -sys.maxint
    for j in range(i):
        if centers[j][0]>=(centers[i][0]-2*r) and centers[j][0]<=(centers[i][0]+2*r):
            if maxy<f(centers[j][0],centers[j][1],xi[i]):
                maxy = max(maxy,f(centers[j][0],centers[j][1],xi[i]))
    if maxy==(-sys.maxint):
        centers[i] = [xi[i],r]
    else:
        centers[i] = [xi[i],maxy]
answer = []
for i in range(n):
    answer.append(centers[i][1])
print "" "".join(map(str,answer))","['brute force', 'geometry', 'implementation', 'math']"
4599,"You are given a positive integer $$$x$$$. Check whether the number $$$x$$$ is representable as the sum of the cubes of two positive integers.Formally, you need to check if there are two integers $$$a$$$ and $$$b$$$ ($$$1 \le a, b$$$) such that $$$a^3+b^3=x$$$.For example, if $$$x = 35$$$, then the numbers $$$a=2$$$ and $$$b=3$$$ are suitable ($$$2^3+3^3=8+27=35$$$). If $$$x=4$$$, then no pair of numbers $$$a$$$ and $$$b$$$ is suitable. NoteThe number $$$1$$$ is not representable as the sum of two cubes.The number $$$2$$$ is represented as $$$1^3+1^3$$$.The number $$$4$$$ is not representable as the sum of two cubes.The number $$$34$$$ is not representable as the sum of two cubes.The number $$$35$$$ is represented as $$$2^3+3^3$$$.The number $$$16$$$ is represented as $$$2^3+2^3$$$.The number $$$703657519796$$$ is represented as $$$5779^3+7993^3$$$. #!/usr/bin/env python
# -*- coding: utf-8 -*-

""""""Codeforces Round #702 (Div. 3)

Problem C. Sum of Cubes

:author:         Kitchen Tong
:mail:    kctong529@gmail.com

Please feel free to contact me if you have any question
regarding the implementation below.
""""""

__version__ = '3.1'
__date__ = '2021-03-13'


import sys


def solve(x, cubes) -> bool:
    for c in cubes:
        if x - c in cubes:
            return True
    return False
 
 
def main(argv=None):
    cubes = {pow(i, 3) for i in range(1, 10001)}
    t = int(input())
    for _ in range(t):
        x = int(input())
        ans = solve(x, cubes)
        print('YES' if ans == True else 'NO')
    return 0


if __name__ == ""__main__"":
    STATUS = main()
    sys.exit(STATUS)
","['binary search', 'brute force', 'math']"
3084,"A Pythagorean triple is a triple of integer numbers $$$(a, b, c)$$$ such that it is possible to form a right triangle with the lengths of the first cathetus, the second cathetus and the hypotenuse equal to $$$a$$$, $$$b$$$ and $$$c$$$, respectively. An example of the Pythagorean triple is $$$(3, 4, 5)$$$.Vasya studies the properties of right triangles, and he uses a formula that determines if some triple of integers is Pythagorean. Unfortunately, he has forgotten the exact formula; he remembers only that the formula was some equation with squares. So, he came up with the following formula: $$$c = a^2 - b$$$.Obviously, this is not the right formula to check if a triple of numbers is Pythagorean. But, to Vasya's surprise, it actually worked on the triple $$$(3, 4, 5)$$$: $$$5 = 3^2 - 4$$$, so, according to Vasya's formula, it is a Pythagorean triple.When Vasya found the right formula (and understood that his formula is wrong), he wondered: how many are there triples of integers $$$(a, b, c)$$$ with $$$1 \le a \le b \le c \le n$$$ such that they are Pythagorean both according to his formula and the real definition? He asked you to count these triples. NoteThe only Pythagorean triple satisfying $$$c = a^2 - b$$$ with $$$1 \le a \le b \le c \le 9$$$ is $$$(3, 4, 5)$$$; that's why the answer for $$$n = 3$$$ is $$$0$$$, and the answer for $$$n = 6$$$ (and for $$$n = 9$$$) is $$$1$$$. from cmath import sqrt
from sys import stdin, stdout
import math

I = stdin.readline
O = stdout.write

# n = int(I())
# arr = list(map(int, I().split()))

def solve():
    n = int(I())
    
    maxi = int(math.sqrt(2*n - 1))
    ans = (maxi + 1) // 2
    ans -= 1

    print(ans)
    	

for tc in range(int(input())):
    solve()","['binary search', 'brute force', 'math', 'number theory']"
26,"Vasya has recently developed a new algorithm to optimize the reception of customer flow and he considered the following problem.Let the queue to the cashier contain n people, at that each of them is characterized by a positive integer ai — that is the time needed to work with this customer. What is special about this very cashier is that it can serve two customers simultaneously. However, if two customers need ai and aj of time to be served, the time needed to work with both of them customers is equal to max(ai, aj). Please note that working with customers is an uninterruptable process, and therefore, if two people simultaneously come to the cashier, it means that they begin to be served simultaneously, and will both finish simultaneously (it is possible that one of them will have to wait).Vasya used in his algorithm an ingenious heuristic — as long as the queue has more than one person waiting, then some two people of the first three standing in front of the queue are sent simultaneously. If the queue has only one customer number i, then he goes to the cashier, and is served within ai of time. Note that the total number of phases of serving a customer will always be equal to ⌈n / 2⌉.Vasya thinks that this method will help to cope with the queues we all hate. That's why he asked you to work out a program that will determine the minimum time during which the whole queue will be served using this algorithm. nan inf = 999999999

n = input()
v = map(int, raw_input().split())
dp = []
path = []

def qoo(a, b):
    if a >= n and b >= n:
        return 0
    if b >= n:
        return v[a]
    if dp[a][b] == inf:
        dp[a][b] = qoo(b + 1, b + 2) + max(v[a], v[b])
        if b + 1 < n:
            t = qoo(b, b + 2) + max(v[a], v[b + 1])
            if t < dp[a][b]:
                dp[a][b] = t
                path[a][b] = 1
            t = qoo(a, b + 2) + max(v[b], v[b + 1])
            if t < dp[a][b]:
                dp[a][b] = t
                path[a][b] = 2

    return dp[a][b]

def path_dump(a, b):
    if a >= n and b >= n:
        pass
    elif b >= n:
        print a + 1
    else:
        if path[a][b] == 0:
            print a + 1, b + 1
            path_dump(b + 1, b + 2)
        elif path[a][b] == 1:
            print a + 1, b + 2
            path_dump(b, b + 2)
        else:
            print b + 1, b + 2
            path_dump(a, b + 2)

if n == 1:
    print max(v)
    print 1
else:
    dp = [[inf] * n for _ in xrange(n)]
    path = [[0] * n for _ in xrange(n)]
    print qoo(0, 1)
    path_dump(0, 1)",['dp']
3894,"Note that the only difference between the easy and hard version is the constraint on the number of queries. You can make hacks only if all versions of the problem are solved.This is an interactive problem.You are given a tree consisting of $$$n$$$ nodes numbered with integers from $$$1$$$ to $$$n$$$. Ayush and Ashish chose two secret distinct nodes in the tree. You need to find out both the nodes. You can make the following query:   Provide a list of nodes and you will receive a node from that list whose sum of distances to both the hidden nodes is minimal (if there are multiple such nodes in the list, you will receive any one of them). You will also get the sum of distances of that node to the hidden nodes. Recall that a tree is a connected graph without cycles. The distance between two nodes is defined as the number of edges in the simple path between them.More formally, let's define two hidden nodes as $$$s$$$ and $$$f$$$. In one query you can provide the set of nodes $$$\{a_1, a_2, \ldots, a_c\}$$$ of the tree. As a result, you will get two numbers $$$a_i$$$ and $$$dist(a_i, s) + dist(a_i, f)$$$. The node $$$a_i$$$ is any node from the provided set, for which the number $$$dist(a_i, s) + dist(a_i, f)$$$ is minimal.You can ask no more than $$$14$$$ queries. NoteThe tree from the first test is shown below, and the hidden nodes are $$$1$$$ and $$$3$$$. from collections import deque
def NC_Dij(lis,start):

    ret = [float(""inf"")] * len(lis)
    ret[start] = 0
    
    q = deque([start])
    plis = [i for i in range(len(lis))]

    while len(q) > 0:
        now = q.popleft()

        for nex in lis[now]:

            if ret[nex] > ret[now] + 1:
                ret[nex] = ret[now] + 1
                plis[nex] = now
                q.append(nex)

    return ret,plis

tt = int(input())

for loop in range(tt):

    n = int(input())
    lis = [ [] for i in range(n)]

    for i in range(n-1):

        v,u = map(int,input().split())
        v -= 1
        u -= 1

        lis[v].append(u)
        lis[u].append(v)

    print (""?"",n,*[i+1 for i in range(n)] , flush=True)

    x1,d1 = map(int,input().split())
    x1 -= 1

    dlis,plis = NC_Dij(lis,x1)

    r = max(dlis)+1
    l = 0

    dic = {}
    dic[0] = x1

    while r-l != 1:

        m = (l+r)//2
        #print (l,r,m)

        nodes = []
        for i in range(n):
            if dlis[i] == m:
                nodes.append(i+1)
        
        print (""?"",len(nodes), *nodes , flush=True)
        nx,nd = map(int,input().split())
        nx -= 1

        dic[m] = nx
        if nd == d1:
            l = m 
        else:
            r = m

    ans1 = dic[l]
    dlis2,plis2 = NC_Dij(lis,ans1)
    nodes = []
    for i in range(n):
        if dlis2[i] == d1:
            nodes.append(i+1)
    print (""?"",len(nodes), *nodes , flush=True)
    ans2,tmp = map(int,input().split())

    print (""!"",ans1+1,ans2 , flush=True)

    ret = input()
    ","['binary search', 'dfs and similar', 'graphs', 'interactive', 'shortest paths', 'trees']"
1210,"One Big Software Company has n employees numbered from 1 to n. The director is assigned number 1. Every employee of the company except the director has exactly one immediate superior. The director, of course, doesn't have a superior.We will call person a a subordinates of another person b, if either b is an immediate supervisor of a, or the immediate supervisor of a is a subordinate to person b. In particular, subordinates of the head are all other employees of the company.To solve achieve an Important Goal we need to form a workgroup. Every person has some efficiency, expressed by a positive integer ai, where i is the person's number. The efficiency of the workgroup is defined as the total efficiency of all the people included in it.The employees of the big software company are obsessed with modern ways of work process organization. Today pair programming is at the peak of popularity, so the workgroup should be formed with the following condition. Each person entering the workgroup should be able to sort all of his subordinates who are also in the workgroup into pairs. In other words, for each of the members of the workgroup the number of his subordinates within the workgroup should be even.Your task is to determine the maximum possible efficiency of the workgroup formed at observing the given condition. Any person including the director of company can enter the workgroup. NoteIn the sample test the most effective way is to make a workgroup from employees number 1, 2, 4, 5, 6. n = int(input())
t = [list(map(int, input().split())) for q in range(n)]
n += 1
u = [-1e7] * n
v = [0] * n
for i, (j, a) in list(enumerate(t, 1))[::-1]:
    u[i] = max(u[i], v[i] + a)
    v[j], u[j] = max(v[j] + v[i], u[j] + u[i]), max(v[j] + u[i], u[j] + v[i])
print(u[1])","['dfs and similar', 'dp', 'graphs', 'strings', 'trees']"
3467,"The programming competition season has already started and it's time to train for ICPC. Sereja coaches his teams for a number of year and he knows that to get ready for the training session it's not enough to prepare only problems and editorial. As the training sessions lasts for several hours, teams become hungry. Thus, Sereja orders a number of pizzas so they can eat right after the end of the competition.Teams plan to train for n times during n consecutive days. During the training session Sereja orders exactly one pizza for each team that is present this day. He already knows that there will be ai teams on the i-th day.There are two types of discounts in Sereja's favourite pizzeria. The first discount works if one buys two pizzas at one day, while the second is a coupon that allows to buy one pizza during two consecutive days (two pizzas in total).As Sereja orders really a lot of pizza at this place, he is the golden client and can use the unlimited number of discounts and coupons of any type at any days.Sereja wants to order exactly ai pizzas on the i-th day while using only discounts and coupons. Note, that he will never buy more pizzas than he need for this particular day. Help him determine, whether he can buy the proper amount of pizzas each day if he is allowed to use only coupons and discounts. Note, that it's also prohibited to have any active coupons after the end of the day n. NoteIn the first sample, Sereja can use one coupon to buy one pizza on the first and the second days, one coupon to buy pizza on the second and the third days and one discount to buy pizzas on the fourth days. This is the only way to order pizzas for this sample.In the second sample, Sereja can't use neither the coupon nor the discount without ordering an extra pizza. Note, that it's possible that there will be no teams attending the training sessions on some days. _ = input()
a = list(map(int, input().split()))
def doIt():
	for i, c in enumerate(a):
		if c % 2 == 1:
			if len(a) > i+1:
				if a[i+1] > 0:
					a[i+1] -= 1
				else:
					return ""NO""
			else:
				return ""NO""
	return ""YES""
print(doIt())","['constructive algorithms', 'greedy']"
1345,"You are given some Tetris field consisting of $$$n$$$ columns. The initial height of the $$$i$$$-th column of the field is $$$a_i$$$ blocks. On top of these columns you can place only figures of size $$$2 \times 1$$$ (i.e. the height of this figure is $$$2$$$ blocks and the width of this figure is $$$1$$$ block). Note that you cannot rotate these figures.Your task is to say if you can clear the whole field by placing such figures.More formally, the problem can be described like this:The following process occurs while at least one $$$a_i$$$ is greater than $$$0$$$:  You place one figure $$$2 \times 1$$$ (choose some $$$i$$$ from $$$1$$$ to $$$n$$$ and replace $$$a_i$$$ with $$$a_i + 2$$$);  then, while all $$$a_i$$$ are greater than zero, replace each $$$a_i$$$ with $$$a_i - 1$$$. And your task is to determine if it is possible to clear the whole field (i.e. finish the described process), choosing the places for new figures properly.You have to answer $$$t$$$ independent test cases. NoteThe first test case of the example field is shown below:Gray lines are bounds of the Tetris field. Note that the field has no upper bound.One of the correct answers is to first place the figure in the first column. Then after the second step of the process, the field becomes $$$[2, 0, 2]$$$. Then place the figure in the second column and after the second step of the process, the field becomes $$$[0, 0, 0]$$$.And the second test case of the example field is shown below:It can be shown that you cannot do anything to end the process.In the third test case of the example, you first place the figure in the second column after the second step of the process, the field becomes $$$[0, 2]$$$. Then place the figure in the first column and after the second step of the process, the field becomes $$$[0, 0]$$$.In the fourth test case of the example, place the figure in the first column, then the field becomes $$$[102]$$$ after the first step of the process, and then the field becomes $$$[0]$$$ after the second step of the process. import sys
 
def inp():
    return(int(input()))
def inlt():
    return(list(map(int,input().split())))

def main():

    for k in range(inp()):
        n=inp()
        col=inlt()

        i=0
        for b in col:

            if(n-1!=i):
                if(col[i+1]-b)%2==1:
                    print(""NO"")
                    i+=1
                    break
            i+=1
            if(i==n):
                print(""YES"")
                break
        
     
    return
 
main()","['implementation', 'number theory']"
1479,"The integers shop sells $$$n$$$ segments. The $$$i$$$-th of them contains all integers from $$$l_i$$$ to $$$r_i$$$ and costs $$$c_i$$$ coins.Tomorrow Vasya will go to this shop and will buy some segments there. He will get all integers that appear in at least one of bought segments. The total cost of the purchase is the sum of costs of all segments in it.After shopping, Vasya will get some more integers as a gift. He will get integer $$$x$$$ as a gift if and only if all of the following conditions are satisfied:   Vasya hasn't bought $$$x$$$.  Vasya has bought integer $$$l$$$ that is less than $$$x$$$.  Vasya has bought integer $$$r$$$ that is greater than $$$x$$$. Vasya can get integer $$$x$$$ as a gift only once so he won't have the same integers after receiving a gift.For example, if Vasya buys segment $$$[2, 4]$$$ for $$$20$$$ coins and segment $$$[7, 8]$$$ for $$$22$$$ coins, he spends $$$42$$$ coins and receives integers $$$2, 3, 4, 7, 8$$$ from these segments. He also gets integers $$$5$$$ and $$$6$$$ as a gift.Due to the technical issues only the first $$$s$$$ segments (that is, segments $$$[l_1, r_1], [l_2, r_2], \ldots, [l_s, r_s]$$$) will be available tomorrow in the shop.Vasya wants to get (to buy or to get as a gift) as many integers as possible. If he can do this in differents ways, he selects the cheapest of them.For each $$$s$$$ from $$$1$$$ to $$$n$$$, find how many coins will Vasya spend if only the first $$$s$$$ segments will be available. NoteIn the first test case if $$$s = 1$$$ then Vasya can buy only the segment $$$[2, 4]$$$ for $$$20$$$ coins and get $$$3$$$ integers.The way to get $$$7$$$ integers for $$$42$$$ coins in case $$$s = 2$$$ is described in the statement.In the second test case note, that there can be the same segments in the shop. import sys
 
t = int(sys.stdin.readline())
results = []
INF = 10 ** 10
for case in range(t):
    n = int(sys.stdin.readline())
    start = [INF, INF, INF]
    end = [0, 0, INF]
    single = [0, INF]
    
    for _ in range(n):
        current = list(map(int, sys.stdin.readline().split(' ')))
        if current[0] < start[0]:
            start = current.copy()
        elif current[0] == start[0]:
            start[2] = min(start[2], current[2])
        if current[1] > end[1]:
            end = current.copy()
        elif current[1] == end[1]:
            end[2] = min(end[2], current[2])
            
        length = current[1] - current[0] + 1
        if length > single[0]:
            single[0], single[1] = length, current[2]
        elif length == single[0]:
            single[1] = min(single[1], current[2])
        
        cost = start[2] + end[2]
        if end[1] - start[0] + 1 == single[0]:
            cost = min(cost, single[1])
        results.append(str(cost))
 
print('\n'.join(results))","['data structures', 'greedy', 'implementation']"
3728,"As you must know, the maximum clique problem in an arbitrary graph is NP-hard. Nevertheless, for some graphs of specific kinds it can be solved effectively.Just in case, let us remind you that a clique in a non-directed graph is a subset of the vertices of a graph, such that any two vertices of this subset are connected by an edge. In particular, an empty set of vertexes and a set consisting of a single vertex, are cliques.Let's define a divisibility graph for a set of positive integers A = {a1, a2, ..., an} as follows. The vertices of the given graph are numbers from set A, and two numbers ai and aj (i ≠ j) are connected by an edge if and only if either ai is divisible by aj, or aj is divisible by ai.You are given a set of non-negative integers A. Determine the size of a maximum clique in a divisibility graph for set A. NoteIn the first sample test a clique of size 3 is, for example, a subset of vertexes {3, 6, 18}. A clique of a larger size doesn't exist in this graph. #!/usr/bin/env python3
import os
import sys
from io import BytesIO, IOBase


class FastO:
    def __init__(self, fd=1):
        stream = BytesIO()
        self.flush = lambda: os.write(fd, stream.getvalue()) and not stream.truncate(0) and stream.seek(0)
        self.write = lambda b: stream.write(b.encode())


class ostream:
    def __lshift__(self, a):
        sys.stdout.write(str(a))
        return self


sys.stdout, cout = FastO(), ostream()

numbers, num, sign = [], 0, True
for char in os.read(0, os.fstat(0).st_size):
    if char >= 48:
        num = num * 10 + char - 48
    elif char == 45:
        sign = False
    elif char != 13:
        numbers.append(num if sign else -num)
        num, sign = 0, True

if char >= 48:
    numbers.append(num if sign else -num)

getnum = iter(numbers).__next__

n = getnum()
dp = [0] * (10**6 + 1)
for _ in range(n):
    dp[getnum()] = 1
for i in reversed(range(10**6 + 1)):
    dp[i] = max((dp[x] + 1 for x in range(2 * i, 10**6 + 1, i) if dp[x]), default=1) if dp[i] else 0

cout << max(dp)
","['dp', 'math', 'number theory']"
2672,"Your friend Mishka and you attend a calculus lecture. Lecture lasts n minutes. Lecturer tells ai theorems during the i-th minute.Mishka is really interested in calculus, though it is so hard to stay awake for all the time of lecture. You are given an array t of Mishka's behavior. If Mishka is asleep during the i-th minute of the lecture then ti will be equal to 0, otherwise it will be equal to 1. When Mishka is awake he writes down all the theorems he is being told — ai during the i-th minute. Otherwise he writes nothing.You know some secret technique to keep Mishka awake for k minutes straight. However you can use it only once. You can start using it at the beginning of any minute between 1 and n - k + 1. If you use it on some minute i then Mishka will be awake during minutes j such that  and will write down all the theorems lecturer tells.You task is to calculate the maximum number of theorems Mishka will be able to write down if you use your technique only once to wake him up. NoteIn the sample case the better way is to use the secret technique at the beginning of the third minute. Then the number of theorems Mishka will be able to write down will be equal to 16. n,k=map(int,input().split())
l=list(map(int,input().split()))
s=list(map(int,input().split()))
sum1=0
dic={}
for i in range(n):
    if s[i]!=0:
        sum1=sum1+l[i]
    else:
        dic[i]=l[i]
#print('sum1',sum1)
#print(dic)
if len(dic)!=0:
    l2=list(dic.values())
    s2=list(dic.keys())
    m=len(l2)
    sum2=l2[0]
    strt=0
    end=1
    max=0
    #print(l2)
    #print(s2)
    while strt<m and end<m:
        if s2[end]-s2[strt]<=k-1:
            sum2=sum2+l2[end]
            end=end+1
            #print('end',end)
        else:
            if sum2>max:
                max=sum2

            #print('strt',strt)
            sum2=sum2-l2[strt]
            strt=strt+1


        #print('sum',sum2)
    #print(sum1)
    if sum2>max:
        max=sum2
    print(sum1+max)
else:
    print(sum1)
","['data structures', 'dp', 'implementation', 'two pointers']"
1618,"Polycarp is very careful. He even types numeric sequences carefully, unlike his classmates. If he sees a sequence without a space after the comma, with two spaces in a row, or when something else does not look neat, he rushes to correct it. For example, number sequence written like ""1,2 ,3,...,   10"" will be corrected to ""1, 2, 3, ..., 10"".In this task you are given a string s, which is composed by a concatination of terms, each of which may be:   a positive integer of an arbitrary length (leading zeroes are not allowed),  a ""comma"" symbol ("",""),  a ""space"" symbol ("" ""),  ""three dots"" (""..."", that is, exactly three points written one after another, also known as suspension points). Polycarp wants to add and remove spaces in the string s to ensure the following:   each comma is followed by exactly one space (if the comma is the last character in the string, this rule does not apply to it),  each ""three dots"" term is preceded by exactly one space (if the dots are at the beginning of the string, this rule does not apply to the term),  if two consecutive numbers were separated by spaces only (one or more), then exactly one of them should be left,  there should not be other spaces. Automate Polycarp's work and write a program that will process the given string s. nan ans = input()
while "" ,"" in ans:
    ans = ans.replace("" ,"", "","")
ans = ans.replace(""..."", "" ..."").replace("","", "", "")
while ""  "" in ans:
    ans = ans.replace(""  "", "" "")
for d in ""0123456789"": ans = ans.replace("". "" + d, ""."" + d)
print(ans.strip(), end="""")
","['implementation', 'strings']"
1412,"Vasya is a regular participant at programming contests and is already experienced in finding important sentences in long statements. Of course, numbers constraints are important — factorization of a number less than 1000000 is easier than of a number less than 1000000000. However, sometimes it's hard to understand the number at the first glance. Could it be shortened? For example, instead of 1000000 you could write $$$10^{6}$$$, instead of 1000000000  —$$$10^{9}$$$, instead of 1000000007 — $$$10^{9}+7$$$.Vasya decided that, to be concise, the notation should follow several rules:   the notation should only consist of numbers, operations of addition (""+""), multiplication (""*"") and exponentiation (""^""), in particular, the use of braces is forbidden;  the use of several exponentiation operations in a row is forbidden, for example, writing ""2^3^4"" is unacceptable;  the value of the resulting expression equals to the initial number;  the notation should consist of the minimal amount of symbols. Given $$$n$$$, find the equivalent concise notation for it. NoteThe third sample allows the answer 10^10 also of the length $$$5$$$. import math
import itertools

pow10 = [1]
for i in range(10):
    pow10.append(pow10[-1] * 10)


def getlen(x):
    """"""length of the decimal representation of integer x""""""
    return int(math.log10(x)) + 1


class ShortestRepresentation:

    def __init__(self, n):
        self.n = n
        self._m = {}
        self._s = [set() for i in range(10)]

        self._generate_powers()
        self._generate_power_and_power(7)
        self._generate_simple_and_power(7)

    def _generate_powers(self):
        """"""add to the collection all expressions of the form a^b""""""
        range_x = itertools.takewhile(
            lambda x: x**2 <= self.n,
            itertools.count(2))
        for x in range_x:
            c = x**2
            p = 2
            while c <= self.n:
                self.update(c, '{}^{}'.format(x, p))
                c *= x
                p += 1

    def _generate_power_and_power(self, maxlen):
        """"""add to the collection all expressions of the form a^b*c^d""""""
        for i in range(1, maxlen + 1):
            range_j = itertools.takewhile(
                lambda j: i + j + 1 <= maxlen,
                itertools.count(i))
            for j in range_j:
                for x, y in itertools.product(self._s[i], self._s[j]):
                    x2 = self.get(x)
                    y2 = self.get(y)
                    self.update(x * y, '{}*{}'.format(x2, y2))

    def _generate_simple_and_power(self, maxlen):
        """"""add to the collection all expressions of the form a^b*c""""""
        for i in range(1, maxlen - 1):
            range_xy = itertools.product(
                range(1, pow10[maxlen - 1 - i]),
                self._s[i])
            for x, y in range_xy:
                y2 = self.get(y)
                self.update(x * y, '{}*{}'.format(x, y2))

    def update(self, x, s):
        """"""update with s x'th entry of the collection""""""
        if x > self.n:
            return

        ls = len(s)
        if ls >= getlen(x):  # length of s should be at least shorter
            return

        if x not in self._m:
            self._m[x] = s
            self._s[ls].add(x)
        else:
            lm = len(self._m[x])
            if ls < lm:
                self._s[lm].remove(x)
                self._m[x] = s
                self._s[ls].add(x)

    def get(self, x):
        """"""retrieve shortest valid representation of number x""""""
        return self._m[x] if x in self._m else str(x)


n = int(input())
if n < 10**10:
    sr = ShortestRepresentation(n)
    ans = sr.get(n)

    # check a*b and a+b
    range_i = itertools.takewhile(
        lambda i: i * 2 + 1 < len(ans),
        itertools.count())
    for i in range_i:
        range_x = itertools.chain(
            range(1, pow10[i] + 1),
            sr._s[i])
        for x in range_x:
            ans = min(
                ans, '{}+{}'.format(sr.get(x), sr.get(n - x)), key=len)
            if n % x > 0:
                continue
            ans = min(
                ans, '{}*{}'.format(sr.get(x), sr.get(n // x)), key=len)

    print(ans)
else:
    print('100^5')
","['brute force', 'greedy', 'implementation', 'math']"
254,"Highway 201 is the most busy street in Rockport. Traffic cars cause a lot of hindrances to races, especially when there are a lot of them. The track which passes through this highway can be divided into $$$n$$$ sub-tracks. You are given an array $$$a$$$ where $$$a_i$$$ represents the number of traffic cars in the $$$i$$$-th sub-track. You define the inconvenience of the track as $$$\sum\limits_{i=1}^{n} \sum\limits_{j=i+1}^{n} \lvert a_i-a_j\rvert$$$, where $$$|x|$$$ is the absolute value of $$$x$$$. You can perform the following operation any (possibly zero) number of times: choose a traffic car and move it from its current sub-track to any other sub-track.Find the minimum inconvenience you can achieve. NoteFor the first test case, you can move a car from the $$$3$$$-rd sub-track to the $$$1$$$-st sub-track to obtain $$$0$$$ inconvenience.For the second test case, moving any car won't decrease the inconvenience of the track. import sys

input = lambda: sys.stdin.buffer.readline().decode().strip()
print = sys.stdout.write

for _ in range(int(input())):
    n = int(input())
    nums = list(map(int, input().split()))
    total = sum(nums)
    reminder = total % n
    print(str((n - reminder) * reminder) + ""\n"")
","['combinatorics', 'greedy', 'math']"
2367,"Bakry got bored of solving problems related to xor, so he asked you to solve this problem for him.You are given an array $$$a$$$ of $$$n$$$ integers $$$[a_1, a_2, \ldots, a_n]$$$.Let's call a subarray $$$a_{l}, a_{l+1}, a_{l+2}, \ldots, a_r$$$ good if $$$a_l \, \&amp; \, a_{l+1} \, \&amp; \, a_{l+2} \, \ldots \, \&amp; \, a_r &gt; a_l \oplus a_{l+1} \oplus a_{l+2} \ldots \oplus a_r$$$, where $$$\oplus$$$ denotes the bitwise XOR operation and $$$\&amp;$$$ denotes the bitwise AND operation.Find the length of the longest good subarray of $$$a$$$, or determine that no such subarray exists. NoteIn the first case, the answer is $$$2$$$, as the whole array is good: $$$5 \&amp; 6 = 4 &gt; 5 \oplus 6 = 3$$$.In the third case, the answer is $$$4$$$, and one of the longest good subarrays is $$$[a_2, a_3, a_4, a_5]$$$: $$$1\&amp; 3 \&amp; 3 \&amp;1 = 1 &gt; 1\oplus 3 \oplus 3\oplus 1 = 0$$$. from __future__ import division, print_function

import os,sys
from io import BytesIO, IOBase

if sys.version_info[0] < 3:
    from __builtin__ import xrange as range
    from future_builtins import ascii, filter, hex, map, oct, zip

from bisect import bisect_left as lower_bound, bisect_right as upper_bound 
def so():  return int(input())
def st():  return input()
def mj():  return map(int,input().strip().split("" ""))
def msj(): return list(map(str,input().strip().split("" "")))
def le():  return list(map(int,input().split()))
def rc():  return map(float,input().split())
def lebe():return list(map(int, input()))

def dmain():
    sys.setrecursionlimit(1000000)
    threading.stack_size(1024000)
    thread = threading.Thread(target=main)
    thread.start()
def joro(L):
    return(''.join(map(str, L)))
def joron(L):
    return('\n'.join(map(str, L)))

def decimalToBinary(n): return bin(n).replace(""0b"","""")


def isprime(n):
    for i in range(2,int(n**0.5)+1):
        if n%i==0:
            return False
    return True
def npr(n, r):
    return factorial(n) // factorial(n - r) if n >= r else 0
 
 
def ncr(n, r):
    return factorial(n) // (factorial(r) * factorial(n - r)) if n >= r else 0
 
 
def lower_bound(li, num):
    answer = -1
    start = 0
    end = len(li) - 1
 
    while (start <= end):
        middle = (end + start) // 2
        if li[middle] >= num:
            answer = middle
            end = middle - 1
        else:
            start = middle + 1
    return answer  # min index where x is not less than num
 
 
def upper_bound(li, num):
    answer = -1
    start = 0
    end = len(li) - 1
 
    while (start <= end):
        middle = (end + start) // 2
 
        if li[middle] <= num:
            answer = middle
            start = middle + 1
 
        else:
            end = middle - 1
    return answer  # max index where x is not greater than num
def tir(a,b,c):
    if(0==c):
        return 1
    if(len(a)<=b):
        return 0
    
    if(c!=-1):
        return (tir(a,1+b,c+a[b]) or tir(a,b+1,c-a[b]) or tir(a,1+b,c)) 
        
        
    else:
        return (tir(a,1+b,a[b]) or tir(a,b+1,-a[b]) or tir(a,1+b,-1))
   
 
def abs(x):
    return x if x >= 0 else -x
 
 
def binary_search(li, val, lb, ub):
    # print(lb, ub, li)
    ans = -1
    while (lb <= ub):
        mid = (lb + ub) // 2
        # print('mid is',mid, li[mid])
        if li[mid] > val:
            ub = mid - 1
        elif val > li[mid]:
            lb = mid + 1
        else:
            ans = mid  # return index
            break
    return ans
 
 
def kadane(x):  # maximum sum contiguous subarray
    sum_so_far = 0
    current_sum = 0
    for i in x:
        current_sum += i
        if current_sum < 0:
            current_sum = 0
        else:
            sum_so_far = max(sum_so_far, current_sum)
    return sum_so_far

                    
def pref(li):
    pref_sum = [0]
    for i in li:
        pref_sum.append(pref_sum[-1] + i)
    return pref_sum
 

        
        
def SieveOfEratosthenes(n):
    prime = [True for i in range(n + 1)]
    p = 2
    li = []
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n + 1, p):
                prime[i] = False
        p += 1
 
    for p in range(2, len(prime)):
        if prime[p]:
            li.append(p)
    return li
 
 
def primefactors(n):
    factors = []
    while (n % 2 == 0):
        factors.append(2)
        n //= 2
    for i in range(3, int(sqrt(n)) + 1, 2):  # only odd factors left
        while n % i == 0:
            factors.append(i)
            n //= i
    if n > 2:  # incase of prime
        factors.append(n)
    return factors
         
    
def read():
    sys.stdin  = open('input.txt', 'r')  
    sys.stdout = open('output.txt', 'w') 
def tr(n):
    return n*(n+1)//2
boi=int(998244353)
doi=int(1e9+7)
hoi=int(1e6+1e5+5)
poi=int(1009)
y=""YES""
n=""NO""
def gosa(x, y): 
  
   while(y): 
       x, y = y, x % y 
  
   return x

L=[0]*hoi
M=[0]*hoi
N=[0]*hoi
O=[0]*hoi














    
        

        


            

def bulli(x):
    return bin(x).count('1')




        
    
    
        




            
def iu():
    import sys
    import math as my
    import functools
    input=sys.stdin.readline
    from collections import deque, defaultdict
    bec=0
    m=so()
    P=le()
    for i in range(1,1+m):
        L[i]=P[i-1]
    for i in range(20,-1,-1):
        M[0]=0
        for j in range(1,1<<20):
            M[j]=-1
        for j in range(1,1+m):
            
            N[j]=(L[j]>>i&1)+N[j-1]
            O[j]=O[j]^((N[j]%2)<<i)
            z=(N[j]%2)
            zz=O[j]
            if(-1==zz):
                M[zz]=j
            else:
                if(j-N[j]==M[zz]-N[M[zz]]):
                    bec=max(j-M[zz],bec)
                else:
                    M[zz]=j
    print(bec)
            
    
    
    
    
        
                
            
        
        
    
    
            
    
    
    
    
    
    
        
            
        
    
    
    
    
        
            
    
        
        
        
def main():
    for i in range(1):
        #print(""Case #""+str(i+1)+"": "",end="""")
        iu()        
    
    
    
    
        
        
    
        
    
    
            
    
    
    
                
            
            
    
        

                
    
        
        

            
                    
                
                    
                    
                    
                    
                    
                    
        
                
        
        
       
    
           
          
          
                
            
        
                
    
        
        
        
       
            
                
        




# region fastio
# template taken from https://github.com/cheran-senthil/PyRival/blob/master/templates/template.py

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


def print(*args, **kwargs):
    """"""Prints the values to a stream, or to sys.stdout by default.""""""
    sep, file = kwargs.pop(""sep"", "" ""), kwargs.pop(""file"", sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop(""end"", ""\n""))
    if kwargs.pop(""flush"", False):
        file.flush()


if sys.version_info[0] < 3:
    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# endregion


if __name__ == ""__main__"":
    #read()
    main()
    #dmain()

# Comment Read()","['bitmasks', 'greedy', 'math', 'two pointers']"
657,"Inflation has occurred in Berlandia, so the store needs to change the price of goods.The current price of good $$$n$$$ is given. It is allowed to increase the price of the good by $$$k$$$ times, with $$$1 \le k \le m$$$, k is an integer. Output the roundest possible new price of the good. That is, the one that has the maximum number of zeros at the end.For example, the number 481000 is more round than the number 1000010 (three zeros at the end of 481000 and only one at the end of 1000010).If there are several possible variants, output the one in which the new price is maximal.If it is impossible to get a rounder price, output $$$n \cdot m$$$ (that is, the maximum possible price). NoteIn the first case $$$n = 6$$$, $$$m = 11$$$. We cannot get a number with two zeros or more at the end, because we need to increase the price $$$50$$$ times, but $$$50 &gt; m = 11$$$. The maximum price multiple of $$$10$$$ would be $$$6 \cdot 10 = 60$$$.In the second case $$$n = 5$$$, $$$m = 43$$$. The maximum price multiple of $$$100$$$ would be $$$5 \cdot 40 = 200$$$.In the third case, $$$n = 13$$$, $$$m = 5$$$. All possible new prices will not end in $$$0$$$, then you should output $$$n \cdot m = 65$$$.In the fourth case, you should increase the price $$$15$$$ times.In the fifth case, increase the price $$$12000$$$ times. #I = lambda: [int(i) for i in input().split()]
#import io, os, sys
#input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
 
 
from collections import Counter,defaultdict,deque
#from heapq import heappush,heappop,heapify
import sys
import math
import bisect
def lcm(a,b):
    return ((a*b)//math.gcd(a,b))


def all_factors(n):
    """"""returns a sorted list of all distinct factors of n""""""
    small, large = [], []
    for i in range(1, int(n**0.5) + 1, 2 if n & 1 else 1):
        if not n % i:
            small.append(i)
            large.append(n // i)
    if small[-1] == large[-1]:
        large.pop()
    large.reverse()
    small.extend(large)
    return small
 
# n = int(input())
# l1 = list(map(int,input().split()))
# n,x = map(int,input().split())
# s = input()
mod = 1000000007
# print(""Case #""+str(_+1)+"":"",)
def f(x):
    l = [x,0,0]
    while(x%2==0 or x%5==0):
        if x%2==0:
            l[1]+=1
            x = x//2
        if x%5==0:
            l[2]+=1
            x = x//5
    l[0] = x
    return l
def count(x):
    c = 0
    x = str(x)
    for i in range(len(x)-1,-1,-1):
        if x[i] != '0':
            break
        c+=1
    return c
for _ in range(int(input())):
    n,m = map(int,input().split())
    a = f(n)
    x = 1
    px = -1
    t1 = a[1]
    t2 = a[2]
    a[1] -= min(t1,t2)
    a[2] -= min(t1,t2)
    while(x < m and (a[1] or a[2])):
        if x==px:
            break
        px = x
        if a[1] and x*5<=m:
            x*=5
            a[1]-=1
        if a[2] and x*2<=m:
            x*=2
            a[2]-=1
        
    while(x*10 < m):
        x*=10
    x = x*(m//x)
    ans = n*x
    print(ans)
    '''if count(ans)-count(n) > count(m):
        print(ans)
    else:
        while(x < m):
            x = x+(pow(10,len(str(m))-1))
            t = n*x
            if count(t)>=count(ans):
                ans =  max(ans,t)
        print(ans)'''
        
            
        
    
                    
    
    
","['brute force', 'number theory']"
4262,"Lolek and Bolek are about to travel abroad by plane. The local airport has a special ""Choose Your Plane"" offer. The offer's conditions are as follows:  it is up to a passenger to choose a plane to fly on;  if the chosen plane has x (x &gt; 0) empty seats at the given moment, then the ticket for such a plane costs x zlotys (units of Polish currency). The only ticket office of the airport already has a queue of n passengers in front of it. Lolek and Bolek have not stood in the queue yet, but they are already wondering what is the maximum and the minimum number of zlotys the airport administration can earn if all n passengers buy tickets according to the conditions of this offer?The passengers buy tickets in turn, the first person in the queue goes first, then goes the second one, and so on up to n-th person. NoteIn the first test sample the number of passengers is equal to the number of empty seats, so regardless of the way the planes are chosen, the administration will earn the same sum.In the second sample the sum is maximized if the 1-st person in the queue buys a ticket to the 1-st plane, the 2-nd person — to the 2-nd plane, the 3-rd person — to the 3-rd plane, the 4-th person — to the 1-st plane. The sum is minimized if the 1-st person in the queue buys a ticket to the 1-st plane, the 2-nd person — to the 1-st plane, the 3-rd person — to the 2-nd plane, the 4-th person — to the 2-nd plane. n,m=list(map(int,input().split()))
a=list(map(int,input().split()))
a.sort()
t=n
i=0
ma=mi=0
while i<m and n>0:
    if a[i]>n:
        mi+=(n*(2*a[i]-n+1)/2)
    else:
        mi+=(a[i]*(a[i]+1)/2)
    n-=min(a[i],n)
    i+=1
n=t
i=0
while n>0:
    ma+=max(a)
    a[a.index(max(a))]-=1
    n-=1
print(int(ma),int(mi))    
    



",['implementation']
2458,"You are given two polynomials:  P(x) = a0·xn + a1·xn - 1 + ... + an - 1·x + an and  Q(x) = b0·xm + b1·xm - 1 + ... + bm - 1·x + bm.  Calculate limit . NoteLet's consider all samples:           You can learn more about the definition and properties of limits if you follow the link: http://en.wikipedia.org/wiki/Limit_of_a_function n, m = map(int, raw_input().split())
P = map(int, raw_input().split())
Q = map(int, raw_input().split())
if n > m:
    if P[0] > 0 and Q[0] > 0 or P[0] < 0 and Q[0] < 0:
        print ""Infinity""
    else:
        print ""-Infinity""
elif n < m:
    print ""0/1""
else:
    a, b = abs(P[0]), abs(Q[0])
    for i in xrange(100, 0, -1):
        if a%i == 0 and b%i == 0:
            a /= i
            b /= i
    if P[0] > 0 and Q[0] > 0 or P[0] < 0 and Q[0] < 0:
        print str(a) + ""/"" + str(b)
    else:
        print ""-"" + str(a) + ""/"" + str(b)
",['math']
2655,"This is an interactive problem.Ayush devised a new scheme to set the password of his lock. The lock has $$$k$$$ slots where each slot can hold integers from $$$1$$$ to $$$n$$$. The password $$$P$$$ is a sequence of $$$k$$$ integers each in the range $$$[1, n]$$$, $$$i$$$-th element of which goes into the $$$i$$$-th slot of the lock.To set the password of his lock, Ayush comes up with an array $$$A$$$ of $$$n$$$ integers each in the range $$$[1, n]$$$ (not necessarily distinct). He then picks $$$k$$$ non-empty mutually disjoint subsets of indices $$$S_1, S_2, ..., S_k$$$ $$$(S_i \underset{i \neq j} \cap S_j = \emptyset)$$$ and sets his password as $$$P_i = \max\limits_{j \notin S_i} A[j]$$$. In other words, the $$$i$$$-th integer in the password is equal to the maximum over all elements of $$$A$$$ whose indices do not belong to $$$S_i$$$.You are given the subsets of indices chosen by Ayush. You need to guess the password. To make a query, you can choose a non-empty subset of indices of the array and ask the maximum of all elements of the array with index in this subset. You can ask no more than 12 queries. NoteThe array $$$A$$$ in the example is $$$[1, 2, 3, 4]$$$. The length of the password is $$$2$$$. The first element of the password is the maximum of $$$A[2]$$$, $$$A[4]$$$ (since the first subset contains indices $$$1$$$ and $$$3$$$, we take maximum over remaining indices). The second element of the password is the maximum of $$$A[1]$$$, $$$A[3]$$$ (since the second subset contains indices $$$2$$$, $$$4$$$).Do not forget to read the string ""Correct"" / ""Incorrect"" after guessing the password. from sys import stdin,stdout
T=int(stdin.readline().strip())
def query(l,r):
    print(""?"",end="" "")
    c=0
    for i in range(l,r+1):
        for j in s[i]:
            c+=1
    print(c,end="" "")
    for i in range(l,r+1):
        for j in s[i]:
            print(j,end="" "")
    print()
    stdout.flush()
    
    x=int(stdin.readline().strip())
    return x
    
for caso in range(T):
    n,m=map(int,stdin.readline().strip().split())
    s=[list(map(int,stdin.readline().strip().split()))[1::] for i in range(m)]
    l=0
    r=m
    aux=[]
    for i in range(1,n+1):
        f=False
        for j in s:
            if i in j:
                f=True
        if f==False:
            aux.append(i)
    s.append(aux)
    x=query(l,r)
    ans=[x for i in range(m+1)]
    for i in range(10):
        l1=l
        r1=(l+r)//2

        if(l1>r1):
            break
        x1=query(l1,r1)
        if x1!=x:
            for j in range(l1,r1+1):
                ans[j]=x
            l=r1+1
        else:
            for j in range(r1+1,r+1):
                ans[j]=x
            r=r1
    c=0
    for i in range(m+1):
        if i==l:
            continue
        for j in s[i]:
            c+=1
    print(""?"",end="" "")
    print(c,end="" "")
    for i in range(m+1):
        if l==i:
            continue
        for j in s[i]:
            print(j,end="" "")
    print()
    stdout.flush()
    
    x=int(stdin.readline().strip())
    ans[l]=x
    print(""! "",*ans[0:m])
    stdout.flush()
    ans=stdin.readline().strip()
    if ans!=""Correct"":
        print(""Malll"")
        exit(-77)
                
                
            
        
 
","['binary search', 'implementation', 'interactive', 'math']"
4789,"Polycarpus has a sequence, consisting of n non-negative integers: a1, a2, ..., an.Let's define function f(l, r) (l, r are integer, 1 ≤ l ≤ r ≤ n) for sequence a as an operation of bitwise OR of all the sequence elements with indexes from l to r. Formally: f(l, r) = al | al + 1 | ...  | ar. Polycarpus took a piece of paper and wrote out the values of function f(l, r) for all l, r (l, r are integer, 1 ≤ l ≤ r ≤ n). Now he wants to know, how many distinct values he's got in the end. Help Polycarpus, count the number of distinct values of function f(l, r) for the given sequence a.Expression x | y means applying the operation of bitwise OR to numbers x and y. This operation exists in all modern programming languages, for example, in language C++ and Java it is marked as ""|"", in Pascal — as ""or"". NoteIn the first test case Polycarpus will have 6 numbers written on the paper: f(1, 1) = 1, f(1, 2) = 3, f(1, 3) = 3, f(2, 2) = 2, f(2, 3) = 2, f(3, 3) = 0. There are exactly 4 distinct numbers among them: 0, 1, 2, 3. n=int(input())
a,b=set(),set()
for i in list(map(int,input().split())):
    a={i|j for j in a}
    a.add(i)
    b.update(a)
print(len(b))",['bitmasks']
2552,"You've got an undirected graph, consisting of n vertices and m edges. We will consider the graph's vertices numbered with integers from 1 to n. Each vertex of the graph has a color. The color of the i-th vertex is an integer ci.Let's consider all vertices of the graph, that are painted some color k. Let's denote a set of such as V(k). Let's denote the value of the neighbouring color diversity for color k as the cardinality of the set Q(k) = {cu :  cu ≠ k and there is vertex v belonging to set V(k) such that nodes v and u are connected by an edge of the graph}.Your task is to find such color k, which makes the cardinality of set Q(k) maximum. In other words, you want to find the color that has the most diverse neighbours. Please note, that you want to find such color k, that the graph has at least one vertex with such color. nan n,m=map(int,raw_input().split())
c=map(int,raw_input().split())
adj=[[] for i in xrange(n+1)]
for i in xrange(m):
    u,v=map(int,raw_input().split())
    adj[u].append(v)
    adj[v].append(u)
ans=111111111111111111111111111111111111111111111111111111111111111110
color=[set() for i in xrange(100010)]
count=-1
vis=set()
for i in xrange(1,n+1):
    vis.add(c[i-1])
    for j in adj[i]:
        if c[j-1] == c[i-1]:
            continue
        else:
            color[c[i-1]].add(c[j-1])
    #print i,c[i-1],len(cc)
    #print cc
vis=list(vis)
vis=sorted(vis)
for i in vis:
    if len(color[i]) > count:
        count=len(color[i])
        ans=i
print ans","['brute force', 'dfs and similar', 'graphs']"
4593,"There are n workers in a company, each of them has a unique id from 1 to n. Exaclty one of them is a chief, his id is s. Each worker except the chief has exactly one immediate superior.There was a request to each of the workers to tell how how many superiors (not only immediate). Worker's superiors are his immediate superior, the immediate superior of the his immediate superior, and so on. For example, if there are three workers in the company, from which the first is the chief, the second worker's immediate superior is the first, the third worker's immediate superior is the second, then the third worker has two superiors, one of them is immediate and one not immediate. The chief is a superior to all the workers except himself.Some of the workers were in a hurry and made a mistake. You are to find the minimum number of workers that could make a mistake. NoteIn the first example it is possible that only the first worker made a mistake. Then:   the immediate superior of the first worker is the second worker,  the immediate superior of the third worker is the first worker,  the second worker is the chief.  n,s=[int(i) for i in input().split()]

s-=1

n-=1

d=0

l=[int(i) for i in input().split()]

if l[s]!=0:d+=1

l=l[:s]+l[s+1:]

for i in range(0,len(l)):

	if(l[i]==0):l[i]=n+5

l.sort()

j=0

i=0

c=0

while 1:

	while i<len(l) and j==l[i]:

		i+=1

	if i>=len(l):

		break

	elif l[i]-j==1:

		j+=1

		i+=1

		continue

	else:

		l.pop()

		d+=1

		j+=1

print(d)



# Made By Mostafa_Khaled","['graphs', 'greedy']"
315,"Valera had an undirected connected graph without self-loops and multiple edges consisting of n vertices. The graph had an interesting property: there were at most k edges adjacent to each of its vertices. For convenience, we will assume that the graph vertices were indexed by integers from 1 to n.One day Valera counted the shortest distances from one of the graph vertices to all other ones and wrote them out in array d. Thus, element d[i] of the array shows the shortest distance from the vertex Valera chose to vertex number i.Then something irreparable terrible happened. Valera lost the initial graph. However, he still has the array d. Help him restore the lost graph. nan n, k = map(int, raw_input().split())

numbers = map(int, raw_input().split())
indices = range(1, len(numbers) + 1)

pairs = zip(numbers, indices)
pairs = sorted(pairs)

edges = []

valid = True

if pairs[0][0] != 0:
    valid = False
else:
    parent = 0
    remaining_edges = k
    for i in range(1, len(pairs)):
        while (pairs[parent][0] != pairs[i][0]-1 or not remaining_edges)and parent < i:
            parent += 1
            remaining_edges = k - 1
        if parent >= i or remaining_edges == 0:
            valid = False
            break
        edges.append((pairs[parent][1], pairs[i][1]))
        remaining_edges -= 1
if not valid:
    print -1
else:
    print len(edges)
    for edge in edges:
        print edge[0], edge[1]","['dfs and similar', 'graphs', 'sortings']"
1192,"Alice and Bob are playing a game. They start with a positive integer $$$n$$$ and take alternating turns doing operations on it. Each turn a player can subtract from $$$n$$$ one of its divisors that isn't $$$1$$$ or $$$n$$$. The player who cannot make a move on his/her turn loses. Alice always moves first.Note that they subtract a divisor of the current number in each turn.You are asked to find out who will win the game if both players play optimally. NoteIn the first test case, the game ends immediately because Alice cannot make a move.In the second test case, Alice can subtract $$$2$$$ making $$$n = 2$$$, then Bob cannot make a move so Alice wins.In the third test case, Alice can subtract $$$3$$$ so that $$$n = 9$$$. Bob's only move is to subtract $$$3$$$ and make $$$n = 6$$$. Now, Alice can subtract $$$3$$$ again and $$$n = 3$$$. Then Bob cannot make a move, so Alice wins. import sys

input = sys.stdin.readline
inf = float('inf')


def getInt():
    return int(input())


def getStr():
    return input().strip()


def getList(split=True):
    s = getStr()
    if split:
        s = s.split()
    return map(int, s)


t = getInt()
# t = 1

M = 10 ** 9 + 7

A = {2**i for i in range(1, 32, 2)}


def solve():
    # if x is a power of 2 then Alice loose
    # if x is odd of x is  2 to the power off odd number then Alice loose else she will win
    x = getInt()

    if x & 1 or x in A:
        print(""Bob"")
    else:
        print(""Alice"")


for _ in range(t):
    solve()
","['games', 'math', 'number theory']"
3326,"Arkady coordinates rounds on some not really famous competitive programming platform. Each round features $$$n$$$ problems of distinct difficulty, the difficulties are numbered from $$$1$$$ to $$$n$$$.To hold a round Arkady needs $$$n$$$ new (not used previously) problems, one for each difficulty. As for now, Arkady creates all the problems himself, but unfortunately, he can't just create a problem of a desired difficulty. Instead, when he creates a problem, he evaluates its difficulty from $$$1$$$ to $$$n$$$ and puts it into the problems pool.At each moment when Arkady can choose a set of $$$n$$$ new problems of distinct difficulties from the pool, he holds a round with these problems and removes them from the pool. Arkady always creates one problem at a time, so if he can hold a round after creating a problem, he immediately does it.You are given a sequence of problems' difficulties in the order Arkady created them. For each problem, determine whether Arkady held the round right after creating this problem, or not. Initially the problems pool is empty. NoteIn the first example Arkady held the round after the first three problems, because they are of distinct difficulties, and then only after the last problem. import sys
from math import sqrt, gcd, ceil, log
# from bisect import bisect, bisect_left
from collections import defaultdict, Counter, deque
# from heapq import heapify, heappush, heappop
input = sys.stdin.readline
read = lambda: list(map(int, input().strip().split()))


def main():
	n, m = read(); arr = read()
	ans = []
	count = defaultdict(int)
	s = 0
	t = (n*(n+1))//2
	for i in arr:
		if count[i] == 0:
			s += i
		count[i] += 1
		if s == t:
			for i in count:
				count[i] -= 1
				if count[i] == 0:
					s -= i
			ans.append(""1"")
		else:
			ans.append(""0"")


	print(("""").join(ans))







if __name__ == ""__main__"":
	main()","['data structures', 'implementation']"
4428,"Paprika loves permutations. She has an array $$$a_1, a_2, \dots, a_n$$$. She wants to make the array a permutation of integers $$$1$$$ to $$$n$$$.In order to achieve this goal, she can perform operations on the array. In each operation she can choose two integers $$$i$$$ ($$$1 \le i \le n$$$) and $$$x$$$ ($$$x &gt; 0$$$), then perform $$$a_i := a_i \bmod x$$$ (that is, replace $$$a_i$$$ by the remainder of $$$a_i$$$ divided by $$$x$$$). In different operations, the chosen $$$i$$$ and $$$x$$$ can be different.Determine the minimum number of operations needed to make the array a permutation of integers $$$1$$$ to $$$n$$$. If it is impossible, output $$$-1$$$.A permutation is an array consisting of $$$n$$$ distinct integers from $$$1$$$ to $$$n$$$ in arbitrary order. For example, $$$[2,3,1,5,4]$$$ is a permutation, but $$$[1,2,2]$$$ is not a permutation ($$$2$$$ appears twice in the array) and $$$[1,3,4]$$$ is also not a permutation ($$$n=3$$$ but there is $$$4$$$ in the array). NoteFor the first test, the only possible sequence of operations which minimizes the number of operations is:   Choose $$$i=2$$$, $$$x=5$$$. Perform $$$a_2 := a_2 \bmod 5 = 2$$$. For the second test, it is impossible to obtain a permutation of integers from $$$1$$$ to $$$n$$$. import sys
inpu = sys.stdin.buffer.readline
prin = sys.stdout.write
for _ in range(int(inpu())) :
    n = int(inpu())
    a = list(map(int, inpu().split()))
    a.sort()
    ind = n
    idd = [0]*(n + 1)
    b = []
    for i in range(n) :
        if a[i] > n :
            ind = i
            break
        elif idd[a[i]] == 1:
            b.append(a[i])
        else:
            idd[a[i]] = 1
    count = 0
    c = b + a[ind :]
    ind = 0
    for j in range(1, n + 1) :
        if idd[j] == 0:
            if c[ind] > 2*j :
                count += 1
                ind += 1
            else :
                prin(""-1\n"")
                break
    else :
        prin(str(count) + '\n')","['binary search', 'greedy', 'math', 'sortings']"
4931,"In the capital city of Berland, Bertown, demonstrations are against the recent election of the King of Berland. Berland opposition, led by Mr. Ovalny, believes that the elections were not fair enough and wants to organize a demonstration at one of the squares.Bertown has n squares, numbered from 1 to n, they are numbered in the order of increasing distance between them and the city center. That is, square number 1 is central, and square number n is the farthest from the center. Naturally, the opposition wants to hold a meeting as close to the city center as possible (that is, they want an square with the minimum number).There are exactly k (k &lt; n) days left before the demonstration. Now all squares are free. But the Bertown city administration never sleeps, and the approval of an application for the demonstration threatens to become a very complex process. The process of approval lasts several days, but every day the following procedure takes place:  The opposition shall apply to hold a demonstration at a free square (the one which isn't used by the administration).  The administration tries to move the demonstration to the worst free square left. To do this, the administration organizes some long-term activities on the square, which is specified in the application of opposition. In other words, the administration starts using the square and it is no longer free. Then the administration proposes to move the opposition demonstration to the worst free square. If the opposition has applied for the worst free square then request is accepted and administration doesn't spend money. If the administration does not have enough money to organize an event on the square in question, the opposition's application is accepted. If administration doesn't have enough money to organize activity, then rest of administration's money spends and application is accepted  If the application is not accepted, then the opposition can agree to the administration's proposal (that is, take the worst free square), or withdraw the current application and submit another one the next day. If there are no more days left before the meeting, the opposition has no choice but to agree to the proposal of City Hall. If application is accepted opposition can reject it. It means than opposition still can submit more applications later, but square remains free. In order to organize an event on the square i, the administration needs to spend ai bourles. Because of the crisis the administration has only b bourles to confront the opposition. What is the best square that the opposition can take, if the administration will keep trying to occupy the square in question each time? Note that the administration's actions always depend only on the actions of the opposition. NoteIn the first sample the opposition can act like this. On day one it applies for square 3. The administration has to organize an event there and end up with 3 bourles. If on the second day the opposition applies for square 2, the administration won't have the money to intervene.In the second sample the opposition has only the chance for the last square. If its first move occupies one of the first four squares, the administration is left with at least 4 bourles, which means that next day it can use its next move to move the opposition from any square to the last one.In the third sample administration has a lot of money, so opposition can occupy only last square. R=lambda:map(int,raw_input().split())
n,k=R()
m=R()[0]
c=R()
z=sorted(c[:-1])
s=sum(z[-k:])
print n if s <= m else 1+min(i for i,j in enumerate(c) if s-z[-k]+j>m)
",['greedy']
69,"Vanya and his friend Vova play a computer game where they need to destroy n monsters to pass a level. Vanya's character performs attack with frequency x hits per second and Vova's character performs attack with frequency y hits per second. Each character spends fixed time to raise a weapon and then he hits (the time to raise the weapon is 1 / x seconds for the first character and 1 / y seconds for the second one). The i-th monster dies after he receives ai hits. Vanya and Vova wonder who makes the last hit on each monster. If Vanya and Vova make the last hit at the same time, we assume that both of them have made the last hit. NoteIn the first sample Vanya makes the first hit at time 1 / 3, Vova makes the second hit at time 1 / 2, Vanya makes the third hit at time 2 / 3, and both boys make the fourth and fifth hit simultaneously at the time 1.In the second sample Vanya and Vova make the first and second hit simultaneously at time 1. n, x, y = map(int, input().split())
for _ in range(n):
    a = int(input())
    c1, c2 = ((a + 1) * x // (x + y)) / x, ((a + 1) * y // (x + y)) / y
    if c1 == c2:
        print('Both')
    elif c1 > c2:
        print('Vanya')
    else:
        print('Vova')
","['binary search', 'implementation', 'math', 'sortings']"
4483,"You are fed up with your messy room, so you decided to clean it up.Your room is a bracket sequence $$$s=s_{1}s_{2}\dots s_{n}$$$ of length $$$n$$$. Each character of this string is either an opening bracket '(' or a closing bracket ')'.In one operation you can choose any consecutive substring of $$$s$$$ and reverse it. In other words, you can choose any substring $$$s[l \dots r]=s_l, s_{l+1}, \dots, s_r$$$ and change the order of elements in it into $$$s_r, s_{r-1}, \dots, s_{l}$$$.For example, if you will decide to reverse substring $$$s[2 \dots 4]$$$ of string $$$s=$$$""((()))"" it will be equal to $$$s=$$$""()(())"".A regular (aka balanced) bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters '1' and '+' between the original characters of the sequence. For example, bracket sequences ""()()"", ""(())"" are regular (the resulting expressions are: ""(1)+(1)"", ""((1+1)+1)""), and "")("" and ""("" are not.A prefix of a string $$$s$$$ is a substring that starts at position $$$1$$$. For example, for $$$s=$$$""(())()"" there are $$$6$$$ prefixes: ""("", ""(("", ""(()"", ""(())"", ""(())("" and ""(())()"".In your opinion, a neat and clean room $$$s$$$ is a bracket sequence that:  the whole string $$$s$$$ is a regular bracket sequence;  and there are exactly $$$k$$$ prefixes of this sequence which are regular (including whole $$$s$$$ itself). For example, if $$$k = 2$$$, then ""(())()"" is a neat and clean room.You want to use at most $$$n$$$ operations to make your room neat and clean. Operations are applied one after another sequentially.It is guaranteed that the answer exists. Note that you do not need to minimize the number of operations: find any way to achieve the desired configuration in $$$n$$$ or less operations. NoteIn the first example, the final sequence is ""()(()())"", where two prefixes are regular, ""()"" and ""()(()())"". Note, that all the operations except ""5 8"" in the example output are useless (they do not change $$$s$$$). t = int(input())
for test_i in range(t):
    n, k = map(int, input().split())
    s = list(input())
    ans = []
    for i in range(k - 1):
        if s[2 * i] != '(':
            i0 = s.index('(', 2 * i)
            ans.append((2 * i + 1, i0 + 1))
            s[2 * i], s[i0] = '(', ')'
        if s[2 * i + 1] != ')':
            i0 = s.index(')', 2 * i + 1)
            ans.append((2 * i + 2, i0 + 1))
            s[2 * i + 1], s[i0] = ')', '('
    for i in range(n // 2 - k + 1):
        if s[2 * (k - 1) + i] != '(':
            i0 = s.index('(', 2 * (k - 1) + i)
            ans.append((2 * (k - 1) + i + 1, i0 + 1))
            s[2 * (k - 1) + i], s[i0] = '(', ')'
    print(len(ans))
    for pair in ans:
        print(*pair)",['constructive algorithms']
1526,"In one very large and very respectable company there is a cloakroom with a coat hanger. It is represented by n hooks, positioned in a row. The hooks are numbered with positive integers from 1 to n from the left to the right.The company workers have a very complicated work schedule. At the beginning of a work day all the employees are not there and the coat hanger in the cloakroom is empty. At some moments of time the employees arrive and some of them leave.When some employee arrives, he hangs his cloak on one of the available hooks. To be of as little discomfort to his colleagues as possible, the hook where the coat will hang, is chosen like this. First the employee chooses the longest segment among available hooks following in a row. If there are several of such segments, then he chooses the one closest to the right. After that the coat is hung on the hook located in the middle of this segment. If the segment has an even number of hooks, then among two central hooks we choose the one closest to the right.When an employee leaves, he takes his coat. As all the company workers deeply respect each other, no one takes somebody else's coat.From time to time the director of this respectable company gets bored and he sends his secretary to see how many coats hang on the coat hanger from the i-th to the j-th hook inclusive. And this whim is always to be fulfilled, otherwise the director gets angry and has a mental breakdown.Not to spend too much time traversing from the director's office to the cloakroom and back again, the secretary asked you to write a program, emulating the company cloakroom's work. nan import sys
from heapq import *    
n,q = map(int,raw_input().split())
rl = sys.stdin.readline
z,l,r,t = {},{},{},{}
h = []
qq = 2*q+2
a = [True]*qq
b,e = [0]*qq,[0]*qq
ac = 0
def add(bb,ee):
    global b,e,h,ac
    if bb>=ee:
	l[ee]=r[bb-1]=0
	return
    b[ac]=bb
    e[ac]=ee
    r[bb-1]=l[ee]=ac
    heappush(h,(bb-ee,-ee,bb,ac))
    ac+=1
add (1,n+1)
def f(x):
    r = 0
    while x: r+=t.get(x,0); x-=x&-x; 
    return r
for _ in xrange(q):
    p = rl()
    if p[0]=='0':
	_,i,j = map(int,p.split())
	print f(j)-f(i-1)
    else:
	i = int(p)
	if i in z:
	    m = z[i]
	    a[l[m]]=a[r[m]]=False
	    bb=b[l[m]] if l[m] else m
	    ee=e[r[m]] if r[m] else m+1
	    add(bb,ee)
	    del z[i]
	    d=-1
	else:
	    while 1:
		_,ee,bb,j = heappop(h)
		if a[j]: break
	    m = (-ee+bb)/2
	    add(bb,m)
	    add(m+1,-ee)
	    z[i] = m
	    d=1
	while m<=n: t[m]=t.get(m,0)+d; m+=m&-m
",['data structures']
2022,"You are given a sequence of integers of length $$$n$$$ and integer number $$$k$$$. You should print any integer number $$$x$$$ in the range of $$$[1; 10^9]$$$ (i.e. $$$1 \le x \le 10^9$$$) such that exactly $$$k$$$ elements of given sequence are less than or equal to $$$x$$$.Note that the sequence can contain equal elements.If there is no such $$$x$$$, print ""-1"" (without quotes). NoteIn the first example $$$5$$$ is also a valid answer because the elements with indices $$$[1, 3, 4, 6]$$$ is less than or equal to $$$5$$$ and obviously less than or equal to $$$6$$$.In the second example you cannot choose any number that only $$$2$$$ elements of the given sequence will be less than or equal to this number because $$$3$$$ elements of the given sequence will be also less than or equal to this number. n, k = map(int, input().split())
a = list(map(int, input().split()))
a.sort()
if k == 0:
    if a[0] == 1:
        print(-1)
    else:
        print(1)
elif k == n:
    print(10 ** 9)
elif k < n:
    if a[k] > a[k-1]:
        print(a[k]-1)
    else:
        print(-1)
",['sortings']
1714,"Your friend is developing a computer game. He has already decided how the game world should look like — it should consist of $$$n$$$ locations connected by $$$m$$$ two-way passages. The passages are designed in such a way that it should be possible to get from any location to any other location.Of course, some passages should be guarded by the monsters (if you just can go everywhere without any difficulties, then it's not fun, right?). Some crucial passages will be guarded by really fearsome monsters, requiring the hero to prepare for battle and designing his own tactics of defeating them (commonly these kinds of monsters are called bosses). And your friend wants you to help him place these bosses.The game will start in location $$$s$$$ and end in location $$$t$$$, but these locations are not chosen yet. After choosing these locations, your friend will place a boss in each passage such that it is impossible to get from $$$s$$$ to $$$t$$$ without using this passage. Your friend wants to place as much bosses as possible (because more challenges means more fun, right?), so he asks you to help him determine the maximum possible number of bosses, considering that any location can be chosen as $$$s$$$ or as $$$t$$$. nan from sys import stdin
from itertools import repeat
def main():
    n, m = map(int, stdin.readline().split())
    dat = map(int, stdin.read().split(), repeat(10, 2 * m))
    xt = [None] * (2 * m)
    la = [None] * (n + 1)
    j = 0
    for i in xrange(m):
        x, y = dat[j], dat[j+1]
        xt[j] = la[y]
        la[y] = j
        j += 1
        xt[j] = la[x]
        la[x] = j
        j += 1
    st = [(1, 0, la[1])]
    po = st.pop
    pu = st.append
    itr = la[:]
    c = 1
    low = [0] * (n + 1)
    d = [0] * (n + 1)
    gn = 0
    g = [0] * (n + 1)
    ss = []
    pos = ss.pop
    pus = ss.append
    ins = [0] * (n + 1)
    b = []
    while st:
        x, p, it = po()
        if not d[x]:
            low[x] = d[x] = c
            c += 1
            pus(x)
            ins[x] = 1
        else:
            if low[x] > low[dat[it]]:
                low[x] = low[dat[it]]
            it = xt[it]
        while it is not None and d[dat[it]]:
            y = dat[it]
            if y != p and low[x] > d[y]:
                low[x] = d[y]
            it = xt[it]
        if it is None:
            if low[x] == d[x]:
                while 1:
                    v = pos()
                    ins[v] = 0
                    g[v] = gn
                    if v == x:
                        break
                if p:
                    b.extend((x, p))
                gn += 1
        else:
            pu((x, p, it))
            pu((dat[it], x, la[dat[it]]))
    dat = [g[x] for x in b]
    m = len(dat) / 2
    xt = [None] * (2 * m)
    la = [None] * gn
    j = 0
    for i in xrange(m):
        x, y = dat[j], dat[j+1]
        xt[j] = la[y]
        la[y] = j
        j += 1
        xt[j] = la[x]
        la[x] = j
        j += 1
    d = [None] * gn
    pu(0)
    d[0] = 0
    while st:
        x = po()
        y = la[x]
        while y is not None:
            z = dat[y]
            if d[z] is None:
                d[z] = d[x] + 1
                pu(z)
            y = xt[y]
    z = v = -1
    for i, x in enumerate(d):
        if z < x:
            z = x
            v = i
    d = [None] * gn
    pu(v)
    d[v] = 0
    while st:
        x = po()
        y = la[x]
        while y is not None:
            z = dat[y]
            if d[z] is None:
                d[z] = d[x] + 1
                pu(z)
            y = xt[y]
    print max(d)
main()
","['dfs and similar', 'graphs', 'trees']"
3044,"Vasya is preparing a contest, and now he has written a statement for an easy problem. The statement is a string of length $$$n$$$ consisting of lowercase Latin latters. Vasya thinks that the statement can be considered hard if it contains a subsequence hard; otherwise the statement is easy. For example, hard, hzazrzd, haaaaard can be considered hard statements, while har, hart and drah are easy statements. Vasya doesn't want the statement to be hard. He may remove some characters from the statement in order to make it easy. But, of course, some parts of the statement can be crucial to understanding. Initially the ambiguity of the statement is $$$0$$$, and removing $$$i$$$-th character increases the ambiguity by $$$a_i$$$ (the index of each character is considered as it was in the original statement, so, for example, if you delete character r from hard, and then character d, the index of d is still $$$4$$$ even though you delete it from the string had).Vasya wants to calculate the minimum ambiguity of the statement, if he removes some characters (possibly zero) so that the statement is easy. Help him to do it!Recall that subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements. NoteIn the first example, first two characters are removed so the result is ardh.In the second example, $$$5$$$-th character is removed so the result is hhzawde.In the third example there's no need to remove anything. n = input()
s = raw_input()
a = map(int, raw_input().split())
d = [[0] * 4 for i in range(n)]

if s[0] == 'h': d[0][0] = a[0]
for i in range(1, n):
    if s[i] == 'h':
        d[i][0] = d[i - 1][0] + a[i]
        d[i][1] = min(d[i - 1][1], d[i - 1][0])
        d[i][2] = d[i - 1][2]
        d[i][3] = d[i - 1][3]
    elif s[i] == 'a':
        d[i][0] = d[i - 1][0]
        d[i][1] = d[i - 1][1] + a[i]
        d[i][2] = min(d[i - 1][2], d[i - 1][1])
        d[i][3] = d[i - 1][3]
    elif s[i] == 'r':
        d[i][0] = d[i - 1][0]
        d[i][1] = d[i - 1][1]
        d[i][2] = d[i - 1][2] + a[i]
        d[i][3] = min(d[i - 1][3], d[i - 1][2])
    elif s[i] == 'd':
        d[i][0] = d[i - 1][0]
        d[i][1] = d[i - 1][1]
        d[i][2] = d[i - 1][2]
        d[i][3] = d[i - 1][3] + a[i]
    else:
        d[i][0] = d[i - 1][0]
        d[i][1] = d[i - 1][1]
        d[i][2] = d[i - 1][2]
        d[i][3] = d[i - 1][3]


print min(d[-1])
",['dp']
2287,"Today s kilometer long auto race takes place in Berland. The track is represented by a straight line as long as s kilometers. There are n cars taking part in the race, all of them start simultaneously at the very beginning of the track. For every car is known its behavior — the system of segments on each of which the speed of the car is constant. The j-th segment of the i-th car is pair (vi, j, ti, j), where vi, j is the car's speed on the whole segment in kilometers per hour and ti, j is for how many hours the car had been driving at that speed. The segments are given in the order in which they are ""being driven on"" by the cars.Your task is to find out how many times during the race some car managed to have a lead over another car. A lead is considered a situation when one car appears in front of another car. It is known, that all the leads happen instantly, i. e. there are no such time segment of positive length, during which some two cars drive ""together"". At one moment of time on one and the same point several leads may appear. In this case all of them should be taken individually. Meetings of cars at the start and finish are not considered to be counted as leads. nan def foo():
	n, s0 = map(int, raw_input().split())
	d = []
	v = []
	t = []
	for i in range(1, n + 1):
		a = map(int, raw_input().split())
		d.append(a[0])
		v0 = []
		t0 = []
		for j in range(1, 2 * a[0], 2):
			v0.append(a[j])
			t0.append(0)
			t0[-1] = t0[-2] + a[j + 1] if len(t0) >= 2 else a[j + 1]
		v.append(v0)
		t.append(t0)
	ans = 0
	for i in range(n):
		for j in range(i + 1, n):
			p1, p2, s1, s2, t0, pre = [0, 0, 0, 0, 0, -1]
			while p1 < d[i] and p2 < d[j]:
				if t[i][p1] < t[j][p2]:
					s1 += (t[i][p1] - t0) * v[i][p1]
					s2 += (t[i][p1] - t0) * v[j][p2]
					t0 = t[i][p1]
					p1 += 1
				elif t[i][p1] > t[j][p2]:
					s1 += (t[j][p2] - t0) * v[i][p1]
					s2 += (t[j][p2] - t0) * v[j][p2]
					t0 = t[j][p2]
					p2 += 1
				else:
					s1 += (t[i][p1] - t0) * v[i][p1]
					s2 += (t[i][p1] - t0) * v[j][p2]
					t0 = t[i][p1]
					p1 += 1
					p2 += 1
				if s1 > s2:
					if pre == j: ans += 1
					pre = i
				if s1 < s2:
					if pre == i: ans += 1
					pre = j
	return ans

print foo()
			
","['brute force', 'implementation', 'two pointers']"
1295,"Every evening Vitalya sets n alarm clocks to wake up tomorrow. Every alarm clock rings during exactly one minute and is characterized by one integer ai — number of minute after midnight in which it rings. Every alarm clock begins ringing at the beginning of the minute and rings during whole minute. Vitalya will definitely wake up if during some m consecutive minutes at least k alarm clocks will begin ringing. Pay attention that Vitalya considers only alarm clocks which begin ringing during given period of time. He doesn't consider alarm clocks which started ringing before given period of time and continues ringing during given period of time.Vitalya is so tired that he wants to sleep all day long and not to wake up. Find out minimal number of alarm clocks Vitalya should turn off to sleep all next day. Now all alarm clocks are turned on.  NoteIn first example Vitalya should turn off first alarm clock which rings at minute 3.In second example Vitalya shouldn't turn off any alarm clock because there are no interval of 10 consequence minutes in which 3 alarm clocks will ring.In third example Vitalya should turn off any 6 alarm clocks. 
n,m,k = map(int,input().split())
Alarm = [int(x) for x in input().split()]
ringing_now = []
Ans = 0
Alarm = list(set(Alarm)) # To remove duplicacy
Alarm.sort()

for i in range(n):
    # Just append it . Don't Check Now.
    ringing_now.append(Alarm[i])
    # NOw check two condition.
    # 1. if there are more than k alarms ringing now
    # 2. and simultaneously diff bw max and min is less than m
    if(len(ringing_now)>=k and ringing_now[-1] - ringing_now[len(ringing_now)-k]<m):
        ringing_now.pop()
        Ans += 1
print(Ans)
",['greedy']
3832,"You are given a string $$$s$$$ consisting of $$$n$$$ lowercase Latin letters.Let's define a substring as a contiguous subsegment of a string. For example, ""acab"" is a substring of ""abacaba"" (it starts in position $$$3$$$ and ends in position $$$6$$$), but ""aa"" or ""d"" aren't substrings of this string. So the substring of the string $$$s$$$ from position $$$l$$$ to position $$$r$$$ is $$$s[l; r] = s_l s_{l + 1} \dots s_r$$$.You have to choose exactly one of the substrings of the given string and reverse it (i. e. make $$$s[l; r] = s_r s_{r - 1} \dots s_l$$$) to obtain a string that is less lexicographically. Note that it is not necessary to obtain the minimum possible string.If it is impossible to reverse some substring of the given string to obtain a string that is less, print ""NO"". Otherwise print ""YES"" and any suitable substring.String $$$x$$$ is lexicographically less than string $$$y$$$, if either $$$x$$$ is a prefix of $$$y$$$ (and $$$x \ne y$$$), or there exists such $$$i$$$ ($$$1 \le i \le min(|x|, |y|)$$$), that $$$x_i &lt; y_i$$$, and for any $$$j$$$ ($$$1 \le j &lt; i$$$) $$$x_j = y_j$$$. Here $$$|a|$$$ denotes the length of the string $$$a$$$. The lexicographic comparison of strings is implemented by operator &lt; in modern programming languages​​. NoteIn the first testcase the resulting string is ""aacabba"". '''input
6
aabcfg
'''
from sys import stdin, stdout
import math
from copy import deepcopy
from collections import defaultdict
import heapq


# main starts
n = int(stdin.readline().strip())
string = list(stdin.readline().strip())
for i in range(1, len(string)):
	if string[i - 1] <= string[i]:
		continue
	else:
		string[i - 1], string[i] = string[i], string[i - 1]
		print('YES')
		print(i, i + 1)
		break
else:
	print(""NO"")
","['implementation', 'sortings', 'strings']"
1504,"You are given a graph with $$$3 \cdot n$$$ vertices and $$$m$$$ edges. You are to find a matching of $$$n$$$ edges, or an independent set of $$$n$$$ vertices.A set of edges is called a matching if no two edges share an endpoint.A set of vertices is called an independent set if no two vertices are connected with an edge. NoteThe first two graphs are same, and there are both a matching of size 1 and an independent set of size 1. Any of these matchings and independent sets is a correct answer.The third graph does not have a matching of size 2, however, there is an independent set of size 2. Moreover, there is an independent set of size 5: 2 3 4 5 6. However such answer is not correct, because you are asked to find an independent set (or matching) of size exactly $$$n$$$.The fourth graph does not have an independent set of size 2, but there is a matching of size 2. import sys
input = sys.stdin.readline

def main():
    tes = int(input())
    for testcase in [0]*tes:
        n,m = map(int,input().split())
        new = [True]*(3*n)
        res = []

        for i in range(1,m+1):
            u,v = map(int,input().split())
            if new[u-1] and new[v-1]:
                if len(res) < n:
                    res.append(i)
                    new[u-1] = new[v-1] = False

        
        if len(res) >= n:
            print(""Matching"")
            print(*res)
        else:
            vs = []
            for i in range(3*n):
                if new[i]:
                    vs.append(i+1)
                    if len(vs) >= n:
                        break
            print(""IndSet"")
            print(*vs)

if __name__ == '__main__':
    main()","['constructive algorithms', 'graphs', 'greedy']"
763,"Petya has a simple graph (that is, a graph without loops or multiple edges) consisting of $$$n$$$ vertices and $$$m$$$ edges.The weight of the $$$i$$$-th vertex is $$$a_i$$$.The weight of the $$$i$$$-th edge is $$$w_i$$$.A subgraph of a graph is some set of the graph vertices and some set of the graph edges. The set of edges must meet the condition: both ends of each edge from the set must belong to the chosen set of vertices. The weight of a subgraph is the sum of the weights of its edges, minus the sum of the weights of its vertices. You need to find the maximum weight of subgraph of given graph. The given graph does not contain loops and multiple edges. NoteIn the first test example, the optimal subgraph consists of the vertices $$${1, 3, 4}$$$ and has weight $$$4 + 4 + 5 - (1 + 2 + 2) = 8$$$. In the second test case, the optimal subgraph is empty. class edge(object):
	def __init__(self,ne,to,fl):
		self.ne=ne
		self.to=to
		self.fl=fl

def add(x,y,z):
	global tot
	tot+=1
	e.append(edge(he[x],y,z))
	he[x]=tot

def addedge(x,y,z):
	add(x,y,z)
	add(y,x,0)

def bfs():
	global deep
	deep=[0 for i in range(T+1)]
	q=[]
	q.append(S)
	deep[S]=1
	lp=0
	while (len(q)>lp):
		x=q[lp]
		lp+=1
		i=he[x]
		while (i):
			y=e[i].to
			if ((deep[y]==0)and(e[i].fl!=0)):
				deep[y]=deep[x]+1
				q.append(y)
			i=e[i].ne
	return deep[T]!=0

def dfs(x,flow):
	global deep
	if ((x==T)or(flow==0)):
		return flow
	used=0
	i=he[x]
	while (i):
		y=e[i].to
		if ((deep[y]==deep[x]+1)and(e[i].fl!=0)):
			now=dfs(y,min(flow-used,e[i].fl))
			used+=now
			e[i].fl-=now
			e[i^1].fl+=now
			if (flow==used):
				break;
		i=e[i].ne
	if (used==0):
		deep[x]=-1
	return used

def dinic():
	res=0
	while (bfs()):
		res+=dfs(S,INF)
	return res

n,m=map(int,input().split())
ans=0
weight=[0]+list(map(int,input().split()))

e=[0,0]
tot=1
S=n+m+1
T=S+1
he=[0 for i in range(T+1)]
INF=1000000007#只要>10^9就足够了

for i in range(1,n+1):
	addedge(S,i,weight[i]);
for i in range(1,m+1):
	x,y,w=map(int,input().split())
	addedge(n+i,T,w)
	addedge(x,n+i,INF)
	addedge(y,n+i,INF)
	ans+=w
ans-=dinic()
print(ans)","['graphs', 'other']"
4342,"Mike wants to prepare for IMO but he doesn't know geometry, so his teacher gave him an interesting geometry problem. Let's define f([l, r]) = r - l + 1 to be the number of integer points in the segment [l, r] with l ≤ r (say that ). You are given two integers n and k and n closed intervals [li, ri] on OX axis and you have to find:  In other words, you should find the sum of the number of integer points in the intersection of any k of the segments. As the answer may be very large, output it modulo 1000000007 (109 + 7).Mike can't solve this problem so he needs your help. You will help him, won't you?  NoteIn the first example: ;;.So the answer is 2 + 1 + 2 = 5. from sys import stdin
from itertools import repeat
def main():
    n, k = map(int, stdin.readline().split())
    mod = 10 ** 9 + 7
    f = [1] * (n + 1)
    inv = [1] * (n + 1)
    invf = [1] * (n + 1)
    for i in xrange(2, n + 1):
        f[i] = f[i-1] * i % mod
        inv[i] = mod - mod / i * inv[mod%i] % mod
        invf[i] = invf[i-1] * inv[i] % mod
    dat = map(int, stdin.read().split(), repeat(10, 2 * n))
    for i in xrange(1, 2 * n, 2):
        dat[i] += 1
    s = list(set(dat))
    s.sort()
    d = {x: i for i, x in enumerate(s)}
    l = len(d)
    ev = [0 for _ in xrange(l)]
    for i in xrange(n):
        x, y = dat[i*2], dat[i*2+1]
        ev[d[x]] += 1
        ev[d[y]] -= 1
    p = s[0]
    t = ev[0]
    ans = 0
    def comb(a, b):
        return f[a] * invf[b] * invf[a-b] % mod
    for i in xrange(1, l):
        q = s[i]
        if t >= k:
            ans += (q - p) * comb(t, k)
            ans %= mod
        t += ev[i]
        p = q
    print ans
main()
","['combinatorics', 'data structures', 'dp', 'geometry', 'implementation']"
373,"It turns out that you are a great fan of rock band AC/PE. Peter learned that and started the following game: he plays the first song of the list of n songs of the group, and you have to find out the name of the song. After you tell the song name, Peter immediately plays the following song in order, and so on.The i-th song of AC/PE has its recognizability pi. This means that if the song has not yet been recognized by you, you listen to it for exactly one more second and with probability of pi percent you recognize it and tell it's name. Otherwise you continue listening it. Note that you can only try to guess it only when it is integer number of seconds after the moment the song starts playing.In all AC/PE songs the first words of chorus are the same as the title, so when you've heard the first ti seconds of i-th song and its chorus starts, you immediately guess its name for sure.For example, in the song Highway To Red the chorus sounds pretty late, but the song has high recognizability. In the song Back In Blue, on the other hand, the words from the title sound close to the beginning of the song, but it's hard to name it before hearing those words. You can name both of these songs during a few more first seconds.Determine the expected number songs of you will recognize if the game lasts for exactly T seconds (i. e. you can make the last guess on the second T, after that the game stops).If all songs are recognized faster than in T seconds, the game stops after the last song is recognized. nan def main():
    n, time = map(int, raw_input().split())
    pp, qq, tt, qqtt = [], [], [], []
    for i in xrange(n):
        a, b = raw_input().split()
        p = float(a) / 100.
        pp.append(p)
        q = 1. - p
        qq.append(q)
        t = int(b) - 1
        tt.append(t)
        qqtt.append(q ** t)
    t_cur, u_cur, t_prev, u_prev = ([0.] * (time + 1) for _ in '1234')
    for k in xrange(n - 1, 0, -1):
        q_1, t_1, qt_1 = qq[k - 1], tt[k - 1], qqtt[k - 1]
        p, t, qt = pp[k], tt[k], qqtt[k]
        q = w = qq[k]
        for i in xrange(time):
            t_cur[i + 1] = x = ((p * u_prev[i] + 1. - w) if i < t else
                                (p * u_prev[i] + qt * t_prev[i - t] + 1.))
            u_cur[i + 1] = ((q_1 * u_cur[i] + x) if i + 1 < t_1 else
                            (q_1 * u_cur[i] + x - qt_1 * t_cur[i - t_1 + 1]))
            w *= q
        t_cur, u_cur, t_prev, u_prev = t_prev, u_prev, t_cur, u_cur
        t_cur[0] = u_cur[0] = 0.
    p, t, qt = pp[0], tt[0], qqtt[0]
    q = w = qq[0]
    for i in xrange(t):
        t_cur[i + 1] = p * u_prev[i] + 1. - w
        w *= q
    for i in xrange(t, time):
        t_cur[i + 1] = p * u_prev[i] + qt * t_prev[i - t] + 1.
    print('{:.12f}'.format(t_cur[-1]))


if __name__ == '__main__':
    main()
","['dp', 'two pointers']"
1128,"Once Bob took a paper stripe of n squares (the height of the stripe is 1 square). In each square he wrote an integer number, possibly negative. He became interested in how many ways exist to cut this stripe into three pieces so that the sum of numbers from each piece is equal to the sum of numbers from any other piece, and each piece contains positive integer amount of squares. Would you help Bob solve this problem? nan from itertools import accumulate
n = int(input())
a = list(map(int, input().split()))
s = sum(a)
p = s // 3
k = list(accumulate(a))
r = list(accumulate(x == 2*p for x in reversed(k)))
print(0 if s%3 else sum(r[-1-i] - 2*(not p) for i,x in enumerate(k[:-1]) if x == p))","['binary search', 'dp', 'sortings']"
1215,"You are playing a game similar to Sokoban on an infinite number line. The game is discrete, so you only consider integer positions on the line.You start on a position $$$0$$$. There are $$$n$$$ boxes, the $$$i$$$-th box is on a position $$$a_i$$$. All positions of the boxes are distinct. There are also $$$m$$$ special positions, the $$$j$$$-th position is $$$b_j$$$. All the special positions are also distinct.In one move you can go one position to the left or to the right. If there is a box in the direction of your move, then you push the box to the next position in that direction. If the next position is taken by another box, then that box is also pushed to the next position, and so on. You can't go through the boxes. You can't pull the boxes towards you.You are allowed to perform any number of moves (possibly, zero). Your goal is to place as many boxes on special positions as possible. Note that some boxes can be initially placed on special positions. NoteIn the first testcase you can go $$$5$$$ to the right: the box on position $$$1$$$ gets pushed to position $$$6$$$ and the box on position $$$5$$$ gets pushed to position $$$7$$$. Then you can go $$$6$$$ to the left to end up on position $$$-1$$$ and push a box to $$$-2$$$. At the end, the boxes are on positions $$$[-2, 6, 7, 11, 15]$$$, respectively. Among them positions $$$[-2, 6, 7, 15]$$$ are special, thus, the answer is $$$4$$$.In the second testcase you can push the box from $$$-1$$$ to $$$-10^9$$$, then the box from $$$1$$$ to $$$10^9$$$ and obtain the answer $$$2$$$.The third testcase showcases that you are not allowed to pull the boxes, thus, you can't bring them closer to special positions.In the fourth testcase all the boxes are already on special positions, so you can do nothing and still obtain the answer $$$3$$$.In the fifth testcase there are fewer special positions than boxes. You can move either $$$8$$$ or $$$9$$$ to the right to have some box on position $$$10$$$. import sys
from collections import defaultdict
from bisect import bisect_left, bisect_right
input = sys.stdin.readline

def solve():
    n, m = list(map(int, input().split()))
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))
    # start at 0; < 0; > 0
    # x x + 1 x + 2...
    # two parts
    x1, y1 = bisect_left(a, 0), bisect_left(b, 0)

    # 核心思路：把连续箱子中的最右的位置放到特殊位置上，这样可以对于每个特殊位置的左边覆盖最多的位置
    ans = 0

    def get_max_num(a, b):
        mp = defaultdict(int)
        for v in a:
            mp[v] = 1
        # original same
        same = 0
        for v in b:
            if mp[v] == 1:
                same += 1
        maxn = same
        for i, v in enumerate(b):
            # delete 1

            # if v in mp => Ologn
            if mp[v] == 1: # O1
                same -= 1
            # core
            # how many concutive(including same)
            idx1 = bisect_right(a, v)
            # how many special(most left: v - idx1 + 1, most right:v)
            idx2 = bisect_left(b, v - idx1 + 1)
            maxn = max(maxn, same + i - idx2 + 1)
        return maxn

    ans += get_max_num(a[x1:], b[y1:])


    new_a = [-aa for aa in a[:x1]]
    new_b = [-bb for bb in b[:y1]]

    ans += get_max_num(new_a[::-1], new_b[::-1])
    print(ans)












if __name__ == '__main__':
    for _ in range(int(input())):
        solve()","['binary search', 'dp', 'greedy', 'implementation', 'two pointers']"
2115,"Inna and Dima bought a table of size n × m in the shop. Each cell of the table contains a single letter: ""D"", ""I"", ""M"", ""A"".Inna loves Dima, so she wants to go through his name as many times as possible as she moves through the table. For that, Inna acts as follows:  initially, Inna chooses some cell of the table where letter ""D"" is written;  then Inna can move to some side-adjacent table cell that contains letter ""I""; then from this cell she can go to one of the side-adjacent table cells that contains the written letter ""M""; then she can go to a side-adjacent cell that contains letter ""A"". Then Inna assumes that she has gone through her sweetheart's name;  Inna's next move can be going to one of the side-adjacent table cells that contains letter ""D"" and then walk on through name DIMA in the similar manner. Inna never skips a letter. So, from the letter ""D"" she always goes to the letter ""I"", from the letter ""I"" she always goes the to letter ""M"", from the letter ""M"" she always goes to the letter ""A"", and from the letter ""A"" she always goes to the letter ""D"". Depending on the choice of the initial table cell, Inna can go through name DIMA either an infinite number of times or some positive finite number of times or she can't go through his name once. Help Inna find out what maximum number of times she can go through name DIMA. NoteNotes to the samples:In the first test sample, Inna cannot go through name DIMA a single time.In the second test sample, Inna can go through the infinite number of words DIMA. For that, she should move in the clockwise direction starting from the lower right corner.In the third test sample the best strategy is to start from the cell in the upper left corner of the table. Starting from this cell, Inna can go through name DIMA four times.  import sys
n, m = map(int, input().split())
m += 1
d = {'I': 0, 'M': 1, 'A': 2, 'D': 3, '\n': -7}
t = list(map(d.get, sys.stdin.read())) + [-7] * m
p = [[] for q in t]
c = [0] * len(t)
for a in range(n * m):
    for b in (a - m, a + m, a - 1, a + 1):
        if abs(t[b] - t[a] + 1) == 2:
            p[a].append(b)
            c[b] += 1
s = [i for i, q in enumerate(c) if not q]
while s:
    a = s.pop()
    for b in p[a]:
        t[b] = max(t[b], t[a] + 1)
        c[b] -= 1
        if c[b] == 0: s.append(b)
k = max(t) - 2 >> 2
print('Poor Inna!' if any(c) else k if k > 0 else 'Poor Dima!')
","['dfs and similar', 'dp', 'graphs', 'implementation']"
109,"Let $$$a_1, \ldots, a_n$$$ be an array of $$$n$$$ positive integers. In one operation, you can choose an index $$$i$$$ such that $$$a_i = i$$$, and remove $$$a_i$$$ from the array (after the removal, the remaining parts are concatenated).The weight of $$$a$$$ is defined as the maximum number of elements you can remove.You must answer $$$q$$$ independent queries $$$(x, y)$$$: after replacing the $$$x$$$ first elements of $$$a$$$ and the $$$y$$$ last elements of $$$a$$$ by $$$n+1$$$ (making them impossible to remove), what would be the weight of $$$a$$$? NoteExplanation of the first query:After making first $$$x = 3$$$ and last $$$y = 1$$$ elements impossible to remove, $$$a$$$ becomes $$$[\times, \times, \times, 9, 5, 4, 6, 5, 7, 8, 3, 11, \times]$$$ (we represent $$$14$$$ as $$$\times$$$ for clarity).Here is a strategy that removes $$$5$$$ elements (the element removed is colored in red):  $$$[\times, \times, \times, 9, \color{red}{5}, 4, 6, 5, 7, 8, 3, 11, \times]$$$  $$$[\times, \times, \times, 9, 4, 6, 5, 7, 8, 3, \color{red}{11}, \times]$$$  $$$[\times, \times, \times, 9, 4, \color{red}{6}, 5, 7, 8, 3, \times]$$$  $$$[\times, \times, \times, 9, 4, 5, 7, \color{red}{8}, 3, \times]$$$  $$$[\times, \times, \times, 9, 4, 5, \color{red}{7}, 3, \times]$$$  $$$[\times, \times, \times, 9, 4, 5, 3, \times]$$$ (final state) It is impossible to remove more than $$$5$$$ elements, hence the weight is $$$5$$$. class Fenwick:
    def __init__(self, size):
        self.size = size
        self.tree = [0] * (size + 1)

    def add(self, idx, val):
        idx = int(idx)
        while idx <= self.size:
            self.tree[idx] += val
            idx += idx & (-idx)

    def sum(self, idx):
        ret = 0
        idx = int(idx)
        while idx > 0:
            ret += self.tree[idx]
            idx -= idx & (-idx)
        return ret


n, q = map(int, input().split())
A = [int(x) for x in input().split()]
A = [A[i] - (i + 1) for i in range(n)]
query = [[] for _ in range(n + 1)]
for i in range(q):
    x, y = map(int, input().split())
    l, r = x, n - y - 1
    query[r].append((l, i))
ft = Fenwick(n + 1)

# ans = [0 for _ in range(q + 3)]
# for r in range(n):
#     ob = A[r]
#     if ob <= 0:
#         if ft.sum(1) >= -ob:
#             low, high = 0, r
#             while low + 1 < high:
#                 mid = low + high >> 1;
#                 if ft.sum(mid + 1) >= -ob:
#                     low = mid
#                 else: high = mid
#             idx = low
#             if ft.sum(high + 1) >= -ob:
#                 idx = max(idx, high)
#             ft.add(1, 1)
#             ft.add(idx + 2, -1)
#     for qr in query[r]:
#         ans[qr[1]] = ft.sum(qr[0] + 1)
#
# for _ in range(q):
#     print(ans[_])

ans = [0 for _ in range(q + 3)]
for r in range(n):
    ob = A[r]
    if ob <= 0:
        if ft.sum(1) >= -ob:
            low, high = 0, r
            while low + 1 < high:
                mid = low + high >> 1
                if ft.sum(mid + 1) >= -ob:
                    low = mid
                else: high = mid
            idx = high if ft.sum(high + 1) >= -ob else low
            ft.add(1, 1)
            ft.add(idx + 2, -1)
    for qr in query[r]:
        ans[qr[1]] = ft.sum(qr[0] + 1)
for _ in range(q):
    print(ans[_])","['binary search', 'data structures', 'sortings']"
2067,"This is the hard version of the problem. The difference is that in this version the array contains zeros. You can make hacks only if both versions of the problem are solved.You are given an array $$$[a_1, a_2, \ldots a_n]$$$ consisting of integers $$$-1$$$, $$$0$$$ and $$$1$$$. You have to build a partition of this array into the set of segments $$$[l_1, r_1], [l_2, r_2], \ldots, [l_k, r_k]$$$ with the following property:  Denote the alternating sum of all elements of the $$$i$$$-th segment as $$$s_i$$$: $$$s_i$$$ = $$$a_{l_i} - a_{l_i+1} + a_{l_i+2} - a_{l_i+3} + \ldots \pm a_{r_i}$$$. For example, the alternating sum of elements of segment $$$[2, 4]$$$ in array $$$[1, 0, -1, 1, 1]$$$ equals to $$$0 - (-1) + 1 = 2$$$.  The sum of $$$s_i$$$ over all segments of partition should be equal to zero. Note that each $$$s_i$$$ does not have to be equal to zero, this property is about sum of $$$s_i$$$ over all segments of partition.The set of segments $$$[l_1, r_1], [l_2, r_2], \ldots, [l_k, r_k]$$$ is called a partition of the array $$$a$$$ of length $$$n$$$ if $$$1 = l_1 \le r_1, l_2 \le r_2, \ldots, l_k \le r_k = n$$$ and $$$r_i + 1 = l_{i+1}$$$ for all $$$i = 1, 2, \ldots k-1$$$. In other words, each element of the array must belong to exactly one segment.You have to build a partition of the given array with properties described above or determine that such partition does not exist.Note that it is not required to minimize the number of segments in the partition. NoteIn the first test case we can build a partition of $$$4$$$ segments — each of them will contain only one element of the array equals to $$$0$$$. So the sum will be equal to $$$0 + 0 + 0 + 0 = 0$$$.In the second test case we can build a partition of $$$4$$$ segments. The alternating sum of the first segment will be equal to $$$-1$$$, the alternating sum of the second segment will be equal to $$$1$$$, of the third segment — $$$0 - 1 + 0 = -1$$$, of the fourth segment — $$$1 - 0 = 1$$$. The sum will be equal to $$$-1 + 1 -1 + 1 = 0$$$.In the third test case it can be proved that the required partition does not exist. t=int(input())
for _ in range(t):
    result=[]
    n=int(input())
    nlist=list(map(int,input().split()))
    if (n-nlist.count(0))%2==1:
        print(-1)
        continue
    i=0
    ans=0
    while i<n:
        if nlist[i]==0:
            j=i
            while j+1<n and nlist[j+1]==0:
                j=j+1
            if j==n-1:
                ans+=1
                result.append([i+1,j+1])
                break
            if nlist[j+2]==0:
                tempj=j+2
                while tempj+1<n and nlist[tempj+1]==0:
                    tempj=tempj+1
                if nlist[j+1]==nlist[tempj+1]:
                    if j==i:
                        ans+=3
                        result.append([i+1,i+2])
                        result.append([i+3,tempj+1])
                        result.append([tempj+2,tempj+2])
                        i=tempj+2
                    else:
                        ans+=4
                        result.append([i+1,j])
                        result.append([j+1,j+2])
                        result.append([j+3,tempj+1])
                        result.append([tempj+2,tempj+2])
                        i=tempj+2
                else:
                    ans+=4
                    result.append([i+1,j+1])
                    result.append([j+2,j+2])
                    result.append([j+3,tempj+1])
                    result.append([tempj+2,tempj+2])
                    i=tempj+2
            else:
                if nlist[j+1]==nlist[j+2]:
                    if j==i:
                        ans+=2
                        result.append([i+1,i+2])
                        result.append([i+3,i+3])
                        i=i+3
                    else:
                        ans+=3
                        result.append([i+1,j])
                        result.append([j+1,j+2])
                        result.append([j+3,j+3])
                        i=j+3
                else:
                    ans+=3
                    result.append([i+1,j+1])
                    result.append([j+2,j+2])
                    result.append([j+3,j+3])
                    i=j+3
                    
        else:
            if nlist[i+1]==0:
                j=i+1
                while j+1<n and nlist[j+1]==0:
                    j=j+1
                if nlist[i]==nlist[j+1]:
                    if j-i==1:
                        ans+=2
                        result.append([i+1,i+1])
                        result.append([i+2,i+3])
                        i=j+2
                    else:
                        ans+=3
                        result.append([i+1,i+1])
                        result.append([i+2,j])
                        result.append([j+1,j+2])
                        i=j+2
                else:
                    ans+=3
                    result.append([i+1,i+1])
                    result.append([i+2,j+1])
                    result.append([j+2,j+2])
                    i=j+2
            else:
                if nlist[i]==nlist[i+1]:
                    ans+=1
                    result.append([i+1,i+2])
                    i=i+2
                else:
                    ans+=2
                    result.append([i+1,i+1])
                    result.append([i+2,i+2])
                    i=i+2
    print(ans)
    for i in range(ans):
        print(result[i][0],result[i][1])","['constructive algorithms', 'dp', 'greedy']"
3793,"Pasha loves to send strictly positive integers to his friends. Pasha cares about security, therefore when he wants to send an integer $$$n$$$, he encrypts it in the following way: he picks three integers $$$a$$$, $$$b$$$ and $$$c$$$ such that $$$l \leq a,b,c \leq r$$$, and then he computes the encrypted value $$$m = n \cdot a + b - c$$$.Unfortunately, an adversary intercepted the values $$$l$$$, $$$r$$$ and $$$m$$$. Is it possible to recover the original values of $$$a$$$, $$$b$$$ and $$$c$$$ from this information? More formally, you are asked to find any values of $$$a$$$, $$$b$$$ and $$$c$$$ such that  $$$a$$$, $$$b$$$ and $$$c$$$ are integers,  $$$l \leq a, b, c \leq r$$$,  there exists a strictly positive integer $$$n$$$, such that $$$n \cdot a + b - c = m$$$.  NoteIn the first example $$$n = 3$$$ is possible, then $$$n \cdot 4 + 6 - 5 = 13 = m$$$. Other possible solutions include: $$$a = 4$$$, $$$b = 5$$$, $$$c = 4$$$ (when $$$n = 3$$$); $$$a = 5$$$, $$$b = 4$$$, $$$c = 6$$$ (when $$$n = 3$$$); $$$a = 6$$$, $$$b = 6$$$, $$$c = 5$$$ (when $$$n = 2$$$); $$$a = 6$$$, $$$b = 5$$$, $$$c = 4$$$ (when $$$n = 2$$$).In the second example the only possible case is $$$n = 1$$$: in this case $$$n \cdot 2 + 2 - 3 = 1 = m$$$. Note that, $$$n = 0$$$ is not possible, since in that case $$$n$$$ is not a strictly positive integer. # -*- coding: utf-8 -*-
""""""
Created on Tue Jul 21 01:33:02 2020

@author: Manan Tyagi
""""""
import math
t=int(input())
p=0
a=0
while t:
    t-=1
    l,r,m=map(int,input().split())
    mxd=r-l
    if m<l:
        pr=m-l
        c=r
        b=c+pr
        a=l
    elif m==l:
        a=l
        b=l
        c=l
        
        
        
    else:
        for i in range(r,l-1,-1):     #checking on every iteration
                                    
            n=math.floor(m/i)
            n1=math.ceil(m/i)
            f1=abs((n*i)-m)
            f2=abs((n1*i)-m)
            re=min(f1,f2)
            if re<=mxd:
                if re==f1:
                    p=n
                else:
                    p=n1
                a=i
                break
                
               
        
        #print(p)
        pr=m-(a*p)
        #print(pr)
        if pr>0:
            c=l
            b=c+pr
        else:
            c=r
            b=c+pr
            
        
    print(a,b,c)","['binary search', 'brute force', 'math', 'number theory']"
2021,"There is a straight snowy road, divided into n blocks. The blocks are numbered from 1 to n from left to right. If one moves from the i-th block to the (i + 1)-th block, he will leave a right footprint on the i-th block. Similarly, if one moves from the i-th block to the (i - 1)-th block, he will leave a left footprint on the i-th block. If there already is a footprint on the i-th block, the new footprint will cover the old one.  At the beginning, there were no footprints. Then polar bear Alice starts from the s-th block, makes a sequence of moves and ends in the t-th block. It is known that Alice never moves outside of the road. You are given the description of Alice's footprints. Your task is to find a pair of possible values of s, t by looking at the footprints. NoteThe first test sample is the one in the picture. n = input()
s = raw_input()
if ('R' in s) ^ ('L' in s):
    x = []
    flag = False
    for i in xrange(n):
        if not flag and (s[i] == 'R' or s[i] == 'L'):
            x.append(i)
            flag = True
        if flag and s[i] == '.':
            x.append(i)
            break
    if 'R' in s:
        print x[0] + 1, x[1] + 1
    else:
        print x[1], x[0]
else:
    print s.index('R') + 1, s.index('L')
    
","['greedy', 'implementation']"
3844,"You are given an array $$$a$$$ of $$$n$$$ positive integers. Let $$$\text{LIS}(a)$$$ denote the length of longest strictly increasing subsequence of $$$a$$$. For example,  $$$\text{LIS}([2, \underline{1}, 1, \underline{3}])$$$ = $$$2$$$.  $$$\text{LIS}([\underline{3}, \underline{5}, \underline{10}, \underline{20}])$$$ = $$$4$$$.  $$$\text{LIS}([3, \underline{1}, \underline{2}, \underline{4}])$$$ = $$$3$$$.  We define array $$$a'$$$ as the array obtained after reversing the array $$$a$$$ i.e. $$$a' = [a_n, a_{n-1}, \ldots , a_1]$$$.The beauty of array $$$a$$$ is defined as $$$min(\text{LIS}(a),\text{LIS}(a'))$$$.Your task is to determine the maximum possible beauty of the array $$$a$$$ if you can rearrange the array $$$a$$$ arbitrarily. NoteIn the first test case, $$$a$$$ = $$$[6, 6, 6]$$$ and $$$a'$$$ = $$$[6, 6, 6]$$$. $$$\text{LIS}(a) = \text{LIS}(a')$$$ = $$$1$$$. Hence the beauty is $$$min(1, 1) = 1$$$.In the second test case, $$$a$$$ can be rearranged to $$$[2, 5, 4, 5, 4, 2]$$$. Then $$$a'$$$ = $$$[2, 4, 5, 4, 5, 2]$$$. $$$\text{LIS}(a) = \text{LIS}(a') = 3$$$. Hence the beauty is $$$3$$$ and it can be shown that this is the maximum possible beauty.In the third test case, $$$a$$$ can be rearranged to $$$[1, 2, 3, 2]$$$. Then $$$a'$$$ = $$$[2, 3, 2, 1]$$$. $$$\text{LIS}(a) = 3$$$, $$$\text{LIS}(a') = 2$$$. Hence the beauty is $$$min(3, 2) = 2$$$ and it can be shown that $$$2$$$ is the maximum possible beauty. import sys
from collections import  Counter
from math import ceil

sys.setrecursionlimit(10**5)



def pro(arr):
    n=len(arr)
    dic = {}
    for i in range(n):
        dic[arr[i]]=dic.get(arr[i],0) + 1

    a,b=0,0
    for i,j in dic.items():
        if(j>=2):
            b+=1
        else:
            a+=1

    print(b+ceil(a/2) )




# check i/o format
# read q
# ordering matters in q ??
t=int(input())
#arr=list(map(int,input().split()))
for i in range(t):
    n=int(input())
    arr=list(map(int,input().split()))
    #arr=list(input())
    pro(arr)","['constructive algorithms', 'greedy', 'implementation', 'math']"
964,"Consider the insertion sort algorithm used to sort an integer sequence $$$[a_1, a_2, \ldots, a_n]$$$ of length $$$n$$$ in non-decreasing order.For each $$$i$$$ in order from $$$2$$$ to $$$n$$$, do the following. If $$$a_i \ge a_{i-1}$$$, do nothing and move on to the next value of $$$i$$$. Otherwise, find the smallest $$$j$$$ such that $$$a_i &lt; a_j$$$, shift the elements on positions from $$$j$$$ to $$$i-1$$$ by one position to the right, and write down the initial value of $$$a_i$$$ to position $$$j$$$. In this case we'll say that we performed an insertion of an element from position $$$i$$$ to position $$$j$$$.It can be noticed that after processing any $$$i$$$, the prefix of the sequence $$$[a_1, a_2, \ldots, a_i]$$$ is sorted in non-decreasing order, therefore, the algorithm indeed sorts any sequence.For example, sorting $$$[4, 5, 3, 1, 3]$$$ proceeds as follows:   $$$i = 2$$$: $$$a_2 \ge a_1$$$, do nothing;  $$$i = 3$$$: $$$j = 1$$$, insert from position $$$3$$$ to position $$$1$$$: $$$[3, 4, 5, 1, 3]$$$;  $$$i = 4$$$: $$$j = 1$$$, insert from position $$$4$$$ to position $$$1$$$: $$$[1, 3, 4, 5, 3]$$$;  $$$i = 5$$$: $$$j = 3$$$, insert from position $$$5$$$ to position $$$3$$$: $$$[1, 3, 3, 4, 5]$$$. You are given an integer $$$n$$$ and a list of $$$m$$$ integer pairs $$$(x_i, y_i)$$$. We are interested in sequences such that if you sort them using the above algorithm, exactly $$$m$$$ insertions will be performed: first from position $$$x_1$$$ to position $$$y_1$$$, then from position $$$x_2$$$ to position $$$y_2$$$, ..., finally, from position $$$x_m$$$ to position $$$y_m$$$.How many sequences of length $$$n$$$ consisting of (not necessarily distinct) integers between $$$1$$$ and $$$n$$$, inclusive, satisfy the above condition? Print this number modulo $$$998\,244\,353$$$. NoteIn the first test case, the algorithm performs no insertions — therefore, the initial sequence is already sorted in non-decreasing order. There are $$$10$$$ such sequences: $$$[1, 1, 1], [1, 1, 2], [1, 1, 3], [1, 2, 2], [1, 2, 3], [1, 3, 3], [2, 2, 2], [2, 2, 3], [2, 3, 3], [3, 3, 3]$$$.In the second test case, the only sequence satisfying the conditions is $$$[3, 2, 1]$$$.In the third test case, $$$[4, 5, 3, 1, 3]$$$ is one of the sought sequences. 
def divisors(M):
    d=[]
    i=1
    while M>=i**2:
        if M%i==0:
            d.append(i)
            if i**2!=M:
                d.append(M//i)
        i=i+1
    return d

def popcount(x):
    x = x - ((x >> 1) & 0x55555555)
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)
    x = (x + (x >> 4)) & 0x0f0f0f0f
    x = x + (x >> 8)
    x = x + (x >> 16)
    return x & 0x0000007f

def eratosthenes(n):
    res=[0 for i in range(n+1)]
    prime=set([])
    for i in range(2,n+1):
        if not res[i]:
            prime.add(i)
            for j in range(1,n//i+1):
                res[i*j]=1
    return prime

def factorization(n):
    res=[]
    for p in prime:
        if n%p==0:
            while n%p==0:
                n//=p
            res.append(p)
    if n!=1:
        res.append(n)
    return res

def euler_phi(n):
    res = n
    for x in range(2,n+1):
        if x ** 2 > n:
            break
        if n%x==0:
            res = res//x * (x-1)
            while n%x==0:
                n //= x
    if n!=1:
        res = res//n * (n-1)
    return res

def ind(b,n):
    res=0
    while n%b==0:
        res+=1
        n//=b
    return res

def isPrimeMR(n):
    d = n - 1
    d = d // (d & -d)
    L = [2, 3, 5, 7, 11, 13, 17]
    for a in L:
        t = d
        y = pow(a, t, n)
        if y == 1: continue
        while y != n - 1:
            y = (y * y) % n
            if y == 1 or t == n - 1: return 0
            t <<= 1
    return 1
def findFactorRho(n):
    from math import gcd
    m = 1 << n.bit_length() // 8
    for c in range(1, 99):
        f = lambda x: (x * x + c) % n
        y, r, q, g = 2, 1, 1, 1
        while g == 1:
            x = y
            for i in range(r):
                y = f(y)
            k = 0
            while k < r and g == 1:
                ys = y
                for i in range(min(m, r - k)):
                    y = f(y)
                    q = q * abs(x - y) % n
                g = gcd(q, n)
                k += m
            r <<= 1
        if g == n:
            g = 1
            while g == 1:
                ys = f(ys)
                g = gcd(abs(x - ys), n)
        if g < n:
            if isPrimeMR(g): return g
            elif isPrimeMR(n // g): return n // g
            return findFactorRho(g)
def primeFactor(n):
    i = 2
    ret = {}
    rhoFlg = 0
    while i*i <= n:
        k = 0
        while n % i == 0:
            n //= i
            k += 1
        if k: ret[i] = k
        i += 1 + i % 2
        if i == 101 and n >= 2 ** 20:
            while n > 1:
                if isPrimeMR(n):
                    ret[n], n = 1, 1
                else:
                    rhoFlg = 1
                    j = findFactorRho(n)
                    k = 0
                    while n % j == 0:
                        n //= j
                        k += 1
                    ret[j] = k

    if n > 1: ret[n] = 1
    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}
    return ret

def divisors(n):
    res = [1]
    prime = primeFactor(n)
    for p in prime:
        newres = []
        for d in res:
            for j in range(prime[p]+1):
                newres.append(d*p**j)
        res = newres
    res.sort()
    return res

def xorfactorial(num):
    if num==0:
        return 0
    elif num==1:
        return 1
    elif num==2:
        return 3
    elif num==3:
        return 0
    else:
        x=baseorder(num)
        return (2**x)*((num-2**x+1)%2)+function(num-2**x)

def xorconv(n,X,Y):
    if n==0:
        res=[(X[0]*Y[0])%mod]
        return res
    x=[X[i]+X[i+2**(n-1)] for i in range(2**(n-1))]
    y=[Y[i]+Y[i+2**(n-1)] for i in range(2**(n-1))]
    z=[X[i]-X[i+2**(n-1)] for i in range(2**(n-1))]
    w=[Y[i]-Y[i+2**(n-1)] for i in range(2**(n-1))]
    res1=xorconv(n-1,x,y)
    res2=xorconv(n-1,z,w)
    former=[(res1[i]+res2[i])*inv for i in range(2**(n-1))]
    latter=[(res1[i]-res2[i])*inv for i in range(2**(n-1))]
    former=list(map(lambda x:x%mod,former))
    latter=list(map(lambda x:x%mod,latter))
    return former+latter

def merge_sort(A,B):
    pos_A,pos_B = 0,0
    n,m = len(A),len(B)
    res = []
    while pos_A < n and pos_B < m:
        a,b = A[pos_A],B[pos_B]
        if a < b:
            res.append(a)
            pos_A += 1
        else:
            res.append(b)
            pos_B += 1
    res += A[pos_A:]
    res += B[pos_B:]
    return res

class UnionFindVerSize():
    def __init__(self, N):
        self._parent = [n for n in range(0, N)]
        self._size = [1] * N
        self.group = N

    def find_root(self, x):
        if self._parent[x] == x: return x
        self._parent[x] = self.find_root(self._parent[x])
        stack = [x]
        while self._parent[stack[-1]]!=stack[-1]:
            stack.append(self._parent[stack[-1]])
        for v in stack:
            self._parent[v] = stack[-1]
        return self._parent[x]

    def unite(self, x, y):
        gx = self.find_root(x)
        gy = self.find_root(y)
        if gx == gy: return

        self.group -= 1

        if self._size[gx] < self._size[gy]:
            self._parent[gx] = gy
            self._size[gy] += self._size[gx]
        else:
            self._parent[gy] = gx
            self._size[gx] += self._size[gy]

    def get_size(self, x):
        return self._size[self.find_root(x)]

    def is_same_group(self, x, y):
        return self.find_root(x) == self.find_root(y)

class WeightedUnionFind():
    def __init__(self,N):
        self.parent = [i for i in range(N)]
        self.size = [1 for i in range(N)]
        self.val = [0 for i in range(N)]
        self.flag = True
        self.edge = [[] for i in range(N)]

    def dfs(self,v,pv):
        stack = [(v,pv)]
        new_parent = self.parent[pv]
        while stack:
            v,pv = stack.pop()
            self.parent[v] = new_parent
            for nv,w in self.edge[v]:
                if nv!=pv:
                    self.val[nv] = self.val[v] + w
                    stack.append((nv,v))

    def unite(self,x,y,w):
        if not self.flag:
            return
        if self.parent[x]==self.parent[y]:
            self.flag = (self.val[x] - self.val[y] == w)
            return

        if self.size[self.parent[x]]>self.size[self.parent[y]]:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[x] += self.size[y]
            self.val[y] = self.val[x] - w
            self.dfs(y,x)
        else:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[y] += self.size[x]
            self.val[x] = self.val[y] + w
            self.dfs(x,y)

class Dijkstra():
    class Edge():
        def __init__(self, _to, _cost):
            self.to = _to
            self.cost = _cost

    def __init__(self, V):
        self.G = [[] for i in range(V)]
        self._E = 0
        self._V = V

    @property
    def E(self):
        return self._E

    @property
    def V(self):
        return self._V

    def add_edge(self, _from, _to, _cost):
        self.G[_from].append(self.Edge(_to, _cost))
        self._E += 1

    def shortest_path(self, s):
        import heapq
        que = []
        d = [10**15] * self.V
        d[s] = 0
        heapq.heappush(que, (0, s))

        while len(que) != 0:
            cost, v = heapq.heappop(que)
            if d[v] < cost: continue

            for i in range(len(self.G[v])):
                e = self.G[v][i]
                if d[e.to] > d[v] + e.cost:
                    d[e.to] = d[v] + e.cost
                    heapq.heappush(que, (d[e.to], e.to))
        return d

#Z[i]:length of the longest list starting from S[i] which is also a prefix of S
#O(|S|)
def Z_algorithm(s):
    N = len(s)
    Z_alg = [0]*N

    Z_alg[0] = N
    i = 1
    j = 0
    while i < N:
        while i+j < N and s[j] == s[i+j]:
            j += 1
        Z_alg[i] = j
        if j == 0:
            i += 1
            continue
        k = 1
        while i+k < N and k + Z_alg[k]<j:
            Z_alg[i+k] = Z_alg[k]
            k += 1
        i += k
        j -= k
    return Z_alg

class BIT():
    def __init__(self,n,mod=0):
        self.BIT = [0]*(n+1)
        self.num = n
        self.mod = mod

    def query(self,idx):
        res_sum = 0
        mod = self.mod
        while idx > 0:
            res_sum += self.BIT[idx]
            if mod:
                res_sum %= mod
            idx -= idx&(-idx)
        return res_sum

    #Ai += x O(logN)
    def update(self,idx,x):
        mod = self.mod
        while idx <= self.num:
            self.BIT[idx] += x
            if mod:
                self.BIT[idx] %= mod
            idx += idx&(-idx)
        return

class dancinglink():
    def __init__(self,n,debug=False):
        self.n = n
        self.debug = debug
        self._left = [i-1 for i in range(n)]
        self._right = [i+1 for i in range(n)]
        self.exist = [True for i in range(n)]

    def pop(self,k):
        if self.debug:
            assert self.exist[k]
        L = self._left[k]
        R = self._right[k]
        if L!=-1:
            if R!=self.n:
                self._right[L],self._left[R] = R,L
            else:
                self._right[L] = self.n
        elif R!=self.n:
            self._left[R] = -1
        self.exist[k] = False

    def left(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._left[res]
            if res==-1:
                break
            k -= 1
        return res

    def right(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._right[res]
            if res==self.n:
                break
            k -= 1
        return res

class SparseTable():
    def __init__(self,A,merge_func,ide_ele):
        N=len(A)
        n=N.bit_length()
        self.table=[[ide_ele for i in range(n)] for i in range(N)]
        self.merge_func=merge_func

        for i in range(N):
            self.table[i][0]=A[i]

        for j in range(1,n):
            for i in range(0,N-2**j+1):
                f=self.table[i][j-1]
                s=self.table[i+2**(j-1)][j-1]
                self.table[i][j]=self.merge_func(f,s)

    def query(self,s,t):
        b=t-s+1
        m=b.bit_length()-1
        return self.merge_func(self.table[s][m],self.table[t-2**m+1][m])

class BinaryTrie:
    class node:
        def __init__(self,val):
            self.left = None
            self.right = None
            self.max = val

    def __init__(self):
        self.root = self.node(-10**15)

    def append(self,key,val):
        pos = self.root
        for i in range(29,-1,-1):
            pos.max = max(pos.max,val)
            if key>>i & 1:
                if pos.right is None:
                    pos.right = self.node(val)
                    pos = pos.right
                else:
                    pos = pos.right
            else:
                if pos.left is None:
                    pos.left = self.node(val)
                    pos = pos.left
                else:
                    pos = pos.left
        pos.max = max(pos.max,val)

    def search(self,M,xor):
        res = -10**15
        pos = self.root
        for i in range(29,-1,-1):
            if pos is None:
                break

            if M>>i & 1:
                if xor>>i & 1:
                    if pos.right:
                        res = max(res,pos.right.max)
                    pos = pos.left
                else:
                    if pos.left:
                        res = max(res,pos.left.max)
                    pos = pos.right
            else:
                if xor>>i & 1:
                    pos = pos.right
                else:
                    pos = pos.left

        if pos:
            res = max(res,pos.max)
        return res

def solveequation(edge,ans,n,m):
    #edge=[[to,dire,id]...]
    x=[0]*m
    used=[False]*n
    for v in range(n):
        if used[v]:
            continue
        y = dfs(v)
        if y!=0:
            return False
    return x

    def dfs(v):
        used[v]=True
        r=ans[v]
        for to,dire,id in edge[v]:
            if used[to]:
                continue
            y=dfs(to)
            if dire==-1:
                x[id]=y
            else:
                x[id]=-y
            r+=y
        return r

class SegmentTree:
    def __init__(self, init_val, segfunc, ide_ele):
        n = len(init_val)
        self.segfunc = segfunc
        self.ide_ele = ide_ele
        self.num = 1 << (n - 1).bit_length()
        self.tree = [ide_ele] * 2 * self.num
        self.size = n
        for i in range(n):
            self.tree[self.num + i] = init_val[i]
        for i in range(self.num - 1, 0, -1):
            self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])

    def update(self, k, x):
        k += self.num
        self.tree[k] += x
        while k > 1:
            self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])
            k >>= 1

    def bisect(self,S):
        pos = 1
        if self.tree[1] < S:
            return self.num
        while pos<self.num:
            l,r = 2*pos,2*pos+1
            if S<=self.tree[l]:
                pos = 2*pos
            else:
                S -= self.tree[l]
                pos = 2 * pos + 1
        return pos - self.num

import sys,random,bisect
from collections import deque,defaultdict
from heapq import heapify,heappop,heappush
from itertools import permutations
from math import gcd,log

input = lambda :sys.stdin.buffer.readline()
mi = lambda :map(int,input().split())
li = lambda :list(mi())

def cmb(n, r, mod):
    if ( r<0 or r>n ):
        return 0
    return (g1[n] * g2[r] % mod) * g2[n-r] % mod

mod = 998244353
N = 5*10**5
g1 = [1]*(N+1)
g2 = [1]*(N+1)
inverse = [1]*(N+1)

for i in range( 2, N + 1 ):
    g1[i]=( ( g1[i-1] * i ) % mod )
    inverse[i]=( ( -inverse[mod % i] * (mod//i) ) % mod )
    g2[i]=( (g2[i-1] * inverse[i]) % mod )
inverse[0]=0

def merge(A0,A1):
    Y0,S0 = A0
    Y1,S1 = A1
    if not Y0:
        return A1
    if not Y1:
        return A0

    Y2 = Y0 + Y1
    cnt = 0
    idx = 0
    
    n = len(S0)
    T = [S0[0]] + [S0[i+1]-S0[i] for i in range(n-1)]
    #print(T)
    Seg = SegmentTree(T,lambda x,y:x+y,0)
    for y in Y1:
        idx = Seg.bisect(y-1)
        #print(idx,Seg.num,Seg.tree[1])
        if idx!=Seg.num:
            Seg.update(idx,1)
    S0 = [Seg.tree[Seg.num+i] for i in range(n)]
    #print(S0)
    for i in range(1,n):
        S0[i] += S0[i-1]
    
    S1 = S1[::-1]
    S2 = []
    for i in range(n):
        while S1:
            if S1[-1] < S0[i]:
                S2.append(S1.pop())
            elif S1[-1]==S0[i]:
                S1.pop()
            else:
                break
        S2.append(S0[i])
    S1 = S1[::-1]
    S2 += S1

    return [Y2,S2]

for _ in range(int(input())):
    n,m = mi()
    init = [[] for i in range(m)]
    tS = []
    k = n//5
    for i in range(m):
        x,y = mi()
        #y = random.randint(1,10)
        #print(y)
        #y = int(input())
        init[i] = [[y+1],[y+1]]

        """"""
        ntS = []
        for val in tS:
            if y+1<=val+1:
                ntS.append(val+1)
            else:
                ntS.append(val)
        if y+1 not in ntS:
            ntS.append(y+1)
        tS = ntS
        #""""""
        
    Seg = SegmentTree(init,merge,[[],[]])
    Y,S = Seg.tree[1]
    #print(Seg.tree)

    #S.sort()
    #tS.sort()
    #print(S==tS)
    
    k = len(S) + 1
    print(cmb(n-k+n,n,mod))","['combinatorics', 'data structures']"
1779,"She does her utmost to flawlessly carry out a person's last rites and preserve the world's balance of yin and yang.Hu Tao, being the little prankster she is, has tried to scare you with this graph problem! You are given a connected undirected graph of $$$n$$$ nodes with $$$m$$$ edges. You also have $$$q$$$ queries. Each query consists of two nodes $$$a$$$ and $$$b$$$.Initially, all edges in the graph have a weight of $$$0$$$. For each query, you must choose a simple path starting from $$$a$$$ and ending at $$$b$$$. Then you add $$$1$$$ to every edge along this path. Determine if it's possible, after processing all $$$q$$$ queries, for all edges in this graph to have an even weight. If so, output the choice of paths for each query. If it is not possible, determine the smallest number of extra queries you could add to make it possible. It can be shown that this number will not exceed $$$10^{18}$$$ under the given constraints.A simple path is defined as any path that does not visit a node more than once.An edge is said to have an even weight if its value is divisible by $$$2$$$. NoteHere is what the queries look like for the first test case (red corresponds to the 1st query, blue 2nd query, and green 3rd query):    Notice that every edge in the graph is part of either $$$0$$$ or $$$2$$$ colored query edges.The graph in the second test case looks like this:    There does not exist an assignment of paths that will force all edges to have even weights with the given queries. One must add at least $$$2$$$ new queries to obtain a set of queries that can satisfy the condition. import sys
input=sys.stdin.readline
def unionfind(u):
    v=u
    while u!=parent[u]:
        u=parent[u]
    while v!=u:
        w=parent[v]
        parent[v]=u
        v=parent[w]
    return u
def path(u,v):
    s=[u]
    pre=[-1]*(n+1)
    pre[u]=u
    while s:
        x=s.pop()
        for y in g[x]:
            if pre[y]>=0:
                continue
            pre[y]=x
            s.append(y)
    ans=[v]
    while ans[-1]!=u:
        ans.append(pre[ans[-1]])
    return ans[::-1]
n,m=map(int,input().split())#30w 30w
g=[[] for i in range(n+1)]
parent=[i for i in range(n+1)]
for i in range(m):
    u, v = map(int, input().split())
    root1,root2=unionfind(u),unionfind(v)
    if root1==root2:
        continue
    parent[max(root1,root2)]=min(root1,root2)
    g[u].append(v)
    g[v].append(u)
l=len(g)
q=int(input())#n*q 30w
query=[]
d={}
for i in range(q):
    a,b=map(int,input().split())
    query.append([a,b])
    if a in d:
        del d[a]
    else:
        d[a]=1
    if b in d:
        del d[b]
    else:
        d[b]=1
if len(d)>0:
    print(""NO"")
    print(len(d)//2)
else:
    print(""YES"")
    for i in range(q):
        ans=path(query[i][0],query[i][1])
        print(len(ans))
        print("" "".join(map(str,ans)))
","['constructive algorithms', 'dfs and similar', 'graphs', 'greedy', 'other', 'trees']"
4272,"A recently found Ancient Prophesy is believed to contain the exact Apocalypse date. The prophesy is a string that only consists of digits and characters ""-"".We'll say that some date is mentioned in the Prophesy if there is a substring in the Prophesy that is the date's record in the format ""dd-mm-yyyy"". We'll say that the number of the date's occurrences is the number of such substrings in the Prophesy. For example, the Prophesy ""0012-10-2012-10-2012"" mentions date 12-10-2012 twice (first time as ""0012-10-2012-10-2012"", second time as ""0012-10-2012-10-2012"").The date of the Apocalypse is such correct date that the number of times it is mentioned in the Prophesy is strictly larger than that of any other correct date.A date is correct if the year lies in the range from 2013 to 2015, the month is from 1 to 12, and the number of the day is strictly more than a zero and doesn't exceed the number of days in the current month. Note that a date is written in the format ""dd-mm-yyyy"", that means that leading zeroes may be added to the numbers of the months or days if needed. In other words, date ""1-1-2013"" isn't recorded in the format ""dd-mm-yyyy"", and date ""01-01-2013"" is recorded in it.Notice, that any year between 2013 and 2015 is not a leap year. nan import re

def c(d):
    d,m,y=map(int,d.split('-'))
    M=set([1,3,5,7,8,10,12])
    return y > 2012 and y< 2016 and d>0and(d<29 and m==2 or d<32 and m in M or d<30 and m in (set(range(4,13))-M))
    
    
d=re.findall(""(?=(\d\d-\d\d-\d{4}))"", raw_input())
r={}
for i in d:
    r[i]=r.get(i,0)+c(i)

print max(r.items(), key=lambda y:y[1])[0]","['brute force', 'implementation', 'strings']"
828,"Boboniu likes playing chess with his employees. As we know, no employee can beat the boss in the chess game, so Boboniu has never lost in any round.You are a new applicant for his company. Boboniu will test you with the following chess question:Consider a $$$n\times m$$$ grid (rows are numbered from $$$1$$$ to $$$n$$$, and columns are numbered from $$$1$$$ to $$$m$$$). You have a chess piece, and it stands at some cell $$$(S_x,S_y)$$$ which is not on the border (i.e. $$$2 \le S_x \le n-1$$$ and $$$2 \le S_y \le m-1$$$).From the cell $$$(x,y)$$$, you can move your chess piece to $$$(x,y')$$$ ($$$1\le y'\le m, y' \neq y$$$) or $$$(x',y)$$$ ($$$1\le x'\le n, x'\neq x$$$). In other words, the chess piece moves as a rook. From the cell, you can move to any cell on the same row or column.Your goal is to visit each cell exactly once. Can you find a solution?Note that cells on the path between two adjacent cells in your route are not counted as visited, and it is not required to return to the starting point. NotePossible routes for two examples:   n, m, x, y = map(int, input().split())
for i in range(n):
    if i % 2 == 0:
        for j in range(m):
            print(f'{(i + x - 1) % n + 1} {(j + y - 1) % m + 1}')
    else:
        for j in range(m - 1, -1, -1):
            print(f'{(i + x - 1) % n + 1} {(j + y - 1) % m + 1}')
",['constructive algorithms']
1375,"Vanya decided to walk in the field of size n × n cells. The field contains m apple trees, the i-th apple tree is at the cell with coordinates (xi, yi). Vanya moves towards vector (dx, dy). That means that if Vanya is now at the cell (x, y), then in a second he will be at cell . The following condition is satisfied for the vector: , where  is the largest integer that divides both a and b. Vanya ends his path when he reaches the square he has already visited. Vanya wonders, from what square of the field he should start his path to see as many apple trees as possible. NoteIn the first sample Vanya's path will look like: (1, 3) - (3, 1) - (0, 4) - (2, 2) - (4, 0) - (1, 3)In the second sample: (0, 0) - (1, 1) - (0, 0) from itertools   import *
from collections import *
from operator    import *
from bisect      import *
from fractions   import *

Ii = lambda: map(int, raw_input().split())
Is = lambda: raw_input().split()
ri = raw_input

def egcd(a, b):
  '''solves for a*x+b*y = gcd(a,b)'''
  x,y, u,v = 0,1, 1,0
  while a != 0:
    q, r = b//a, b%a
    m, n = x-u*q, y-v*q
    b,a, x,y, u,v = a,r, u,v, m,n
  gcd = b
  return gcd, x, y

def modInverse(a,m):
  '''solves for a*x = 1 (mod m)'''
  return egcd(a,m)[1]%m

sx,sy,best = 0,0,0
n,m,dx,dy = Ii()
dxi = modInverse(dx,n)
C = [0]*n
for _ in xrange(m):
  alpha,beta = Ii()
  key = (beta-dxi*dy*alpha)%n
  C[key] += 1
  if C[key] > best:
    sx,sy = alpha,beta
    best = C[key]
print sx,sy",['math']
1739,"Rikhail Mubinchik believes that the current definition of prime numbers is obsolete as they are too complex and unpredictable. A palindromic number is another matter. It is aesthetically pleasing, and it has a number of remarkable properties. Help Rikhail to convince the scientific community in this!Let us remind you that a number is called prime if it is integer larger than one, and is not divisible by any positive integer other than itself and one.Rikhail calls a number a palindromic if it is integer, positive, and its decimal representation without leading zeros is a palindrome, i.e. reads the same from left to right and right to left.One problem with prime numbers is that there are too many of them. Let's introduce the following notation: π(n) — the number of primes no larger than n, rub(n) — the number of palindromic numbers no larger than n. Rikhail wants to prove that there are a lot more primes than palindromic ones.He asked you to solve the following problem: for a given value of the coefficient A find the maximum n, such that π(n) ≤ A·rub(n). nan #!/usr/bin/env python
import math

def is_pal(n):
	if str(n) == str(n)[::-1]:
		return True
	else:
		return False

def sieve(n, a):
	primos = [True]*(n+1)
	primos[0] = False
	primos[1] = False
	# m = int(math.sqrt(n))

	c = 0
	pl= 1
	r = 1
	for i in range(2, n):
		if primos[i]:
			c += 1
			for k in range(i*i,n+1,i):
				primos[k] = False
		if is_pal(i):
			pl += 1
		if c<=a*pl:
			r = i
	return r		

def pald(n):
	c = 0
	for i in xrange(0,n + 1):
		if str(i) == str(i)[::-1]:
			c += 1
	return c



p,q = [int(x) for x in raw_input().split("" "")]


A = p/float(q)

print sieve(2000000,A)

# i = 1
# c = 0
# pl = 0
# z = -1
# for i in xrange(1,len(primos)):
# 	if primos[i]:
# 		c += 1
# 	if is_pal(i):
# 		pl += 1
# 	if c <= A*pl:
# 		z = i
		# break
	# else:
		# print c, A, pl,i
		# break
# print z
# 	print i

# print i

# p = 0
# pl = 0
# for i in xrange(2,3000000):
# 	if primos[i]:
# 		p += 1
# 	if is_pal(primos[i]):
# 		pl += 1
# 	if p > A*pl:
# 		print i
# 		break
# i = 1

# while True:
# 	p = sieve(i)
# 	c = 0
	
# 	for i in xrange(len(p)):
# 		if p[i]:
# 			c += 1

# 	pl = pald(i)

# 	if c <= A*pl:
# 		i += 1
# 	else:
# 		# i -= 1
# 		break

# # 	print i

# print i","['brute force', 'implementation', 'math', 'number theory']"
1924,"You are going to the beach with the idea to build the greatest sand castle ever in your head! The beach is not as three-dimensional as you could have imagined, it can be decribed as a line of spots to pile up sand pillars. Spots are numbered 1 through infinity from left to right. Obviously, there is not enough sand on the beach, so you brought n packs of sand with you. Let height hi of the sand pillar on some spot i be the number of sand packs you spent on it. You can't split a sand pack to multiple pillars, all the sand from it should go to a single one. There is a fence of height equal to the height of pillar with H sand packs to the left of the first spot and you should prevent sand from going over it. Finally you ended up with the following conditions to building the castle:  h1 ≤ H: no sand from the leftmost spot should go over the fence;  For any  |hi - hi + 1| ≤ 1: large difference in heights of two neighboring pillars can lead sand to fall down from the higher one to the lower, you really don't want this to happen;  : you want to spend all the sand you brought with you. As you have infinite spots to build, it is always possible to come up with some valid castle structure. Though you want the castle to be as compact as possible. Your task is to calculate the minimum number of spots you can occupy so that all the aforementioned conditions hold. NoteHere are the heights of some valid castles:   n = 5, H = 2, [2, 2, 1, 0, ...], [2, 1, 1, 1, 0, ...], [1, 0, 1, 2, 1, 0, ...]  n = 6, H = 8, [3, 2, 1, 0, ...], [2, 2, 1, 1, 0, ...], [0, 1, 0, 1, 2, 1, 1, 0...] (this one has 5 spots occupied) The first list for both cases is the optimal answer, 3 spots are occupied in them.And here are some invalid ones:  n = 5, H = 2, [3, 2, 0, ...], [2, 3, 0, ...], [1, 0, 2, 2, ...]  n = 6, H = 8, [2, 2, 2, 0, ...], [6, 0, ...], [1, 4, 1, 0...], [2, 2, 1, 0, ...]  n, H = map(int, input().split())
l = 1
r = n
while l < r:
	mid = int((l + r) / 2)
	ans = 0
	if mid <= H:
		ans = int(mid * (mid + 1) // 2)
		pass
	else :
		R = int(mid - (H - 1))
		Len = int(R - 2)
		ans = ans + int(H * (H - 1) // 2)
		tmp = int(R / 2)
		#print(""%d %d %d"" % (R, Len, tmp))
		ans = ans + (H + H + tmp - 1) * tmp + (R - tmp * 2) * (H + tmp)
		pass
	#print((l, r, mid, int(mid * (mid + 1) // 2)))
	if ans >= n:
		r = mid
	else : l = mid + 1
	pass
print(""%d"" % l)
","['binary search', 'constructive algorithms', 'math']"
416,"Fox Ciel is in the Amusement Park. And now she is in a queue in front of the Ferris wheel. There are n people (or foxes more precisely) in the queue: we use first people to refer one at the head of the queue, and n-th people to refer the last one in the queue.There will be k gondolas, and the way we allocate gondolas looks like this:  When the first gondolas come, the q1 people in head of the queue go into the gondolas.  Then when the second gondolas come, the q2 people in head of the remain queue go into the gondolas.    ... The remain qk people go into the last (k-th) gondolas. Note that q1, q2, ..., qk must be positive. You can get from the statement that  and qi &gt; 0.You know, people don't want to stay with strangers in the gondolas, so your task is to find an optimal allocation way (that is find an optimal sequence q) to make people happy. For every pair of people i and j, there exists a value uij denotes a level of unfamiliar. You can assume uij = uji for all i, j (1 ≤ i, j ≤ n) and uii = 0 for all i (1 ≤ i ≤ n). Then an unfamiliar value of a gondolas is the sum of the levels of unfamiliar between any pair of people that is into the gondolas.A total unfamiliar value is the sum of unfamiliar values for all gondolas. Help Fox Ciel to find the minimal possible total unfamiliar value for some optimal allocation. NoteIn the first example, we can allocate people like this: {1, 2} goes into a gondolas, {3, 4, 5} goes into another gondolas.In the second example, an optimal solution is : {1, 2, 3} | {4, 5, 6} | {7, 8}. import sys
import os
range = xrange
input = raw_input

big = 10**9
ord0 = ord('0')

S = os.read(0, 2**25)

ii = 0
n = 0
while ord(S[ii]) >= ord0:
    n = 10 * n + ord(S[ii]) - ord0
    ii += 1
ii += 1

K = 0
while ord(S[ii]) >= ord0:
    K = 10 * K + ord(S[ii]) - ord0
    ii += 1
ii += 2

mat = [ord(S[ii + 2 * i + j * (2 * n + 1)]) - ord0 for j in range(n) for i in range(n)]

# i - j = k
for k in range(2, n):
    for i in range(k, n):
        j = i - k
        mat[j + i*n] += mat[j +     n*(i - 1)] +        \
                        mat[j + 1 + n*i      ] -             \
                        mat[j + 1 + n*(i - 1)]

intervals = [[] for _ in range(20)]
for i in range(n):
    intervals[(i ^ i + 1).bit_length()].append(i)

best = [mat[n * i] for i in range(n)]
old_best = [0]*n
prev_block_start = [0]*n

for _ in range(2, K+1):
    best, old_best = old_best, best
    for interval in reversed(intervals):
        for i in interval:
            up = i | i + 1
            down = i - (i ^ up)
            
            lower = prev_block_start[down] if down >= 0 else 0
            upper = prev_block_start[up] if up < n else i - 1

            besta = big
            besta_ind = 0
            for j in range(lower, upper + 1 if upper < i else i):
                val = mat[j + 1 + n*i] + old_best[j]
                if val < besta:
                    besta = val
                    besta_ind = j
            best[i] = besta
            prev_block_start[i] = besta_ind
print best[n - 1]
","['data structures', 'divide and conquer', 'dp']"
486,"One day, at the ""Russian Code Cup"" event it was decided to play football as an out of competition event. All participants was divided into n teams and played several matches, two teams could not play against each other more than once.The appointed Judge was the most experienced member — Pavel. But since he was the wisest of all, he soon got bored of the game and fell asleep. Waking up, he discovered that the tournament is over and the teams want to know the results of all the matches.Pavel didn't want anyone to discover about him sleeping and not keeping an eye on the results, so he decided to recover the results of all games. To do this, he asked all the teams and learned that the real winner was friendship, that is, each team beat the other teams exactly k times. Help Pavel come up with chronology of the tournir that meets all the conditions, or otherwise report that there is no such table. nan #!/usr/bin/python
import re
import inspect
import os
from sys import argv, exit

def rstr():
    return input()

def rstrs(splitchar=' '):
    return [i for i in input().split(splitchar)]

def rint():
    return int(input())

def rints(splitchar=' '):
    return [int(i) for i in rstrs(splitchar)]

def varnames(obj, namespace=globals()):
    return [name for name in namespace if namespace[name] is obj]

def pvar(var, override=False):
    prnt(varnames(var), var)

def prnt(*args, override=False):
    return
    if '-v' in argv or override:
        print(*args)

pq = []
def penq(thing):
    pq.append(thing)

def pdump():
    s = ('\n'.join(pq)).encode()
    os.write(1, s)

if __name__ == '__main__':
    teams, wins = rints()

    if teams < wins*2+1:
        print('-1')
        exit(0)

    penq(str(teams*wins))
    for team in range(teams):
        w = 0
        while w < wins: 
            otherteam = (team + w + 1) % teams
            penq('{} {}'.format(team + 1, otherteam + 1))
            w += 1

    pdump()
","['constructive algorithms', 'graphs', 'implementation']"
1047,"Michael is accused of violating the social distancing rules and creating a risk of spreading coronavirus. He is now sent to prison. Luckily, Michael knows exactly what the prison looks like from the inside, especially since it's very simple.The prison can be represented as a rectangle $$$a\times b$$$ which is divided into $$$ab$$$ cells, each representing a prison cell, common sides being the walls between cells, and sides on the perimeter being the walls leading to freedom. Before sentencing, Michael can ask his friends among the prison employees to make (very well hidden) holes in some of the walls (including walls between cells and the outermost walls). Michael wants to be able to get out of the prison after this, no matter which cell he is placed in. However, he also wants to break as few walls as possible.Your task is to find out the smallest number of walls to be broken so that there is a path to the outside from every cell after this. NoteSome possible escape plans for the example test cases are shown below. Broken walls are shown in gray, not broken walls are shown in black.  n = int(input())
A=[]
for i in range(n):
    A+=[list(map(int, input().split()))]
    
S=[]
for item in A:
    s=0
    for i in range(min(item[0],item[1])):
            if min(item[0]-i*2,item[1]-i*2)<3:         
                s+=(item[0]-i*2)*(item[1]-i*2)
                break
            elif (item[0]-i*2)>1and (item[1]-i*2>1):
                s+=2*(item[0]-i*2)+2*(item[1]-i*2)-4
    S+=[s]
    
for item in S:
    print(item)    ",['constructive algorithms']
1551,"You are given a permutation p of length n. Also you are given m foe pairs (ai, bi) (1 ≤ ai, bi ≤ n, ai ≠ bi). Your task is to count the number of different intervals (x, y) (1 ≤ x ≤ y ≤ n) that do not contain any foe pairs. So you shouldn't count intervals (x, y) that contain at least one foe pair in it (the positions and order of the values from the foe pair are not important).Consider some example: p = [1, 3, 2, 4] and foe pairs are {(3, 2), (4, 2)}. The interval (1, 3) is incorrect because it contains a foe pair (3, 2). The interval (1, 4) is also incorrect because it contains two foe pairs (3, 2) and (4, 2). But the interval (1, 2) is correct because it doesn't contain any foe pair. NoteIn the first example the intervals from the answer are (1, 1), (1, 2), (2, 2), (3, 3) and (4, 4). def f():
    sizes = input().split(' ')
    n, m = int(sizes[0]), int(sizes[1]) 
    permStr = input().split(' ')
    pairsStr = [input() for i in range(m)]

    indexes = [0 for i in range(n+1)]
    for i in range(n):
        indexes[int(permStr[i])] = i+1
    lowerNums = [0 for i in range(n+1)]

    for i in range(m):
        pair = pairsStr[i].split("" "")
        a, b = indexes[int(pair[0])], indexes[int(pair[1])]
        if a < b:
            l = a
            h = b
        else:
            l = b
            h = a
        if l > lowerNums[h]:
            lowerNums[h] = l

    counter = 0
    left = 0
    for i in range(1,n+1):
        candidate = lowerNums[i]
        if candidate > left:
            r=i-1-left
            q=i-1-candidate
            counter += (r*(r-1) - q*(q-1))//2
            left = candidate
    r=i-left
    counter += r*(r-1)//2

    print(counter + n)


f() 
","['combinatorics', 'sortings', 'two pointers']"
177,"oolimry has an array $$$a$$$ of length $$$n$$$ which he really likes. Today, you have changed his array to $$$b$$$, a permutation of $$$a$$$, to make him sad.Because oolimry is only a duck, he can only perform the following operation to restore his array:   Choose two integers $$$i,j$$$ such that $$$1 \leq i,j \leq n$$$.  Swap $$$b_i$$$ and $$$b_j$$$. The sadness of the array $$$b$$$ is the minimum number of operations needed to transform $$$b$$$ into $$$a$$$.Given the array $$$a$$$, find any array $$$b$$$ which is a permutation of $$$a$$$ that has the maximum sadness over all permutations of the array $$$a$$$. NoteIn the first test case, the array $$$[1,2]$$$ has sadness $$$1$$$. We can transform $$$[1,2]$$$ into $$$[2,1]$$$ using one operation with $$$(i,j)=(1,2)$$$.In the second test case, the array $$$[3,3,2,1]$$$ has sadness $$$2$$$. We can transform $$$[3,3,2,1]$$$ into $$$[1,2,3,3]$$$ with two operations with $$$(i,j)=(1,4)$$$ and $$$(i,j)=(2,3)$$$ respectively. import sys

def solve():
	inp = sys.stdin.readline
	n = int(inp())
	a = list(map(int, inp().split()))
	c = [[] for i in range(n + 1)]
	p = [None] * (n + 1)
	for i in range(n):
		c[a[i]].append(i)
	for i in range(n + 1):
		p[i] = (-len(c[i]), i)
	p.sort()
	b = [None] * n
	for k in range(-p[0][0]):
		pr = p[0][1]
		for i in range(1, n + 5):
			sz, v = p[i]
			#print(k, pr, v, sz)
			if -sz > k:
				b[c[pr][k]] = v
				pr = v
			else:
				#print(c[pr])
				b[c[pr][k]] = p[0][1]
				break
	print(' '.join(map(str, b)))


def main():
	for i in range(int(sys.stdin.readline())):
		solve()


if __name__ == '__main__':
	main()
","['constructive algorithms', 'graphs', 'greedy']"
4388,"There always is something to choose from! And now, instead of ""Noughts and Crosses"", Inna choose a very unusual upgrade of this game. The rules of the game are given below:There is one person playing the game. Before the beginning of the game he puts 12 cards in a row on the table. Each card contains a character: ""X"" or ""O"". Then the player chooses two positive integers a and b (a·b = 12), after that he makes a table of size a × b from the cards he put on the table as follows: the first b cards form the first row of the table, the second b cards form the second row of the table and so on, the last b cards form the last (number a) row of the table. The player wins if some column of the table contain characters ""X"" on all cards. Otherwise, the player loses.Inna has already put 12 cards on the table in a row. But unfortunately, she doesn't know what numbers a and b to choose. Help her win the game: print to her all the possible ways of numbers a, b that she can choose and win. nan # http://codeforces.com/contest/400/problem/0
# Codeforces : A. Inna and choose options

liste_a = (1, 2, 3, 4, 6, 12)
liste_results = []

def process(essai):
    global liste_results
    liste_av = [0]
    for a in liste_a:
        b = 12 // a
        for r in range(b):
            if essai[r::b] == 'X'*a:
                liste_av[0] += 1
                liste_av.append('{}x{}'.format(a,b))
                break
    liste_av[0] = str(liste_av[0])
    liste_results.append(liste_av)




t = int(input())
for k in range(t):
    essai = input()
    process(essai)

for s in liste_results:
    print(*s)
",['implementation']
4313,"Please note the non-standard memory limit.There are $$$n$$$ problems numbered with integers from $$$1$$$ to $$$n$$$. $$$i$$$-th problem has the complexity $$$c_i = 2^i$$$, tag $$$tag_i$$$ and score $$$s_i$$$.After solving the problem $$$i$$$ it's allowed to solve problem $$$j$$$ if and only if $$$\text{IQ} &lt; |c_i - c_j|$$$ and $$$tag_i \neq tag_j$$$. After solving it your $$$\text{IQ}$$$ changes and becomes $$$\text{IQ} = |c_i - c_j|$$$ and you gain $$$|s_i - s_j|$$$ points.Any problem can be the first. You can solve problems in any order and as many times as you want.Initially your $$$\text{IQ} = 0$$$. Find the maximum number of points that can be earned. NoteIn the first test case optimal sequence of solving problems is as follows:   $$$1 \rightarrow 2$$$, after that total score is $$$5$$$ and $$$\text{IQ} = 2$$$  $$$2 \rightarrow 3$$$, after that total score is $$$10$$$ and $$$\text{IQ} = 4$$$  $$$3 \rightarrow 1$$$, after that total score is $$$20$$$ and $$$\text{IQ} = 6$$$  $$$1 \rightarrow 4$$$, after that total score is $$$35$$$ and $$$\text{IQ} = 14$$$ In the second test case optimal sequence of solving problems is as follows:   $$$1 \rightarrow 2$$$, after that total score is $$$5$$$ and $$$\text{IQ} = 2$$$  $$$2 \rightarrow 3$$$, after that total score is $$$10$$$ and $$$\text{IQ} = 4$$$  $$$3 \rightarrow 4$$$, after that total score is $$$15$$$ and $$$\text{IQ} = 8$$$  $$$4 \rightarrow 1$$$, after that total score is $$$35$$$ and $$$\text{IQ} = 14$$$ In the third test case optimal sequence of solving problems is as follows:   $$$1 \rightarrow 3$$$, after that total score is $$$17$$$ and $$$\text{IQ} = 6$$$  $$$3 \rightarrow 4$$$, after that total score is $$$35$$$ and $$$\text{IQ} = 8$$$  $$$4 \rightarrow 2$$$, after that total score is $$$42$$$ and $$$\text{IQ} = 12$$$  import os,sys
from random import randint, shuffle
from io import BytesIO, IOBase

from collections import defaultdict,deque,Counter
from bisect import bisect_left,bisect_right
from heapq import heappush,heappop
from functools import lru_cache
from itertools import accumulate, permutations
import math

# Fast IO Region
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# for _ in range(int(input())):
#     n = int(input())
#     a = list(map(int, input().split()))

# for _ in range(int(input())):
#     n = int(input())
#     a = list(map(int, input().split()))
#     a.sort()
#     b = []
#     st = set()
#     c = []
#     for i in range(n):
#         if a[i] in st:
#             c.append(a[i])
#         else:
#             b.append(a[i])
#             st.add(a[i])
#     print(*(b + c))

# for _ in range(int(input())):
#     n, m = list(map(int, input().split()))
#     a = list(map(int, input().split()))
#     for i in range(n):
#         a[i] %= m
#     cnt = [0] * m
#     for i in range(n):
#         cnt[a[i]] += 1
#     # print(cnt)
#     ans = 0
#     if cnt[0] > 0:
#         ans += 1
#     for i in range(1, (m - 1) // 2 + 1):
#         x, y = cnt[i], cnt[m - i]
#         if x == y == 0: continue
#         if x < y: x, y = y, x
#         if x - y <= 1:
#             ans += 1
#         else:
#             ans += x - y
#     if m % 2 == 0:
#         ans += (cnt[m // 2] > 0)
#     print(ans)

# for _ in range(int(input())):
#     n, k = list(map(int, input().split()))
#     ans = []
#     for i in range(k - 3):
#         ans.append(1)
#         k -= 1
#         n -= 1
#     r = 1
#     while n % 2 == 0:
#         r *= 2
#         n //= 2
#     if n == 1:
#         n = 4
#         r //= 4
#         ans += [2 * r, r, r]
#     else:
#         ans += [n // 2 * r, n // 2 * r, r]
#     print(*ans)

# N = int(pow(10 ** 9, 0.5)) + 5
# def get_prime_linear(n):
#     global cnt
#     for i in range(2, n + 1):
#         if not st[i]:
#             primes[cnt] = i
#             cnt += 1
#         for j in range(n):
#             if primes[j] > n / i: break
#             st[primes[j] * i] = True
#             if i % primes[j] == 0: break 
# primes, cnt, st = [0] * (N + 5), 0, [False] * (N + 5)
# get_prime_linear(N)
# prime1e3 = primes[:cnt]
# @lru_cache(None)
# def get_factor(n):
#     res = []
#     for i in prime1e3:
#         if i * i > n:
#             break
#         while n % i == 0:
#             n //= i
#             res.append(i)
#     if n > 1:
#         res.append(n)
#     return res

# for _ in range(int(input())):
#     n, k = list(map(int, input().split()))
#     a = list(map(int, input().split()))
#     for i in range(n):
#         f = get_factor(a[i])
#         st = set()
#         for j in f:
#             if j in st:
#                 st.remove(j)
#             else:
#                 st.add(j)
#         a[i] = 1
#         for j in st:
#             a[i] *= j
#     print(a)
#     ans = 0
#     st = set()
#     for i in range(n):
#         if a[i] in st:
#             st = set()
#             st.add(a[i])
#             ans += 1
#         else:
#             st.add(a[i])
#     print(ans + 1)

for _ in range(int(input())):
    n = int(input())
    a = list(map(int, input().split()))
    s = list(map(int, input().split()))
    dp = [0] * n
    for i in range(n):
        for j in range(i)[::-1]:
            if a[i] != a[j]:
                dp[i], dp[j] = max(dp[i], dp[j] + abs(s[i] - s[j])), max(dp[j], dp[i] + abs(s[i] - s[j]))
    print(max(dp))","['bitmasks', 'dp', 'graphs', 'number theory']"
977,"In a dream Marco met an elderly man with a pair of black glasses. The man told him the key to immortality and then disappeared with the wind of time.When he woke up, he only remembered that the key was a sequence of positive integers of some length n, but forgot the exact sequence. Let the elements of the sequence be a1, a2, ..., an. He remembered that he calculated gcd(ai, ai + 1, ..., aj) for every 1 ≤ i ≤ j ≤ n and put it into a set S. gcd here means the greatest common divisor.Note that even if a number is put into the set S twice or more, it only appears once in the set.Now Marco gives you the set S and asks you to help him figure out the initial sequence. If there are many solutions, print any of them. It is also possible that there are no sequences that produce the set S, in this case print -1. NoteIn the first example 2 = gcd(4, 6), the other elements from the set appear in the sequence, and we can show that there are no values different from 2, 4, 6 and 12 among gcd(ai, ai + 1, ..., aj) for every 1 ≤ i ≤ j ≤ n. n=int(input())
a=list(map(int,input().split()))
cur=a[-1]
from math import gcd
for i in range(1,n-1):
    cur=gcd(cur,a[i])
if (cur %a[0]!=0) and (a[0]!=1):
    print(-1)
else:
    print(2*n)
    for i in a:
        print(i,a[0],end=' ')
","['constructive algorithms', 'math']"
2555,"You are given a string $$$s$$$ consisting only of characters + and -. You perform some process with this string. This process can be described by the following pseudocode: res = 0for init = 0 to inf    cur = init    ok = true    for i = 1 to |s|        res = res + 1        if s[i] == '+'            cur = cur + 1        else            cur = cur - 1        if cur &lt; 0            ok = false            break    if ok        breakNote that the $$$inf$$$ denotes infinity, and the characters of the string are numbered from $$$1$$$ to $$$|s|$$$.You have to calculate the value of the $$$res$$$ after the process ends. nan #!/usr/bin/env python
from __future__ import division, print_function

import os
import sys
from io import BytesIO, IOBase

if sys.version_info[0] < 3:
    from __builtin__ import xrange as range
    from future_builtins import ascii, filter, hex, map, oct, zip


# region fastio

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


def print(*args, **kwargs):
    """"""Prints the values to a stream, or to sys.stdout by default.""""""
    sep, file = kwargs.pop(""sep"", "" ""), kwargs.pop(""file"", sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop(""end"", ""\n""))
    if kwargs.pop(""flush"", False):
        file.flush()


if sys.version_info[0] < 3:
    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)


from math import sqrt, floor, factorial, gcd, log
from collections import deque, Counter, defaultdict
from itertools import permutations, combinations
from math import gcd
from bisect import bisect


input = lambda: sys.stdin.readline().rstrip(""\r\n"")
read = lambda: list(map(int, input().strip().split("" "")))



def func(x):
    t = 0
    for i in arr:
        if i <= x:
            t += i
    return(t)

def solve():
    for _ in range(int(input())):
        s = input(); 
        arr = [[-1, 1][i==""+""] for i in s]
        for i in range(1, len(s)):arr[i] += arr[i-1]
        ans = 0; sett = set()

        for i in range(len(s)):
            if arr[i] < 0 and arr[i] not in sett:
                ans += i+1
                sett.add(arr[i])
        # print(arr, sett)
        # if ans:
        print(ans+len(s))
        # else:
        #     print(len(s))














  

if __name__ == ""__main__"":
	solve()",['math']
426,"After the lessons n groups of schoolchildren went outside and decided to visit Polycarpus to celebrate his birthday. We know that the i-th group consists of si friends (1 ≤ si ≤ 4), and they want to go to Polycarpus together. They decided to get there by taxi. Each car can carry at most four passengers. What minimum number of cars will the children need if all members of each group should ride in the same taxi (but one taxi can take more than one group)? NoteIn the first test we can sort the children into four cars like this:  the third group (consisting of four children),  the fourth group (consisting of three children),  the fifth group (consisting of three children),  the first and the second group (consisting of one and two children, correspondingly). There are other ways to sort the groups into four cars. input()
inp = sorted(list(map(int, input().split())))[::-1]
taxi = 0
while len(inp) > 0:
	#print(inp, taxi)
	taxi += 1
	temp = 4 - inp.pop(0)
	if temp == 0:
		continue
	else:
		while temp > 0 and len(inp) >= 1:
			if temp - inp[-1] >= 0:
				temp -= inp[-1]
				inp.pop()
			else:
				break
print(taxi)","['greedy', 'implementation', 'other']"
4478,"$$$n$$$ players are playing a game. There are two different maps in the game. For each player, we know his strength on each map. When two players fight on a specific map, the player with higher strength on that map always wins. No two players have the same strength on the same map. You are the game master and want to organize a tournament. There will be a total of $$$n-1$$$ battles. While there is more than one player in the tournament, choose any map and any two remaining players to fight on it. The player who loses will be eliminated from the tournament. In the end, exactly one player will remain, and he is declared the winner of the tournament. For each player determine if he can win the tournament. NoteIn the first test case, the $$$4$$$-th player will beat any other player on any game, so he will definitely win the tournament.In the second test case, everyone can be a winner. In the third test case, there is only one player. Clearly, he will win the tournament. import os
import sys
from io import BytesIO, IOBase

## PYRIVAL BOOTSTRAP
# https://github.com/cheran-senthil/PyRival/blob/master/pyrival/misc/bootstrap.py
# This decorator allows for recursion without actually doing recursion
from types import GeneratorType
## @bootstrap, yield when getting and returning value in recursive functions


def main():
    @bootstrap
    def dfs(value):
        for v in beaten_by[value]:
            if iptw[v] == '1':
                continue
            else:
                iptw[v] = '1'
                yield dfs(v)
        yield

    for _ in range(iip()):
        n = iip()
        a = liip()
        b = liip()

        beaten_by = [set() for _ in range(n)]
        li = []
        for i in range(n):
            li.append((a[i], b[i], i))

        starts = set()

        li.sort(key=lambda x: -x[0])
        starts.add(li[0][2])
        for i in range(n - 1):
            beaten_by[li[i + 1][2]].add(li[i][2])

        li.sort(key=lambda x: -x[1])
        starts.add(li[0][2])
        for i in range(n - 1):
            beaten_by[li[i + 1][2]].add(li[i][2])

        iptw = ['0'] * n # is possible to win
        for v in starts:
            iptw[v] = '1'

        for start in starts:
            dfs(start)

        print(''.join(iptw))

    
# region fastio
 
BUFSIZE = 8192
 

class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
 
# endregion
 
if __name__ == ""__main__"":
    def bootstrap(f, stack=[]):
        def wrappedfunc(*args, **kwargs):
            if stack:
                return f(*args, **kwargs)
            else:
                to = f(*args, **kwargs)
                while True:
                    if type(to) is GeneratorType:
                        stack.append(to)
                        to = next(to)
                    else:
                        stack.pop()
                        if not stack:
                            break
                        to = stack[-1].send(to)
                return to
        return wrappedfunc
    
    ip = lambda: input()
    iip = lambda: int(input())
    miip = lambda: map(int, input().split())
    liip = lambda: list(map(int, input().split()))
    sip = lambda: input().split() # splitted input
    lip = lambda: list(input())
    
    main()","['data structures', 'dfs and similar', 'dp', 'graphs', 'greedy', 'two pointers']"
2369,"Arseniy is already grown-up and independent. His mother decided to leave him alone for m days and left on a vacation. She have prepared a lot of food, left some money and washed all Arseniy's clothes. Ten minutes before her leave she realized that it would be also useful to prepare instruction of which particular clothes to wear on each of the days she will be absent. Arseniy's family is a bit weird so all the clothes is enumerated. For example, each of Arseniy's n socks is assigned a unique integer from 1 to n. Thus, the only thing his mother had to do was to write down two integers li and ri for each of the days — the indices of socks to wear on the day i (obviously, li stands for the left foot and ri for the right). Each sock is painted in one of k colors.When mother already left Arseniy noticed that according to instruction he would wear the socks of different colors on some days. Of course, that is a terrible mistake cause by a rush. Arseniy is a smart boy, and, by some magical coincidence, he posses k jars with the paint — one for each of k colors.Arseniy wants to repaint some of the socks in such a way, that for each of m days he can follow the mother's instructions and wear the socks of the same color. As he is going to be very busy these days he will have no time to change the colors of any socks so he has to finalize the colors now.The new computer game Bota-3 was just realised and Arseniy can't wait to play it. What is the minimum number of socks that need their color to be changed in order to make it possible to follow mother's instructions and wear the socks of the same color during each of m days. NoteIn the first sample, Arseniy can repaint the first and the third socks to the second color.In the second sample, there is no need to change any colors. def dfs(v, visited, edges, colors):
    st = [v]
    visited.add(v)
    comp = []
    cols = dict()
    while st:
        ver = st.pop()
        comp.append(colors[ver])
        if ver in edges:
            for i in edges[ver]:
                if i not in visited:
                    st.append(i)
                    visited.add(i)
    for i in comp:
        if i not in cols:
            cols[i] = 1
        else:
            cols[i] += 1
    max_c = 0
    for i in cols:
        if cols[i] > max_c:
            max_c = cols[i]
    return len(comp) - max_c



n, m, k = [int(x) for x in input().split()]
colors = {i + 1 : int(x) for i, x in enumerate(input().split())}
edges = dict()
for i in range(m):
    v1, v2 = [int(x) for x in input().split()]
    if v1 in edges:
        edges[v1].append(v2)
    else:
        edges[v1] = [v2]
    if v2 in edges:
        edges[v2].append(v1)
    else:
        edges[v2] = [v1]

visited = set()
answer = 0
for i in range(1, n + 1):
    if i not in visited:
        answer += dfs(i, visited, edges, colors)


print(answer)
","['dfs and similar', 'dsu', 'graphs', 'greedy']"
3837,"Fox Ciel and her friends are in a dancing room. There are n boys and m girls here, and they never danced before. There will be some songs, during each song, there must be exactly one boy and one girl are dancing. Besides, there is a special rule:  either the boy in the dancing pair must dance for the first time (so, he didn't dance with anyone before);  or the girl in the dancing pair must dance for the first time. Help Fox Ciel to make a schedule that they can dance as many songs as possible. NoteIn test case 1, there are 2 boys and 1 girl. We can have 2 dances: the 1st boy and 1st girl (during the first song), the 2nd boy and 1st girl (during the second song).And in test case 2, we have 2 boys with 2 girls, the answer is 3. n, m = map(int, raw_input().split())
mu = []
fu = []
res = []
for i in range(1, n + 1):
    for j in range(1, m + 1):
        if i not in mu or j not in fu:
            res.append([i, j])
            mu.append(i)
            fu.append(j)

print len(res)
for i in res:
    print i[0], i[1]",['greedy']
1965,"As their story unravels, a timeless tale is told once again...Shirahime, a friend of Mocha's, is keen on playing the music game Arcaea and sharing Mocha interesting puzzles to solve. This day, Shirahime comes up with a new simple puzzle and wants Mocha to solve them. However, these puzzles are too easy for Mocha to solve, so she wants you to solve them and tell her the answers. The puzzles are described as follow.There are $$$n$$$ squares arranged in a row, and each of them can be painted either red or blue.Among these squares, some of them have been painted already, and the others are blank. You can decide which color to paint on each blank square.Some pairs of adjacent squares may have the same color, which is imperfect. We define the imperfectness as the number of pairs of adjacent squares that share the same color.For example, the imperfectness of ""BRRRBBR"" is $$$3$$$, with ""BB"" occurred once and ""RR"" occurred twice.Your goal is to minimize the imperfectness and print out the colors of the squares after painting.  NoteIn the first test case, if the squares are painted ""BRRBRBR"", the imperfectness is $$$1$$$ (since squares $$$2$$$ and $$$3$$$ have the same color), which is the minimum possible imperfectness. for t in range(int(input())):
    n=int(input())
    s=input()

    if s==('?'*n):
        s=s.replace('?','R',1)
    
    while '?' in s:
        s=s.replace('R?','RB')
        s=s.replace('B?','BR')
        s=s.replace('?R','BR')
        s=s.replace('?B','RB')
    
    print(s)","['dp', 'greedy']"
93,"On a strip of land of length $$$n$$$ there are $$$k$$$ air conditioners: the $$$i$$$-th air conditioner is placed in cell $$$a_i$$$ ($$$1 \le a_i \le n$$$). Two or more air conditioners cannot be placed in the same cell (i.e. all $$$a_i$$$ are distinct).Each air conditioner is characterized by one parameter: temperature. The $$$i$$$-th air conditioner is set to the temperature $$$t_i$$$.    Example of strip of length $$$n=6$$$, where $$$k=2$$$, $$$a=[2,5]$$$ and $$$t=[14,16]$$$. For each cell $$$i$$$ ($$$1 \le i \le n$$$) find it's temperature, that can be calculated by the formula $$$$$$\min_{1 \le j \le k}(t_j + |a_j - i|),$$$$$$where $$$|a_j - i|$$$ denotes absolute value of the difference $$$a_j - i$$$.In other words, the temperature in cell $$$i$$$ is equal to the minimum among the temperatures of air conditioners, increased by the distance from it to the cell $$$i$$$.Let's look at an example. Consider that $$$n=6, k=2$$$, the first air conditioner is placed in cell $$$a_1=2$$$ and is set to the temperature $$$t_1=14$$$ and the second air conditioner is placed in cell $$$a_2=5$$$ and is set to the temperature $$$t_2=16$$$. In that case temperatures in cells are:  temperature in cell $$$1$$$ is: $$$\min(14 + |2 - 1|, 16 + |5 - 1|)=\min(14 + 1, 16 + 4)=\min(15, 20)=15$$$;  temperature in cell $$$2$$$ is: $$$\min(14 + |2 - 2|, 16 + |5 - 2|)=\min(14 + 0, 16 + 3)=\min(14, 19)=14$$$;  temperature in cell $$$3$$$ is: $$$\min(14 + |2 - 3|, 16 + |5 - 3|)=\min(14 + 1, 16 + 2)=\min(15, 18)=15$$$;  temperature in cell $$$4$$$ is: $$$\min(14 + |2 - 4|, 16 + |5 - 4|)=\min(14 + 2, 16 + 1)=\min(16, 17)=16$$$;  temperature in cell $$$5$$$ is: $$$\min(14 + |2 - 5|, 16 + |5 - 5|)=\min(14 + 3, 16 + 0)=\min(17, 16)=16$$$;  temperature in cell $$$6$$$ is: $$$\min(14 + |2 - 6|, 16 + |5 - 6|)=\min(14 + 4, 16 + 1)=\min(18, 17)=17$$$. For each cell from $$$1$$$ to $$$n$$$ find the temperature in it. nan import sys
input = sys.stdin.readline
t =int(input())

for _ in range(t):
    sp = input()
    n,k = map(int,input().split())
    a = list(map(int,input().split()))
    b = list(map(int,input().split()))
    # c = [[0,0]]*k
    # g = []
    # vis = [0]*n
    ans = [float('inf')]*n
    # q=[]
    for i in range(k):
        # c[i] = [a[i], b[i]]
        # q.append(a[i]-1)
        ans[a[i]-1]=b[i]
    # c = sorted(c,key=lambda x:x[1])
    # # q=[c[0][0]-1]
    # for i in range(k):
    #     q.append(c[i][0]-1)

    # vis[c[0][0]-1]=1
    # ans[c[0][0]-1] = c[0][1]
    # print(q)
    # op = 0
    # while q and n>1:
    #     s= q.pop(0)
    #     for nv in g[s]:
    #         if abs(ans[nv]-ans[s])>1:
    #             q.append(nv)
    #             ans[nv]=min(ans[s]+1,ans[nv])
    #             # op+=1
    for i in range(n-1):
        ans[i+1] = min(ans[i]+1,ans[i+1])
    for i in range(n-1,0,-1):
        ans[i-1] = min(ans[i-1],ans[i]+1)
    print(*ans)
    # print(""Operation: "",op)
    # print(vis)

# print(a)","['data structures', 'dp', 'implementation', 'shortest paths', 'sortings', 'two pointers']"
731,"Petya and Vasya are competing with each other in a new interesting game as they always do.At the beginning of the game Petya has to come up with an array of $$$N$$$ positive integers. Sum of all elements in his array should be equal to $$$S$$$. Then Petya has to select an integer $$$K$$$ such that $$$0 \leq K \leq S$$$.In order to win, Vasya has to find a non-empty subarray in Petya's array such that the sum of all selected elements equals to either $$$K$$$ or $$$S - K$$$. Otherwise Vasya loses.You are given integers $$$N$$$ and $$$S$$$. You should determine if Petya can win, considering Vasya plays optimally. If Petya can win, help him to do that. nan n,s = list(map(int,input().split()))

val = s//n
rem = s%n

v1 = val
v2 = val+rem
if v1>1:
    print('YES')
    for i in range(0,n-1):
        print(v1,end="" "")
    print(v2)
    print(1)
else:
    print('NO')","['constructive algorithms', 'math']"
497,"You are playing a game on a $$$n \times m$$$ grid, in which the computer has selected some cell $$$(x, y)$$$ of the grid, and you have to determine which one. To do so, you will choose some $$$k$$$ and some $$$k$$$ cells $$$(x_1, y_1),\, (x_2, y_2), \ldots, (x_k, y_k)$$$, and give them to the computer. In response, you will get $$$k$$$ numbers $$$b_1,\, b_2, \ldots b_k$$$, where $$$b_i$$$ is the manhattan distance from $$$(x_i, y_i)$$$ to the hidden cell $$$(x, y)$$$ (so you know which distance corresponds to which of $$$k$$$ input cells). After receiving these $$$b_1,\, b_2, \ldots, b_k$$$, you have to be able to determine the hidden cell. What is the smallest $$$k$$$ for which is it possible to always guess the hidden cell correctly, no matter what cell computer chooses?As a reminder, the manhattan distance between cells $$$(a_1, b_1)$$$ and $$$(a_2, b_2)$$$ is equal to $$$|a_1-a_2|+|b_1-b_2|$$$. NoteIn the first test case, the smallest such $$$k$$$ is $$$2$$$, for which you can choose, for example, cells $$$(1, 1)$$$ and $$$(2, 1)$$$.Note that you can't choose cells $$$(1, 1)$$$ and $$$(2, 3)$$$ for $$$k = 2$$$, as both cells $$$(1, 2)$$$ and $$$(2, 1)$$$ would give $$$b_1 = 1, b_2 = 2$$$, so we wouldn't be able to determine which cell is hidden if computer selects one of those.In the second test case, you should choose $$$k = 1$$$, for it you can choose cell $$$(3, 1)$$$ or $$$(1, 1)$$$. import math

N = int(input())
for tt in range(N):
    ss = input().split(' ')
    a,b = int(ss[0]),int(ss[1])
    st = {}
    if a == 1 and b == 1:
        print(0)
        continue
    elif a == 1 or b == 1:
        print(1)
        continue
    
    t = min(a,b)
    print(2)
",['math']
3017,"You are playing a video game and you have just reached the bonus level, where the only possible goal is to score as many points as possible. Being a perfectionist, you've decided that you won't leave this level until you've gained the maximum possible number of points there.The bonus level consists of n small platforms placed in a line and numbered from 1 to n from left to right and (n - 1) bridges connecting adjacent platforms. The bridges between the platforms are very fragile, and for each bridge the number of times one can pass this bridge from one of its ends to the other before it collapses forever is known in advance.The player's actions are as follows. First, he selects one of the platforms to be the starting position for his hero. After that the player can freely move the hero across the platforms moving by the undestroyed bridges. As soon as the hero finds himself on a platform with no undestroyed bridge attached to it, the level is automatically ended. The number of points scored by the player at the end of the level is calculated as the number of transitions made by the hero between the platforms. Note that if the hero started moving by a certain bridge, he has to continue moving in the same direction until he is on a platform.Find how many points you need to score to be sure that nobody will beat your record, and move to the next level with a quiet heart. NoteOne possibility of getting 5 points in the sample is starting from platform 3 and consequently moving to platforms 4, 3, 2, 1 and 2. After that the only undestroyed bridge is the bridge between platforms 4 and 5, but this bridge is too far from platform 2 where the hero is located now. n=input()
a=map(int,raw_input().split())
f=lambda:[[0,0] for _ in range(n)]
l=f()
for i in range(1,n):
  x=a[i-1]
  p,q=l[i-1]
  l[i][0]=(x-1)/2*2+1+max(p,q)
  if x>1:l[i][1]=x/2*2+q
r=f()
for i in range(n-2,-1,-1):
  x=a[i]
  p,q=r[i+1]
  r[i][0]=(x-1)/2*2+1+max(p,q)
  if x>1:r[i][1]=x/2*2+q
print max(map(lambda i:max(l[i])+max(r[i]), range(n)))
",['dp']
2101,"You are given $$$n$$$ segments on a number line; each endpoint of every segment has integer coordinates. Some segments can degenerate to points. Segments can intersect with each other, be nested in each other or even coincide.The intersection of a sequence of segments is such a maximal set of points (not necesserily having integer coordinates) that each point lies within every segment from the sequence. If the resulting set isn't empty, then it always forms some continuous segment. The length of the intersection is the length of the resulting segment or $$$0$$$ in case the intersection is an empty set.For example, the intersection of segments $$$[1;5]$$$ and $$$[3;10]$$$ is $$$[3;5]$$$ (length $$$2$$$), the intersection of segments $$$[1;5]$$$ and $$$[5;7]$$$ is $$$[5;5]$$$ (length $$$0$$$) and the intersection of segments $$$[1;5]$$$ and $$$[6;6]$$$ is an empty set (length $$$0$$$).Your task is to remove exactly one segment from the given sequence in such a way that the intersection of the remaining $$$(n - 1)$$$ segments has the maximal possible length. NoteIn the first example you should remove the segment $$$[3;3]$$$, the intersection will become $$$[2;3]$$$ (length $$$1$$$). Removing any other segment will result in the intersection $$$[3;3]$$$ (length $$$0$$$).In the second example you should remove the segment $$$[1;3]$$$ or segment $$$[2;6]$$$, the intersection will become $$$[2;4]$$$ (length $$$2$$$) or $$$[1;3]$$$ (length $$$2$$$), respectively. Removing any other segment will result in the intersection $$$[2;3]$$$ (length $$$1$$$).In the third example the intersection will become an empty set no matter the segment you remove.In the fourth example you will get the intersection $$$[3;10]$$$ (length $$$7$$$) if you remove the segment $$$[1;5]$$$ or the intersection $$$[1;5]$$$ (length $$$4$$$) if you remove the segment $$$[3;10]$$$. n=int(input())
l,r,s=[],[],[]
for i in range(n):
  a,b=map(int,input().split())
  l.append(a)
  r.append(b)
  s.append((a,b)) 
l=sorted(l)[::-1]
r=sorted(r)
if (l[0],r[0]) in s:
  print(max(r[1]-l[1],0))
else:
  print(max(r[0]-l[1],r[1]-l[0],0))
","['greedy', 'math', 'sortings']"
3091,"Nastya just made a huge mistake and dropped a whole package of rice on the floor. Mom will come soon. If she sees this, then Nastya will be punished.In total, Nastya dropped $$$n$$$ grains. Nastya read that each grain weighs some integer number of grams from $$$a - b$$$ to $$$a + b$$$, inclusive (numbers $$$a$$$ and $$$b$$$ are known), and the whole package of $$$n$$$ grains weighs from $$$c - d$$$ to $$$c + d$$$ grams, inclusive (numbers $$$c$$$ and $$$d$$$ are known). The weight of the package is the sum of the weights of all $$$n$$$ grains in it.Help Nastya understand if this information can be correct. In other words, check whether each grain can have such a mass that the $$$i$$$-th grain weighs some integer number $$$x_i$$$ $$$(a - b \leq x_i \leq a + b)$$$, and in total they weigh from $$$c - d$$$ to $$$c + d$$$, inclusive ($$$c - d \leq \sum\limits_{i=1}^{n}{x_i} \leq c + d$$$). NoteIn the first test case of the example, we can assume that each grain weighs $$$17$$$ grams, and a pack $$$119$$$ grams, then really Nastya could collect the whole pack.In the third test case of the example, we can assume that each grain weighs $$$16$$$ grams, and a pack $$$128$$$ grams, then really Nastya could collect the whole pack.In the fifth test case of the example, we can be assumed that $$$3$$$ grains of rice weigh $$$2$$$, $$$2$$$, and $$$3$$$ grams, and a pack is $$$7$$$ grams, then really Nastya could collect the whole pack.In the second and fourth test cases of the example, we can prove that it is impossible to determine the correct weight of all grains of rice and the weight of the pack so that the weight of the pack is equal to the total weight of all collected grains. from sys import stdin, stdout
read = stdin.readline
write = stdout.write
xr = xrange

def main():
	for tc in xr(int(read())):
		n,a,b,c,d = map(int, read().split())
		if n * (a + b ) < c - d or n * (a - b) > c + d: write('No\n')
		else: write('Yes\n')

if __name__ == ""__main__"":
	main()
",['math']
3380,"Imagine that there is a group of three friends: A, B and С. A owes B 20 rubles and B owes C 20 rubles. The total sum of the debts is 40 rubles. You can see that the debts are not organized in a very optimal manner. Let's rearrange them like that: assume that A owes C 20 rubles and B doesn't owe anything to anybody. The debts still mean the same but the total sum of the debts now equals 20 rubles.This task is a generalisation of a described example. Imagine that your group of friends has n people and you know the debts between the people. Optimize the given debts without changing their meaning. In other words, finally for each friend the difference between the total money he should give and the total money he should take must be the same. Print the minimum sum of all debts in the optimal rearrangement of the debts. See the notes to the test samples to better understand the problem. NoteIn the first sample, you can assume that person number 1 owes 8 rubles to person number 2, 1 ruble to person number 3 and 1 ruble to person number 4. He doesn't owe anybody else anything. In the end, the total debt equals 10.In the second sample, there are no debts.In the third sample, you can annul all the debts. # -*- coding: utf-8 -*-

n, m = map(int, input().split())
abc = [list(map(int, input().split())) for i in range(m)]

mat = [[0]*n for i in range(n)]
for t in abc:
    mat[t[0]-1][t[1]-1] = t[2]
    
total = 0
for i in range(n):
    s = sum(mat[i][:]) - sum([mat[x][i] for x in range(n)])
    if s < 0:
        continue;
    total += s
print(total)
    ",['implementation']
3622,"Natasha travels around Mars in the Mars rover. But suddenly it broke down, namely — the logical scheme inside it. The scheme is an undirected tree (connected acyclic graph) with a root in the vertex $$$1$$$, in which every leaf (excluding root) is an input, and all other vertices are logical elements, including the root, which is output. One bit is fed to each input. One bit is returned at the output.There are four types of logical elements: AND ($$$2$$$ inputs), OR ($$$2$$$ inputs), XOR ($$$2$$$ inputs), NOT ($$$1$$$ input). Logical elements take values from their direct descendants (inputs) and return the result of the function they perform. Natasha knows the logical scheme of the Mars rover, as well as the fact that only one input is broken. In order to fix the Mars rover, she needs to change the value on this input.For each input, determine what the output will be if Natasha changes this input. NoteThe original scheme from the example (before the input is changed):Green indicates bits '1', yellow indicates bits '0'.If Natasha changes the input bit $$$2$$$ to $$$0$$$, then the output will be $$$1$$$.If Natasha changes the input bit $$$3$$$ to $$$0$$$, then the output will be $$$0$$$.If Natasha changes the input bit $$$6$$$ to $$$1$$$, then the output will be $$$1$$$.If Natasha changes the input bit $$$8$$$ to $$$0$$$, then the output will be $$$1$$$.If Natasha changes the input bit $$$9$$$ to $$$0$$$, then the output will be $$$0$$$. # https://codeforces.com/problemset/problem/1010/D
# TLE
import sys
input=sys.stdin.readline

def handle(type_, val_, u, g, S):
    if type_   == 'NOT':
        S.append(g[u][0])
    else:
        v1, v2     = g[u] 
        val1, val2 = Val[v1], Val[v2] 
        
        if oper[type_](1-val1, val2) != val_:
            S.append(v1)
            
        if oper[type_](val1, 1-val2) != val_:
            S.append(v2)       
 
def xor_(a, b):
    return a ^ b
 
def or_(a, b):
    return a | b
 
def not_(a):
    return 1^a
 
def and_(a, b):
    return a&b
 
g={}
 
# {key: [type, val]}
 
def push(d, u, v):
    if u not in d:
        d[u]=[]
    d[u].append(v)
 
n = int(input())
Val  = [None]*n
Type = ['']*n
 
 
for i in range(n):
    arr = input().split()
    
    if len(arr)==2:
        if arr[0]=='IN':
            Type[i] = 'IN'
            Val[i]  = int(arr[1])
        else:
            Type[i]=arr[0]
            push(g, i, int(arr[1])-1)
    else:
        type_, v1, v2 = arr[0], int(arr[1]), int(arr[2])  
        Type[i]=type_ 
        push(g, i, v1-1)
        push(g, i, v2-1)
        
oper={}
 
oper['XOR']=xor_
oper['OR']=or_
oper['NOT']=not_
oper['AND']=and_    
 
S=[0]
i=0
while i<len(S):
    u=S[i]
    if u in g:
        for v in g[u]:
            S.append(v)
    i+=1    
    
for u in S[::-1]:
    if u in g:
        type_ = Type[u]
        
        if len(g[u])==1:
            val_   = Val[g[u][0]]
            Val[u] = oper[type_](val_)
        else:
            val_1, val_2  = Val[g[u][0]], Val[g[u][1]]
            Val[u] = oper[type_](val_1, val_2)
            
ans= [0]*n
S  = [0]
i  = 0
 
while i<len(S):
    u=S[i]
    
    if u in g:
        type_, val_ = Type[u], Val[u]
        handle(type_, val_, u, g, S)
        
    i+=1
    
root_val = Val[0]    
ans      = [root_val]*n
 
for x in S:
    if Type[x]=='IN':
        ans[x]=1-ans[x]
        
print(''.join([str(ans[x]) for x in range(n) if Type[x]=='IN'] ))  ","['dfs and similar', 'graphs', 'implementation', 'trees']"
2072,"Little Mishka is a great traveller and she visited many countries. After thinking about where to travel this time, she chose XXX — beautiful, but little-known northern country.Here are some interesting facts about XXX:  XXX consists of n cities, k of whose (just imagine!) are capital cities.  All of cities in the country are beautiful, but each is beautiful in its own way. Beauty value of i-th city equals to ci.  All the cities are consecutively connected by the roads, including 1-st and n-th city, forming a cyclic route 1 — 2 — ... — n — 1. Formally, for every 1 ≤ i &lt; n there is a road between i-th and i + 1-th city, and another one between 1-st and n-th city.  Each capital city is connected with each other city directly by the roads. Formally, if city x is a capital city, then for every 1 ≤ i ≤ n,  i ≠ x, there is a road between cities x and i.  There is at most one road between any two cities.  Price of passing a road directly depends on beauty values of cities it connects. Thus if there is a road between cities i and j, price of passing it equals ci·cj.Mishka started to gather her things for a trip, but didn't still decide which route to follow and thus she asked you to help her determine summary price of passing each of the roads in XXX. Formally, for every pair of cities a and b (a &lt; b), such that there is a road between a and b you are to find sum of products ca·cb. Will you help her? NoteThis image describes first sample case:It is easy to see that summary price is equal to 17.This image describes second sample case:It is easy to see that summary price is equal to 71. n, k = [int(x) for x in input().split()]
c = [int(x) for x in input().split()]
ids = [(int(x)-1) for x in input().split()]

s = sum(c)
ans = 0
for i in range(n):
  ans += (c[i] * c[(i+1)%n])
for i in range(k):
  if (abs(ids[i] - ids[(i+1)%k]) == 1) or (ids[i] == n-1 and ids[0] == 0):
    ans += c[ids[i]]*c[ids[(i+1)%k]]
temp = 0
for i in range(k):
  ans += c[ids[i]] * (s - c[(ids[i]-1)%n] - c[(ids[i]+1)%n] - c[ids[i]])
  ans -= c[ids[i]]*temp
  temp += c[ids[i]]
  

print(repr(ans))
","['implementation', 'math']"
3919,"Polycarpus got hold of a family tree. The found tree describes the family relations of n people, numbered from 1 to n. Every person in this tree has at most one direct ancestor. Also, each person in the tree has a name, the names are not necessarily unique.We call the man with a number a a 1-ancestor of the man with a number b, if the man with a number a is a direct ancestor of the man with a number b.We call the man with a number a a k-ancestor (k &gt; 1) of the man with a number b, if the man with a number b has a 1-ancestor, and the man with a number a is a (k - 1)-ancestor of the 1-ancestor of the man with a number b.In the tree the family ties do not form cycles. In other words there isn't a person who is his own direct or indirect ancestor (that is, who is an x-ancestor of himself, for some x, x &gt; 0).We call a man with a number a the k-son of the man with a number b, if the man with a number b is a k-ancestor of the man with a number a.Polycarpus is very much interested in how many sons and which sons each person has. He took a piece of paper and wrote m pairs of numbers vi, ki. Help him to learn for each pair vi, ki the number of distinct names among all names of the ki-sons of the man with number vi. nan n = int(raw_input())
child = [set({}) for i in range(0, n + 1)]
query = [list({}) for i in range(0, n + 1)]
ans = [dict(set({})) for i in range(0, n + 1)]
ss = [0 for i in range(0, n + 1)]
fa = [0 for i in range(0, n + 1)]
hash_string = dict()
nowstrings = 0
for i in range(1, n + 1):
    s = raw_input().split()
    child[int(s[1])] |= {i}
    fa[i] = int(s[1])
    if s[0] not in hash_string:
        nowstrings += 1
        hash_string[s[0]] = nowstrings
    ss[i] = hash_string[s[0]]
fa[0] = -1
Child = [list(child[i]) for i in range(0, n+1)]
lenChild = [len(Child[i]) for i in range(0, n+1)]
nowChild = [0 for i in range(0, n+1)]
m = int(raw_input())
answer = [0 for i in range(0, m)]
for i in range(0, m):
    s = raw_input().split()
    query[int(s[0])] += {int(s[1])}
    query[int(s[0])] += {i}
def dfs(x, dep):
    while x != -1:
        if nowChild[x] == lenChild[x]:
            if x != 0:
                ans[x][dep] = {ss[x]}
                for nowlistindex in range(0, len(query[x]), 2):
                    i = query[x][nowlistindex]
                    j = query[x][nowlistindex+1]
                    if dep + i not in ans[x]:
                        answer[j] = 0
                    else:
                        answer[j] = len(ans[x][dep + i])
                """"""count ans""""""
                if len(ans[x]) < len(ans[fa[x]]):
                    for j in ans[x]:
                        if j not in ans[fa[x]]:
                            ans[fa[x]][j] = ans[x][j]
                        elif len(ans[x][j]) < len(ans[fa[x]][j]):
                            ans[fa[x]][j] |= ans[x][j]
                            ans[x][j].clear()
                        else:
                            ans[x][j] |= ans[fa[x]][j]
                            ans[fa[x]][j].clear()
                            ans[fa[x]][j] = ans[x][j]
                    ans[x].clear()
                else:
                    for j in ans[fa[x]]:
                        if j not in ans[x]:
                            ans[x][j] = ans[fa[x]][j]
                        elif len(ans[x][j]) > len(ans[fa[x]][j]):
                            ans[x][j] |= ans[fa[x]][j]
                            ans[fa[x]][j].clear()
                        else:
                            ans[fa[x]][j] |= ans[x][j]
                            ans[x][j].clear()
                            ans[x][j] = ans[fa[x]][j]
                    ans[fa[x]].clear()
                    ans[fa[x]] = ans[x]
            x = fa[x]
            nowChild[x] += 1
            dep -= 1
        else:
            x = Child[x][nowChild[x]]
            dep += 1
dfs(0, 0)
for i in range(0, m):
    print(answer[i])
","['binary search', 'data structures', 'dfs and similar', 'dp', 'sortings']"
644,"In some social network, there are $$$n$$$ users communicating with each other in $$$m$$$ groups of friends. Let's analyze the process of distributing some news between users.Initially, some user $$$x$$$ receives the news from some source. Then he or she sends the news to his or her friends (two users are friends if there is at least one group such that both of them belong to this group). Friends continue sending the news to their friends, and so on. The process ends when there is no pair of friends such that one of them knows the news, and another one doesn't know.For each user $$$x$$$ you have to determine what is the number of users that will know the news if initially only user $$$x$$$ starts distributing it.  nan import sys,bisect

from sys  import stdin,stdout

from bisect import bisect_left,bisect_right,bisect,insort,insort_left,insort_right

from math import gcd,ceil,floor,sqrt

from collections import Counter,defaultdict,deque,OrderedDict

from queue import Queue,PriorityQueue

from string import ascii_lowercase

from heapq import *

from itertools import islice


sys.setrecursionlimit(10**6)
INF = float('inf')
MOD = 998244353
mod = 10**9+7

def st():
    return list(stdin.readline().strip())

def inp():
    return int(stdin.readline())

def li():
    return list(map(int,stdin.readline().split()))

def mp():
    return map(int,stdin.readline().split())

def solve():
    n,m=mp()
    d={i:[] for i in range(1,n+1)}
    for _ in range(m):
        l=li()
        x=l[0]
        if x>1:
            for i in range(1,x):
                d[l[i]].append(l[i+1])
                d[l[i+1]].append(l[i])

    
                
    ans=[-1 for i in range(n+1)]
    vi=[-1 for i in range(n+1)]
    for i in range(1,n+1):
        
        if vi[i]==-1:
            
            vi[i]=i
            stack=[i]
            ans[i]=1
            while stack:
                a=stack.pop()
                for x in d[a]:
                    if vi[x]==-1:
                        ans[i]+=1
                        vi[x]=i
                        stack.append(x)
                    

    print(' '.join((str(ans[vi[i]]) for i in range(1,n+1))))
    

for _ in range(1):
    solve()
##    print(""Case #{}:"".format(_+1),c)
##    
","['dfs and similar', 'dsu', 'graphs']"
1057,"Three swimmers decided to organize a party in the swimming pool! At noon, they started to swim from the left side of the pool.It takes the first swimmer exactly $$$a$$$ minutes to swim across the entire pool and come back, exactly $$$b$$$ minutes for the second swimmer and $$$c$$$ minutes for the third. Hence, the first swimmer will be on the left side of the pool after $$$0$$$, $$$a$$$, $$$2a$$$, $$$3a$$$, ... minutes after the start time, the second one will be at $$$0$$$, $$$b$$$, $$$2b$$$, $$$3b$$$, ... minutes, and the third one will be on the left side of the pool after $$$0$$$, $$$c$$$, $$$2c$$$, $$$3c$$$, ... minutes.You came to the left side of the pool exactly $$$p$$$ minutes after they started swimming. Determine how long you have to wait before one of the swimmers arrives at the left side of the pool. NoteIn the first test case, the first swimmer is on the left side in $$$0, 5, 10, 15, \ldots$$$ minutes after the start time, the second swimmer is on the left side in $$$0, 4, 8, 12, \ldots$$$ minutes after the start time, and the third swimmer is on the left side in $$$0, 8, 16, 24, \ldots$$$ minutes after the start time. You arrived at the pool in $$$9$$$ minutes after the start time and in a minute you will meet the first swimmer on the left side.In the second test case, the first swimmer is on the left side in $$$0, 6, 12, 18, \ldots$$$ minutes after the start time, the second swimmer is on the left side in $$$0, 10, 20, 30, \ldots$$$ minutes after the start time, and the third swimmer is on the left side in $$$0, 9, 18, 27, \ldots$$$ minutes after the start time. You arrived at the pool $$$2$$$ minutes after the start time and after $$$4$$$ minutes meet the first swimmer on the left side.In the third test case, you came to the pool $$$10$$$ minutes after the start time. At the same time, all three swimmers are on the left side. A rare stroke of luck!In the fourth test case, all swimmers are located on the left side in $$$0, 9, 18, 27, \ldots$$$ minutes after the start time. You arrived at the pool $$$10$$$ minutes after the start time and after $$$8$$$ minutes meet all three swimmers on the left side. # import sys
# sys.stdout = open('DSA/Stacks/output.txt', 'w')
# sys.stdin = open('DSA/Stacks/input.txt', 'r')

for _ in range(int(input())):
    p,a,b,c = map(int, input().split())
    zz = [a,b,c]
    for i in range(len(zz)):
        if p%zz[i]==0:
            zz[i]=0
        else:
            zz[i] = zz[i]-(p%zz[i])
    print(min(zz))",['math']
4229,"Polycarp plays a well-known computer game (we won't mention its name). In this game, he can craft tools of two types — shovels and swords. To craft a shovel, Polycarp spends two sticks and one diamond; to craft a sword, Polycarp spends two diamonds and one stick.Each tool can be sold for exactly one emerald. How many emeralds can Polycarp earn, if he has $$$a$$$ sticks and $$$b$$$ diamonds? NoteIn the first test case Polycarp can earn two emeralds as follows: craft one sword and one shovel.In the second test case Polycarp does not have any diamonds, so he cannot craft anything. #------------------------------what is this I don't know....just makes my mess faster--------------------------------------
import os
import sys
from io import BytesIO, IOBase
 
BUFSIZE = 8192
 
class FastIO(IOBase):
	newlines = 0
 
	def __init__(self, file):
		self._fd = file.fileno()
		self.buffer = BytesIO()
		self.writable = ""x"" in file.mode or ""r"" not in file.mode
		self.write = self.buffer.write if self.writable else None
 
	def read(self):
		while True:
			b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
			if not b:
				break
			ptr = self.buffer.tell()
			self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
		self.newlines = 0
		return self.buffer.read()
 
	def readline(self):
		while self.newlines == 0:
			b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
			self.newlines = b.count(b""\n"") + (not b)
			ptr = self.buffer.tell()
			self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
		self.newlines -= 1
		return self.buffer.readline()
 
	def flush(self):
		if self.writable:
			os.write(self._fd, self.buffer.getvalue())
			self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
	def __init__(self, file):
		self.buffer = FastIO(file)
		self.flush = self.buffer.flush
		self.writable = self.buffer.writable
		self.write = lambda s: self.buffer.write(s.encode(""ascii""))
		self.read = lambda: self.buffer.read().decode(""ascii"")
		self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
 
#----------------------------------Real game starts here--------------------------------------

#_______________________________________________________________#
def fact(x):
	if x == 0:
		return 1
	else:
		return x * fact(x-1)
def lower_bound(li, num): #return 0 if all are greater or equal to
	answer = -1 
	start = 0
	end = len(li)-1

	while(start <= end):
		middle = (end+start)//2
		if li[middle] >= num:
			answer = middle
			end = middle - 1
		else:
			start = middle + 1
	return answer #index where x is not less than num
def upper_bound(li, num): #return n-1 if all are small or equal
	answer = -1
	start = 0
	end = len(li)-1

	while(start <= end):
		middle = (end+start)//2

		if li[middle] <= num:
			answer = middle
			start = middle + 1
		
		else:
			end = middle - 1
	return answer #index where x is not greater than num

def abs(x):
	return x if x >=0 else -x
def binary_search(li, val, lb, ub):
	ans = 0
	while(lb <= ub):
		mid = (lb+ub)//2
		#print(mid, li[mid])
		if li[mid] > val:
			ub = mid-1
		elif val > li[mid]:
			lb = mid + 1
		else:
			ans = 1
			break
	return ans

def sieve_of_eratosthenes(n):
	ans = []
	arr = [1]*(n+1)
	arr[0],arr[1], i = 0, 0, 2
	while(i*i <= n):
		if arr[i] == 1:
			j = i+i
			while(j <= n):
				arr[j] = 0
				j += i
		i += 1
	for k in range(n):
		if arr[k] == 1:
			ans.append(k)
	return ans
def nc2(x):
	if x == 1:
		return 0
	else:
		return x*(x-1)//2
#_______________________________________________________________#
'''
      ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄
   ▄███████▀▀▀▀▀▀███████▄
░▐████▀▒▒Aestroix▒▒▀██████
░███▀▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▀████
░▐██▒▒▒▒▒KARMANYA▒▒▒▒▒▒████▌         ________________
░▐█▌▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒████▌  ? ?   |▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒|
░░█▒▒▄▀▀▀▀▀▄▒▒▄▀▀▀▀▀▄▒▒▐███▌   ?    |___CM ONE DAY___|
░░░▐░░░▄▄░░▌▐░░░▄▄░░▌▒▐███▌     ? ? |▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒|
░▄▀▌░░░▀▀░░▌▐░░░▀▀░░▌▒▀▒█▌    ? ?    
░▌▒▀▄░░░░▄▀▒▒▀▄░░░▄▀▒▒▄▀▒▌      ? 
░▀▄▐▒▀▀▀▀▒▒▒▒▒▒▀▀▀▒▒▒▒▒▒█     ? ? 
░░░▀▌▒▄██▄▄▄▄████▄▒▒▒▒█▀       ? 
░░░░▄█████████ ████=========█▒▒▐▌
░░░▀███▀▀████▀█████▀▒▌
░░░░░▌▒▒▒▄▒▒▒▄▒▒▒▒▒▒▐
░░░░░▌▒▒▒▒▀▀▀▒▒▒▒▒▒▒▐
░░░░░████████████████
'''

for _ in range(int(input()) if True else 1):
	o, z = map(int, input().split())
	print(min(o, z, (o+z)//3))




	





","['binary search', 'greedy', 'math']"
485,"Facetook is a well known social network website, and it will launch a new feature called Facetook Priority Wall. This feature will sort all posts from your friends according to the priority factor (it will be described).This priority factor will be affected by three types of actions:   1. ""X posted on Y's wall"" (15 points),  2. ""X commented on Y's post"" (10 points),  3. ""X likes Y's post"" (5 points). X and Y will be two distinct names. And each action will increase the priority factor between X and Y (and vice versa) by the above value of points (the priority factor between X and Y is the same as the priority factor between Y and X).You will be given n actions with the above format (without the action number and the number of points), and you have to print all the distinct names in these actions sorted according to the priority factor with you. nan r={'posted':15,'commented':10,'likes':5}
n=input()
a={}
m=set()
for _ in '0'*int(input()):
	t=input().split()
	s=t[0]
	p=t[3-(t[1]=='likes')][:-2]
	m.add(s)
	m.add(p)
	if s==n:
		a[p]=a.get(p,0)+r[t[1]]
	if p==n:
		a[s]=a.get(s,0)+r[t[1]]
if n in m:
	m.remove(n)
for v in sorted(set(a.values())|set([0]))[::-1]:
	print('\n'.join(sorted(s for s in m if a.get(s,0)==v)))
","['implementation', 'other', 'strings']"
1392,"Let's imagine: there is a chess piece billiard ball. Its movements resemble the ones of a bishop chess piece. The only difference is that when a billiard ball hits the board's border, it can reflect from it and continue moving.More formally, first one of four diagonal directions is chosen and the billiard ball moves in that direction. When it reaches the square located on the board's edge, the billiard ball reflects from it; it changes the direction of its movement by 90 degrees and continues moving. Specifically, having reached a corner square, the billiard ball is reflected twice and starts to move the opposite way. While it moves, the billiard ball can make an infinite number of reflections. At any square of its trajectory the billiard ball can stop and on that the move is considered completed.  It is considered that one billiard ball a beats another billiard ball b if a can reach a point where b is located.You are suggested to find the maximal number of billiard balls, that pairwise do not beat each other and that can be positioned on a chessboard n × m in size. nan def gcd(x,y):
  return y and gcd(y,x%y) or x
n,m=map(int,raw_input().split())
print gcd(n-1,m-1)+1
","['dfs and similar', 'dsu', 'graphs', 'number theory']"
805,"Watchmen are in a danger and Doctor Manhattan together with his friend Daniel Dreiberg should warn them as soon as possible. There are n watchmen on a plane, the i-th watchman is located at point (xi, yi).They need to arrange a plan, but there are some difficulties on their way. As you know, Doctor Manhattan considers the distance between watchmen i and j to be |xi - xj| + |yi - yj|. Daniel, as an ordinary person, calculates the distance using the formula .The success of the operation relies on the number of pairs (i, j) (1 ≤ i &lt; j ≤ n), such that the distance between watchman i and watchmen j calculated by Doctor Manhattan is equal to the distance between them calculated by Daniel. You were asked to compute the number of such pairs. NoteIn the first sample, the distance between watchman 1 and watchman 2 is equal to |1 - 7| + |1 - 5| = 10 for Doctor Manhattan and  for Daniel. For pairs (1, 1), (1, 5) and (7, 5), (1, 5) Doctor Manhattan and Daniel will calculate the same distances. 

points = []
row_count = int(input())
for _ in range(row_count):
    rawLine = input().split()
    points.append([int(rawLine[0]),int(rawLine[1])])


total = 0
for i in range(2):
    points.sort(key= lambda x : x[i])
    previous = 1
    for j in range(1,row_count+1):
        if j != row_count and points[j][i] == points[j-1][i]:
            previous += 1
        else:
            total += (previous*(previous-1))/2
            previous = 1

points.sort(key= lambda x : (x[0],x[1]))
previous = 1
for j in range(1,row_count+1):
    if j != row_count and points[j][0] == points[j-1][0] and points[j][1] == points[j-1][1]:
        previous += 1
    else:
        total -= (previous*(previous-1))/2 # Duplicates
        previous = 1

print(int(total))","['data structures', 'geometry', 'implementation', 'sortings']"
4077,"Circular land is an $$$2n \times 2n$$$ grid. Rows of this grid are numbered by integers from $$$1$$$ to $$$2n$$$ from top to bottom and columns of this grid are numbered by integers from $$$1$$$ to $$$2n$$$ from left to right. The cell $$$(x, y)$$$ is the cell on the intersection of row $$$x$$$ and column $$$y$$$ for $$$1 \leq x \leq 2n$$$ and $$$1 \leq y \leq 2n$$$.There are $$$n^2$$$ of your friends in the top left corner of the grid. That is, in each cell $$$(x, y)$$$ with $$$1 \leq x, y \leq n$$$ there is exactly one friend. Some of the other cells are covered with snow.Your friends want to get to the bottom right corner of the grid. For this in each cell $$$(x, y)$$$ with $$$n+1 \leq x, y \leq 2n$$$ there should be exactly one friend. It doesn't matter in what cell each of friends will be.You have decided to help your friends to get to the bottom right corner of the grid.For this, you can give instructions of the following types:   You select a row $$$x$$$. All friends in this row should move to the next cell in this row. That is, friend from the cell $$$(x, y)$$$ with $$$1 \leq y &lt; 2n$$$ will move to the cell $$$(x, y + 1)$$$ and friend from the cell $$$(x, 2n)$$$ will move to the cell $$$(x, 1)$$$.  You select a row $$$x$$$. All friends in this row should move to the previous cell in this row. That is, friend from the cell $$$(x, y)$$$ with $$$1 &lt; y \leq 2n$$$ will move to the cell $$$(x, y - 1)$$$ and friend from the cell $$$(x, 1)$$$ will move to the cell $$$(x, 2n)$$$.  You select a column $$$y$$$. All friends in this column should move to the next cell in this column. That is, friend from the cell $$$(x, y)$$$ with $$$1 \leq x &lt; 2n$$$ will move to the cell $$$(x + 1, y)$$$ and friend from the cell $$$(2n, y)$$$ will move to the cell $$$(1, y)$$$.  You select a column $$$y$$$. All friends in this column should move to the previous cell in this column. That is, friend from the cell $$$(x, y)$$$ with $$$1 &lt; x \leq 2n$$$ will move to the cell $$$(x - 1, y)$$$ and friend from the cell $$$(1, y)$$$ will move to the cell $$$(2n, y)$$$. Note how friends on the grid border behave in these instructions.  Example of applying the third operation to the second column. Here, colorful circles denote your friends and blue cells are covered with snow. You can give such instructions any number of times. You can give instructions of different types. If after any instruction one of your friends is in the cell covered with snow he becomes ill.In order to save your friends you can remove snow from some cells before giving the first instruction:   You can select the cell $$$(x, y)$$$ that is covered with snow now and remove snow from this cell for $$$c_{x, y}$$$ coins. You can do this operation any number of times.You want to spend the minimal number of coins and give some instructions to your friends. After this, all your friends should be in the bottom right corner of the grid and none of them should be ill.Please, find how many coins you will spend. NoteIn the first test case you can remove snow from the cells $$$(2, 1)$$$ and $$$(2, 2)$$$ for $$$100$$$ coins. Then you can give instructions   All friends in the first collum should move to the previous cell. After this, your friend will be in the cell $$$(2, 1)$$$.  All friends in the second row should move to the next cell. After this, your friend will be in the cell $$$(2, 2)$$$. In the second test case you can remove all snow from the columns $$$3$$$ and $$$4$$$ for $$$22$$$ coins. Then you can give instructions   All friends in the first row should move to the next cell.  All friends in the first row should move to the next cell.  All friends in the second row should move to the next cell.  All friends in the second row should move to the next cell.  All friends in the third column should move to the next cell.  All friends in the third column should move to the next cell.  All friends in the fourth column should move to the next cell.  All friends in the fourth column should move to the next cell. It can be shown that none of the friends will become ill and that it is impossible to spend less coins. from sys import stdin, gettrace

if gettrace():
    def inputi():
        return input()
else:
    def input():
        return next(stdin)[:-1]


    def inputi():
        return stdin.buffer.readline()


def solve():
    n = int(input())
    cc = [[int(c) for c in input().split()] for _ in range(2*n)]
    res = sum(sum(cc[i][n:]) for i in range(n, 2*n)) + min(cc[0][n],
                                                           cc[0][2*n - 1],
                                                           cc[n-1][n],
                                                           cc[n-1][2*n -1],
                                                           cc[n][0],
                                                           cc[2*n-1][0],
                                                           cc[n][n-1],
                                                           cc[2*n-1][n-1])
    print(res)

def main():
    t = int(input())
    for _ in range(t):
        solve()


if __name__ == ""__main__"":
    main()
","['constructive algorithms', 'greedy', 'math']"
1557,"Vasya is interested in arranging dominoes. He is fed up with common dominoes and he uses the dominoes of different heights. He put n dominoes on the table along one axis, going from left to right. Every domino stands perpendicular to that axis so that the axis passes through the center of its base. The i-th domino has the coordinate xi and the height hi. Now Vasya wants to learn for every domino, how many dominoes will fall if he pushes it to the right. Help him do that. Consider that a domino falls if it is touched strictly above the base. In other words, the fall of the domino with the initial coordinate x and height h leads to the fall of all dominoes on the segment [x + 1, x + h - 1]. nan n = input()
l=sorted([map(int,raw_input().split())+[i] for i in xrange(n)]+[(3*10**8,0)],reverse=1)
r=[(0,0)]*(n+1)
r[0]=[(-1,0)]
for i in xrange(1,n+1):
    x,h,j=l[i]
    y = x+h
    p = i-1
    while (y>l[p][0]): p-=r[p][1]
    r[i]=(j,i-p)

print ' '.join(map(lambda x:str(x[1]),sorted(r[1:])))
","['binary search', 'data structures', 'sortings']"
1777,"A rectangle with sides $$$A$$$ and $$$B$$$ is cut into rectangles with cuts parallel to its sides. For example, if $$$p$$$ horizontal and $$$q$$$ vertical cuts were made, $$$(p + 1) \cdot (q + 1)$$$ rectangles were left after the cutting. After the cutting, rectangles were of $$$n$$$ different types. Two rectangles are different if at least one side of one rectangle isn't equal to the corresponding side of the other. Note that the rectangle can't be rotated, this means that rectangles $$$a \times b$$$ and $$$b \times a$$$ are considered different if $$$a \neq b$$$.For each type of rectangles, lengths of the sides of rectangles are given along with the amount of the rectangles of this type that were left after cutting the initial rectangle.Calculate the amount of pairs $$$(A; B)$$$ such as the given rectangles could be created by cutting the rectangle with sides of lengths $$$A$$$ and $$$B$$$. Note that pairs $$$(A; B)$$$ and $$$(B; A)$$$ are considered different when $$$A \neq B$$$. NoteIn the first sample there are three suitable pairs: $$$(1; 9)$$$, $$$(3; 3)$$$ and $$$(9; 1)$$$.In the second sample case there are 6 suitable pairs: $$$(2; 220)$$$, $$$(4; 110)$$$, $$$(8; 55)$$$, $$$(10; 44)$$$, $$$(20; 22)$$$ and $$$(40; 11)$$$.Here the sample of cut for $$$(20; 22)$$$.  The third sample has no suitable pairs. n = input()

w=[]
h=[]
c=[]
cntw={}
cnth={}
gcdC=0
cntC=0

def insert1(a,b,c):
	if not a in b :
		b[a]=c
	else :
		b[a]=b[a]+c

def gcd(a,b): 
	if a % b == 0 :
		return b
	else :
		return gcd(b,a%b)

for i in range(0, n):
	a,b,d = map(int, raw_input().split())
	w.append(a)
	h.append(b)
	c.append(d)
	insert1(a,cntw,d)
	insert1(b,cnth,d)
	cntC += d
	if gcdC == 0 :
		gcdC = d
	else :
		gcdC = gcd(gcdC, d)

for i in range(0, n):
	if cntw[w[i]] * cnth[h[i]] != cntC * c[i]:
		print 0
		exit()

ans = 0
i = 1
while (i * i <= gcdC) :
	if gcdC % i == 0 :
		ans += 1
		if i * i != gcdC :
			ans += 1
	i += 1

print ans
",['math']
2227,"For a connected undirected weighted graph G, MST (minimum spanning tree) is a subgraph of G that contains all of G's vertices, is a tree, and sum of its edges is minimum possible.You are given a graph G. If you run a MST algorithm on graph it would give you only one MST and it causes other edges to become jealous. You are given some queries, each query contains a set of edges of graph G, and you should determine whether there is a MST containing all these edges or not. NoteThis is the graph of sample:  Weight of minimum spanning tree on this graph is 6.MST with edges (1, 3, 4, 6), contains all of edges from the first query, so answer on the first query is ""YES"".Edges from the second query form a cycle of length 3, so there is no spanning tree including these three edges. Thus, answer is ""NO"". import sys, collections
range = xrange
input = raw_input

class DisjointSetUnion0:
    def __init__(self, n):
        self.data = [-1] * n

    def __getitem__(self, a):
        acopy = a
        while self.data[a] >= 0:
            a = self.data[a]
        while acopy != a:
            self.data[acopy], acopy = a, self.data[acopy]
        return a

    def __call__(self, a, b):
        a, b = self[a], self[b]
        if a != b:
            if self.data[a] > self.data[b]:
                a, b = b, a

            self.data[a] += self.data[b]
            self.data[b] = a

class DisjointSetUnion1:
    def __init__(self):
        self.data = collections.defaultdict(lambda: -1)

    def __getitem__(self, a):
        acopy = a
        while self.data[a] >= 0:
            a = self.data[a]
        while acopy != a:
            self.data[acopy], acopy = a, self.data[acopy]
        return a

    def __call__(self, a, b):
        a, b = self[a], self[b]
        if a != b:
            if self.data[a] > self.data[b]:
                a, b = b, a

            self.data[a] += self.data[b]
            self.data[b] = a
            return True
        return False

inp = [int(x) for x in sys.stdin.read().split()]; ii = 0

n = inp[ii]; ii += 1
m = inp[ii]; ii += 1

V = []
W = []
for _ in range(m):
    u = inp[ii] - 1; ii += 1
    v = inp[ii] - 1; ii += 1
    w = inp[ii]; ii += 1
    eind = len(V)
    V.append(v)
    V.append(u)
    W.append(w)

q = inp[ii]; ii += 1
ans = [1]*q

queries = collections.defaultdict(list)

for qind in range(q):
    k = inp[ii]; ii += 1
    E = [eind - 1 << 1 for eind in inp[ii: ii + k]]; ii += k
    found = set()
    for eind in E:
        w = W[eind >> 1]
        if w not in found:
            found.add(w)
            queries[w].append([qind])
        queries[w][-1].append(eind)

buckets = collections.defaultdict(list)
for eind in range(0, 2 * m, 2):
    buckets[W[eind >> 1]].append(eind)

dsu0 = DisjointSetUnion0(n)
for w in sorted(buckets):
    for query in queries[w]:
        dsu1 = DisjointSetUnion1()
        qind = query[0]
        for eind in query[1:]:
            v = dsu0[V[eind]]
            u = dsu0[V[eind ^ 1]]
            if not dsu1(u,v):
                ans[qind] = 0
                break

    for eind in buckets[w]:
        dsu0(V[eind], V[eind ^ 1])

print '\n'.join('YES' if a else 'NO' for a in ans)
","['data structures', 'dsu', 'graphs']"
1424,"After the educational reform Polycarp studies only two subjects at school, Safety Studies and PE (Physical Education). During the long months of the fourth term, he received n marks in them. When teachers wrote a mark in the journal, they didn't write in what subject the mark was for, they just wrote the mark.Now it's time to show the journal to his strict parents. Polycarp knows that recently at the Parent Meeting the parents were told that he received a Safety Studies marks and b PE marks (a + b = n). Now Polycarp wants to write a subject's name in front of each mark so that:   there are exactly a Safety Studies marks,  there are exactly b PE marks,  the total average score in both subjects is maximum. An average subject grade is the sum of all marks in it, divided by the number of them. Of course, the division is performed in real numbers without rounding up or down. Polycarp aims to maximize the x1 + x2, where x1 is the average score in the first subject (Safety Studies), and x2 is the average score in the second one (Physical Education). NoteIn the first sample the average score in the first subject is equal to 4, and in the second one — to 4.5. The total average score is 8.5. f=lambda:map(int,raw_input().split())
n,(a,b),t=f(),f(),f()
s=[sorted(t,reverse=a<b),t][a==b][:a]
c=[[1]*s.count(i)for i in range(6)]
for x in t:print c[x]and(c[x].pop())or 2,
","['greedy', 'math', 'sortings']"
3097,"There are n student groups at the university. During the study day, each group can take no more than 7 classes. Seven time slots numbered from 1 to 7 are allocated for the classes.The schedule on Monday is known for each group, i. e. time slots when group will have classes are known.Your task is to determine the minimum number of rooms needed to hold classes for all groups on Monday. Note that one room can hold at most one group class in a single time slot. NoteIn the first example one room is enough. It will be occupied in each of the seven time slot by the first group or by the second group.In the second example three rooms is enough, because in the seventh time slot all three groups have classes. n = int(input())
a = [input() for i in range(n)]
print(max(map(lambda x: x.count('1'), zip(*a))))",['implementation']
4810,"Little Bolek has found a picture with n mountain peaks painted on it. The n painted peaks are represented by a non-closed polyline, consisting of 2n segments. The segments go through 2n + 1 points with coordinates (1, y1), (2, y2), ..., (2n + 1, y2n + 1), with the i-th segment connecting the point (i, yi) and the point (i + 1, yi + 1). For any even i (2 ≤ i ≤ 2n) the following condition holds: yi - 1 &lt; yi and yi &gt; yi + 1. We shall call a vertex of a polyline with an even x coordinate a mountain peak.   The figure to the left shows the initial picture, the figure to the right shows what the picture looks like after Bolek's actions. The affected peaks are marked red, k = 2.  Bolek fancied a little mischief. He chose exactly k mountain peaks, rubbed out the segments that went through those peaks and increased each peak's height by one (that is, he increased the y coordinate of the corresponding points). Then he painted the missing segments to get a new picture of mountain peaks. Let us denote the points through which the new polyline passes on Bolek's new picture as (1, r1), (2, r2), ..., (2n + 1, r2n + 1).Given Bolek's final picture, restore the initial one. nan n, k = map(int, input().split())
ins = list(map(int, input().split()))
for i in range(1, 2*n + 1):
    if ins[i] > ins[i - 1] and ins[i] > ins[i + 1] and k != 0\
            and (ins[i] - 1) > ins[i - 1] and (ins[i] - 1) > ins[i + 1]:
        ins[i] -= 1
        k -= 1
print(' '.join(str(x) for x in ins))","['brute force', 'constructive algorithms', 'implementation']"
2364,"You are given $$$n$$$ strings $$$s_1, s_2, \ldots, s_n$$$ consisting of lowercase Latin letters.In one operation you can remove a character from a string $$$s_i$$$ and insert it to an arbitrary position in a string $$$s_j$$$ ($$$j$$$ may be equal to $$$i$$$). You may perform this operation any number of times. Is it possible to make all $$$n$$$ strings equal? NoteIn the first test case, you can do the following:   Remove the third character of the first string and insert it after the second character of the second string, making the two strings ""ca"" and ""cbab"" respectively. Remove the second character of the second string and insert it after the second character of the first string, making both strings equal to ""cab"". In the second test case, it is impossible to make all $$$n$$$ strings equal. for i in range(int(input())):
    a = int(input())
    d = {}
    for i in range(a):
        for x in input():
            if x in d:
                d[x] += 1
            else:
                d[x] = 1
    key = True
    for i in d:
        if d[i] % a != 0:
            key = False
    if key: print(""YES"")
    else: print(""NO"")","['greedy', 'strings']"
471,"Вам задано прямоугольное клетчатое поле, состоящее из n строк и m столбцов. Поле содержит цикл из символов «*», такой что:  цикл можно обойти, посетив каждую его клетку ровно один раз, перемещаясь каждый раз вверх/вниз/вправо/влево на одну клетку;  цикл не содержит самопересечений и самокасаний, то есть две клетки цикла соседствуют по стороне тогда и только тогда, когда они соседние при перемещении вдоль цикла (самокасание по углу тоже запрещено). Ниже изображены несколько примеров допустимых циклов:  Все клетки поля, отличные от цикла, содержат символ «.». Цикл на поле ровно один. Посещать клетки, отличные от цикла, Роботу нельзя.В одной из клеток цикла находится Робот. Эта клетка помечена символом «S». Найдите последовательность команд для Робота, чтобы обойти цикл. Каждая из четырёх возможных команд кодируется буквой и обозначает перемещение Робота на одну клетку:  «U» — сдвинуться на клетку вверх,  «R» — сдвинуться на клетку вправо,  «D» — сдвинуться на клетку вниз,  «L» — сдвинуться на клетку влево. Робот должен обойти цикл, побывав в каждой его клетке ровно один раз (кроме стартовой точки — в ней он начинает и заканчивает свой путь).Найдите искомую последовательность команд, допускается любое направление обхода цикла. ПримечаниеВ первом тестовом примере для обхода по часовой стрелке последовательность посещенных роботом клеток выглядит следующим образом:  клетка (3, 2);  клетка (3, 1);  клетка (2, 1);  клетка (1, 1);  клетка (1, 2);  клетка (1, 3);  клетка (2, 3);  клетка (3, 3);  клетка (3, 2).  def read_ints():
    return [int(x) for x in input(' ').split()]


def main():
    n, m = read_ints()
    field = []
    x, y = None, None
    for i in range(n):
        line = input()
        if 'S' in line:
            x, y = i, line.find('S')
        field.append(list(line))
    field[x][y] = '*'
    flag = False
    curr_x, curr_y = x, y
    delta = [(-1, 0, 'U'), (+1, 0, 'D'), (0, -1, 'L'), (0, +1, 'R')]
    par_x, par_y = -1, -1
    while True:
        if flag:
            field[curr_x][curr_y] = 'U'
        flag = True
        for dx, dy, label in delta:
            next_x, next_y = curr_x + dx, curr_y + dy
            if not 0 <= next_x < n:
                continue
            if not 0 <= next_y < m:
                continue
            if par_x == next_x and par_y == next_y:
                continue
            if field[next_x][next_y] == '*':
                print(label, end='', flush=True)
                par_x, par_y = curr_x, curr_y
                curr_x, curr_y = next_x, next_y
                break
        if x == curr_x and y == curr_y:
            break

if __name__ == '__main__':
    main()","['dfs and similar', 'graphs']"
1589,"It is given a positive integer $$$n$$$. In $$$1$$$ move, one can select any single digit and remove it (i.e. one selects some position in the number and removes the digit located at this position). The operation cannot be performed if only one digit remains. If the resulting number contains leading zeroes, they are automatically removed.E.g. if one removes from the number $$$32925$$$ the $$$3$$$-rd digit, the resulting number will be $$$3225$$$. If one removes from the number $$$20099050$$$ the first digit, the resulting number will be $$$99050$$$ (the $$$2$$$ zeroes going next to the first digit are automatically removed).What is the minimum number of steps to get a number such that it is divisible by $$$25$$$ and positive? It is guaranteed that, for each $$$n$$$ occurring in the input, the answer exists. It is guaranteed that the number $$$n$$$ has no leading zeros. NoteIn the first test case, it is already given a number divisible by $$$25$$$.In the second test case, we can remove the digits $$$1$$$, $$$3$$$, and $$$4$$$ to get the number $$$75$$$.In the third test case, it's enough to remove the last digit to get the number $$$325$$$.In the fourth test case, we can remove the three last digits to get the number $$$50$$$.In the fifth test case, it's enough to remove the digits $$$4$$$ and $$$7$$$. for _ in range(int(input())):
    s = input()
    count = 0
    for i in range(len(s) - 1):
        for j in range(i+1, len(s)):
            if int(s[i]+s[j]) % 25 == 0:
                count = len(s)-i-2
    print(count)","['dfs and similar', 'dp', 'greedy', 'math']"
3105,"You are given an array $$$a$$$ of length $$$n$$$.You are also given a set of distinct positions $$$p_1, p_2, \dots, p_m$$$, where $$$1 \le p_i &lt; n$$$. The position $$$p_i$$$ means that you can swap elements $$$a[p_i]$$$ and $$$a[p_i + 1]$$$. You can apply this operation any number of times for each of the given positions.Your task is to determine if it is possible to sort the initial array in non-decreasing order ($$$a_1 \le a_2 \le \dots \le a_n$$$) using only allowed swaps.For example, if $$$a = [3, 2, 1]$$$ and $$$p = [1, 2]$$$, then we can first swap elements $$$a[2]$$$ and $$$a[3]$$$ (because position $$$2$$$ is contained in the given set $$$p$$$). We get the array $$$a = [3, 1, 2]$$$. Then we swap $$$a[1]$$$ and $$$a[2]$$$ (position $$$1$$$ is also contained in $$$p$$$). We get the array $$$a = [1, 3, 2]$$$. Finally, we swap $$$a[2]$$$ and $$$a[3]$$$ again and get the array $$$a = [1, 2, 3]$$$, sorted in non-decreasing order.You can see that if $$$a = [4, 1, 2, 3]$$$ and $$$p = [3, 2]$$$ then you cannot sort the array.You have to answer $$$t$$$ independent test cases. nan import sys

def controlla(i):
    global res, r,ultimo_ok
    if res == False:
        return
    if i == 0:
        controlla(ultimo_ok+1)
        return
    if r[i-1]<= r[i]:
        if i == N-1:
            
            return
        else:
            ultimo_ok  = max(ultimo_ok,i)
            controlla(ultimo_ok+1)
    else:
        if P[i-1] == 1:
            a = r[i]
            r[i] = r[i-1]
            r[i-1] = a
            controlla(i-1)
        else:
            res = False            
            return

sys.setrecursionlimit(10000)
#sys.stdin = open(""input.txt"")
T = int(input())
for t in range(T):
    N,M = map(int,input().split())
    r = list(map(int, input().strip().split()))
    p = list(map(int, input().strip().split()))
    P = [-1] * N
    for m in range(M):
        a = p[m]
        P[a-1] = 1
   
    res = True
    ultimo_ok = 0
    controlla(1)
    if not res:
        print (""NO"")
    else:
        print(""YES"")
","['dfs and similar', 'sortings']"
1623,"Devu and his brother love each other a lot. As they are super geeks, they only like to play with arrays. They are given two arrays a and b by their father. The array a is given to Devu and b to his brother. As Devu is really a naughty kid, he wants the minimum value of his array a should be at least as much as the maximum value of his brother's array b. Now you have to help Devu in achieving this condition. You can perform multiple operations on the arrays. In a single operation, you are allowed to decrease or increase any element of any of the arrays by 1. Note that you are allowed to apply the operation on any index of the array multiple times.You need to find minimum number of operations required to satisfy Devu's condition so that the brothers can play peacefully without fighting.  NoteIn example 1, you can increase a1 by 1 and decrease b2 by 1 and then again decrease b2 by 1. Now array a will be [3; 3] and array b will also be [3; 3]. Here minimum element of a is at least as large as maximum element of b. So minimum number of operations needed to satisfy Devu's condition are 3.In example 3, you don't need to do any operation, Devu's condition is already satisfied.  R = lambda: map(int, input().split())
n, m = R()
a = sorted(R())
b = sorted(R())
b.reverse()
ans = 0
for i in range(min(n, m)):
    if b[i] > a[i]:
        ans += b[i] - a[i]
print(ans)","['binary search', 'other', 'sortings', 'two pointers']"
530,"Fox Ciel wants to write a task for a programming contest. The task is: ""You are given a simple undirected graph with n vertexes. Each its edge has unit length. You should calculate the number of shortest paths between vertex 1 and vertex 2.""Same with some writers, she wants to make an example with some certain output: for example, her birthday or the number of her boyfriend. Can you help her to make a test case with answer equal exactly to k? NoteIn first example, there are 2 shortest paths: 1-3-2 and 1-4-2.In second example, there are 9 shortest paths: 1-3-6-2, 1-3-7-2, 1-3-8-2, 1-4-6-2, 1-4-7-2, 1-4-8-2, 1-5-6-2, 1-5-7-2, 1-5-8-2. k = int(input())


edges = [['N' for i in range(1010)] for j in range(1010)]
vertices = 2

def add_edge(a, b):
    global edges
    edges[a][b] = edges[b][a] = 'Y'


for i in range(1, 29 + 1):
    vertices += 3
    add_edge(i * 3, i * 3 - 1)
    add_edge(i * 3, i * 3 + 2)
    add_edge(i * 3 + 1, i * 3 - 1)
    add_edge(i * 3 + 1, i * 3 + 2)


for bit in range(30):
    if (1 << bit) & k:
        lst = 1
        for i in range((29 - bit) * 2):
            vertices += 1
            add_edge(lst, vertices)
            lst = vertices
        add_edge(lst, 3 * bit + 2)

print(vertices)

if 0:
    for i in range(1, vertices + 1):
        print(i, ':', '\n\t', end='')
        for j in range(1, vertices + 1):
            if edges[i][j] == 'Y':
                print(j, end=' ')
        print('')
else:
    print('\n'.join(map(lambda x: ''.join(x[1:vertices+1]), edges[1:vertices + 1])))
","['bitmasks', 'constructive algorithms', 'graphs', 'implementation', 'math']"
3867,"You and your friend Ilya are participating in an individual programming contest consisting of multiple stages. A contestant can get between $$$0$$$ and $$$100$$$ points, inclusive, for each stage, independently of other contestants.Points received by contestants in different stages are used for forming overall contest results. Suppose that $$$k$$$ stages of the contest are completed. For each contestant, $$$k - \lfloor \frac{k}{4} \rfloor$$$ stages with the highest scores are selected, and these scores are added up. This sum is the overall result of the contestant. (Here $$$\lfloor t \rfloor$$$ denotes rounding $$$t$$$ down.)For example, suppose $$$9$$$ stages are completed, and your scores are $$$50, 30, 50, 50, 100, 10, 30, 100, 50$$$. First, $$$7$$$ stages with the highest scores are chosen — for example, all stages except for the $$$2$$$-nd and the $$$6$$$-th can be chosen. Then your overall result is equal to $$$50 + 50 + 50 + 100 + 30 + 100 + 50 = 430$$$.As of now, $$$n$$$ stages are completed, and you know the points you and Ilya got for these stages. However, it is unknown how many more stages will be held. You wonder what the smallest number of additional stages is, after which your result might become greater than or equal to Ilya's result, at least in theory. Find this number! NoteIn the first test case, you have scored $$$100$$$ points for the first stage, while Ilya has scored $$$0$$$. Thus, your overall result ($$$100$$$) is already not less than Ilya's result ($$$0$$$).In the second test case, you have scored $$$0$$$ points for the first stage, while Ilya has scored $$$100$$$. A single stage with an opposite result is enough for both your and Ilya's overall scores to become equal to $$$100$$$.In the third test case, your overall result is $$$30 + 40 + 50 = 120$$$, while Ilya's result is $$$100 + 100 + 100 = 300$$$. After three additional stages your result might become equal to $$$420$$$, while Ilya's result might become equal to $$$400$$$.In the fourth test case, your overall result after four additional stages might become equal to $$$470$$$, while Ilya's result might become equal to $$$400$$$. Three stages are not enough. t = int(input())

def solve(n,A,B):
  A.sort()
  B.sort()
  k = int(n/4)
  j = k-1
  sumA = sum(A[k:])
  sumB = sum(B[k:])
  i = 0
  while sumA < sumB:
    i += 1
    n += 1
    sumA += 100
    if n%4 == 0:
      k = int(n/4)-1
      sumA -= A[k]
      continue
    if j >= 0:
      sumB += B[j]
    j -= 1
  print(i)


for _ in range(t):
  n = int(input())
  A = list(map(int, input().split()))
  B = list(map(int, input().split()))
  solve(n,A,B)","['binary search', 'sortings']"
1720,"Mike and Joe are playing a game with some stones. Specifically, they have $$$n$$$ piles of stones of sizes $$$a_1, a_2, \ldots, a_n$$$. These piles are arranged in a circle.The game goes as follows. Players take turns removing some positive number of stones from a pile in clockwise order starting from pile $$$1$$$. Formally, if a player removed stones from pile $$$i$$$ on a turn, the other player removes stones from pile $$$((i\bmod n) + 1)$$$ on the next turn.If a player cannot remove any stones on their turn (because the pile is empty), they lose. Mike goes first.If Mike and Joe play optimally, who will win? NoteIn the first test case, Mike just takes all $$$37$$$ stones on his first turn.In the second test case, Joe can just copy Mike's moves every time. Since Mike went first, he will hit $$$0$$$ on the first pile one move before Joe does so on the second pile. t = int(input())
ar = [[] for i in range(t)]
p1, p2 = 'Mike', 'Joe'
for i in range(t):
    n = int(input())
    ar[i] += [int(o) for o in input().split()]


for i in range(t):
    if (len(ar[i]) % 2 == 1):
        print(""Mike"")
    else:
        smallest = 0
        for j in range(len(ar[i])):
            if (ar[i][j] < ar[i][smallest]):
                smallest = j
        # print(smallest)
        if (smallest % 2 == 0):
            print(""Joe"")
        else:
            print(""Mike"")
        # if (sum([s for s in ar[i][::2]]) > sum([s for s in ar[i][1::2]])):
        #     print(""Mike\n"")
        # else:
        #     print(""Joe\n"")
","['games', 'greedy']"
43,"n fish, numbered from 1 to n, live in a lake. Every day right one pair of fish meet, and the probability of each other pair meeting is the same. If two fish with indexes i and j meet, the first will eat up the second with the probability aij, and the second will eat up the first with the probability aji = 1 - aij. The described process goes on until there are at least two fish in the lake. For each fish find out the probability that it will survive to be the last in the lake. nan import sys
from array import array  # noqa: F401


def input():
    return sys.stdin.buffer.readline().decode('utf-8')


n = int(input())
prob = [tuple(map(float, input().split())) for _ in range(n)]
full_bit = (1 << n) - 1
dp = [0.0] * full_bit + [1.0]

for bit in range(full_bit, 0, -1):
    popcount = len([1 for i in range(n) if (1 << i) & bit])
    if popcount == 1 or dp[bit] == 0.0:
        continue
    div = 1 / ((popcount * (popcount - 1)) >> 1)

    for i in range(n):
        if ((1 << i) & bit) == 0:
            continue
        for j in range(i + 1, n):
            if ((1 << j) & bit) == 0:
                continue
            dp[bit - (1 << j)] += dp[bit] * prob[i][j] * div
            dp[bit - (1 << i)] += dp[bit] * prob[j][i] * div

print(*(dp[1 << i] for i in range(n)))
","['bitmasks', 'dp', 'probabilities']"
4043,"This problem is an extension of the problem ""Wonderful Coloring - 1"". It has quite many differences, so you should read this statement completely.Recently, Paul and Mary have found a new favorite sequence of integers $$$a_1, a_2, \dots, a_n$$$. They want to paint it using pieces of chalk of $$$k$$$ colors. The coloring of a sequence is called wonderful if the following conditions are met:  each element of the sequence is either painted in one of $$$k$$$ colors or isn't painted;  each two elements which are painted in the same color are different (i. e. there's no two equal values painted in the same color);  let's calculate for each of $$$k$$$ colors the number of elements painted in the color — all calculated numbers must be equal;  the total number of painted elements of the sequence is the maximum among all colorings of the sequence which meet the first three conditions. E. g. consider a sequence $$$a=[3, 1, 1, 1, 1, 10, 3, 10, 10, 2]$$$ and $$$k=3$$$. One of the wonderful colorings of the sequence is shown in the figure.    The example of a wonderful coloring of the sequence $$$a=[3, 1, 1, 1, 1, 10, 3, 10, 10, 2]$$$ and $$$k=3$$$. Note that one of the elements isn't painted. Help Paul and Mary to find a wonderful coloring of a given sequence $$$a$$$. NoteIn the first test case, the answer is shown in the figure in the statement. The red color has number $$$1$$$, the blue color — $$$2$$$, the green — $$$3$$$. import sys 



def process(n, k, a):
    counts = {}
    indices = {}

    for i in range(len(a)):
        if a[i] in counts:
            counts[a[i]]+=1
        else:
            counts[a[i]]=1 
        if a[i] in indices:
            indices[a[i]].append(i)
        else:
            indices[a[i]]=[i]
    
    counter = 0 

    to_sort =[]

    for i in counts: 
        counter+=min(counts[i], k)
        to_sort.append((i, min(counts[i], k)))

  
    to_sort.sort(key = lambda x: x[1], reverse = True)
    
    #print(to_sort)

    to_return = [0]*n 
    paint_number = 0 

    paint_max = int(counter/k)*k

    for i, j in to_sort:
   
        painted = 0 
    

        while(painted<j ):
            if paint_number == paint_max: return to_return
            to_return[indices[i][painted]]=(paint_number%k)+1
            paint_number+=1
            painted+=1
            
            
    
    return to_return



#print(process(9, 2, [1,2,3,4,4,5,5,5,5]))



t = int(input())

for i in range(t):
    n, k = [int(x) for x in input().split()]
    a = [int(x) for x in input().split()]

    sys.stdout.write("" "".join(map(str,process(n, k, a))) + ""\n"")","['binary search', 'constructive algorithms', 'data structures', 'greedy']"
210,"You're given an array $$$a$$$ of length $$$2n$$$. Is it possible to reorder it in such way so that the sum of the first $$$n$$$ elements isn't equal to the sum of the last $$$n$$$ elements? NoteIn the first example, the first $$$n$$$ elements have sum $$$2+1+3=6$$$ while the last $$$n$$$ elements have sum $$$1+1+2=4$$$. The sums aren't equal.In the second example, there's no solution. n = int(input())
l = list(map(int, input().split()))
l.sort()
if sum(l[0:n])!=sum(l[n:]):
    print(*l)
else:
    print(-1)","['constructive algorithms', 'greedy', 'sortings']"
354,"Polycarp was given a row of tiles. Each tile contains one lowercase letter of the Latin alphabet. The entire sequence of tiles forms the string $$$s$$$.In other words, you are given a string $$$s$$$ consisting of lowercase Latin letters.Initially, Polycarp is on the first tile of the row and wants to get to the last tile by jumping on the tiles. Jumping from $$$i$$$-th tile to $$$j$$$-th tile has a cost equal to $$$|index(s_i) - index(s_j)|$$$, where $$$index(c)$$$ is the index of the letter $$$c$$$ in the alphabet (for example, $$$index($$$'a'$$$)=1$$$, $$$index($$$'b'$$$)=2$$$, ..., $$$index($$$'z'$$$)=26$$$) .Polycarp wants to get to the $$$n$$$-th tile for the minimum total cost, but at the same time make maximum number of jumps.In other words, among all possible ways to get to the last tile for the minimum total cost, he will choose the one with the maximum number of jumps.Polycarp can visit each tile at most once.Polycarp asks you to help — print the sequence of indices of string $$$s$$$ on which he should jump. NoteIn the first test case, the required path corresponds to the picture:  In this case, the minimum possible total cost of the path is achieved. Since $$$index($$$'l'$$$)=12$$$, $$$index($$$'o'$$$)=15$$$, $$$index($$$'g'$$$)=7$$$, $$$index($$$'i'$$$)=9$$$, $$$index($$$'c'$$$)=3$$$, then the total cost of the path is $$$|12-9|+|9-7|+|7-3|=3+2+4=9$$$. from string import ascii_lowercase as asc
import sys
input = lambda: sys.stdin.buffer.readline().decode().strip()
print = sys.stdout.write


for _ in range(int(input())):
    word = list(input())
    ci, ti = asc.index(word[0]) + 1, asc.index(word[-1]) + 1

    ans = []
    if ci <= ti:
        for i in range(ci, ti + 1):
            [ans.append(j + 1) for j, l in enumerate(word) if l == chr(i + 96)]
    else:
        for i in range(ci, ti - 1, -1):
            [ans.append(k + 1) for k, l in enumerate(word) if l == chr(i + 96)]

    print(str(abs(ti - ci)) + "" "" + str(len(ans)) + ""\n"" + ' '.join(map(str, ans)) + ""\n"")
","['constructive algorithms', 'strings']"
1374,"Polycarp found the string $$$s$$$ and the permutation $$$p$$$. Their lengths turned out to be the same and equal to $$$n$$$.A permutation of $$$n$$$ elements — is an array of length $$$n$$$, in which every integer from $$$1$$$ to $$$n$$$ occurs exactly once. For example, $$$[1, 2, 3]$$$ and $$$[4, 3, 5, 1, 2]$$$ are permutations, but $$$[1, 2, 4]$$$, $$$[4, 3, 2, 1, 2]$$$ and $$$[0, 1, 2]$$$ are not.In one operation he can multiply $$$s$$$ by $$$p$$$, so he replaces $$$s$$$ with string $$$new$$$, in which for any $$$i$$$ from $$$1$$$ to $$$n$$$ it is true that $$$new_i = s_{p_i}$$$. For example, with $$$s=wmbe$$$ and $$$p = [3, 1, 4, 2]$$$, after operation the string will turn to $$$s=s_3 s_1 s_4 s_2=bwem$$$.Polycarp wondered after how many operations the string would become equal to its initial value for the first time. Since it may take too long, he asks for your help in this matter.It can be proved that the required number of operations always exists. It can be very large, so use a 64-bit integer type.  NoteIn the first sample operation doesn't change the string, so it will become the same as it was after $$$1$$$ operations.In the second sample the string will change as follows: $$$s$$$ = babaa $$$s$$$ = abaab $$$s$$$ = baaba $$$s$$$ = abbaa $$$s$$$ = baaab $$$s$$$ = ababa from collections import *
from heapq import *
from bisect import *
from itertools import *
from string import *
from math import *
 
 
def solve():
    n = int(input())
    s = input()
    P = list(map(int, input().split()))
    P = [x - 1 for x in P]

    seen = set()
    components = []

    def dfs(u, component):
        if u not in seen:
            seen.add(u)
            component.append(u)
            dfs(P[u], component)

    for i in range(n):
        if i not in seen:
            component = []
            dfs(i, component)
            components.append(component)

    def find_cycle_length(vals):
        a = ''.join(s[i] for i in vals)
        m = len(a)
        for k in range(1,m+1):
            if m % k != 0: continue
            if all(a[j] == a[j-k] for j in range(k,m)):
                return k
        assert False

 
    ans = [find_cycle_length(comp) for comp in components]
    return lcm(*ans)
 
 
def main():
    T = int(input())
    for _ in range(T):
        print(solve())
 
 
if __name__ == ""__main__"":
    main()","['graphs', 'math', 'number theory', 'strings']"
2016,"You are given an integer array of length $$$n$$$.You have to choose some subsequence of this array of maximum length such that this subsequence forms a increasing sequence of consecutive integers. In other words the required sequence should be equal to $$$[x, x + 1, \dots, x + k - 1]$$$ for some value $$$x$$$ and length $$$k$$$.Subsequence of an array can be obtained by erasing some (possibly zero) elements from the array. You can erase any elements, not necessarily going successively. The remaining elements preserve their order. For example, for the array $$$[5, 3, 1, 2, 4]$$$ the following arrays are subsequences: $$$[3]$$$, $$$[5, 3, 1, 2, 4]$$$, $$$[5, 1, 4]$$$, but the array $$$[1, 3]$$$ is not. NoteAll valid answers for the first example (as sequences of indices):   $$$[1, 3, 5, 6]$$$  $$$[2, 3, 5, 6]$$$ All valid answers for the second example:   $$$[1, 4]$$$  $$$[2, 5]$$$  $$$[3, 6]$$$ All valid answers for the third example:   $$$[1]$$$  $$$[2]$$$  $$$[3]$$$  $$$[4]$$$ All valid answers for the fourth example:   $$$[1, 2, 3, 7, 8, 9]$$$  
n=[int(k) for k in raw_input().split("" "")][0]
a=[int(k) for k in raw_input().split("" "")]
r={}
for i in a:
    if i in r:
        r[i+1]=r[i]+1
    else:
        r[i+1]=1

mv=max(r.values())

mr=[k-1 for k in r if r[k]==mv][0]

tg=mr-mv+1
res=[]
for i in range(n):
    if a[i]==tg:
        tg+=1
        res+=[str(i+1)]
     #  print i,a[i]

print len(res)        
print "" "".join(res)",['dp']
533,"Valera's lifelong ambition was to be a photographer, so he bought a new camera. Every day he got more and more clients asking for photos, and one day Valera needed a program that would determine the maximum number of people he can serve.The camera's memory is d megabytes. Valera's camera can take photos of high and low quality. One low quality photo takes a megabytes of memory, one high quality photo take b megabytes of memory. For unknown reasons, each client asks him to make several low quality photos and several high quality photos. More formally, the i-th client asks to make xi low quality photos and yi high quality photos.Valera wants to serve as many clients per day as possible, provided that they will be pleased with his work. To please the i-th client, Valera needs to give him everything he wants, that is, to make xi low quality photos and yi high quality photos. To make one low quality photo, the camera must have at least a megabytes of free memory space. Similarly, to make one high quality photo, the camera must have at least b megabytes of free memory space. Initially the camera's memory is empty. Valera also does not delete photos from the camera so that the camera's memory gradually fills up.Calculate the maximum number of clients Valera can successfully serve and print the numbers of these clients. nan I = lambda : map(int, raw_input().split())

n, d = I()
a, b = I()
clients = []
for i in xrange(n):
    clients.append(I())
for i in xrange(n):
    clients[i] = (clients[i][0]*a + clients[i][1]*b, i)
clients.sort()
ans = []
for i in xrange(n):
    if d - clients[i][0] >= 0:
        d -= clients[i][0]
        ans.append(clients[i][1])
print len(ans)
for s in ans:
    print s+1,
print
","['greedy', 'sortings']"
4508,"A team of students from the city S is sent to the All-Berland Olympiad in Informatics. Traditionally, they go on the train. All students have bought tickets in one carriage, consisting of n compartments (each compartment has exactly four people). We know that if one compartment contain one or two students, then they get bored, and if one compartment contain three or four students, then the compartment has fun throughout the entire trip.The students want to swap with other people, so that no compartment with students had bored students. To swap places with another person, you need to convince him that it is really necessary. The students can not independently find the necessary arguments, so they asked a sympathetic conductor for help. The conductor can use her life experience to persuade any passenger to switch places with some student.However, the conductor does not want to waste time persuading the wrong people, so she wants to know what is the minimum number of people necessary to persuade her to change places with the students. Your task is to find the number. After all the swaps each compartment should either have no student left, or have a company of three or four students.  nan #! /usr/bin/env python

n = int(input())
counts = [0] * 5
nums = [int(x) for x in input().split()]
for x in nums:
    counts[x] += 1

s = sum(nums)
if s > 2 and s != 5:
    ans = 0
    if counts[1] >= counts[2]:
        ans += counts[2]
        counts[3] += counts[2]
        counts[1] -= counts[2]
        ans += 2 * (counts[1] // 3)
        counts[3] += counts[1] // 3
        counts[1] %= 3
        if counts[3] > 0:
            ans += counts[1]
        elif counts[1] != 0:
            ans += 2
    else:
        ans += counts[1]
        counts[2] -= counts[1]
        ans += 2 * (counts[2] // 3)
        counts[2] %= 3
        if counts[4] > 0:
            ans += counts[2]
        elif counts[2] != 0:
            ans += 2
    print(ans)
else:
    print(-1)
","['combinatorics', 'constructive algorithms', 'greedy', 'implementation']"
367,"There are n employees working in company ""X"" (let's number them from 1 to n for convenience). Initially the employees didn't have any relationships among each other. On each of m next days one of the following events took place:  either employee y became the boss of employee x (at that, employee x didn't have a boss before);  or employee x gets a packet of documents and signs them; then he gives the packet to his boss. The boss signs the documents and gives them to his boss and so on (the last person to sign the documents sends them to the archive);  or comes a request of type ""determine whether employee x signs certain documents"". Your task is to write a program that will, given the events, answer the queries of the described type. At that, it is guaranteed that throughout the whole working time the company didn't have cyclic dependencies. nan n, m = map(int, input().split())
ev = [tuple(map(int, input().split())) for _ in range(m)]

g = [[] for _ in range(n + 1)]
qry = [[] for _ in range(m + 1)]
roots = set(range(1, n + 1))
qcnt = 0
for e in ev:
	if e[0] == 1:
		g[e[2]].append(e[1])
		roots.remove(e[1])
	elif e[0] == 3:
		qry[e[2]].append((qcnt, e[1]))
		qcnt += 1

tin, tout = [0] * (n + 1), [0] * (n + 1)
st = [(u, 0) for u in roots]
time = 0
while st:
	u, w = st.pop()
	if w:
		tout[u] = time
		continue
	time += 1
	tin[u] = time
	st.append((u, 1))
	for v in g[u]:
		st.append((v, 0))

p = list(range(n + 1))
def find(x):
	if x != p[x]:
		p[x] = find(p[x])
	return p[x]

pcnt = 0
ans = [None] * qcnt
for e in ev:
	if e[0] == 1:
		p[find(e[1])] = find(e[2])
	elif e[0] == 2:
		pcnt += 1
		for qid, x in qry[pcnt]:
			ans[qid] = 'YES' if find(e[1]) == find(x) and tin[x] <= tin[e[1]] <= tout[x] else 'NO'

print(*ans, sep='\n')","['dfs and similar', 'dsu', 'graphs', 'trees']"
4800,"The New Year is coming! That's why many people today are busy preparing New Year presents. Vasily the Programmer is no exception.Vasily knows that the best present is (no, it's not a contest) money. He's put n empty wallets from left to right in a row and decided how much money to put in what wallet. Vasily decided to put ai coins to the i-th wallet from the left.Vasily is a very busy man, so the money are sorted into the bags by his robot. Initially, the robot stands by the leftmost wallet in the row. The robot can follow instructions of three types: go to the wallet that is to the left of the current one (if such wallet exists), go to the wallet that is to the right of the current one (if such wallet exists), put a coin to the current wallet. Due to some technical malfunctions the robot cannot follow two ""put a coin"" instructions in a row.Vasily doesn't want to wait for long, so he wants to write a program for the robot that contains at most 106 operations (not necessarily minimum in length) the robot can use to put coins into the wallets. Help him. nan # import sys
#
# sys.stdin = open('input.txt')

n = input()
a = map(int, raw_input().split())

t = []
t.append('PRL' * a[0])
for k in range(1, n):
    t.append('PLR' * a[k])
print 'R'.join(t)
","['constructive algorithms', 'implementation']"
2962,"We are sum for we are manySome NumberThis version of the problem differs from the next one only in the constraint on $$$t$$$. You can make hacks only if both versions of the problem are solved.You are given two positive integers $$$l$$$ and $$$r$$$.Count the number of distinct triplets of integers $$$(i, j, k)$$$ such that $$$l \le i &lt; j &lt; k \le r$$$ and $$$\operatorname{lcm}(i,j,k) \ge i + j + k$$$.Here $$$\operatorname{lcm}(i, j, k)$$$ denotes the least common multiple (LCM) of integers $$$i$$$, $$$j$$$, and $$$k$$$. NoteIn the first test case, there are $$$3$$$ suitable triplets:   $$$(1,2,3)$$$,  $$$(1,3,4)$$$,  $$$(2,3,4)$$$. In the second test case, there is $$$1$$$ suitable triplet:   $$$(3,4,5)$$$.  import sys
input = sys.stdin.buffer.readline

# from collections import defaultdict, deque, Counter
from math import gcd, lcm
from functools import reduce
# from itertools import accumulate, chain, islice, starmap
# from operator import add, sub, mul, floordiv, truediv


# def f(L,R,tup):

def lcm3(tup):
	a,b,c = tup
	if c%b or c%a:
		return 2*c
	else:
		return c


def tup_gen(hi=2*10**5,a=1,b=1):
	# if a * b <= hi:
	yield (a,b)
	# k = 1
	# while a*k+b <= hi//a:
	for k in range(1, (hi//a-b)//a+1):
		for i in tup_gen(hi, a*k+b, a):
			yield i
		# k+=1

# s = set(tuple(sorted((b,a,a*b))) for (a,b) in tup_gen())
# s.add((3,4,6))
# s.add((6,10,15))

ma = 0


for _ in range(int(input())):
	L, R = map(int,input().split())

	tot = (R-L+1)*(R-L)*(R-L-1) // 6
	# ans = tot
	tmp = 0
	
	# s = set()
	if R > ma:
		ma = R
	# s = set(tuple(sorted((b,a,a*b))) for (a,b) in tup_gen(R))
	# l = list(tuple(sorted((b,a,a*b))) for (a,b) in tup_gen(R))
		l = list(tup_gen(R))
	# s.add((3,4,6))
	# s.add((6,10,15))

	# for a, b in tup_gen(R, L, 1,1):
	# 	# cands = [(b,a,a*b),(2*b,a,a*b),(b,2*a,a*b),(2*b,2*a,a*b),(b,a,a*b*2),(2*b,a,a*b*2),(b,2*a,a*b*2),(2*b,2*a,a*b*2)]
	# 	cands = [(b,a,a*b),(2*b,a,a*b),(b,2*a,a*b),(2*b,2*a,a*b)]
	# 	for cand in cands:
	# 		if not all(x%2==0 for x in cand):
	# 			# assert reduce(gcd,cand) < 2
	# 			s.add(tuple(sorted(cand)))




	# s2 = set()

	l2 = list()

	# for tup in s:
	# 	a,b,c=tup
	# 	c2 = 0
	# 	for n in range(1,R//c+1):
	# 		c2 += c
	# 		if a<b<c2:
	# 			tup2=(a,b,c2)
	# 			if lcm3(tup2) < sum(tup2) and not all(x%2==0 for x in tup2):# and tup2 not in s:
	# 				# if tup2 in s:
	# 				# 	print(""?????"",tup2,n)
	# 				# assert reduce(gcd,tup2) < 2
	# 				s2.add(tup2)
	# 				# l2.append(tup2)
	# 			elif n > 1:
	# 				break
	# 	# s2.add(tup)

	# for tup in l:
	# for b,a in tup_gen(R):
	for b,a in l:
		# a,b,c=tup
		# a,b=min(a,b),max(a,b)
		c = a*b
		tup = (a,b,c)
		su=a+b+c
		if a<b<c:
			if lcm3(tup) < su:
					# assert reduce(gcd,tup) < 2
					# s2.add(tup)
					# l2.append(tup)
					lo,hi=(L+a-1)//a, R//c
					if lo <= hi:
						tmp += hi-lo+1
			# else:
			# 	break
		
		if a<b<=c:
			for n in range(2,R//c+1):
				su+=c
				tup2=(a,b,c*n)
				if lcm3(tup2) < su:# and not all(x%2==0 for x in tup2):# and tup2 not in s:
					# if tup2 in s:
					# 	print(""?????"",tup2,n)
					# assert reduce(gcd,tup2) < 2
					# s2.add(tup2)
					# l2.append(tup2)
					lo,hi=(L+a-1)//a, R//(c*n)
					if lo <= hi:
						tmp += hi-lo+1
				else:
					break
			# s2.add(tup)

	# s2.add((3,4,6))
	# s2.add((6,10,15))

	l2.append((3,4,6))
	l2.append((6,10,15))

	
	for tup in l2:
		a,b,c=tup
		# if a<b<c:
			# s4 = set()
		lo,hi=(L+a-1)//a, R//c
		if lo <= hi:
			tmp += hi-lo+1
			# for d in range((L+a-1)//a, R//c+1):
			# 	tup2 = (d*a,d*b,d*c)
			# 	if tup2 in s3:
			# 		print(tup2,""?????"")
			# 	s3.add(tup2)
			# 	s4.add(tup2)
			# assert tmp == len(s3), (L,R,lo,hi,tup, s3,s4)


		# s32= set(list(s3))









	# for tup in s3:
	# 	a,b,c=tup
	# 	if L<=a<b<c<=R:# and lcm3(tup) < sum(tup):
	# 		# s4.add(tup)
	# 		ans -= 1

	# print(tot - len(s3))
	print(tot-tmp)
","['binary search', 'brute force', 'combinatorics', 'math', 'number theory', 'two pointers']"
4844,"Misha walked through the snowy forest and he was so fascinated by the trees to decide to draw his own tree!Misha would like to construct a rooted tree with $$$n$$$ vertices, indexed from 1 to $$$n$$$, where the root has index 1. Every other vertex has a parent $$$p_i$$$, and $$$i$$$ is called a child of vertex $$$p_i$$$. Vertex $$$u$$$ belongs to the subtree of vertex $$$v$$$ iff $$$v$$$ is reachable from $$$u$$$ while iterating over the parents ($$$u$$$, $$$p_{u}$$$, $$$p_{p_{u}}$$$, ...). Clearly, $$$v$$$ belongs to its own subtree, and the number of vertices in the subtree is called the size of the subtree. Misha is only interested in trees where every vertex belongs to the subtree of vertex $$$1$$$.Below there is a tree with $$$6$$$ vertices. The subtree of vertex $$$2$$$ contains vertices $$$2$$$, $$$3$$$, $$$4$$$, $$$5$$$. Hence the size of its subtree is $$$4$$$.   The branching coefficient of the tree is defined as the maximum number of children in any vertex. For example, for the tree above the branching coefficient equals $$$2$$$. Your task is to construct a tree with $$$n$$$ vertices such that the sum of the subtree sizes for all vertices equals $$$s$$$, and the branching coefficient is minimum possible. NoteBelow one can find one of the possible solutions for the first sample case. The sum of subtree sizes equals $$$3 + 1 + 1 = 5$$$, and the branching coefficient equals $$$2$$$.  Below one can find one of the possible solutions for the third sample case. The sum of subtree sizes equals $$$6 + 3 + 2 + 1 + 2 + 1 = 15$$$, and the branching coefficient equals $$$2$$$.   import math
def f(n,k):
    if k==1:
        return (n*(n+1))//2
    a=math.floor(math.log(n,k))
    b=sum(k**i for i in range(a+1))
    c=sum((i+1)*k**i for i in range(a+1))
    if n<b:
        return c-(b-n)*(a+1)
    else:
        return c+(n-b)*(a+2)
n,s=map(int,input().split())
if s==(n*(n+1))//2:
    print(""Yes"")
    a=[str(i+1) for i in range(n-1)]
    print("" "".join(a))
elif s>(n*(n+1))//2:
    print(""No"")
elif s<2*n-1:
    print(""No"")
else:
    mini=1
    maxi=n-1
    curr=1
    while True:
        a,b=f(n,curr),f(n,curr+1)
        if b>s:
            mini=curr+1
            curr=math.ceil((curr+maxi)/2)
        elif a<=s:
            maxi=curr-1
            curr=(curr+mini)//2
        else:
            opt=curr+1
            break
    depths=[0,1]+[0]*(n-1)
    ins=1
    ind=2
    while True:
        a=min(opt**(ind-1),n-ins)
        depths[ind]=a
        ind+=1
        ins+=a
        if ins==n:
            break
    left=s-b
    far=ind-1
    bulk=ind-1
    if depths[bulk]==1:
        bulk-=1
    while left>0:
        if far+1-bulk<=left:
            far+=1
            left-=far-bulk
            depths[far]+=1
            depths[bulk]-=1
            if depths[bulk]==1:
                bulk-=1
        else:
            depths[bulk]-=1
            depths[bulk+left]+=1
            left=0
    verts=[None]*far
    sumi=0
    for i in range(far):
        verts[i]=list(range(sumi+1,sumi+1+depths[i+1]))
        sumi+=depths[i+1]
    out=""""
    for i in range(1,far):
        for j in range(len(verts[i])):
            out+=str(verts[i-1][j//opt])+"" ""
    print(""Yes"")
    print(out)","['binary search', 'constructive algorithms', 'dfs and similar', 'graphs', 'greedy', 'trees']"
1658,"You have a sequence $$$a_1, a_2, \ldots, a_n$$$ of length $$$n$$$, consisting of integers between $$$1$$$ and $$$m$$$. You also have a string $$$s$$$, consisting of $$$m$$$ characters B.You are going to perform the following $$$n$$$ operations.   At the $$$i$$$-th ($$$1 \le i \le n$$$) operation, you replace either the $$$a_i$$$-th or the $$$(m + 1 - a_i)$$$-th character of $$$s$$$ with A. You can replace the character at any position multiple times through the operations. Find the lexicographically smallest string you can get after these operations.A string $$$x$$$ is lexicographically smaller than a string $$$y$$$ of the same length if and only if in the first position where $$$x$$$ and $$$y$$$ differ, the string $$$x$$$ has a letter that appears earlier in the alphabet than the corresponding letter in $$$y$$$. NoteIn the first test case, the sequence $$$a = [1, 1, 3, 1]$$$. One of the possible solutions is the following.   At the $$$1$$$-st operation, you can replace the $$$1$$$-st character of $$$s$$$ with A. After it, $$$s$$$ becomes ABBBB.  At the $$$2$$$-nd operation, you can replace the $$$5$$$-th character of $$$s$$$ with A (since $$$m+1-a_2=5$$$). After it, $$$s$$$ becomes ABBBA.  At the $$$3$$$-rd operation, you can replace the $$$3$$$-rd character of $$$s$$$ with A. After it, $$$s$$$ becomes ABABA.  At the $$$4$$$-th operation, you can replace the $$$1$$$-st character of $$$s$$$ with A. After it, $$$s$$$ remains equal to ABABA.  The resulting string is ABABA. It is impossible to produce a lexicographically smaller string.In the second test case, you are going to perform only one operation. You can replace either the $$$2$$$-nd character or $$$4$$$-th character of $$$s$$$ with A. You can get strings BABBB and BBBAB after the operation. The string BABBB is the lexicographically smallest among these strings.In the third test case, the only string you can get is A.In the fourth test case, you can replace the $$$1$$$-st and $$$2$$$-nd characters of $$$s$$$ with A to get AABB.In the fifth test case, you can replace the $$$1$$$-st and $$$3$$$-rd characters of $$$s$$$ with A to get ABABBBB. def convertToList(str1):
    list1=[]
    list1[:]=str1
    return list1
    
def convertToString(list1):
    str1 =""""
    return str1.join(list1)
    
n =int(input())
for i in range(n):
    t,m=map(int,input().split())
    x=list(map(int,input().split()))
    num2 =0
    num3=0
    str1 =""B""*m
    list1 = convertToList(str1)
    for j in range(t):
        num = (m+1)-x[j]-1
        num1 =x[j]-1
        num2= min(num1,num)
        if(list1[num2] != ""A""):
            list1[num2] = ""A""
        else:
            num3= max(num1,num)
            list1[num3] = ""A""
    str1 = convertToString(list1)
    print(str1)","['constructive algorithms', 'greedy', 'other', 'strings']"
3264,"You are given a square grid with $$$n$$$ rows and $$$n$$$ columns. Each cell contains either $$$0$$$ or $$$1$$$. In an operation, you can select a cell of the grid and flip it (from $$$0 \to 1$$$ or $$$1 \to 0$$$). Find the minimum number of operations you need to obtain a square that remains the same when rotated $$$0^{\circ}$$$, $$$90^{\circ}$$$, $$$180^{\circ}$$$ and $$$270^{\circ}$$$.The picture below shows an example of all rotations of a grid.   NoteIn the first test case, we can perform one operations to make the grid $$$\begin{matrix}0 &amp; 1 &amp; 0\\ 1 &amp; 1 &amp; \color{red}{1}\\ 0 &amp; 1 &amp; 0\end{matrix}$$$. Now, all rotations of the square are the same.In the second test case, all rotations of the square are already the same, so we don't need any flips. import sys

input = lambda: sys.stdin.readline().rstrip(""\r\n"")
printf = lambda d: sys.stdout.write(str(d) + ""\n"")
def read_int(): return int(input())
def read_ints(): return list(map(int, input().split()))
def read_ints_grid(n): return [read_ints() for _ in range(n)]
def read_str(): return input().strip()
def read_strs(): return read_str().split(' ')

MAX = int(1e10) + 5
# pos = [0] * MAX
mod = 10 ** 9 + 7
from collections import Counter
# import numpy as np


def solve():
    n = read_int()
    l = []
    for i in range(n):
        a = input().strip()
        l.append(a)

    m = (n+1) // 2 if n % 2 else n//2
    used = set()
    ans = 0
    for i in range(m):
        for j in range(m):
            l2 = []
            if (i, j) not in used:
                if i == j and j == n-1-i:
                    used.add((i, j))
                    # used.add((j, n - 1 - i))
                    used.add((n - 1 - j, i))
                    used.add((n - 1 - i, n - 1 - j))
                    continue
                l2.append(l[i][j])
                l2.append(l[j][n-1-i])
                l2.append(l[n-1-j][i])
                l2.append(l[n-1-i][n-1-j])
                used.add((i, j))
                used.add((j, n-1-i))
                used.add((n-1-j, i))
                used.add((n-1-i, n-1-j))
            if l2:
                ans += min(l2.count(""0""), l2.count(""1""))
            # print((i,j ), (j, n-1-i), (n-1-j, i), (n-1-i,n-1-j), l2, ans)
    print(ans)




t = int(input())
for _ in range(t):
    solve()",['implementation']
2451,"Timur has a stairway with $$$n$$$ steps. The $$$i$$$-th step is $$$a_i$$$ meters higher than its predecessor. The first step is $$$a_1$$$ meters higher than the ground, and the ground starts at $$$0$$$ meters.   The stairs for the first test case. Timur has $$$q$$$ questions, each denoted by an integer $$$k_1, \dots, k_q$$$. For each question $$$k_i$$$, you have to print the maximum possible height Timur can achieve by climbing the steps if his legs are of length $$$k_i$$$. Timur can only climb the $$$j$$$-th step if his legs are of length at least $$$a_j$$$. In other words, $$$k_i \geq a_j$$$ for each step $$$j$$$ climbed.Note that you should answer each question independently. NoteConsider the first test case, pictured in the statement.   If Timur's legs have length $$$1$$$, then he can only climb stair $$$1$$$, so the highest he can reach is $$$1$$$ meter.  If Timur's legs have length $$$2$$$ or $$$4$$$, then he can only climb stairs $$$1$$$, $$$2$$$, and $$$3$$$, so the highest he can reach is $$$1+2+1=4$$$ meters.  If Timur's legs have length $$$9$$$ or $$$10$$$, then he can climb the whole staircase, so the highest he can reach is $$$1+2+1+5=9$$$ meters.  In the first question of the second test case, Timur has no legs, so he cannot go up even a single step. :( t = int(input())

for _ in range(t):
    nq = [int(x) for x in input().split()]
    nnum, qnum = nq[0], nq[1]
    
    n = [int(x) for x in input().split()]
    q = [int(x) for x in input().split()]
    
    qv = []
    for i in range(qnum):
        qv.append([q[i], i])
        
    qv.sort()
    
    retsum = 0
    j = 0
    ans = [0]*qnum
    for i in range(qnum):
        k, index = qv[i][0], qv[i][1]
        while (j < nnum and n[j] <= k):
            retsum += n[j]
            j += 1
        ans[index] = retsum
        
    print(*ans)","['binary search', 'greedy', 'math']"
3277,"Permutation p is an ordered set of integers p1,  p2,  ...,  pn, consisting of n distinct positive integers, each of them doesn't exceed n. We'll denote the i-th element of permutation p as pi. We'll call number n the size or the length of permutation p1,  p2,  ...,  pn.You have a sequence of integers a1, a2, ..., an. In one move, you are allowed to decrease or increase any number by one. Count the minimum number of moves, needed to build a permutation from this sequence. NoteIn the first sample you should decrease the first number by one and then increase the second number by one. The resulting permutation is (2, 1).In the second sample you need 6 moves to build permutation (1, 3, 2). '''
      ___           ___                         ___                       ___           ___                         ___
     /\__\         /\  \         _____         /\  \                     /\  \         /\  \                       /\__\
    /:/ _/_        \:\  \       /::\  \        \:\  \       ___         /::\  \       |::\  \         ___         /:/ _/_
   /:/ /\  \        \:\  \     /:/\:\  \        \:\  \     /\__\       /:/\:\__\      |:|:\  \       /\__\       /:/ /\  \
  /:/ /::\  \   ___  \:\  \   /:/  \:\__\   ___ /::\  \   /:/__/      /:/ /:/  /    __|:|\:\  \     /:/  /      /:/ /::\  \
 /:/_/:/\:\__\ /\  \  \:\__\ /:/__/ \:|__| /\  /:/\:\__\ /::\  \     /:/_/:/__/___ /::::|_\:\__\   /:/__/      /:/_/:/\:\__\
 \:\/:/ /:/  / \:\  \ /:/  / \:\  \ /:/  / \:\/:/  \/__/ \/\:\  \__  \:\/:::::/  / \:\~~\  \/__/  /::\  \      \:\/:/ /:/  /
  \::/ /:/  /   \:\  /:/  /   \:\  /:/  /   \::/__/       ~~\:\/\__\  \::/~~/~~~~   \:\  \       /:/\:\  \      \::/ /:/  /
   \/_/:/  /     \:\/:/  /     \:\/:/  /     \:\  \          \::/  /   \:\~~\        \:\  \      \/__\:\  \      \/_/:/  /
     /:/  /       \::/  /       \::/  /       \:\__\         /:/  /     \:\__\        \:\__\          \:\__\       /:/  /
     \/__/         \/__/         \/__/         \/__/         \/__/       \/__/         \/__/           \/__/       \/__/

'''
""""""
░░██▄░░░░░░░░░░░▄██
░▄▀░█▄░░░░░░░░▄█░░█░
░█░▄░█▄░░░░░░▄█░▄░█░
░█░██████████████▄█░
░█████▀▀████▀▀█████░
▄█▀█▀░░░████░░░▀▀███
██░░▀████▀▀████▀░░██
██░░░░█▀░░░░▀█░░░░██
███▄░░░░░░░░░░░░▄███
░▀███▄░░████░░▄███▀░
░░░▀██▄░▀██▀░▄██▀░░░
░░░░░░▀██████▀░░░░░░
░░░░░░░░░░░░░░░░░░░░
""""""
import sys
import math
import collections
import operator as op
from collections import deque
from math import gcd, inf, sqrt, pi, cos, sin, ceil, log2
from bisect import bisect_right, bisect_left

# sys.stdin = open('input.txt', 'r')
# sys.stdout = open('output.txt', 'w')

from functools import reduce
from sys import stdin, stdout, setrecursionlimit
setrecursionlimit(2**20)


def factorial(n):
    if n == 0:
        return 1
    return (n * factorial(n - 1))


def ncr(n, r):
    r = min(r, n - r)
    numer = reduce(op.mul, range(n, n - r, -1), 1)
    denom = reduce(op.mul, range(1, r + 1), 1)
    return numer // denom  # or / in Python 2


def prime_factors(n):
    i = 2
    factors = []
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
            factors.append(i)
    if n > 1:
        factors.append(n)
    return (list(factors))


def sumDigits(no):
    return 0 if no == 0 else int(no % 10) + sumDigits(int(no / 10))

MOD = 1000000007
PMOD = 998244353
N = 10**5
T = 1
# T = int(stdin.readline())
for _ in range(T):
    # n, k = list(map(int, stdin.readline().rstrip().split()))
    n = int(stdin.readline())
    a = list(map(int, stdin.readline().rstrip().split()))
    # b = list(map(int, stdin.readline().rstrip().split()))
    # s = list(stdin.readline().strip('\n'))
    # t = str(stdin.readline().strip('\n'))
    # x = int(stdin.readline())
    # s = list(map(int, stdin.readline().rstrip().split()))
    a.sort()
    ans = 0
    for i in range(1, n + 1):
        ans += abs(i - a[i - 1])
    print(ans)
","['greedy', 'implementation', 'sortings']"
2374,"Cirno gives AquaMoon a problem. There are $$$m$$$ people numbered from $$$0$$$ to $$$m - 1$$$. They are standing on a coordinate axis in points with positive integer coordinates. They are facing right (i.e. in the direction of the coordinate increase). At this moment everyone will start running with the constant speed in the direction of coordinate increasing. The initial coordinate of the $$$i$$$-th person on the line is $$$x_i$$$, and the speed of the $$$i$$$-th person is $$$v_i$$$. So the coordinate of the $$$i$$$-th person at the moment $$$t$$$ will be $$$x_i + t \cdot v_i$$$.Cirno captured the coordinates of $$$m$$$ people in $$$k$$$ consecutive integer moments from $$$0$$$ to $$$k - 1$$$. In every moment, the coordinates of $$$m$$$ people were recorded in arbitrary order.To make the problem more funny, Cirno modified one coordinate at the moment $$$y$$$ ($$$0 &lt; y &lt; k-1$$$) to a different integer.AquaMoon wants to find the moment $$$y$$$ and the original coordinate $$$p$$$ before the modification. Actually, she is not a programmer at all. So she wasn't able to solve it. Can you help her? NoteIn the first test the initial coordinates of people are $$$9$$$, $$$6$$$, $$$6$$$, $$$9$$$, $$$9$$$ and their speeds are $$$1$$$, $$$2$$$, $$$1$$$, $$$1$$$, $$$1$$$. So, it's easy to see, that at the moment $$$4$$$ one coordinate was modified from $$$13$$$ to $$$12$$$.This is the first test in the hack format:5 79 6 6 9 91 2 1 1 12 3 4 1 00 2 3 1 44 3 0 1 21 3 4 0 21 4 0 2 32 4 1 3 02 4 1 3 04 0 12 import os,sys
from random import randint
from io import BytesIO, IOBase

from collections import defaultdict,deque,Counter
from bisect import bisect_left,bisect_right
from heapq import heappush,heappop
from functools import lru_cache
from itertools import accumulate
import math

# Fast IO Region
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# for _ in range(int(input())):
#     n = int(input())
#     a = list(map(int, input().split()))

# for _ in range(int(input())):
#     n = int(input())
#     a = list(map(int, input().split()))
#     b = list(map(int, input().split()))
#     if sum(a) != sum(b):
#         print(-1)
#     else:
#         pos, neg = [], []
#         for i in range(n):
#             if a[i] > b[i]:
#                 pos.append([a[i] - b[i], i])
#             elif a[i] < b[i]:
#                 neg.append([b[i] - a[i], i])
#         ans = []
#         while pos:
#             ans.append((pos[-1][1], neg[-1][1]))
#             pos[-1][0] -= 1
#             neg[-1][0] -= 1
#             if pos[-1][0] == 0:
#                 pos.pop()
#             if neg[-1][0] == 0:
#                 neg.pop()
#         print(len(ans))
#         for i, j in ans:
#             print(i + 1, j + 1)

# for _ in range(int(input())):
#     n, m = list(map(int, input().split()))
#     cnt = [[0] * m for _ in range(26)]
#     for _ in range(n):
#         s = input()
#         for i in range(m):
#             cnt[ord(s[i]) - ord('a')][i] += 1
#     for _ in range(n - 1):
#         s = input()
#         for i in range(m):
#             cnt[ord(s[i]) - ord('a')][i] -= 1
#     ans = []
#     for j in range(m):
#         for i in range(26):
#             if cnt[i][j]:
#                 ans.append(chr(97 + i))
#                 break
#     print(''.join(ans))

# for _ in range(int(input())):
#     def solve():
#         n = int(input())
#         a = list(map(int, input().split()))
#         b = sorted(a)
#         odd = defaultdict(list)
#         even = defaultdict(list)
#         for i in range(n):
#             if i % 2:
#                 odd[b[i]].append(i)
#             else:
#                 even[b[i]].append(i)
#         for i in range(n):
#             if i % 2:
#                 if not odd[a[i]]:
#                     print('NO')
#                     return
#                 odd[a[i]].pop()
#             else:
#                 if not even[a[i]]:
#                     print('NO')
#                     return
#                 even[a[i]].pop()
#         print('YES')
#     solve()

# mod = 998244353
# N = 100010
# fac = [1] * N
# for i in range(2, N):
#     fac[i] = fac[i - 1] * i % mod
# invfac = [1] * N
# invfac[N - 1] = pow(fac[N - 1], mod - 2, mod)
# for i in range(N - 1)[::-1]:
#     invfac[i] = invfac[i + 1] * (i + 1) % mod
# def c(i, j):
#     return fac[i] * invfac[j] * invfac[i - j] % mod

# for _ in range(int(input())):
#     n = int(input())
#     s = input()
#     cnt11 = cnt0 = 0
#     cur = 0
#     for i in range(n):
#         if s[i] == '1':
#             cur += 1
#         else:
#             cnt0 += 1
#             cnt11 += cur // 2
#             cur = 0
#     cnt11 += cur // 2
#     print(c(cnt0 + cnt11, cnt0))

m, k = list(map(int, input().split()))
a_1d = [list(map(int, input().split())) for _ in range(k)]
sum_1d = [sum(a_1d[i]) for i in range(k)]
dif_1d = [sum_1d[i + 1] - sum_1d[i] for i in range(k - 1)]

for i in range(k - 2):
    if dif_1d[i] == dif_1d[i + 1]:
        real_dif_1d = dif_1d[i]
        break
for i in range(k - 1):
    if dif_1d[i] != real_dif_1d:
        add_1d = real_dif_1d - dif_1d[i]
        pos = i + 1
        break

sum_2d = []
for i in range(k):
    t = 0
    for j in range(m):
        t += a_1d[i][j] * a_1d[i][j]
    sum_2d.append(t)
dif_2d = [sum_2d[i + 1] - sum_2d[i] for i in range(k - 1)]
difdif_2d = [dif_2d[i + 1] - dif_2d[i] for i in range(k - 2)]

real_dif_2d = difdif_2d[0]
for i in range(k - 3):
    if difdif_2d[i] == difdif_2d[i + 1]:
        real_dif_2d = difdif_2d[i]
        break

if pos > 1:
    real_2d = sum_2d[pos - 1] + sum_2d[pos - 1] - sum_2d[pos - 2] + real_dif_2d
else:
    real_2d = sum_2d[pos + 1] - ((sum_2d[pos + 2] - sum_2d[pos + 1]) - real_dif_2d)

add2d = real_2d - sum_2d[pos]
ori = (add_1d + add2d // add_1d) // 2
print(pos, ori)


# ori - last = add
# ori^2-last^2=add2
# ori+last=add2//add
# ori = (add+add2//add) // 2


# x1   ... xk
# x1+v1 ... xk+vk
# x1+2v1 ... xk+2vk

# sum0
# sum0+dif = fake + x
# sum0+dif*2

# 66999 21111
# 87101010

# a, b, c, d, e = 6, 6, 9, 9, 9
# pre = a*a+b*b+c*c+d*d+e*e
# for _ in range(6):
#     a += 2
#     b += 1
#     c += 1
#     d += 1
#     e += 1
#     print(a*a+b*b+c*c+d*d+e*e, a*a+b*b+c*c+d*d+e*e - pre)
#     pre = a*a+b*b+c*c+d*d+e*e

# ori**2 -last**2 - 


    
    
    ","['interactive', 'math']"
3634,"There are $$$n$$$ friends who want to give gifts for the New Year to each other. Each friend should give exactly one gift and receive exactly one gift. The friend cannot give the gift to himself.For each friend the value $$$f_i$$$ is known: it is either $$$f_i = 0$$$ if the $$$i$$$-th friend doesn't know whom he wants to give the gift to or $$$1 \le f_i \le n$$$ if the $$$i$$$-th friend wants to give the gift to the friend $$$f_i$$$.You want to fill in the unknown values ($$$f_i = 0$$$) in such a way that each friend gives exactly one gift and receives exactly one gift and there is no friend who gives the gift to himself. It is guaranteed that the initial information isn't contradictory.If there are several answers, you can print any. nan # -*- coding: utf-8 -*-

import sys

def read_int_list():
    return map(int, sys.stdin.readline().strip().split())

def read_int():
    return int(sys.stdin.readline().strip())


def solve():
    _ = read_int()
    friends = read_int_list()
    with_present = set()
    unknown = set()
    for idx, f in enumerate(friends, 1):
        if f > 0:
            with_present.add(f)
        else:
            unknown.add(idx)

    without_present = set(xrange(1, len(friends) + 1)) - with_present
    # print('with present', with_present)
    # print('without present', without_present)
    # print('unknown', unknown)

    hm = {}
    common = unknown.intersection(without_present)

    for u in common:
        removed = False
        if u in without_present:
            without_present.remove(u)
            removed = True
        el = without_present.pop()
        hm[u] = el
        if removed:
            without_present.add(u)

    unknown = unknown - common

    for u in unknown:
        el = without_present.pop()
        hm[u] = el

    # print('u', u, 'without present', without_present, 'hm', hm)
    # print('hm', hm)

    for i in xrange(len(friends)):
        idx = i + 1
        v = friends[i]
        if v == 0:
            friends[i] = hm[idx]

    sys.stdout.write(' '.join(map(str, friends)) + '\n')



solve()
","['constructive algorithms', 'data structures', 'math']"
1360,"You are given a matrix, consisting of $$$n$$$ rows and $$$m$$$ columns. The rows are numbered top to bottom, the columns are numbered left to right.Each cell of the matrix can be either free or locked.Let's call a path in the matrix a staircase if it:   starts and ends in the free cell;  visits only free cells;  has one of the two following structures:   the second cell is $$$1$$$ to the right from the first one, the third cell is $$$1$$$ to the bottom from the second one, the fourth cell is $$$1$$$ to the right from the third one, and so on;  the second cell is $$$1$$$ to the bottom from the first one, the third cell is $$$1$$$ to the right from the second one, the fourth cell is $$$1$$$ to the bottom from the third one, and so on.  In particular, a path, consisting of a single cell, is considered to be a staircase.Here are some examples of staircases:  Initially all the cells of the matrix are free.You have to process $$$q$$$ queries, each of them flips the state of a single cell. So, if a cell is currently free, it makes it locked, and if a cell is currently locked, it makes it free.Print the number of different staircases after each query. Two staircases are considered different if there exists such a cell that appears in one path and doesn't appear in the other path. nan class SplayTree():
	def __init__(self):
		self.children={}
		self.parents={}
		self.root=None
	def insert(self, x):
		if self.root is None:
			self.root=x
			self.children[x]=[None,None]
			self.parents[x]=None
		else:
			curr = self.root
			while True:
				if curr == x:
					self.splay(x)
					return None
				elif x < curr:
					if self.children[curr][0] is None:
						self.children[curr][0] = x
						self.children[x] = [None, None]
						self.parents[x] = curr
						self.splay(x)
						return None
					else:
						curr = self.children[curr][0]
				else:
					if self.children[curr][1] is None:
						self.children[curr][1] = x
						self.children[x] = [None, None]
						self.parents[x] = curr
						self.splay(x)
						return None
					else:
						curr = self.children[curr][1]

	def find(self, x):
		return x in self.parents

	def delete(self, x, show=False):
		if self.children[x][0] is None and self.children[x][1] is None:
			if self.root == x:
				self.root = None
			del self.children[x]
			p = self.parents[x]
			del self.parents[x]
			for i in range(2):
				if self.children[p][i] == x:
					self.children[p][i] = None
			self.splay(p)
		elif self.children[x][0] is None or self.children[x][1] is None:
			if self.children[x][0] is None:
				ind = 1
			else:
				ind = 0
			child = self.children[x][ind]
			if self.root == x:
				self.root = child
				del self.children[x]
				del self.parents[x]
				self.parents[child] = None
			else:
				p = self.parents[x]
				self.parents[child] = p
				for i in range(2):
					if self.children[p][i] == x:
						self.children[p][i] = child
				del self.parents[x]
				del self.children[x]
				self.splay(p)
		else:
			s = self.successor(x)
			if self.parents[s] == x:
				skids = self.children[s][:]
				xkid = self.children[x][0]
				xpar = self.parents[x]
				self.children[s] = [xkid, x]
				self.parents[s] = xpar
				self.children[x] = skids
				self.parents[x] = s
				for i in skids:
					if i is not None:
						self.parents[i] = x
				if xkid is not None:
					self.parents[xkid] = s
				if xpar is not None:
					for i in range(2):
						if self.children[xpar][i] == x:
							self.children[xpar][i] = s
				if self.root == x:
					self.root = s
				self.delete(x)
				if xpar is not None:
					self.splay(xpar)
			else:
				skids = self.children[s][:]
				spar = self.parents[s]
				xkids = self.children[x][:]
				xpar = self.parents[x]
				self.children[s] = xkids
				self.parents[s] = xpar
				self.children[x] = skids
				self.parents[x] = spar
				for i in skids:
					if i is not None:
						self.parents[i] = x
				for i in xkids:
					if i is not None:
						self.parents[i] = s
				for i in range(2):
					if spar is not None and self.children[spar][i] == s:
						self.children[spar][i] = x
					if xpar is not None and self.children[xpar][i] == x:
						self.children[xpar][i] = s
				if self.root == x:
					self.root = s
				if show:
					print(self.children)
					print(self.parents)
					print(self.root)
				self.delete(x)
				if xpar is not None:
					self.splay(xpar)

	def successor(self,x):
		if self.find(x):
			if self.children[x][1] is None:
				curr = x
				while self.parents[curr] is not None:
					if self.parents[curr] > curr:
						return self.parents[curr]
					curr = self.parents[curr]
				return None 
			else:
				curr = self.children[x][1]
			while self.children[curr][0] is not None:
				curr = self.children[curr][0]
			return curr
		else:
			curr = self.root
			prev = None
			while True:
				if x < curr:
					if self.children[curr][0] is None:
						self.splay(curr)
						return curr
					else:
						prev = curr
						curr = self.children[curr][0]
				else:
					if self.children[curr][1] is None:
						if prev is not None:
							self.splay(prev)
						return prev
					else:
						curr = self.children[curr][1]
	def predecessor(self,x):
		if self.find(x):
			if self.children[x][0] is None:
				curr = x
				while self.parents[curr] is not None:
					if self.parents[curr] < curr:
						return self.parents[curr]
					curr = self.parents[curr]
				return None
			else:
				curr = self.children[x][0]
			while self.children[curr][1] is not None:
				curr = self.children[curr][1]
			return  curr
		else:
			curr = self.root
			prev = None
			while True:
				if x > curr:
					if self.children[curr][1] is None:
						self.splay(curr)
						return curr
					else:
						prev = curr
						curr = self.children[curr][1]
				else:
					if self.children[curr][0] is None:
						if prev is not None:
							self.splay(prev)
						return prev
					else:
						curr = self.children[curr][0]

	def splay(self, x):
		while self.parents[x] is not None:
			p = self.parents[x]
			gp = self.parents[p]
			if gp is None:
				if p > x:
					a,b = self.children[x]
					c = self.children[p][1]
					self.children[x] = [a,p]
					self.children[p] = [b,c]
					self.parents[x] = None
					self.parents[p] = x
					self.parents[b] = p
					self.root = x
				else:
					a = self.children[p][0]
					b,c = self.children[x]
					self.children[x] = [p,c]
					self.children[p] = [a,b]
					self.parents[x] = None
					self.parents[p] = x
					self.parents[b] = p
					self.root = x
			else:
				ggp = self.parents[gp]
				if p > x and gp > x:
					a,b = self.children[x]
					c = self.children[p][1]
					d = self.children[gp][1]
					self.children[x] = [a,p]
					self.children[p] = [b,gp]
					self.children[gp] = [c,d]
					self.parents[x] = ggp
					self.parents[p] = x
					self.parents[gp] = p
					self.parents[b] = p
					self.parents[c] = gp
				elif p < x and gp < x:
					c,d = self.children[x]
					b = self.children[p][0]
					a = self.children[gp][0]
					self.children[x] = [p,d]
					self.children[p] = [gp,c]
					self.children[gp] = [a,b]
					self.parents[x] = ggp
					self.parents[p] = x
					self.parents[gp] = p
					self.parents[b] = gp
					self.parents[c] = p
				elif p < x and gp > x:
					b,c = self.children[x]
					a = self.children[p][0]
					d = self.children[gp][1]
					self.children[x] = [p,gp]
					self.children[p] = [a,b]
					self.children[gp] = [c,d]
					self.parents[x] = ggp
					self.parents[p] = x
					self.parents[gp] = x
					self.parents[b] = p
					self.parents[c] = gp
				else:
					b,c = self.children[x]
					d = self.children[p][1]
					a = self.children[gp][0]
					self.children[x] = [gp,p]
					self.children[p] = [c,d]
					self.children[gp] = [a,b]
					self.parents[x] = ggp
					self.parents[p] = x
					self.parents[gp] = x
					self.parents[b] = gp
					self.parents[c] = p
				if ggp is not None:
					for i in range(2):
						if self.children[ggp][i] == gp:
							self.children[ggp][i] = x
				else:
					self.root = x
			if None in self.parents:
				del self.parents[None]


n,m,q = map(int,input().split())
diag = {}
for i in range(-m,n+1):
	diag[i] = SplayTree()
	diag[i].insert(max(0,i))
	diag[i].insert(min(n+1,m+1+i))

total = 0
j = n
k = m
while j>0 and k>0:
	total += 2*j*k
	total += j*(k-1)
	total += k*(j-1)
	j-=1
	k-=1
total -= n*m
for _ in range(q):
	x, y = map(int, input().split())
	diff = x-y
	pred = diag[diff].predecessor(x)
	succ = diag[diff].successor(x)
	predup = diag[diff-1].predecessor(x)
	succup = diag[diff-1].successor(x-1)
	preddown = diag[diff+1].predecessor(x+1)
	succdown = diag[diff+1].successor(x)
	beforeup = min(2*(x-pred)-1,2*(x-predup)-2)
	afterup = min(2*(succ-x)-1,2*(succup-x))
	beforedown = min(2*(x-pred)-1,2*(x-preddown))
	afterdown = min(2*(succ-x)-1,2*(succdown-x)-2)
	change = (beforeup+1)*(afterup+1) + (beforedown+1)*(afterdown+1) - 1
	if diag[diff].find(x):
		total += change
		diag[diff].delete(x)
	else:
		total -= change
		diag[diff].insert(x)
	print(total)
","['brute force', 'combinatorics', 'data structures', 'dfs and similar', 'dp', 'implementation', 'math']"
4802,"Have you ever tasted Martian food? Well, you should.Their signature dish is served on a completely black plate with the radius of R, flat as a pancake.First, they put a perfectly circular portion of the Golden Honduras on the plate. It has the radius of r and is located as close to the edge of the plate as possible staying entirely within the plate. I. e. Golden Honduras touches the edge of the plate from the inside. It is believed that the proximity of the portion of the Golden Honduras to the edge of a plate demonstrates the neatness and exactness of the Martians.Then a perfectly round portion of Pink Guadeloupe is put on the plate. The Guadeloupe should not overlap with Honduras, should not go beyond the border of the plate, but should have the maximum radius. I. e. Pink Guadeloupe should touch the edge of the plate from the inside, and touch Golden Honduras from the outside. For it is the size of the Rose Guadeloupe that shows the generosity and the hospitality of the Martians.Further, the first portion (of the same perfectly round shape) of Green Bull Terrier is put on the plate. It should come in contact with Honduras and Guadeloupe, should not go beyond the border of the plate and should have maximum radius.Each of the following portions of the Green Bull Terrier must necessarily touch the Golden Honduras, the previous portion of the Green Bull Terrier and touch the edge of a plate, but should not go beyond the border.To determine whether a stranger is worthy to touch the food, the Martians ask him to find the radius of the k-th portion of the Green Bull Terrier knowing the radii of a plate and a portion of the Golden Honduras. And are you worthy? NoteDish from the first sample looks like this:Dish from the second sample looks like this: #!/usr/bin/env python3

def solve(R,r,k):
  # Thanks to Numberphile's ""Epic circles"" video
  # Use the formula for radii of circles in Pappus chain
  r = r / R
  n = k
  answer = ((1-r)*r)/(2*((n**2)*((1-r)**2)+r))
  # Note that in a Pappus chain the diameter of the circle is 1, so we need to scale up:
  answer = 2*R * answer
  print(""%.10f"" % answer)

t = int(input())
for i in range(t):
  R,r,k = map(int, input().split())
  solve(R,r,k)",['geometry']
3853,"You are given a connected undirected weighted graph consisting of $$$n$$$ vertices and $$$m$$$ edges.You need to print the $$$k$$$-th smallest shortest path in this graph (paths from the vertex to itself are not counted, paths from $$$i$$$ to $$$j$$$ and from $$$j$$$ to $$$i$$$ are counted as one).More formally, if $$$d$$$ is the matrix of shortest paths, where $$$d_{i, j}$$$ is the length of the shortest path between vertices $$$i$$$ and $$$j$$$ ($$$1 \le i &lt; j \le n$$$), then you need to print the $$$k$$$-th element in the sorted array consisting of all $$$d_{i, j}$$$, where $$$1 \le i &lt; j \le n$$$. nan from __future__ import division, print_function
 
DEBUG = 0
 
import os, sys
from atexit import register
from io import BytesIO
import itertools
 
if sys.version_info[0] < 3:
    input = raw_input
    range = xrange
 
    filter = itertools.ifilter
    map = itertools.imap
    zip = itertools.izip
 
if DEBUG:
    debug_print = print
else:
    sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))
    sys.stdout = BytesIO()
    register(lambda: os.write(1, sys.stdout.getvalue()))
 
    input = lambda: sys.stdin.readline().rstrip('\r\n')
    debug_print = lambda *x, **y: None
 
 
def input_as_list():
    return list(map(int, input().split()))
 
 
def array_of(f, *dim):
    return [array_of(f, *dim[1:]) for _ in range(dim[0])] if dim else f()
 
 
def main():
    from heapq import heapify, heappop, heappush
 
    n, m, k = input_as_list()
 
    g = array_of(list, n)
    elist = []
    pq = []
 
    for _ in range(m):
        u, v, d = input_as_list()
        elist.append((d, u-1, v-1))
 
    elist.sort()
    elist = elist[:k]
 
    V = set()
    for d, u, v in elist:
        V.add(u)
        V.add(v)
        g[u].append((v, d))
        g[v].append((u, d))
 
    all_paths = []
 
    for v in V:
        pq = [(0, v)]
        ub = dict()
        done = set()
 
        while pq:
            d, x = heappop(pq)
 
            if x in done:
                continue
 
            debug_print(v, x, d)
            done.add(x)
            if d > 0 : all_paths.append(d)
 
            for u, du in g[x]:
                du += d
 
                if u in ub and du >= ub[u]:
                    continue
 
                heappush(pq, (du, u))
                ub[u] = du
 
    all_paths.sort()
    print(all_paths[2*k-1])
 
main()","['brute force', 'constructive algorithms', 'shortest paths', 'sortings']"
1932,"You are given a grid with $$$n$$$ rows and $$$m$$$ columns. Rows and columns are numbered from $$$1$$$ to $$$n$$$, and from $$$1$$$ to $$$m$$$. The intersection of the $$$a$$$-th row and $$$b$$$-th column is denoted by $$$(a, b)$$$. Initially, you are standing in the top left corner $$$(1, 1)$$$. Your goal is to reach the bottom right corner $$$(n, m)$$$.You can move in four directions from $$$(a, b)$$$: up to $$$(a-1, b)$$$, down to $$$(a+1, b)$$$, left to $$$(a, b-1)$$$ or right to $$$(a, b+1)$$$.You cannot move in the same direction in two consecutive moves, and you cannot leave the grid. What is the minimum number of moves to reach $$$(n, m)$$$? NoteTest case $$$1$$$: $$$n=1$$$, $$$m=1$$$, and initially you are standing in $$$(1, 1)$$$ so $$$0$$$ move is required to reach $$$(n, m) = (1, 1)$$$.Test case $$$2$$$: you should go down to reach $$$(2, 1)$$$.Test case $$$3$$$: it is impossible to reach $$$(1, 3)$$$ without moving right two consecutive times, or without leaving the grid.Test case $$$4$$$: an optimal moving sequence could be: $$$(1, 1) \to (1, 2) \to (2, 2) \to (2, 1) \to (3, 1) \to (3, 2) \to (4, 2)$$$. It can be proved that this is the optimal solution. So the answer is $$$6$$$. test = int(input())
steps = 0
ans = []
for tests in range(test):
    n, m = map(int, input().split())
    if (n== 1 and m > 2) or (m == 1 and n > 2):
        steps = -1
        ans.append(steps)
    if n == m == 1:
        steps = 0
        ans.append(steps)
    if (m>=n) and n!=1:
        if (m+n)%2 == 0:
            steps = 2*((n-1) + (m-n))
            ans.append(steps)
        if (m+n)% 2 != 0:
            steps = 2*((n-1) + (m-n)) - 1
            ans.append(steps)
    if n>m and m!=1:
        if (m+n)%2 == 0:
            steps = 2*((m-1) + (n-m))
            ans.append(steps)
        if (m+n)% 2 != 0:
            steps = 2*((m-1) + (n-m)) - 1
            ans.append(steps)
    if (n==2 and m==1) or (m==2 and n==1):
        steps = 1
        ans.append(steps)
print(*ans, sep = ""\n"")            

    

","['implementation', 'math']"
1222,"The map of Bertown can be represented as a set of $$$n$$$ intersections, numbered from $$$1$$$ to $$$n$$$ and connected by $$$m$$$ one-way roads. It is possible to move along the roads from any intersection to any other intersection. The length of some path from one intersection to another is the number of roads that one has to traverse along the path. The shortest path from one intersection $$$v$$$ to another intersection $$$u$$$ is the path that starts in $$$v$$$, ends in $$$u$$$ and has the minimum length among all such paths.Polycarp lives near the intersection $$$s$$$ and works in a building near the intersection $$$t$$$. Every day he gets from $$$s$$$ to $$$t$$$ by car. Today he has chosen the following path to his workplace: $$$p_1$$$, $$$p_2$$$, ..., $$$p_k$$$, where $$$p_1 = s$$$, $$$p_k = t$$$, and all other elements of this sequence are the intermediate intersections, listed in the order Polycarp arrived at them. Polycarp never arrived at the same intersection twice, so all elements of this sequence are pairwise distinct. Note that you know Polycarp's path beforehand (it is fixed), and it is not necessarily one of the shortest paths from $$$s$$$ to $$$t$$$.Polycarp's car has a complex navigation system installed in it. Let's describe how it works. When Polycarp starts his journey at the intersection $$$s$$$, the system chooses some shortest path from $$$s$$$ to $$$t$$$ and shows it to Polycarp. Let's denote the next intersection in the chosen path as $$$v$$$. If Polycarp chooses to drive along the road from $$$s$$$ to $$$v$$$, then the navigator shows him the same shortest path (obviously, starting from $$$v$$$ as soon as he arrives at this intersection). However, if Polycarp chooses to drive to another intersection $$$w$$$ instead, the navigator rebuilds the path: as soon as Polycarp arrives at $$$w$$$, the navigation system chooses some shortest path from $$$w$$$ to $$$t$$$ and shows it to Polycarp. The same process continues until Polycarp arrives at $$$t$$$: if Polycarp moves along the road recommended by the system, it maintains the shortest path it has already built; but if Polycarp chooses some other path, the system rebuilds the path by the same rules.Here is an example. Suppose the map of Bertown looks as follows, and Polycarp drives along the path $$$[1, 2, 3, 4]$$$ ($$$s = 1$$$, $$$t = 4$$$): Check the picture by the link http://tk.codeforces.com/a.png   When Polycarp starts at $$$1$$$, the system chooses some shortest path from $$$1$$$ to $$$4$$$. There is only one such path, it is $$$[1, 5, 4]$$$;  Polycarp chooses to drive to $$$2$$$, which is not along the path chosen by the system. When Polycarp arrives at $$$2$$$, the navigator rebuilds the path by choosing some shortest path from $$$2$$$ to $$$4$$$, for example, $$$[2, 6, 4]$$$ (note that it could choose $$$[2, 3, 4]$$$);  Polycarp chooses to drive to $$$3$$$, which is not along the path chosen by the system. When Polycarp arrives at $$$3$$$, the navigator rebuilds the path by choosing the only shortest path from $$$3$$$ to $$$4$$$, which is $$$[3, 4]$$$;  Polycarp arrives at $$$4$$$ along the road chosen by the navigator, so the system does not have to rebuild anything. Overall, we get $$$2$$$ rebuilds in this scenario. Note that if the system chose $$$[2, 3, 4]$$$ instead of $$$[2, 6, 4]$$$ during the second step, there would be only $$$1$$$ rebuild (since Polycarp goes along the path, so the system maintains the path $$$[3, 4]$$$ during the third step).The example shows us that the number of rebuilds can differ even if the map of Bertown and the path chosen by Polycarp stays the same. Given this information (the map and Polycarp's path), can you determine the minimum and the maximum number of rebuilds that could have happened during the journey? nan from collections import deque
n, m = map(int, input().split())
graph = [[] for _ in range(n + 1)]
inverse = [[] for _ in range(n + 1)]
for _ in range(m):
    u, v = map(int, input().split())
    graph[u].append(v)
    inverse[v].append(u)
k = int(input())
way = list(map(int, input().split()))
s = way[0]
t = way[-1]
queue = deque()
queue.append(t)
d = [0] * (n + 1)
used = [False] * (n + 1)
used[t] = True
while len(queue):
    cur = queue[0]
    queue.popleft()
    for to in inverse[cur]:
        if not used[to]:
            d[to] = d[cur] + 1
            queue.append(to)
            used[to] = True
ans_max = 0
ans_min = 0
for i in range(k - 1):
    if d[way[i]] > d[way[i + 1]]:
        to_min = -1
        for to in graph[way[i]]:
            if to != way[i + 1] and d[to] <= d[way[i + 1]]:
                to_min = to
        if to_min != -1:
            ans_max += 1
    else:
        ans_max += 1
        ans_min += 1
print(ans_min, ans_max)
","['dfs and similar', 'graphs', 'shortest paths']"
468,"During the archaeological research in the Middle East you found the traces of three ancient religions: First religion, Second religion and Third religion. You compiled the information on the evolution of each of these beliefs, and you now wonder if the followers of each religion could coexist in peace.The Word of Universe is a long word containing the lowercase English characters only. At each moment of time, each of the religion beliefs could be described by a word consisting of lowercase English characters.The three religions can coexist in peace if their descriptions form disjoint subsequences of the Word of Universe. More formally, one can paint some of the characters of the Word of Universe in three colors: $$$1$$$, $$$2$$$, $$$3$$$, so that each character is painted in at most one color, and the description of the $$$i$$$-th religion can be constructed from the Word of Universe by removing all characters that aren't painted in color $$$i$$$.The religions however evolve. In the beginning, each religion description is empty. Every once in a while, either a character is appended to the end of the description of a single religion, or the last character is dropped from the description. After each change, determine if the religions could coexist in peace. NoteIn the first example, after the 6th evolution the religion descriptions are: ad, bc, and ab. The following figure shows how these descriptions form three disjoint subsequences of the Word of Universe:   import sys
input = iter(sys.stdin.buffer.read().decode().splitlines()).__next__

n, q = map(int, input().split())
s = '!' + input()
 
nxt = [[n + 1] * (n + 2) for _ in range(26)]
for i in range(n - 1, -1, -1):
    c = ord(s[i + 1]) - 97
    for j in range(26):
        nxt[j][i] = nxt[j][i + 1]
    nxt[c][i] = i + 1
 
w = [[-1], [-1], [-1]]
idx = lambda i, j, k: i * 65536 + j * 256 + k
dp = [0] * (256 * 256 * 256)
def calc(fix=None):
    r = list(map(range, (len(w[0]), len(w[1]), len(w[2]))))
    if fix is not None: r[fix] = range(len(w[fix]) - 1, len(w[fix]))
    for i in r[0]:
        for j in r[1]:
            for k in r[2]:
                dp[idx(i, j, k)] = min(nxt[w[0][i]][dp[idx(i - 1, j, k)]] if i else n + 1,
                                       nxt[w[1][j]][dp[idx(i, j - 1, k)]] if j else n + 1,
                                       nxt[w[2][k]][dp[idx(i, j, k - 1)]] if k else n + 1)
                if i == j == k == 0: dp[idx(i, j, k)] = 0
 
out = []
for _ in range(q):
    t, *r = input().split()
    if t == '+':
        i, c = int(r[0]) - 1, ord(r[1]) - 97
        w[i].append(c)
        calc(i)
    else:
        i = int(r[0]) - 1
        w[i].pop()
    req = dp[idx(len(w[0]) - 1, len(w[1]) - 1, len(w[2]) - 1)]
    out.append('YES' if req <= n else 'NO')
 
print(*out, sep='\n')","['dp', 'implementation', 'strings']"
4903,"Once when Gerald studied in the first year at school, his teacher gave the class the following homework. She offered the students a string consisting of n small Latin letters; the task was to learn the way the letters that the string contains are written. However, as Gerald is too lazy, he has no desire whatsoever to learn those letters. That's why he decided to lose some part of the string (not necessarily a connected part). The lost part can consist of any number of segments of any length, at any distance from each other. However, Gerald knows that if he loses more than k characters, it will be very suspicious. Find the least number of distinct characters that can remain in the string after no more than k characters are deleted. You also have to find any possible way to delete the characters. NoteIn the first sample the string consists of five identical letters but you are only allowed to delete 4 of them so that there was at least one letter left. Thus, the right answer is 1 and any string consisting of characters ""a"" from 1 to 5 in length.In the second sample you are allowed to delete 4 characters. You cannot delete all the characters, because the string has length equal to 7. However, you can delete all characters apart from ""a"" (as they are no more than four), which will result in the ""aaaa"" string.In the third sample you are given a line whose length is equal to 8, and k = 10, so that the whole line can be deleted. The correct answer is 0 and an empty string. string = input()
n = int(input())
alphabet = {}
a = set(string)
bool_string = {i: True for i in a}
for i in a:
    alphabet[i] = 0
for i in string:
    alphabet[i] += 1
array = [[alphabet[i], i] for i in alphabet]
array.sort()
k = len(array)
i = 0
while n > 0 and i < k:
    n -= array[i][0]
    bool_string[array[i][1]] = False
    i += 1
if n < 0:
    bool_string[array[i-1][1]] = True
    i -= 1
answer = ''
print(k-i)
for i in string:
    if bool_string[i]: answer += i

print(answer)
",['greedy']
4236,"You have array a that contains all integers from 1 to n twice. You can arbitrary permute any numbers in a.Let number i be in positions xi, yi (xi &lt; yi) in the permuted array a. Let's define the value di = yi - xi — the distance between the positions of the number i. Permute the numbers in array a to minimize the value of the sum . nan n=int(input())
A = [0] * (2*n)
per1 = 0
per2 = n
for i in range(1, n):
    if i % 2==1:
        A[per1] = i
        A[per1+n-i] = i
        per1+=1
    else:
        A[per2] = i
        A[per2+n-i] = i
        per2+=1

A[-1] = n
if n % 2 == 1:
    A[n//2] = n
else:
    A[-(n//2+1)] = n
print(' '.join(map(str, A)))",['constructive algorithms']
3505,"There are $$$n$$$ beautiful skyscrapers in New York, the height of the $$$i$$$-th one is $$$h_i$$$. Today some villains have set on fire first $$$n - 1$$$ of them, and now the only safety building is $$$n$$$-th skyscraper.Let's call a jump from $$$i$$$-th skyscraper to $$$j$$$-th ($$$i &lt; j$$$) discrete, if all skyscrapers between are strictly lower or higher than both of them. Formally, jump is discrete, if $$$i &lt; j$$$ and one of the following conditions satisfied:   $$$i + 1 = j$$$  $$$\max(h_{i + 1}, \ldots, h_{j - 1}) &lt; \min(h_i, h_j)$$$  $$$\max(h_i, h_j) &lt; \min(h_{i + 1}, \ldots, h_{j - 1})$$$. At the moment, Vasya is staying on the first skyscraper and wants to live a little longer, so his goal is to reach $$$n$$$-th skyscraper with minimal count of discrete jumps. Help him with calcualting this number. NoteIn the first testcase, Vasya can jump in the following way: $$$1 \rightarrow 2 \rightarrow 4 \rightarrow 5$$$.In the second and third testcases, we can reach last skyscraper in one jump.Sequence of jumps in the fourth testcase: $$$1 \rightarrow 3 \rightarrow 5$$$. # by the authority of GOD     author: manhar singh sachdev #

import os,sys
from io import BytesIO, IOBase

def main():
    n = int(input())
    h = list(map(int,input().split()))
    max_st = [-1]*n
    min_st = [-1]*n
    for i in range(n-2,-1,-1):
        if h[i]>=h[i+1]:
            min_st[i] = i+1
        else:
            x = min_st[i+1]
            while x != -1 and h[i] < h[x]:
                x = min_st[x]
            min_st[i] = x
        if h[i]<=h[i+1]:
            max_st[i] = i+1
        else:
            x = max_st[i+1]
            while x != -1 and h[i] > h[x]:
                x = max_st[x]
            max_st[i] = x
    max_st1 = [-1]*n
    min_st1 = [-1]*n
    for i in range(1,n):
        if h[i]>=h[i-1]:
            min_st1[i] = i-1
        else:
            x = min_st1[i-1]
            while x != -1 and h[i] < h[x]:
                x = min_st1[x]
            min_st1[i] = x
        if h[i]<=h[i-1]:
            max_st1[i] = i-1
        else:
            x = max_st1[i-1]
            while x != -1 and h[i] > h[x]:
                x = max_st1[x]
            max_st1[i] = x
    #print(min_st,max_st,max_st1,min_st1)
    rishta = [[] for _ in range(n)]
    for i,val in enumerate(min_st):
        if val != -1:
            rishta[i].append(val)
            rishta[val].append(i)
    for i,val in enumerate(min_st1):
        if val != -1:
            rishta[i].append(val)
            rishta[val].append(i)
    for i,val in enumerate(max_st):
        if val != -1:
            rishta[i].append(val)
            rishta[val].append(i)
    for i,val in enumerate(max_st1):
        if val != -1:
            rishta[i].append(val)
            rishta[val].append(i)
    lst = [10**10]*n
    lst[0] = 0
    for i in range(n-1):
        lst[i+1] = min(lst[i+1],lst[i]+1)
        for x in rishta[i]:
            if x > i:
                lst[x] = min(lst[x],lst[i]+1)
    print(lst[-1])

#Fast IO Region
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == '__main__':
    main()","['data structures', 'dp', 'graphs']"
2615,"Lenny had an n × m matrix of positive integers. He loved the matrix so much, because each row of the matrix was sorted in non-decreasing order. For the same reason he calls such matrices of integers lovely.One day when Lenny was at school his little brother was playing with Lenny's matrix in his room. He erased some of the entries of the matrix and changed the order of some of its columns. When Lenny got back home he was very upset. Now Lenny wants to recover his matrix.Help him to find an order for the columns of the matrix so that it's possible to fill in the erased entries of the matrix to achieve a lovely matrix again. Note, that you can fill the erased entries of the matrix with any integers. nan n, m = map(int, raw_input().split())
b = [map(int, raw_input().split()) for _ in range(n)]
c = [n - x.count(-1) for x in zip(*b)]
d = []
for r in b:
	t = {}
	for i, x in enumerate(r):
		if x != -1:
			if x not in t:
				t[x] = set()
			t[x].add(i)
	d.append([x for i, x in sorted(t.items())][ : : -1])
p = [i for i, x in enumerate(c) if not x]
for v in d:
	if v:
		for x in v[-1]:
			c[x] -= 1
			if not c[x]:
				p.append(x)
r = []
while p:
	x = p.pop()
	r.append(x + 1)
	for i, v in enumerate(d):
		if v:
			v[-1].discard(x)
			if not v[-1]:
				d[i].pop()
				if d[i]:
					for y in d[i][-1]:
						c[y] -= 1
						if not c[y]:
							p.append(y)
print [-1, ' '.join(map(str, r))][len(r) == m]
","['dfs and similar', 'graphs', 'greedy', 'sortings']"
655,"Egor is a famous Russian singer, rapper, actor and blogger, and finally he decided to give a concert in the sunny Republic of Dagestan.There are $$$n$$$ cities in the republic, some of them are connected by $$$m$$$ directed roads without any additional conditions. In other words, road system of Dagestan represents an arbitrary directed graph. Egor will arrive to the city $$$1$$$, travel to the city $$$n$$$ by roads along some path, give a concert and fly away.As any famous artist, Egor has lots of haters and too annoying fans, so he can travel only by safe roads. There are two types of the roads in Dagestan, black and white: black roads are safe at night only, and white roads — in the morning. Before the trip Egor's manager's going to make a schedule: for each city he'll specify it's color, black or white, and then if during the trip they visit some city, the only time they can leave it is determined by the city's color: night, if it's black, and morning, if it's white. After creating the schedule Egor chooses an available path from $$$1$$$ to $$$n$$$, and for security reasons it has to be the shortest possible.Egor's manager likes Dagestan very much and wants to stay here as long as possible, so he asks you to make such schedule that there would be no path from $$$1$$$ to $$$n$$$ or the shortest path's length would be greatest possible.A path is one city or a sequence of roads such that for every road (excluding the first one) the city this road goes from is equal to the city previous road goes into. Egor can move only along paths consisting of safe roads only. The path length is equal to the number of roads in it. The shortest path in a graph is a path with smallest length. NoteFor the first sample, if we paint city $$$1$$$ white, the shortest path is $$$1 \rightarrow 3$$$. Otherwise, it's $$$1 \rightarrow 2 \rightarrow 3$$$ regardless of other cities' colors.For the second sample, we should paint city $$$3$$$ black, and there are both black and white roads going from $$$2$$$ to $$$4$$$. Note that there can be a road connecting a city with itself. import sys
input = sys.stdin.readline
from collections import deque
n, m = map(int, input().split());back = [[] for i in range(n)]
for _ in range(m):u, v, w = map(int, input().split());u -= 1;v -= 1;back[v].append((u,w)) 
out = [2] * n;outl = [-1] * n;outl[-1] = 0;q = deque([n - 1])
while q:
    v = q.popleft()
    for u, w in back[v]:
        if out[u] != w:out[u] = 1 - w
        else:
            if outl[u] == -1:outl[u] = outl[v] + 1;q.append(u)                
out = [v if v != 2 else 1 for v in out];print(outl[0]);print(''.join(map(str,out)))","['constructive algorithms', 'dfs and similar', 'dp', 'graphs', 'greedy', 'shortest paths']"
2450,"A tree is a connected undirected graph consisting of n vertices and n  -  1 edges. Vertices are numbered 1 through n.Limak is a little polar bear. He once had a tree with n vertices but he lost it. He still remembers something about the lost tree though.You are given m pairs of vertices (a1, b1), (a2, b2), ..., (am, bm). Limak remembers that for each i there was no edge between ai and bi. He also remembers that vertex 1 was incident to exactly k edges (its degree was equal to k).Is it possible that Limak remembers everything correctly? Check whether there exists a tree satisfying the given conditions. NoteIn the first sample, there are n = 5 vertices. The degree of vertex 1 should be k = 2. All conditions are satisfied for a tree with edges 1 - 5, 5 - 2, 1 - 3 and 3 - 4.In the second sample, Limak remembers that none of the following edges existed: 1 - 2, 1 - 3, 1 - 4, 1 - 5 and 1 - 6. Hence, vertex 1 couldn't be connected to any other vertex and it implies that there is no suitable tree. import sys
n,m,k = map(int, sys.stdin.readline().split(' '))
V = map(set, [set()]*n)
for _ in range(m):
  u,v = map(int, sys.stdin.readline().rstrip('\n').split(' '))
  u-=1
  v-=1
  V[u].add(v)
  V[v].add(u)
if n-1-len(V[0])<k:
  print 'impossible'
  exit()
  
visited = set(range(1,n))
comp = 0
for i in range(1,n):
  if i in visited:
    visited.remove(i)
    comp += 1
    if comp>k:
      print 'impossible'
      exit()
    can_connect_to_root = False
    stack = [i]
    for s in stack:
      can_connect_to_root |= s not in V[0]
      removed = set()
      for x in visited:
        if x not in V[s]:
          removed.add(x)
          stack.append(x)
      visited.difference_update(removed)
    if not can_connect_to_root:
      print 'impossible'
      exit()
print 'possible'
","['dfs and similar', 'dsu', 'graphs', 'trees']"
2301,"Overall there are m actors in Berland. Each actor has a personal identifier — an integer from 1 to m (distinct actors have distinct identifiers). Vasya likes to watch Berland movies with Berland actors, and he has k favorite actors. He watched the movie trailers for the next month and wrote the following information for every movie: the movie title, the number of actors who starred in it, and the identifiers of these actors. Besides, he managed to copy the movie titles and how many actors starred there, but he didn't manage to write down the identifiers of some actors. Vasya looks at his records and wonders which movies may be his favourite, and which ones may not be. Once Vasya learns the exact cast of all movies, his favorite movies will be determined as follows: a movie becomes favorite movie, if no other movie from Vasya's list has more favorite actors.Help the boy to determine the following for each movie: whether it surely will be his favourite movie; whether it surely won't be his favourite movie;  can either be favourite or not. NoteNote to the second sample:   Movie jumanji can theoretically have from 1 to 3 Vasya's favourite actors.  Movie theeagle has all three favourite actors, as the actor Vasya failed to remember, can only have identifier 5.  Movie matrix can have exactly one favourite actor.  Movie sourcecode doesn't have any favourite actors. Thus, movie theeagle will surely be favourite, movies matrix and sourcecode won't surely be favourite, and movie jumanji can be either favourite (if it has all three favourite actors), or not favourite. def main():
    file = open(""input.txt"")
    file_o = open(""output.txt"", 'w')
    m, k = map(int, file.readline().split())
    fvr = set(map(int, file.readline().split()))
    n = int(file.readline())
    img_cnt = []
    act_cnt = []
    sur_frv_cut = 0
    sur_frv_cut_sec = 0
    sur_not_cut = 0
    for _ in range(n):
        name = file.readline()
        d = int(file.readline())
        ds = map(int, file.readline().split())
        f = 0
        nf = 0
        for num in ds:
            if num in fvr:
                f = f + 1
            elif num != 0:
                nf = nf + 1
        img = d - nf
        if img > k: img = k
        act = d - (m - k)
        if act < f: act = f

        img_cnt.append(img)
        act_cnt.append(act)

        if img > sur_frv_cut:
            sur_frv_cut_sec = sur_frv_cut
            sur_frv_cut = img
        elif img > sur_frv_cut_sec:
            sur_frv_cut_sec = img

        if act > sur_not_cut:
            sur_not_cut = act

    for i in range(n):

        if act_cnt[i] >= sur_frv_cut or (act_cnt[i] >= sur_frv_cut_sec and img_cnt[i] >= sur_frv_cut): file_o.write(""0\n"")
        elif img_cnt[i] < sur_not_cut: file_o.write(""1\n"")
        else: file_o.write(""2\n"")

    file_o.close()

main()",['implementation']
106,"Doubly linked list is one of the fundamental data structures. A doubly linked list is a sequence of elements, each containing information about the previous and the next elements of the list. In this problem all lists have linear structure. I.e. each element except the first has exactly one previous element, each element except the last has exactly one next element. The list is not closed in a cycle.In this problem you are given n memory cells forming one or more doubly linked lists. Each cell contains information about element from some list. Memory cells are numbered from 1 to n.For each cell i you are given two values:   li — cell containing previous element for the element in the cell i;  ri — cell containing next element for the element in the cell i. If cell i contains information about the element which has no previous element then li = 0. Similarly, if cell i contains information about the element which has no next element then ri = 0.    Three lists are shown on the picture. For example, for the picture above the values of l and r are the following: l1 = 4, r1 = 7; l2 = 5, r2 = 0; l3 = 0, r3 = 0; l4 = 6, r4 = 1; l5 = 0, r5 = 2; l6 = 0, r6 = 4; l7 = 1, r7 = 0.Your task is to unite all given lists in a single list, joining them to each other in any order. In particular, if the input data already contains a single list, then there is no need to perform any actions. Print the resulting list in the form of values li, ri.Any other action, other than joining the beginning of one list to the end of another, can not be performed. nan n = int(input())
C = [0] * (n+1)
def vis(i, label, L, R):
    if C[i] == 0:
        C[i] = label
        if L[i] != 0:
            vis(L[i], label, L, R)
        if R[i] != 0:
            vis(R[i], label, L, R)

L = [0] * (n+1)
R = [0] * (n+1)
label = 1
for i in range(1, n+1):
    l, r = list(map(int, input().split()))
    L[i] = l
    R[i] = r

for i in range(1, n+1):
    if C[i] == 0:
        vis(i, label, L, R)
        label+=1
label-=1
for i in range(1, n+1):
    if label == 1:
        break

    if L[i] != 0 and R[i] != 0:
        continue
    for j in range(1, n+1):
        if i != j:
            if L[i] == 0 and R[j] == 0 and C[i] != C[j]:
                L[i] = j
                R[j] = i
                target = C[j]
                newL = C[i]
                for k in range(1, n+1):
                    if C[k] == target:
                        C[k] = newL
                label-=1
            elif R[i] == 0 and L[j] == 0 and C[i] != C[j]:
                R[i] = j
                L[j] = i
                target = C[j]
                newL = C[i]
                for k in range(1, n+1):
                    if C[k] == target:
                        C[k] = newL
                label-=1

for i in range(1, n+1):
    print(str(L[i]) + "" "" + str(R[i]))
",['implementation']
1630,"Marian is at a casino. The game at the casino works like this.Before each round, the player selects a number between $$$1$$$ and $$$10^9$$$. After that, a dice with $$$10^9$$$ faces is rolled so that a random number between $$$1$$$ and $$$10^9$$$ appears. If the player guesses the number correctly their total money is doubled, else their total money is halved. Marian predicted the future and knows all the numbers $$$x_1, x_2, \dots, x_n$$$ that the dice will show in the next $$$n$$$ rounds. He will pick three integers $$$a$$$, $$$l$$$ and $$$r$$$ ($$$l \leq r$$$). He will play $$$r-l+1$$$ rounds (rounds between $$$l$$$ and $$$r$$$ inclusive). In each of these rounds, he will guess the same number $$$a$$$. At the start (before the round $$$l$$$) he has $$$1$$$ dollar.Marian asks you to determine the integers $$$a$$$, $$$l$$$ and $$$r$$$ ($$$1 \leq a \leq 10^9$$$, $$$1 \leq l \leq r \leq n$$$) such that he makes the most money at the end.Note that during halving and multiplying there is no rounding and there are no precision errors. So, for example during a game, Marian could have money equal to $$$\dfrac{1}{1024}$$$, $$$\dfrac{1}{128}$$$, $$$\dfrac{1}{2}$$$, $$$1$$$, $$$2$$$, $$$4$$$, etc. (any value of $$$2^t$$$, where $$$t$$$ is an integer of any sign). NoteFor the first test case, the best choice is $$$a=4$$$, $$$l=1$$$, $$$r=5$$$, and the game would go as follows.   Marian starts with one dollar.  After the first round, he ends up with $$$2$$$ dollars because the numbers coincide with the chosen one.  After the second round, he ends up with $$$4$$$ dollars because the numbers coincide again.  After the third round, he ends up with $$$2$$$ dollars because he guesses $$$4$$$ even though $$$3$$$ is the correct choice.  After the fourth round, he ends up with $$$4$$$ dollars again.  In the final round, he ends up $$$8$$$ dollars because he again guessed correctly. There are many possible answers for the second test case, but it can be proven that Marian will not end up with more than $$$2$$$ dollars, so any choice with $$$l = r$$$ with the appropriate $$$a$$$ is acceptable. #!/usr/bin/env python3
import sys
import math, random
import functools, itertools, collections, heapq, bisect
from collections import Counter, defaultdict, deque
input = sys.stdin.readline  # to read input quickly

# available on Google, AtCoder Python3, not available on Codeforces
# import numpy as np
# import scipy

m9 = 10**9 + 7  # 998244353
yes, no = ""YES"", ""NO""
# d4 = [(1,0),(0,1),(-1,0),(0,-1)]
# d8 = [(1,0),(1,1),(0,1),(-1,1),(-1,0),(-1,-1),(0,-1),(1,-1)]
# d6 = [(2,0),(1,1),(-1,1),(-2,0),(-1,-1),(1,-1)]  # hexagonal layout
MAXINT = sys.maxsize
e18 = 10**18 + 10

# if testing locally, print to terminal with a different color
CHECK_OFFLINE_TEST = True
# CHECK_OFFLINE_TEST = False  # uncomment this on Codechef
if CHECK_OFFLINE_TEST:
    import getpass
    OFFLINE_TEST = getpass.getuser() == ""htong""

def log(*args):
    if CHECK_OFFLINE_TEST and OFFLINE_TEST:
        print('\033[36m', *args, '\033[0m', file=sys.stderr)

def solve(*args):
    # screen input
    if OFFLINE_TEST:
        log(""----- solving ------"")
        log(*args)
        log(""----- ------- ------"")
    return solve_(*args)

def read_matrix(rows):
    return [list(map(int,input().split())) for _ in range(rows)]

def read_strings(rows):
    return [input().strip() for _ in range(rows)]

def minus_one(arr):
    return [x-1 for x in arr]

def minus_one_matrix(mrr):
    return [[x-1 for x in row] for row in mrr]

# ---------------------------- template ends here ----------------------------




def solve_(arr):
    # your solution here
    
    g = defaultdict(list)
    for i,x in enumerate(arr):
        g[str(x)].append(i)
    
    maxres = 0
    ares = arr[0]
    lres = 0
    rres = 0

    # log(g)

    for element in g:
        # brr = [ for i,x in enumerate(brr)]

        # log(element, brr)

        minprev = 10**10
        left = 0
        for i,x in enumerate(g[element]):
            val,right = (2*i-x,x)
            if val - minprev > maxres:
                maxres = val - minprev
                ares = element
                lres = left
                rres = right

            if val < minprev:
                minprev = val
                left = right

    log(maxres)

    return ares, lres+1, rres+1


# for case_num in [0]:  # no loop over test case
# for case_num in range(100):  # if the number of test cases is specified
for case_num in range(int(input())):

    # read line as an integer
    k = int(input())

    # read line as a string
    # srr = input().strip()

    # read one line and parse each word as a string
    # arr = input().split()

    # read one line and parse each word as an integer
    # a,b,c = list(map(int,input().split()))
    arr = list(map(int,input().split()))
    # arr = minus_one(arr)

    # read multiple rows
    # arr = read_strings(k)  # and return as a list of str
    # mrr = read_matrix(k)  # and return as a list of list of int
    # mrr = minus_one_matrix(mrr)

    res = solve(arr)  # include input here

    # print length if applicable
    # print(len(res))

    # parse result
    res = "" "".join(str(x) for x in res)
    # res = ""\n"".join(str(x) for x in res)
    # res = ""\n"".join("" "".join(str(x) for x in row) for row in res)

    # print result
    # print(""Case #{}: {}"".format(case_num+1, res))   # Google and Facebook - case number required

    print(res)
","['data structures', 'dp', 'greedy', 'math']"
3334,"You are given a set of all integers from $$$l$$$ to $$$r$$$ inclusive, $$$l &lt; r$$$, $$$(r - l + 1) \le 3 \cdot 10^5$$$ and $$$(r - l)$$$ is always odd.You want to split these numbers into exactly $$$\frac{r - l + 1}{2}$$$ pairs in such a way that for each pair $$$(i, j)$$$ the greatest common divisor of $$$i$$$ and $$$j$$$ is equal to $$$1$$$. Each number should appear in exactly one of the pairs.Print the resulting pairs or output that no solution exists. If there are multiple solutions, print any of them. nan ##############--->>>>> Deepcoder Amit Kumar Bhuyan <<<<<---##############

""""""
 Perfection is achieved not when there is nothing more to add, but rather when there is nothing more to take away.
""""""
from __future__ import division, print_function
 
import os,sys
from io import BytesIO, IOBase
 
if sys.version_info[0] < 3:
    from __builtin__ import xrange as range
    from future_builtins import ascii, filter, hex, map, oct, zip
 
 
def ii():  return int(input())
def si():  return input()
def mi():  return map(int,input().strip().split("" ""))
def msi(): return map(str,input().strip().split("" ""))
def li():  return list(mi())
 
def dmain():
    sys.setrecursionlimit(1000000)
    threading.stack_size(1024000)
    thread = threading.Thread(target=main)
    thread.start()
    
#from collections import deque, Counter, OrderedDict,defaultdict
#from heapq import nsmallest, nlargest, heapify,heappop ,heappush, heapreplace
#from math import log,sqrt,factorial,cos,tan,sin,radians
#from bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right
#from decimal import *
#import threading
#from itertools import permutations
#Copy 2D list  m = [x[:] for x in mark] .. Avoid Using Deepcopy
import sys
input = sys.stdin.readline
scan_int = lambda: int(input())
scan_string = lambda: input().rstrip()
read_list = lambda: list(read())
read = lambda: map(int, input().split())
read_float = lambda: map(float, input().split())
# from bisect import bisect_left as lower_bound;
# from bisect import bisect_right as upper_bound;
# from math import ceil, factorial;

 
def ceil(x):
    if x != int(x):
        x = int(x) + 1
    return x
 
def factorial(x, m):
	val = 1
	while x>0:
		val = (val * x) % m
		x -= 1
	return val

def fact(x):
	val = 1
	while x > 0:
		val *= x
		x -= 1
	return val
    
# swap_array function
def swaparr(arr, a,b):
    temp = arr[a];
    arr[a] = arr[b];
    arr[b] = temp;
 
## gcd function
def gcd(a,b):
    if b == 0:
        return a;
    return gcd(b, a % b);

## lcm function
def lcm(a, b):
	return (a * b) // math.gcd(a, b)

def is_integer(n):
	return math.ceil(n) == math.floor(n)
 
## nCr function efficient using Binomial Cofficient
def nCr(n, k): 
	if k > n:
		return 0
	if(k > n - k):
		k = n - k
	res = 1
	for i in range(k):
		res = res * (n - i)
		res = res / (i + 1)
	return int(res)
 
## upper bound function code -- such that e in a[:i] e < x;

 
## prime factorization
def primefs(n):
    ## if n == 1    ## calculating primes
    primes = {}
    while(n%2 == 0 and n > 0):
        primes[2] = primes.get(2, 0) + 1
        n = n//2
    for i in range(3, int(n**0.5)+2, 2):
        while(n%i == 0 and n > 0):
            primes[i] = primes.get(i, 0) + 1
            n = n//i
    if n > 2:
        primes[n] = primes.get(n, 0) + 1
    ## prime factoriazation of n is stored in dictionary
    ## primes and can be accesed. O(sqrt n)
    return primes
 
## MODULAR EXPONENTIATION FUNCTION
def power(x, y, p): 
    res = 1
    x = x % p  
    if (x == 0) : 
        return 0
    while (y > 0) : 
        if ((y & 1) == 1) : 
            res = (res * x) % p 
        y = y >> 1      
        x = (x * x) % p 
    return res 
 
## DISJOINT SET UNINON FUNCTIONS
def swap(a,b):
    temp = a
    a = b
    b = temp
    return a,b;
 
# find function with path compression included (recursive)
# def find(x, link):
#     if link[x] == x:
#         return x
#     link[x] = find(link[x], link);
#     return link[x];
 
# find function with path compression (ITERATIVE)
def find(x, link):
    p = x;
    while( p != link[p]):
        p = link[p];
    
    while( x != p):
        nex = link[x];
        link[x] = p;
        x = nex;
    return p;
 
 
# the union function which makes union(x,y)
# of two nodes x and y
def union(x, y, link, size):
    x = find(x, link)
    y = find(y, link)
    if size[x] < size[y]:
        x,y = swap(x,y)
    if x != y:
        size[x] += size[y]
        link[y] = x
 
## returns an array of boolean if primes or not USING SIEVE OF ERATOSTHANES
def sieve(n): 
    prime = [True for i in range(n+1)] 
    prime[0], prime[1] = False, False
    p = 2
    while (p * p <= n): 
        if (prime[p] == True): 
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    return prime

# Euler's Toitent Function phi
def phi(n) : 
  
    result = n 
    p = 2
    while(p * p<= n) : 
        if (n % p == 0) : 
            while (n % p == 0) : 
                n = n // p 
            result = result * (1.0 - (1.0 / (float) (p))) 
        p = p + 1
    if (n > 1) : 
        result = result * (1.0 - (1.0 / (float)(n))) 
   
    return (int)(result) 

def is_prime(n):
	if n == 0:
		return False
	if n == 1:
		return True
	for i in range(2, int(n ** (1 / 2)) + 1):
		if not n % i:
			return False
 
	return True

def next_prime(n, primes):
	while primes[n] != True:
		n += 1
	return n

 
#### PRIME FACTORIZATION IN O(log n) using Sieve ####
MAXN = int(1e5 + 5)
def spf_sieve():
    spf[1] = 1;
    for i in range(2, MAXN):
        spf[i] = i;
    for i in range(4, MAXN, 2):
        spf[i] = 2;
    for i in range(3, ceil(MAXN ** 0.5), 2):
        if spf[i] == i:
            for j in range(i*i, MAXN, i):
                if spf[j] == j:
                    spf[j] = i;
    ## function for storing smallest prime factors (spf) in the array
 
################## un-comment below 2 lines when using factorization #################
spf = [0 for i in range(MAXN)]
# spf_sieve();
def factoriazation(x):
    res = []
    for i in range(2, int(x ** 0.5) + 1):
    	while x % i == 0:
    		res.append(i)
    		x //= i
    if x != 1:
   		res.append(x)
    return res
    ## this function is useful for multiple queries only, o/w use
    ## primefs function above. complexity O(log n)

def factors(n):
	res = []
	for i in range(1, int(n ** 0.5) + 1):
		if n % i == 0:
			res.append(i)
			res.append(n // i)
	return list(set(res))
 
## taking integer array input
def int_array():
    return list(map(int, input().strip().split()));
 
def float_array():
    return list(map(float, input().strip().split()));
 
## taking string array input
def str_array():
    return input().strip().split();

def binary_search(low, high, w, h, n):
	while low < high:
		mid = low + (high - low) // 2
		# print(low, mid, high)
		if check(mid, w, h, n):
			low = mid + 1
		else:
			high = mid
	return low

## for checking any conditions
def check(beauty, s, n, count):
	pass
	

 
#defining a couple constants
MOD = int(1e9)+7;
CMOD = 998244353;
INF = float('inf'); NINF = -float('inf');
alphs = ""abcdefghijklmnopqrstuvwxyz"".upper()
 
################### ---------------- TEMPLATE ENDS HERE ---------------- ###################
 
from itertools import permutations
import math
import bisect as bis
import random
import sys
import collections as collect

def solve():
	l, r = read()
	print(""YES"")
	for i in range(l, r + 1, 2):
		print(i, i + 1)






# region fastio
# template taken from https://github.com/cheran-senthil/PyRival/blob/master/templates/template.py
 
BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
def print(*args, **kwargs):
    """"""Prints the values to a stream, or to sys.stdout by default.""""""
    sep, file = kwargs.pop(""sep"", "" ""), kwargs.pop(""file"", sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop(""end"", ""\n""))
    if kwargs.pop(""flush"", False):
        file.flush()
 
 
if sys.version_info[0] < 3:
    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
 
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
 
# endregion
 
 
if __name__ == ""__main__"":
    #read()
    for i in range(1):
    	solve()
    #dmain()
 
# Comment Read()
	# fin_time = datetime.now()
# 	print(""Execution time (for loop): "", (fin_time-init_time))
","['greedy', 'math', 'number theory']"
2277,"Vasya has a multiset $$$s$$$ consisting of $$$n$$$ integer numbers. Vasya calls some number $$$x$$$ nice if it appears in the multiset exactly once. For example, multiset $$$\{1, 1, 2, 3, 3, 3, 4\}$$$ contains nice numbers $$$2$$$ and $$$4$$$.Vasya wants to split multiset $$$s$$$ into two multisets $$$a$$$ and $$$b$$$ (one of which may be empty) in such a way that the quantity of nice numbers in multiset $$$a$$$ would be the same as the quantity of nice numbers in multiset $$$b$$$ (the quantity of numbers to appear exactly once in multiset $$$a$$$ and the quantity of numbers to appear exactly once in multiset $$$b$$$). nan raw_input()
s = map(int, raw_input().split())
MAX_SIZE = 101
count = [0] * MAX_SIZE
for num in s:
    count[num] += 1
nUnique = 0
a, b = [0] * MAX_SIZE, [0] * MAX_SIZE
turn = 0
for num in xrange(1, MAX_SIZE):
    if count[num] == 1:
        nUnique += 1
        if turn == 0:
            a[num] = 1
        else:
            b[num] = 1
        turn ^= 1
for num in xrange(1, MAX_SIZE):
    if nUnique & 1 == 1 and count[num] > 2:
        nUnique += 1
        b[num] = 1
        a[num] = count[num] - 1
    elif count[num] > 1:
        a[num] = count[num]
if nUnique & 1 == 1:
    print 'NO'
else:
    print 'YES'
    ret = ''
    for num in s:
        if a[num] > 0:
            ret += 'A'
            a[num] -= 1
        else:
            ret += 'B'
            b[num] -= 1
    print ret","['brute force', 'dp', 'greedy', 'implementation', 'math']"
4489,"The cities of Byteland and Berland are located on the axis $$$Ox$$$. In addition, on this axis there are also disputed cities, which belong to each of the countries in their opinion. Thus, on the line $$$Ox$$$ there are three types of cities:  the cities of Byteland,  the cities of Berland,  disputed cities. Recently, the project BNET has been launched — a computer network of a new generation. Now the task of the both countries is to connect the cities so that the network of this country is connected.The countries agreed to connect the pairs of cities with BNET cables in such a way that:  If you look at the only cities of Byteland and the disputed cities, then in the resulting set of cities, any city should be reachable from any other one by one or more cables,  If you look at the only cities of Berland and the disputed cities, then in the resulting set of cities, any city should be reachable from any other one by one or more cables. Thus, it is necessary to choose a set of pairs of cities to connect by cables in such a way that both conditions are satisfied simultaneously. Cables allow bi-directional data transfer. Each cable connects exactly two distinct cities.The cost of laying a cable from one city to another is equal to the distance between them. Find the minimum total cost of laying a set of cables so that two subsets of cities (Byteland and disputed cities, Berland and disputed cities) are connected.Each city is a point on the line $$$Ox$$$. It is technically possible to connect the cities $$$a$$$ and $$$b$$$ with a cable so that the city $$$c$$$ ($$$a &lt; c &lt; b$$$) is not connected to this cable, where $$$a$$$, $$$b$$$ and $$$c$$$ are simultaneously coordinates of the cities $$$a$$$, $$$b$$$ and $$$c$$$. NoteIn the first example, you should connect the first city with the second, the second with the third, and the third with the fourth. The total length of the cables will be $$$5 + 3 + 4 = 12$$$.In the second example there are no disputed cities, so you need to connect all the neighboring cities of Byteland and all the neighboring cities of Berland. The cities of Berland have coordinates $$$10, 21, 32$$$, so to connect them you need two cables of length $$$11$$$ and $$$11$$$. The cities of Byteland have coordinates $$$14$$$ and $$$16$$$, so to connect them you need one cable of length $$$2$$$. Thus, the total length of all cables is $$$11 + 11 + 2 = 24$$$. rides = int(input())
franxx = []
Zero = []
Two = []

for i in range(rides):
	darling = input().split()
	if (darling[1] == 'B'):
		darling[1] = 1
	elif (darling[1] == 'R'):
		darling[1] = 2
	else:
		darling[1] = 3
	franxx.append((int(darling[0]), int(darling[1])))

love = 0

hiro = [""I love Zero Two"", ""I love Darling""]

for zero, two in franxx:
	if (two == 3 or two == 1):
		if (hiro[0] == 'I love Zero Two'):
			Zero.append(0)
			hiro[0] = zero
		else:
			Zero.append(zero - hiro[0])
			love += zero - hiro[0]
			hiro[0] = zero
			
	if (two == 3 or two == 2):
		if (hiro[1] == 'I love Darling'):
			Two.append(0)
			hiro[1] = zero
		else:
			Two.append(zero - hiro[1])
			love += zero - hiro[1]
			hiro[1] = zero
	
	if (two == 1):
		Two.append(0)
	elif (two == 2):
		Zero.append(0)

hiro = [-1, 0]
for ride in range(rides):
	if (franxx[ride][1] == 3):
		if (hiro[0] == -1):
			hiro[0] = ride
			hiro[1] = 0
		else:
			strelizia = [0, 0]
			if ((hiro[1] & 1) == 0):
				strelizia[0] = franxx[ride][0] - franxx[hiro[0]][0]
			if ((hiro[1] & 2) == 0):
				strelizia[1] = franxx[ride][0] - franxx[hiro[0]][0]

			for darling in range(hiro[0], ride):
				if (hiro[1] & 1):
					strelizia[0] = max(strelizia[0], Zero[darling + 1])
				if (hiro[1] & 2):
					strelizia[1] = max(strelizia[1], Two[darling + 1])
			if (strelizia[0] + strelizia[1] - franxx[ride][0] + franxx[hiro[0]][0] > 0):
				love -= strelizia[0] + strelizia[1] - franxx[ride][0] + franxx[hiro[0]][0]
			hiro[0] = ride
			hiro[1] = 0
	else:
		hiro[1] |= franxx[ride][1]

print(love)","['constructive algorithms', 'greedy']"
1652,"You are preparing for an exam on scheduling theory. The exam will last for exactly T milliseconds and will consist of n problems. You can either solve problem i in exactly ti milliseconds or ignore it and spend no time. You don't need time to rest after solving a problem, either.Unfortunately, your teacher considers some of the problems too easy for you. Thus, he assigned an integer ai to every problem i meaning that the problem i can bring you a point to the final score only in case you have solved no more than ai problems overall (including problem i).Formally, suppose you solve problems p1, p2, ..., pk during the exam. Then, your final score s will be equal to the number of values of j between 1 and k such that k ≤ apj.You have guessed that the real first problem of the exam is already in front of you. Therefore, you want to choose a set of problems to solve during the exam maximizing your final score in advance. Don't forget that the exam is limited in time, and you must have enough time to solve all chosen problems. If there exist different sets of problems leading to the maximum final score, any of them will do. NoteIn the first example, you should solve problems 3, 1, and 4. In this case you'll spend 80 + 100 + 90 = 270 milliseconds, falling within the length of the exam, 300 milliseconds (and even leaving yourself 30 milliseconds to have a rest). Problems 3 and 1 will bring you a point each, while problem 4 won't. You'll score two points.In the second example, the length of the exam is catastrophically not enough to solve even a single problem.In the third example, you have just enough time to solve both problems in 42 + 58 = 100 milliseconds and hand your solutions to the teacher with a smile. from sys import stdin, stdout
from itertools import repeat
def main():
    n, T = map(int, stdin.readline().split())
    dat = map(int, stdin.read().split(), repeat(10, 2 * n))
    a = [(dat[2*i+1], dat[2*i], i + 1) for i in xrange(n)]
    a.sort()
    lo, hi = 0, n + 1
    while lo + 1 < hi:
        mid = (lo + hi) / 2
        k = 0
        c = mid
        for t, x, i in a:
            if not c:
                break
            if x >= mid:
                k += t
                c -= 1
        if not c and k <= T:
            lo = mid
        else:
            hi = mid
    ans = []
    c = lo
    for t, x, i in a:
        if not c:
            break
        if x >= lo:
            ans.append(i)
            c -= 1
    print lo
    print len(ans)
    stdout.write(' '.join(map(str, ans)))
    stdout.write('\n')
main()
","['binary search', 'brute force', 'data structures', 'greedy', 'sortings']"
61,"The History of Magic is perhaps the most boring subject in the Hogwarts school of Witchcraft and Wizardry. Harry Potter is usually asleep during history lessons, and his magical quill writes the lectures for him. Professor Binns, the history of magic teacher, lectures in such a boring and monotonous voice, that he has a soporific effect even on the quill. That's why the quill often makes mistakes, especially in dates.So, at the end of the semester Professor Binns decided to collect the students' parchments with notes and check them. Ron Weasley is in a panic: Harry's notes may contain errors, but at least he has some notes, whereas Ron does not have any. Ronald also has been sleeping during the lectures and his quill had been eaten by his rat Scabbers. Hermione Granger refused to give Ron her notes, because, in her opinion, everyone should learn on their own. Therefore, Ron has no choice but to copy Harry's notes.Due to the quill's errors Harry's dates are absolutely confused: the years of goblin rebellions and other important events for the wizarding world do not follow in order, and sometimes even dates from the future occur. Now Ron wants to change some of the digits while he copies the notes so that the dates were in the chronological (i.e. non-decreasing) order and so that the notes did not have any dates strictly later than 2011, or strictly before than 1000. To make the resulting sequence as close as possible to the one dictated by Professor Binns, Ron will change no more than one digit in each date into other digit. Help him do it. nan import sys

n = int(input())
d = []
for i in range(n):
    d.append(input())
ans = []

bad = 'No solution'
low = 1000
for date in d:
    lowest = 100500
    for i in range(10):
        for j in range(i == 0, 5):
            changed = date[:j] + str(i) + date[j + 1:]
            if lowest > int(changed) >= low:
                lowest = int(changed)
    if lowest > 2011:
        print(bad)
        sys.exit(0)
    ans.append(str(lowest))
    low = lowest

print('\n'.join(ans))","['brute force', 'greedy', 'implementation']"
1566,"Monocarp is playing a strategy game. In the game, he recruits a squad to fight monsters. Before each battle, Monocarp has $$$C$$$ coins to spend on his squad.Before each battle starts, his squad is empty. Monocarp chooses one type of units and recruits no more units of that type than he can recruit with $$$C$$$ coins.There are $$$n$$$ types of units. Every unit type has three parameters:   $$$c_i$$$ — the cost of recruiting one unit of the $$$i$$$-th type;  $$$d_i$$$ — the damage that one unit of the $$$i$$$-th type deals in a second;  $$$h_i$$$ — the amount of health of one unit of the $$$i$$$-th type. Monocarp has to face $$$m$$$ monsters. Every monster has two parameters:   $$$D_j$$$ — the damage that the $$$j$$$-th monster deals in a second;  $$$H_j$$$ — the amount of health the $$$j$$$-th monster has. Monocarp has to fight only the $$$j$$$-th monster during the $$$j$$$-th battle. He wants all his recruited units to stay alive. Both Monocarp's squad and the monster attack continuously (not once per second) and at the same time. Thus, Monocarp wins the battle if and only if his squad kills the monster strictly faster than the monster kills one of his units. The time is compared with no rounding.For each monster, Monocarp wants to know the minimum amount of coins he has to spend to kill that monster. If this amount is greater than $$$C$$$, then report that it's impossible to kill that monster. NoteConsider the first monster of the first example.Monocarp can't recruit one unit of the first type, because it will take both him and the monster $$$0.75$$$ seconds to kill each other. He can recruit two units for the cost of $$$6$$$ coins and kill the monster in $$$0.375$$$ second.Monocarp can recruit one unit of the second type, because he kills the monster in $$$0.6$$$ seconds, and the monster kills him in $$$0.625$$$ seconds. The unit is faster. Thus, $$$5$$$ coins is enough.Monocarp will need at least three units of the third type to kill the first monster, that will cost $$$30$$$ coins.Monocarp will spend the least coins if he chooses the second type of units and recruits one unit of that type. import sys
import os
from io import BytesIO
sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))
input = lambda: sys.stdin.readline().rstrip()

N,C = map(int, input().split())
A = [0]*(C+1)
for _ in range(N):
	c,d,h = map(int, input().split())
	A[c] = max(A[c], h*d)

# 与上面的循环分开，避免有多个c==1的情况
for c in range(C//2,0,-1):
	t = A[c]
	if t>0:
		for i in range(2,C//c+1):
			A[c*i] = max(A[c*i], t*i)

M = int(input())
ans = [-1]*M
B = []
for i in range(M):
	d1,h1 = map(int, input().split())
	B.append((d1*h1,i))
B.sort(reverse=True)

for c in range(1,C+1):
	e = A[c]
	while B and e>B[-1][0]:
		e1,i = B.pop()
		ans[i] = c

print(*ans)


","['binary search', 'brute force', 'greedy', 'math', 'sortings']"
4064,"You are playing a new famous fighting game: Kortal Mombat XII. You have to perform a brutality on your opponent's character.You are playing the game on the new generation console so your gamepad have $$$26$$$ buttons. Each button has a single lowercase Latin letter from 'a' to 'z' written on it. All the letters on buttons are pairwise distinct.You are given a sequence of hits, the $$$i$$$-th hit deals $$$a_i$$$ units of damage to the opponent's character. To perform the $$$i$$$-th hit you have to press the button $$$s_i$$$ on your gamepad. Hits are numbered from $$$1$$$ to $$$n$$$.You know that if you press some button more than $$$k$$$ times in a row then it'll break. You cherish your gamepad and don't want to break any of its buttons.To perform a brutality you have to land some of the hits of the given sequence. You are allowed to skip any of them, however changing the initial order of the sequence is prohibited. The total damage dealt is the sum of $$$a_i$$$ over all $$$i$$$ for the hits which weren't skipped.Note that if you skip the hit then the counter of consecutive presses the button won't reset.Your task is to skip some hits to deal the maximum possible total damage to the opponent's character and not break your gamepad buttons. NoteIn the first example you can choose hits with numbers $$$[1, 3, 4, 5, 6, 7]$$$ with the total damage $$$1 + 16 + 18 + 7 + 2 + 10 = 54$$$.In the second example you can choose all hits so the total damage is $$$2 + 4 + 1 + 3 + 1000 = 1010$$$.In the third example you can choose all hits expect the third one so the total damage is $$$2 + 4 + 3 + 1000 = 1009$$$.In the fourth example you can choose hits with numbers $$$[2, 3, 6, 8]$$$. Only this way you can reach the maximum total damage $$$15 + 2 + 8 + 16 = 41$$$.In the fifth example you can choose only hits with numbers $$$[2, 4, 6]$$$ with the total damage $$$18 + 19 + 15 = 52$$$.In the sixth example you can change either first hit or the second hit (it does not matter) with the total damage $$$10$$$. #from sys import stdin,stdout
#import operator
#from collections import OrderedDict 
#def getKey(item):
#     return item[0]
n,k=map(int,input().strip().split("" ""))
#n,k=map(int,stdin.readline().rstrip().split("" ""))
lst=list(map(int,input().strip().split("" "")))
#lst=list(map(int,stdin.readline().rstrip().split()))
s=input()
#s=stdin.readline()
#l=[0]*n
#for i in range(n):
#    l[i]=[lst[i],s[i]]

#l=sorted(l, key=getKey,reverse=True) 
ss=0
s+=' '
num=[]            
sss=0
i=0
while i<n:
    cnt=0
    sss=0
    if s[i]==s[i+1]:
        for j in range(i,n):
            num.append(lst[j])
            cnt+=1
            sss+=lst[j]
            if s[j]!=s[j+1]:
                break
        i+=cnt
        if cnt<=k:
            ss+=sss
        else:
            num.sort(reverse=True)
            for j in range(k):
                ss+=num[j]
     
        num=[]
    else:
        ss+=lst[i]
        i+=1
        
print(ss)","['greedy', 'sortings', 'two pointers']"
1056,"Unlike Knights of a Round Table, Knights of a Polygonal Table deprived of nobility and happy to kill each other. But each knight has some power and a knight can kill another knight if and only if his power is greater than the power of victim. However, even such a knight will torment his conscience, so he can kill no more than $$$k$$$ other knights. Also, each knight has some number of coins. After a kill, a knight can pick up all victim's coins.Now each knight ponders: how many coins he can have if only he kills other knights?You should answer this question for each knight. NoteConsider the first example.   The first knight is the weakest, so he can't kill anyone. That leaves him with the only coin he initially has.  The second knight can kill the first knight and add his coin to his own two.  The third knight is the strongest, but he can't kill more than $$$k = 2$$$ other knights. It is optimal to kill the second and the fourth knights: $$$2+11+33 = 46$$$.  The fourth knight should kill the first and the second knights: $$$33+1+2 = 36$$$. In the second example the first knight can't kill anyone, while all the others should kill the one with the index less by one than their own.In the third example there is only one knight, so he can't kill anyone. nk, k = [int(x) for x in input().split()]
knights = [int(x) for x in input().split()]
coins = [int(x) for x in input().split()]

data = sorted(zip(knights, coins, range(nk)))
have = [0] * nk
selected = []
for p, c, i in data:
    ans = c + sum(selected)
    have[i] = ans
    selected.append(c)
    selected = sorted(selected, reverse=True)[:k]
print(*have)","['greedy', 'implementation', 'sortings']"
1491,"You are given an integer sequence $$$a_1, a_2, \dots, a_n$$$.Find the number of pairs of indices $$$(l, r)$$$ ($$$1 \le l \le r \le n$$$) such that the value of median of $$$a_l, a_{l+1}, \dots, a_r$$$ is exactly the given number $$$m$$$.The median of a sequence is the value of an element which is in the middle of the sequence after sorting it in non-decreasing order. If the length of the sequence is even, the left of two middle elements is used.For example, if $$$a=[4, 2, 7, 5]$$$ then its median is $$$4$$$ since after sorting the sequence, it will look like $$$[2, 4, 5, 7]$$$ and the left of two middle elements is equal to $$$4$$$. The median of $$$[7, 1, 2, 9, 6]$$$ equals $$$6$$$ since after sorting, the value $$$6$$$ will be in the middle of the sequence.Write a program to find the number of pairs of indices $$$(l, r)$$$ ($$$1 \le l \le r \le n$$$) such that the value of median of $$$a_l, a_{l+1}, \dots, a_r$$$ is exactly the given number $$$m$$$. NoteIn the first example, the suitable pairs of indices are: $$$(1, 3)$$$, $$$(1, 4)$$$, $$$(1, 5)$$$, $$$(2, 2)$$$, $$$(2, 3)$$$, $$$(2, 5)$$$, $$$(4, 5)$$$ and $$$(5, 5)$$$. def ask(x):
    s={}
    s[0]=1
    sum,cnt,res=0,0,0
    for i in range(n):
        if(a[i]<x):
            sum-=1
            cnt-=s.get(sum,0)
        else:
            cnt+=s.get(sum,0)
            sum+=1
        s[sum]=s.get(sum,0)+1
        res+=cnt
    return res

n,m=map(int,input().split())
a=list(map(int,input().split()))
print(ask(m)-ask(m+1))










",['sortings']
501,"A team of furry rescue rangers was sitting idle in their hollow tree when suddenly they received a signal of distress. In a few moments they were ready, and the dirigible of the rescue chipmunks hit the road.We assume that the action takes place on a Cartesian plane. The headquarters of the rescuers is located at point (x1, y1), and the distress signal came from the point (x2, y2).Due to Gadget's engineering talent, the rescuers' dirigible can instantly change its current velocity and direction of movement at any moment and as many times as needed. The only limitation is: the speed of the aircraft relative to the air can not exceed  meters per second.Of course, Gadget is a true rescuer and wants to reach the destination as soon as possible. The matter is complicated by the fact that the wind is blowing in the air and it affects the movement of the dirigible. According to the weather forecast, the wind will be defined by the vector (vx, vy) for the nearest t seconds, and then will change to (wx, wy). These vectors give both the direction and velocity of the wind. Formally, if a dirigible is located at the point (x, y), while its own velocity relative to the air is equal to zero and the wind (ux, uy) is blowing, then after  seconds the new position of the dirigible will be .Gadget is busy piloting the aircraft, so she asked Chip to calculate how long will it take them to reach the destination if they fly optimally. He coped with the task easily, but Dale is convinced that Chip has given the random value, aiming only not to lose the face in front of Gadget. Dale has asked you to find the right answer.It is guaranteed that the speed of the wind at any moment of time is strictly less than the maximum possible speed of the airship relative to the air. nan x,y,xx,yy=map(float,raw_input().split())
v,t=map(float,raw_input().split())
vx,vy=map(float,raw_input().split())
ux,uy=map(float,raw_input().split())
X=x+vx*t
Y=y+vy*t
ans=0
if (X-xx)*(X-xx)+(Y-yy)*(Y-yy)>v*t*v*t:
    ans=t
    x=X
    y=Y
else:
    t=0
    ux=vx
    uy=vy
l=0.0
r=float(pow(10,20))
while r-l>pow(0.1,7):
    m=(l+r)*0.5
    X=x+ux*m
    Y=y+uy*m
    if (X-xx)*(X-xx)+(Y-yy)*(Y-yy)>v*v*(m+t)*(m+t):
        l=m
    else:
        r=m
print round(ans+l,7)
","['binary search', 'geometry', 'math']"
3871,"There are $$$n$$$ cats in a line, labeled from $$$1$$$ to $$$n$$$, with the $$$i$$$-th cat at position $$$i$$$. They are bored of gyrating in the same spot all day, so they want to reorder themselves such that no cat is in the same place as before. They are also lazy, so they want to minimize the total distance they move. Help them decide what cat should be at each location after the reordering.For example, if there are $$$3$$$ cats, this is a valid reordering: $$$[3, 1, 2]$$$. No cat is in its original position. The total distance the cats move is $$$1 + 1 + 2 = 4$$$ as cat $$$1$$$ moves one place to the right, cat $$$2$$$ moves one place to the right, and cat $$$3$$$ moves two places to the left. NoteFor the first test case, there is only one possible permutation that satisfies the conditions: $$$[2, 1]$$$.The second test case was described in the statement. Another possible answer is $$$[2, 3, 1]$$$. for i in range(int(input())):
    n=int(input())
    lst=[]
    if n%2==0:
        for i in range(1,n+1,+2):
            lst.append(i+1)
            lst.append(i)
    else:
        lst.append(3)
        lst.append(1)
        lst.append(2)
        for i in range(3,n,+2):
            lst.append(i+2)
            lst.append(i+1)
    for ele in lst:
        print(ele, end="" "")
    print()
		
  	  	 	 		 	 		 	     		 	  		","['constructive algorithms', 'greedy', 'implementation']"
1774,"And while Mishka is enjoying her trip...Chris is a little brown bear. No one knows, where and when he met Mishka, but for a long time they are together (excluding her current trip). However, best friends are important too. John is Chris' best friend.Once walking with his friend, John gave Chris the following problem:At the infinite horizontal road of width w, bounded by lines y = 0 and y = w, there is a bus moving, presented as a convex polygon of n vertices. The bus moves continuously with a constant speed of v in a straight Ox line in direction of decreasing x coordinates, thus in time only x coordinates of its points are changing. Formally, after time t each of x coordinates of its points will be decreased by vt.There is a pedestrian in the point (0, 0), who can move only by a vertical pedestrian crossing, presented as a segment connecting points (0, 0) and (0, w) with any speed not exceeding u. Thus the pedestrian can move only in a straight line Oy in any direction with any speed not exceeding u and not leaving the road borders. The pedestrian can instantly change his speed, thus, for example, he can stop instantly.Please look at the sample note picture for better understanding.We consider the pedestrian is hit by the bus, if at any moment the point he is located in lies strictly inside the bus polygon (this means that if the point lies on the polygon vertex or on its edge, the pedestrian is not hit by the bus).You are given the bus position at the moment 0. Please help Chris determine minimum amount of time the pedestrian needs to cross the road and reach the point (0, w) and not to be hit by the bus. NoteFollowing image describes initial position in the first sample case: n,w,v,u = map(int,raw_input().split(' '))
later = []
flag = True
for i in range(n):
    p = map(int,raw_input().split(' '))
    if p[0] >= 0:
        reach = p[0]/float(v)
        if p[1] > u*reach:
            flag = False
        if p[1] <= u*reach:
            later.append((reach,p[1]))
    if p[0] < 0:
        flag = False
later.sort(key=lambda x:x[1])

if flag:
    print w/float(u)
else:
    current_t = 0
    current_p = 0
    for t,p in later:
        if (t-current_t)*u > (p-current_p):
            current_p = p
            current_t = t
    print current_t + (w-current_p)/float(u)
","['geometry', 'implementation']"
4052,"A progress bar is an element of graphical interface that displays the progress of a process for this very moment before it is completed. Let's take a look at the following form of such a bar.A bar is represented as n squares, located in line. To add clarity, let's number them with positive integers from 1 to n from the left to the right. Each square has saturation (ai for the i-th square), which is measured by an integer from 0 to k. When the bar for some i (1 ≤ i ≤ n) is displayed, squares 1, 2, ... , i - 1 has the saturation k, squares i + 1, i + 2, ... , n has the saturation 0, and the saturation of the square i can have any value from 0 to k.So some first squares of the progress bar always have the saturation k. Some last squares always have the saturation 0. And there is no more than one square that has the saturation different from 0 and k.The degree of the process's completion is measured in percents. Let the process be t% completed. Then the following inequation is fulfilled: An example of such a bar can be seen on the picture.  For the given n, k, t determine the measures of saturation for all the squares ai of the progress bar. nan arr = [int(x) for x in raw_input().split()]
n, k, t = arr

s = t * n * k / 100

for i in range(n):
    w = min(s, k)
    print(w)
    s -= w
","['implementation', 'math']"
322,"There are $$$n$$$ points and $$$m$$$ segments on the coordinate line. The initial coordinate of the $$$i$$$-th point is $$$a_i$$$. The endpoints of the $$$j$$$-th segment are $$$l_j$$$ and $$$r_j$$$ — left and right endpoints, respectively.You can move the points. In one move you can move any point from its current coordinate $$$x$$$ to the coordinate $$$x - 1$$$ or the coordinate $$$x + 1$$$. The cost of this move is $$$1$$$.You should move the points in such a way that each segment is visited by at least one point. A point visits the segment $$$[l, r]$$$ if there is a moment when its coordinate was on the segment $$$[l, r]$$$ (including endpoints).You should find the minimal possible total cost of all moves such that all segments are visited. NoteIn the first test case the points can be moved as follows:  Move the second point from the coordinate $$$6$$$ to the coordinate $$$5$$$.  Move the third point from the coordinate $$$14$$$ to the coordinate $$$13$$$.  Move the fourth point from the coordinate $$$18$$$ to the coordinate $$$17$$$.  Move the third point from the coordinate $$$13$$$ to the coordinate $$$12$$$.  Move the fourth point from the coordinate $$$17$$$ to the coordinate $$$16$$$. The total cost of moves is $$$5$$$. It is easy to see, that all segments are visited by these movements. For example, the tenth segment ($$$[7, 13]$$$) is visited after the second move by the third point.Here is the image that describes the first test case:   import sys
import os
from io import BytesIO

if sys.version_info[0] < 3:
    sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))

f = sys.stdin
if os.environ.get('USER') == ""loic"":
    f = open(""data.in"")

line = lambda: f.readline().strip('\r\n').split()

def write(w):
    sys.stdout.write(w)
    sys.stdout.write(""\n"")

def solve():
    tmp = sorted(R, key=lambda e: (e[1],-e[0]))
    pts = sorted(A)
    
    dist_l = [[] for _ in range(N)]
    dist_r = [[0] for _ in range(N)]
    
    j = 0
    ref_l = float('-inf')
    pts.append(float('inf'))
    for i in range(N+1):
        pt = pts[i]
        while j < len(tmp):
            l,r = tmp[j]
            if pt < l:
                break
            if l > ref_l and pt > r:
                if i < N:
                    dist_l[i].append(pt - r)
                if i > 0:
                    dist_r[i-1].append(l - pts[i-1])
                ref_l = l
            j += 1
        if i < N:
            dist_l[i].append(0)
    pts.pop()

    dp = [[float('inf') for _ in range(2)] for _ in range(N)]
    for j in range(len(dist_r[0])):
        dp[0][0] = min(dp[0][0], 2 * dist_l[0][0])
        dp[0][1] = min(dp[0][0], dist_l[0][0])
    
    for i in range(1,N):
        pt = pts[i]
        
        for j in range(len(dist_r[i-1])):
            r = dist_r[i-1][j]
            l = dist_l[i][j]
            left = dp[i-1][0] + r + 2*l
            right = dp[i-1][1] + 2*r + 2*l
            dp[i][0] = min(dp[i][0], min(left, right))
            left = dp[i-1][0] + r + l
            right = dp[i-1][1] + 2*r + l
            dp[i][1] = min(dp[i][1], min(left, right))
    
    res = float('inf')
    for j in range(len(dist_r[-1])):
        res = min(res, dp[N-1][0] + dist_r[-1][-1])
        res = min(res, dp[N-1][1] + 2 * dist_r[-1][-1])
    
    return str(res)


T = int(line()[0])
for test in range(1,T+1):
    N,M = map(int,line())
    A = list(map(int,line()))
    R = []
    for _ in range(M):
        a,b = map(int,line())
        R.append((a,b))
    
    write(solve())
    
f.close()","['data structures', 'dp', 'greedy', 'implementation', 'sortings']"
4730,"While Farmer John rebuilds his farm in an unfamiliar portion of Bovinia, Bessie is out trying some alternative jobs. In her new gig as a reporter, Bessie needs to know about programming competition results as quickly as possible. When she covers the 2016 Robot Rap Battle Tournament, she notices that all of the robots operate under deterministic algorithms. In particular, robot i will beat robot j if and only if robot i has a higher skill level than robot j. And if robot i beats robot j and robot j beats robot k, then robot i will beat robot k. Since rapping is such a subtle art, two robots can never have the same skill level.Given the results of the rap battles in the order in which they were played, determine the minimum number of first rap battles that needed to take place before Bessie could order all of the robots by skill level. NoteIn the first sample, the robots from strongest to weakest must be (4, 2, 1, 3), which Bessie can deduce after knowing the results of the first four rap battles.In the second sample, both (1, 3, 2) and (3, 1, 2) are possible orderings of the robots from strongest to weakest after both rap battles. def g(k):
    p = [[] for i in range(n)]
    d = [0] * n
    for x, y in t[:k]:
        p[x].append(y)
        d[y] += 1
    x = 0
    for y in range(n):
        if d[y] == 0:
            if x: return 0
            x = y
    while x:
        q, x = p[x], 0
        for y in q:
            d[y] -= 1
            if d[y] == 0:
                if x: return 0
                x = y
    return 1
f = lambda: map(int, input().split())
n, m = f()
t = [tuple(f()) for i in range(m)]
n += 1
m += 1
l, r = 1, m
while l < r:
    s = l + r >> 1
    if g(s): r = s
    else: l = s + 1
print(-1 if r == m else l)","['binary search', 'dp', 'graphs']"
931,"Andrew, Fedor and Alex are inventive guys. Now they invent the game with strings for two players.Given a group of n non-empty strings. During the game two players build the word together, initially the word is empty. The players move in turns. On his step player must add a single letter in the end of the word, the resulting word must be prefix of at least one string from the group. A player loses if he cannot move.Andrew and Alex decided to play this game k times. The player who is the loser of the i-th game makes the first move in the (i + 1)-th game. Guys decided that the winner of all games is the player who wins the last (k-th) game. Andrew and Alex already started the game. Fedor wants to know who wins the game if both players will play optimally. Help him. nan N = 100000
Z = 26

#别用这玩意儿: trie = [[0] * Z] * N 巨坑！https://www.cnblogs.com/PyLearn/p/7795552.html

trie = [[0 for i in range(Z)] for j in range(N)]
n = 0
k = 0
nodeNum = 0

def insertNode():
	u = 0
	string = input()
	global nodeNum
	
	for i in range(len(string)):
		c = ord(string[i]) - ord('a')
		if trie[u][c] == 0:
			nodeNum += 1
			trie[u][c] = nodeNum	
		u = trie[u][c]
		# print(u)
	
stateWin = [False for i in range(N)]	
stateLose = [False for i in range(N)]	
	
def dfs(u):
	leaf = True
	for c in range(Z):
		if (trie[u][c]) != 0:
			leaf = False
			dfs(trie[u][c])
			stateWin[u] |= (not(stateWin[trie[u][c]]))
			stateLose[u] |= (not(stateLose[trie[u][c]]))
	if leaf == True:
		stateWin[u] = False
		stateLose[u] = True

n,k = map(int,input().split())

for i in range(n):
	insertNode()

dfs(0)


# print(stateWin[0])
# print(stateLose[0])

if (stateWin[0] and (stateLose[0] or (k % 2 == 1) )):
	print(""First"")
else:
	print(""Second"")","['dfs and similar', 'dp', 'games', 'implementation', 'strings', 'trees']"
653,"Valera has 2·n cubes, each cube contains an integer from 10 to 99. He arbitrarily chooses n cubes and puts them in the first heap. The remaining cubes form the second heap. Valera decided to play with cubes. During the game he takes a cube from the first heap and writes down the number it has. Then he takes a cube from the second heap and write out its two digits near two digits he had written (to the right of them). In the end he obtained a single fourdigit integer — the first two digits of it is written on the cube from the first heap, and the second two digits of it is written on the second cube from the second heap.Valera knows arithmetic very well. So, he can easily count the number of distinct fourdigit numbers he can get in the game. The other question is: how to split cubes into two heaps so that this number (the number of distinct fourdigit integers Valera can get) will be as large as possible? NoteIn the first test case Valera can put the first cube in the first heap, and second cube — in second heap. In this case he obtain number 1099. If he put the second cube in the first heap, and the first cube in the second heap, then he can obtain number 9910. In both cases the maximum number of distinct integers is equal to one.In the second test case Valera can obtain numbers 1313, 1345, 2413, 2445. Note, that if he put the first and the third cubes in the first heap, he can obtain only two numbers 1324 and 1345. from math import*
from random import*

n = int(input()) * 2
A = list(map(int, input().split()))
amount = [0] * 101

B = []
for i in range(n):
    if amount[A[i]] < 2:
        amount[A[i]] += 1
        B += [(A[i], i)]
B.sort()
x, y = [], []
for i in range(len(B)):
    if(i % 2 == 0):
        x.append(B[i][1])
    else:
        y.append(B[i][1])
lolka = 0
aaa = 0
# print(x)
# print(y)
print(len(x) * len(y))
for i in range(n):
    if i in x:
        lolka += 1
        aaa += 1
        print(1, end = ' ')
    elif i in y:
        print(2, end = ' ')
    else:
        if len(x) - lolka + aaa < n // 2:
            print(1, end = ' ')
            aaa += 1
        else:
            print(2, end = ' ')
print()

# B, C = [], []
# for i in range(n):


# S = list(set(A))
# where = [0] * 101
# am1, am2 = 0, 0
# for i in range(len(S)):
#     if(i % 2 == 0):
#         where[S[i]] = 1
#         am1 += 1
#     else:
#         where[S[i]] = 2
#         am2 += 1
# used = [0] * 201
# for i in range(n):
#     if not used[A[i]]:
#         print(where[A[i]])
#         used[A[i]] = True
#     else:
#         print(3 - where[A[i]])","['combinatorics', 'constructive algorithms', 'greedy', 'implementation', 'math', 'sortings']"
4530,"In a galaxy far, far away Lesha the student has just got to know that he has an exam in two days. As always, he hasn't attended any single class during the previous year, so he decided to spend the remaining time wisely.Lesha knows that today he can study for at most $$$a$$$ hours, and he will have $$$b$$$ hours to study tomorrow. Note that it is possible that on his planet there are more hours in a day than on Earth. Lesha knows that the quality of his knowledge will only depend on the number of lecture notes he will read. He has access to an infinite number of notes that are enumerated with positive integers, but he knows that he can read the first note in one hour, the second note in two hours and so on. In other words, Lesha can read the note with number $$$k$$$ in $$$k$$$ hours. Lesha can read the notes in arbitrary order, however, he can't start reading a note in the first day and finish its reading in the second day.Thus, the student has to fully read several lecture notes today, spending at most $$$a$$$ hours in total, and fully read several lecture notes tomorrow, spending at most $$$b$$$ hours in total. What is the maximum number of notes Lesha can read in the remaining time? Which notes should he read in the first day, and which — in the second? NoteIn the first example Lesha can read the third note in $$$3$$$ hours in the first day, and the first and the second notes in one and two hours correspondingly in the second day, spending $$$3$$$ hours as well. Note that Lesha can make it the other way round, reading the first and the second notes in the first day and the third note in the second day.In the second example Lesha should read the third and the sixth notes in the first day, spending $$$9$$$ hours in total. In the second day Lesha should read the first, second fourth and fifth notes, spending $$$12$$$ hours in total. 


def check():
    a, b = [int(s) for s in input().split()]
    a1 = min(a, b)
    b1 = max(a, b)
    sum0=0
    i=0
    while(sum0<=a1):
        i += 1
        sum0+=i

    ax=i-1
    sum1=sum0-i
    r=a1-sum1
    if(r==0):
        sum0 = 0
        i = i - 1

        while (sum0 <= b1):
            i += 1
            sum0 += i
        sum2 = sum0 - i
        ay = i - 1
        if(a<=b):
            print(ax)
            for i in range(1,ax+1):
                print(i,end="" "")
                if(i==ax):
                    print()
            if (ax == 0): print( )
            print(ay-ax)
            for j in range(ax+1,ay+1):
                print(j,end="" "")
                if(j==ay): print()
            if (ay - ax == 0): print( )
        else:
            print(ay - ax)
            for j in range(ax + 1, ay + 1):
                print(j, end="" "")
                if(j==ay):
                    print()
            if (ay - ax == 0): print( )
            print(ax)
            for i in range(1,ax+1):
                print(i, end="" "")
                if(i==ax):print()

            if (ax == 0): print( )



    else:
        c=ax+1-r
        sum0=0
        i=ax+1
        b1=b1-c
        while(sum0<=b1):

            i += 1
            sum0+=i
        ay = i - 1
        if a<=b :
            print(ax)
            for i in range(1,ax+2):
                if i==c:
                    continue
                print(i,end="" "")
                if(i==ax+1):print()
            if(ax==0): print( )

            print(ay-ax)
            print(c,end="" "")
            for j in range(ax+2,ay+1):
                print(j,end="" "")
                if(j==ay): print()
            if(ay-ax==0): print( )
        else:

            print(ay - ax)
            print(c, end="" "")
            for j in range(ax + 2, ay + 1):
                print(j, end="" "")
                if(j==ay):print()
            if(ay-ax==0): print( )
            print(ax)

            for i in range(1, ax + 2):
                if i == c:
                    continue
                print(i, end="" "")
                if(i==ax+1): print()
            if(ax==0): print( )


check()","['greedy', 'math']"
3698,"YouKn0wWho has two even integers $$$x$$$ and $$$y$$$. Help him to find an integer $$$n$$$ such that $$$1 \le n \le 2 \cdot 10^{18}$$$ and $$$n \bmod x = y \bmod n$$$. Here, $$$a \bmod b$$$ denotes the remainder of $$$a$$$ after division by $$$b$$$. If there are multiple such integers, output any. It can be shown that such an integer always exists under the given constraints. NoteIn the first test case, $$$4 \bmod 4 = 8 \bmod 4 = 0$$$.In the second test case, $$$10 \bmod 4 = 2 \bmod 10 = 2$$$.In the third test case, $$$420 \bmod 420 = 420 \bmod 420 = 0$$$. import os
import sys
from io import BytesIO, IOBase
 
BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
from collections import defaultdict,deque
from math import ceil,floor,sqrt,log2,gcd,pi
from heapq import heappush,heappop
from bisect import bisect_left,bisect
from functools import reduce
from copy import deepcopy
from itertools import permutations
# from itertools import zip
import sys
abc='abcdefghijklmnopqrstuvwxyz'
ABC=""ABCDEFGHIJKLMNOPQRSTUVWXYZ""

for _ in range(int(input())):
    a,b=map(int,input().split())
    if a>b:
        print(a+b)
    else:
        print(b-((b%a)//2))
            
    ","['math', 'number theory']"
2478,"Let's call an array consisting of n integer numbers a1, a2, ..., an, beautiful if it has the following property:  consider all pairs of numbers x, y (x ≠ y), such that number x occurs in the array a and number y occurs in the array a;  for each pair x, y must exist some position j (1 ≤ j &lt; n), such that at least one of the two conditions are met, either aj = x, aj + 1 = y, or aj = y, aj + 1 = x. Sereja wants to build a beautiful array a, consisting of n integers. But not everything is so easy, Sereja's friend Dima has m coupons, each contains two integers qi, wi. Coupon i costs wi and allows you to use as many numbers qi as you want when constructing the array a. Values qi are distinct. Sereja has no coupons, so Dima and Sereja have made the following deal. Dima builds some beautiful array a of n elements. After that he takes wi rubles from Sereja for each qi, which occurs in the array a. Sereja believed his friend and agreed to the contract, and now he is wondering, what is the maximum amount of money he can pay.Help Sereja, find the maximum amount of money he can pay to Dima. NoteIn the first sample Sereja can pay 5 rubles, for example, if Dima constructs the following array: [1, 2, 1, 2, 2]. There are another optimal arrays for this test.In the third sample Sereja can pay 100 rubles, if Dima constructs the following array: [2]. #!/usr/bin/env python
n, m = map(int, raw_input().split())
w = []
for _ in range(m):
	_, wi = map(int, raw_input().split())
	w.append(wi)

def calc(size, r):
	l = 1

	while l+1 < r:
		v = (l + r) / 2
		edges = v * (v-1) / 2
		if v % 2 == 0:
			edges += v / 2 - 1
		if edges < size:
			l = v
		else:
			r = v
	return l

v = calc(n, m+1)
#print v

print sum(sorted(w)[::-1][:v])","['combinatorics', 'graphs', 'implementation']"
472,"A tree is a connected undirected graph without cycles. Note that in this problem, we are talking about not rooted trees.You are given four positive integers $$$n, d_{12}, d_{23}$$$ and $$$d_{31}$$$. Construct a tree such that:  it contains $$$n$$$ vertices numbered from $$$1$$$ to $$$n$$$,  the distance (length of the shortest path) from vertex $$$1$$$ to vertex $$$2$$$ is $$$d_{12}$$$,  distance from vertex $$$2$$$ to vertex $$$3$$$ is $$$d_{23}$$$,  the distance from vertex $$$3$$$ to vertex $$$1$$$ is $$$d_{31}$$$. Output any tree that satisfies all the requirements above, or determine that no such tree exists. nan t=int(input())
for i in range(t):
    n,a,b,c=[int(x) for x in input().split()]
    l=[1]
    l2=[]
    x=4
    check=True
    '''for i in range(a-1):
        l.append(x)
        x+=1
    l.append(2)'''
    if c+b==a and n>a:
        '''l.pop(-2)
        x-=1
        l.insert(c,3)'''
        a1=1
        a2=x
        print('YES')
        for i in range(a):
            if c==i+1:
                a2=3
                if x > 4 or i == 0:
                    x -= 1
            elif a==i+1:
                a2=2
                z=2
            print(a1,a2)
            if a1==n or a2==n:
                check=False
            x += 1
            a1=a2
            a2=x
        x-=1
    elif a + c == b and n>b:
        '''for i in range(c - 1):
            l.insert(0, x)
            x += 1
        l.insert(0, 3)'''
        print('YES')
        a1=3
        a2=x
        for i in range(b):
            if c==i+1:
                a2=1
                if x > 4 or i == 0:
                    x -= 1
            elif b==i+1:
                a2=2
                z=2
            print(a1,a2)
            if a1==n or a2==n:
                check=False
            x += 1
            a1=a2
            a2=x
        x-=1
    elif a + b == c and n>c:
        '''for i in range(b - 1):
            l.append(x)
            x += 1
        l.append(3)'''
        print('YES')
        a1=1
        a2=x
        for i in range(c):
            if a==i+1:
                a2=2
                if x>4 or i==0:
                    x-=1
            elif c==i+1:
                a2=3
                z=3
            print(a1,a2)
            if a1==n or a2==n:
                check=False
            x+=1
            a1=a2
            a2=x
        x-=1
    else:
        if (c - b + a) % 2 == 0 and c - b + a > 0 and c+b-a>0 and a+b-c>0 and n>(int((c+b-a)/2)+a):
            '''l2.append(l[int((c - b + a) / 2)])
            while (c + b - a) / 2 - 1 != 0:
                l2.append(x)
                x += 1
            l2.append(3)'''
            print('YES')
            a1=1
            a2=x
            index=2
            for i in range(a):
                if a==i+1:
                    a2=2
                    z=2
                    if x>4:
                        x-=1
                elif int((c-b+a)/2)==i+1:
                    index=a2
                print(a1,a2)
                if a1 == n or a2 == n:
                    check = False
                x+=1
                a1=a2
                a2=x
            a1=index
            a2=x
            for i in range(int((c+b-a)/2)):
                if int((c+b-a)/2)==i+1:
                    a2=3
                print(a1,a2)
                if a1 == n or a2 == n:
                    check = False
                x+=1
                a1=a2
                a2=x
            x-=1
        else:
            print('NO')
            continue

    '''if x - 1 > n:
        print(x)
        print('NO')
        continue
    else:
        print('YES')
    for i in range(len(l) - 1):
        print(l[i], l[i + 1])
    for i in range(len(l2) - 1):
        print(l2[i], l2[i + 1])
    z = l[-1]'''
    if check:
        while x <=n:
            print(z,x)
            z = x
            x += 1","['constructive algorithms', 'implementation', 'trees']"
4812,"You are given a permutation $$$p$$$ of integers from $$$0$$$ to $$$n-1$$$ (each of them occurs exactly once). Initially, the permutation is not sorted (that is, $$$p_i&gt;p_{i+1}$$$ for at least one $$$1 \le i \le n - 1$$$). The permutation is called $$$X$$$-sortable for some non-negative integer $$$X$$$ if it is possible to sort the permutation by performing the operation below some finite number of times:   Choose two indices $$$i$$$ and $$$j$$$ $$$(1 \le i \lt j \le n)$$$ such that $$$p_i \&amp; p_j = X$$$.  Swap $$$p_i$$$ and $$$p_j$$$. Here $$$\&amp;$$$ denotes the bitwise AND operation.Find the maximum value of $$$X$$$ such that $$$p$$$ is $$$X$$$-sortable. It can be shown that there always exists some value of $$$X$$$ such that $$$p$$$ is $$$X$$$-sortable. NoteIn the first test case, the only $$$X$$$ for which the permutation is $$$X$$$-sortable are $$$X = 0$$$ and $$$X = 2$$$, maximum of which is $$$2$$$.Sorting using $$$X = 0$$$:   Swap $$$p_1$$$ and $$$p_4$$$, $$$p = [2, 1, 3, 0]$$$.  Swap $$$p_3$$$ and $$$p_4$$$, $$$p = [2, 1, 0, 3]$$$.  Swap $$$p_1$$$ and $$$p_3$$$, $$$p = [0, 1, 2, 3]$$$. Sorting using $$$X = 2$$$:   Swap $$$p_3$$$ and $$$p_4$$$, $$$p = [0, 1, 2, 3]$$$. In the second test case, we must swap $$$p_1$$$ and $$$p_2$$$ which is possible only with $$$X = 0$$$. for _ in range(int(input())):
    n = int(input())-1

    ms = []
    for i, el in enumerate(map(int, input().split())):
        if i != el:
            ms.append(el)
    ans = ms[0]
    for x in ms:
        ans &= x
    print(ans)


","['bitmasks', 'constructive algorithms', 'sortings']"
2307,"You work in a big office. It is a 9 floor building with an elevator that can accommodate up to 4 people. It is your responsibility to manage this elevator.Today you are late, so there are queues on some floors already. For each person you know the floor where he currently is and the floor he wants to reach. Also, you know the order in which people came to the elevator.According to the company's rules, if an employee comes to the elevator earlier than another one, he has to enter the elevator earlier too (even if these employees stay on different floors). Note that the employees are allowed to leave the elevator in arbitrary order.The elevator has two commands:   Go up or down one floor. The movement takes 1 second.  Open the doors on the current floor. During this operation all the employees who have reached their destination get out of the elevator. Then all the employees on the floor get in the elevator in the order they are queued up while it doesn't contradict the company's rules and there is enough space in the elevator. Each employee spends 1 second to get inside and outside the elevator. Initially the elevator is empty and is located on the floor 1.You are interested what is the minimum possible time you need to spend to deliver all the employees to their destination. It is not necessary to return the elevator to the floor 1. Note Explaination for the first sample  t = 0 t = 2 t = 3 t = 5 t = 6 t = 7 t = 9 t = 10 # python3
import sys
from collections import namedtuple


def readline(): return map(int, input().split())


def readlines():
    for line in sys.stdin.readlines():
        yield map(int, line.split())


class State(namedtuple('State', 'payload time floor')):
    def hook(self, pivot, a, b):
        lo, up = min(pivot, a, self.floor), max(pivot, a, self.floor)
        return tuple(x for x in self.payload if x < lo or up < x) + (b,), \
            self.time + abs(self.floor - pivot) + abs(pivot - a)

    def choices_to_take_next(self, a, b):
        floor = self.floor

        payload, time = self.hook(floor, a, b)
        if len(payload) < 5:
            yield payload, time
            if floor > a:
                pivots = (x for x in self.payload if x > floor)
            elif floor == a:
                pivots = ()
            else:
                pivots = (x for x in self.payload if x < floor)
        else:
            pivots = self.payload

        for pivot in pivots:
            yield self.hook(pivot, a, b)


def time_to_get_free(payload, floor):
    if payload:
        lo, up = min(payload), max(payload)
        return abs(lo-up) + min(abs(floor-lo), abs(floor-up))
    else:
        return 0


def main():
    n, = readline()

    floor = 1
    positions = {(): 0}  # empty elevator, time = 0
    for (a, b) in readlines():
        max_acceptable_time = min(positions.values()) + 16 - abs(floor - a)

        new_positions = dict()
        for payload, time in positions.items():
            state = State(payload, time, floor)
            for npayload, ntime in state.choices_to_take_next(a, b):
                if ntime <= max_acceptable_time:
                    npayload = tuple(sorted(npayload))
                    if new_positions.setdefault(npayload, ntime) > ntime:
                        new_positions[npayload] = ntime

        positions = new_positions
        floor = a

    return min(t + time_to_get_free(p, floor) for p, t in positions.items()) \
        + 2 * n


print(main())
","['dp', 'graphs', 'shortest paths']"
4056,"The Little Elephant has array a, consisting of n positive integers, indexed from 1 to n. Let's denote the number with index i as ai.The Little Elephant wants to count, how many pairs of integers l and r are there, such that 1 ≤ l &lt; r ≤ n and sequence b = a1a2... alarar + 1... an has no more than k inversions. An inversion in sequence b is a pair of elements of the sequence b, that change their relative order after a stable sorting of the sequence. In other words, an inversion is a pair of integers i and j, such that 1 ≤ i &lt; j ≤ |b| and bi &gt; bj, where |b| is the length of sequence b, and bj is its j-th element.Help the Little Elephant and count the number of the described pairs. nan # 220E
import sys
from collections import defaultdict
 
class BIT():
    def __init__(self, n):
        self.n = n
        self.tree = [0] * n
    
    def _F(self, i):
        return i & (i + 1)
    
    def _get_sum(self, r):
        '''
        sum on interval [0, r)
        '''
        result = 0
        while r > 0:
            result += self.tree[r-1]
            r = self._F(r-1)
        return result
    
    def get_sum(self, l, r):
        '''
        sum on interval [l, r)
        '''
        return self._get_sum(r) - self._get_sum(l)
    
    def _H(self, i):
        return i | (i + 1)
    
    def add(self, i, value=1):
        while i < self.n:
            self.tree[i] += value
            i = self._H(i)

reader = (line.rstrip() for line in sys.stdin)
input = reader.__next__

n, k = map(int, input().split())
a = list(map(int, input().split()))

pos = defaultdict(list)
for i, val in enumerate(a):
    pos[val].append(i)

i = 0
prev = -1
for val in sorted(a):
    if prev == val: continue
    for j in pos[val]:
        a[j] = i
    i += 1
    prev = val

left = BIT(n)
right = BIT(n)
total_inv = 0

left.add(a[0])
for t in range(1, n):
    i = a[t]
    total_inv += right.get_sum(i+1, n)
    right.add(i)
    if i < a[0]:
        total_inv += 1

if total_inv <= k:
    print((n*(n-1))>>1)
    sys.exit()

l = 0
r = 1
while r < n and total_inv > k:
    total_inv -= left.get_sum(a[r]+1, n) + right.get_sum(0, a[r])
    right.add(a[r], -1)
    r += 1

pairs = 0
while r < n:
    while True:
        add = left.get_sum(a[l+1]+1, n) + right.get_sum(0, a[l+1])
        if total_inv + add > k:
            pairs += l + 1
            break
        else:
            l += 1
            total_inv += add
            left.add(a[l])
    total_inv -= left.get_sum(a[r]+1, n) + right.get_sum(0, a[r])
    right.add(a[r], -1)
    r += 1
print(pairs)
","['data structures', 'two pointers']"
4359,"This problem is different from the hard version. In this version Ujan makes exactly one exchange. You can hack this problem only if you solve both problems.After struggling and failing many times, Ujan decided to try to clean up his house again. He decided to get his strings in order first.Ujan has two distinct strings $$$s$$$ and $$$t$$$ of length $$$n$$$ consisting of only of lowercase English characters. He wants to make them equal. Since Ujan is lazy, he will perform the following operation exactly once: he takes two positions $$$i$$$ and $$$j$$$ ($$$1 \le i,j \le n$$$, the values $$$i$$$ and $$$j$$$ can be equal or different), and swaps the characters $$$s_i$$$ and $$$t_j$$$. Can he succeed?Note that he has to perform this operation exactly once. He has to perform this operation. NoteIn the first test case, Ujan can swap characters $$$s_1$$$ and $$$t_4$$$, obtaining the word ""house"".In the second test case, it is not possible to make the strings equal using exactly one swap of $$$s_i$$$ and $$$t_j$$$. k=int(input())
while(k):
    k-=1
    n=int(input())
    s=input()
    t=input()
    z=set()
    cnt=0
    for i in range(n):
        if(s[i]!=t[i]):
            cnt += 1
            z.add((s[i],t[i]))
    if cnt == 2 and len(z) == 1:
        print('Yes')
    else:
        print('No')",['strings']
3305,"Polycarpus has n markers and m marker caps. Each marker is described by two numbers: xi is the color and yi is the diameter. Correspondingly, each cap is described by two numbers: aj is the color and bj is the diameter. Cap (aj, bj) can close marker (xi, yi) only if their diameters match, that is, bj = yi. Besides, a marker is considered to be beautifully closed, if the cap color and the marker color match, that is, aj = xi.Find the way to close the maximum number of markers. If there are several such ways, then choose the one that has the maximum number of beautifully closed markers. NoteIn the first test sample the first marker should be closed by the fourth cap, the second marker should be closed by the first cap and the third marker should be closed by the second cap. Thus, three markers will be closed, and two of them will be beautifully closed — the first and the third markers. n, m = map(int, raw_input().split())
d = {}
bu = [0] * 1024
bv = bu[:]
for _ in xrange(n):
    a, b = map(int, raw_input().split())
    d[(a, b)] = d.get((a, b), 0) + 1
    bu[b] += 1
y = 0
for _ in xrange(m):
    a, b = map(int, raw_input().split())
    if d.get((a, b), 0) > 0:
        d[(a, b)] -= 1
        y += 1
        bu[b] -= 1
    else:
        bv[b] += 1
x = sum(min(a, b) for a, b in zip(bu, bv))
print x + y, y
","['greedy', 'other', 'sortings']"
3473,"Innovation technologies are on a victorious march around the planet. They integrate into all spheres of human activity!A restaurant called ""Dijkstra's Place"" has started thinking about optimizing the booking system. There are n booking requests received by now. Each request is characterized by two numbers: ci and pi — the size of the group of visitors who will come via this request and the total sum of money they will spend in the restaurant, correspondingly.We know that for each request, all ci people want to sit at the same table and are going to spend the whole evening in the restaurant, from the opening moment at 18:00 to the closing moment.Unfortunately, there only are k tables in the restaurant. For each table, we know ri — the maximum number of people who can sit at it. A table can have only people from the same group sitting at it. If you cannot find a large enough table for the whole group, then all visitors leave and naturally, pay nothing.Your task is: given the tables and the requests, decide which requests to accept and which requests to decline so that the money paid by the happy and full visitors was maximum. nan n=int(raw_input())
a=[[0 for i in range(3)] for i in range(n)]
for i in range(n):
	a[i][1],a[i][0]=map(int,raw_input().split())
	a[i][2]=i
a=sorted(a,key=lambda x: -x[0])
k=int(raw_input())
r=map(int,raw_input().split())
b=[[0 for i in range(2)] for i in range(k)]
for i in range(k):
	b[i][0]=r[i]
	b[i][1]=i
b=sorted(b,key=lambda x: x[0])
c=[]
d=[]
ans=0
y=[0]*(2000)
for i in range(n):
	x=a[i][1]
	for j in range(k):
		if x<=b[j][0] and y[j]==0:
			c.append(b[j][1]+1)
			d.append(a[i][2]+1)
			ans+=a[i][0]
			y[j]=1
			break
print len(c),ans
for i in range(len(c)):
	print d[i],c[i]



","['binary search', 'dp', 'greedy', 'implementation']"
881,"As we all know, Max is the best video game player among her friends. Her friends were so jealous of hers, that they created an actual game just to prove that she's not the best at games. The game is played on a directed acyclic graph (a DAG) with n vertices and m edges. There's a character written on each edge, a lowercase English letter.  Max and Lucas are playing the game. Max goes first, then Lucas, then Max again and so on. Each player has a marble, initially located at some vertex. Each player in his/her turn should move his/her marble along some edge (a player can move the marble from vertex v to vertex u if there's an outgoing edge from v to u). If the player moves his/her marble from vertex v to vertex u, the ""character"" of that round is the character written on the edge from v to u. There's one additional rule; the ASCII code of character of round i should be greater than or equal to the ASCII code of character of round i - 1 (for i &gt; 1). The rounds are numbered for both players together, i. e. Max goes in odd numbers, Lucas goes in even numbers. The player that can't make a move loses the game. The marbles may be at the same vertex at the same time.Since the game could take a while and Lucas and Max have to focus on finding Dart, they don't have time to play. So they asked you, if they both play optimally, who wins the game?You have to determine the winner of the game for all initial positions of the marbles. NoteHere's the graph in the first sample test case:  Here's the graph in the second sample test case:   # int(input())

# [int(i) for i in input().split()]

import sys

sys.setrecursionlimit(20000)

def go(v,w,last):

    if game[v][w][last] >= 0: return(game[v][w][last])



    flag = 0

    move = 0



    for p in edges_out[v]:

        if p[1] >= last:

            move = 1

            if  not go(w,p[0],p[1]):

                flag = 1

                break



    if not move or not flag:

        game[v][w][last] = 0

        return(0)

    else:

        game[v][w][last] = 1

        return(1)

            



n,m = [int(i) for i in input().split()]

edges_in = []

edges_out = []

for i in range(n):

    edges_in.append([])

    edges_out.append([])



for i in range(m):

    s1,s2,s3 = input().split()

    v = int(s1)-1

    w = int(s2)-1

    weight = ord(s3[0]) - ord('a') + 1

    edges_out[v].append((w,weight))

    edges_in[w].append((v,weight))



game = []

for i in range(n):

    tmp1 = []

    for j in range(n):

        tmp2 = []

        for c in range(27):

            tmp2.append(-1)

        tmp1.append(tmp2)

    game.append(tmp1)



##for v in range(n):

##    for w in range(n):

##        for last in range(27):

##            go(v,w,last)



for v in range(n):

    s = ''

    for w in range(n):

        

        if go(v,w,0): s = s + 'A'

        else: s = s + 'B'

    print(s)





# Made By Mostafa_Khaled","['dfs and similar', 'dp', 'games', 'graphs']"
2288,"Zibi is a competitive programming coach. There are $$$n$$$ competitors who want to be prepared well. The training contests are quite unusual – there are two people in a team, two problems, and each competitor will code exactly one of them. Of course, people in one team will code different problems.Rules of scoring also aren't typical. The first problem is always an implementation problem: you have to implement some well-known algorithm very fast and the time of your typing is rated. The second one is an awful geometry task and you just have to get it accepted in reasonable time. Here the length and difficulty of your code are important. After that, Zibi will give some penalty points (possibly negative) for each solution and the final score of the team is the sum of them (the less the score is, the better).We know that the $$$i$$$-th competitor will always have score $$$x_i$$$ when he codes the first task and $$$y_i$$$ when he codes the second task. We can assume, that all competitors know each other's skills and during the contest distribute the problems in the way that minimizes their final score. Remember that each person codes exactly one problem in a contest.Zibi wants all competitors to write a contest with each other. However, there are $$$m$$$ pairs of people who really don't like to cooperate and they definitely won't write a contest together. Still, the coach is going to conduct trainings for all possible pairs of people, such that the people in pair don't hate each other. The coach is interested for each participant, what will be his or her sum of scores of all teams he trained in? NoteIn the first example, there will be only one team consisting of persons $$$1$$$ and $$$3$$$. The optimal strategy for them is to assign the first task to the $$$3$$$-rd person and the second task to the $$$1$$$-st person, this will lead to score equal to $$$1 + 2 = 3$$$.In the second example, nobody likes anyone, so there won't be any trainings. It seems that Zibi won't be titled coach in that case... from sys import stdin
from operator import add
from itertools import repeat

def main():
    n, m = map(int, stdin.readline().split())
    inp = list(map(int, stdin.read().split(), repeat(10, 2*n+2*m)))
    xys = inp[:2*n]
    exc = list(map(add, inp[2*n:], repeat(-1)))

    a = list(range(n))
    a.sort(key=lambda i: xys[2*i] - xys[2*i+1])
    
    xs, ys = 0, sum(xys[1::2])
    res = [0]*n
    for i, idx in enumerate(a):
        x, y = xys[2*idx], xys[2*idx+1]
        ys -= y
        res[idx] = i*y + (n-1-i)*x + xs + ys
        xs += x

    for i in range(m):
        u, v = exc[2*i], exc[2*i+1]
        dif = min(xys[2*u] + xys[2*v+1], xys[2*v] + xys[2*u+1])
        res[u] -= dif
        res[v] -= dif
        
    print(' '.join(map(str,res)))

main()","['constructive algorithms', 'greedy', 'math', 'sortings']"
219,"Yaroslav is playing a game called ""Time"". The game has a timer showing the lifespan he's got left. As soon as the timer shows 0, Yaroslav's character dies and the game ends. Also, the game has n clock stations, station number i is at point (xi, yi) of the plane. As the player visits station number i, he increases the current time on his timer by ai. The stations are for one-time use only, so if the player visits some station another time, the time on his timer won't grow.A player spends d·dist time units to move between stations, where dist is the distance the player has covered and d is some constant. The distance between stations i and j is determined as |xi - xj| + |yi - yj|.Initially, the player is at station number 1, and the player has strictly more than zero and strictly less than one units of time. At station number 1 one unit of money can increase the time on the timer by one time unit (you can buy only integer number of time units).Now Yaroslav is wondering, how much money he needs to get to station n. Help Yaroslav. Consider the time to buy and to increase the timer value negligibly small. nan f = lambda: list(map(int, input().split()))
n, d = f()
a = [0] + f() + [0]
p = [f() for i in range(n)]
r = range(n)
s = [[d * (abs(p[i][0] - p[j][0]) + abs(p[i][1] - p[j][1])) - a[j] * (i != j) for j in r] for i in r]
for k in r: s = [[min(s[i][j], s[i][k] + s[k][j]) for i in r] for j in r]
print(s[-1][0])
","['binary search', 'graphs', 'shortest paths']"
1702,"It's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri &lt; lj or rj &lt; li.Help Leha to choose the necessary vouchers! NoteIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2. from collections import defaultdict

n, x = map (int, raw_input().split())

vouchers=defaultdict(list)

for i in xrange(n):
    l, r, c=map(int, raw_input().split())
    if r-l+1 < x:
        vouchers[r-l+1].append((l, r, c))
    
costo=10**11

for key in vouchers:
	vouchers[key]=sorted(vouchers[key])

for key in xrange (1, x+1):
	minimo=10**11
	k=0
	for voucher in xrange (len (vouchers[key])):
		while k < len (vouchers[x-key]) and vouchers[key][voucher][0] > vouchers[x-key][k][1]:
			minimo=min (minimo, vouchers[x-key][k][2])
			k+=1
		costo=min(costo,minimo+vouchers[key][voucher][2])

if costo==10**11:
	print -1
else:
	print costo","['binary search', 'greedy', 'implementation', 'sortings']"
291,"Demonstrative competitions will be held in the run-up to the $$$20NN$$$ Berlatov Olympic Games. Today is the day for the running competition!Berlatov team consists of $$$2n$$$ runners which are placed on two running tracks; $$$n$$$ runners are placed on each track. The runners are numbered from $$$1$$$ to $$$n$$$ on each track. The runner with number $$$i$$$ runs through the entire track in $$$i$$$ seconds.The competition is held as follows: first runners on both tracks start running at the same time; when the slower of them arrives at the end of the track, second runners on both tracks start running, and everyone waits until the slower of them finishes running, and so on, until all $$$n$$$ pairs run through the track.The organizers want the run to be as long as possible, but if it lasts for more than $$$k$$$ seconds, the crowd will get bored. As the coach of the team, you may choose any order in which the runners are arranged on each track (but you can't change the number of runners on each track or swap runners between different tracks).You have to choose the order of runners on each track so that the duration of the competition is as long as possible, but does not exceed $$$k$$$ seconds.Formally, you want to find two permutations $$$p$$$ and $$$q$$$ (both consisting of $$$n$$$ elements) such that $$$sum = \sum\limits_{i=1}^{n} max(p_i, q_i)$$$ is maximum possible, but does not exceed $$$k$$$. If there is no such pair, report about it. NoteIn the first example the order of runners on the first track should be $$$[5, 3, 2, 1, 4]$$$, and the order of runners on the second track should be $$$[1, 4, 2, 5, 3]$$$. Then the duration of the competition is $$$max(5, 1) + max(3, 4) + max(2, 2) + max(1, 5) + max(4, 3) = 5 + 4 + 2 + 5 + 4 = 20$$$, so it is equal to the maximum allowed duration.In the first example the order of runners on the first track should be $$$[2, 3, 1]$$$, and the order of runners on the second track should be $$$[2, 1, 3]$$$. Then the duration of the competition is $$$8$$$, and it is the maximum possible duration for $$$n = 3$$$. import sys
input = sys.stdin.readline

def sum1n(n):
    return (n*(n+1))//2
def count_max(n):
    k1 = n//2
    k2 = n - k1
    return 2*sum1n(n) - sum1n(k1) - sum1n(k2)
    
n, k = map(int, input().split())

mn = n*(n+1) // 2
if k < mn:
    print(""-1"")
else:
    mx = count_max(n)
    target = min(k, mx)
    print(str(target)+""\n"")

    a = [i for i in range(1, n+1)]
    b = [i for i in range(1, n+1)]
    cur = mn
    i = n-1
    while cur != target:
        f = a[i]
        s = n+1-a[i]
        if f-s < target-cur:
##            print(i)
##            print(a)
##            print(b)
            b[i], b[n-1-i] = b[n-1-i], b[i]
            cur += f-s
            i -= 1
        else:
            j = a[i] - (target-cur) - 1
            b[i], b[j] = b[j], b[i]
            cur = target
##    print(""11"")
    print("" "".join(map(str, a)))
    print("" "".join(map(str, b)))
","['constructive algorithms', 'greedy', 'math']"
1694,"The life goes up and down, just like nice sequences. Sequence t1, t2, ..., tn is called nice if the following two conditions are satisfied:   ti &lt; ti + 1 for each odd i &lt; n;  ti &gt; ti + 1 for each even i &lt; n. For example, sequences (2, 8), (1, 5, 1) and (2, 5, 1, 100, 99, 120) are nice, while (1, 1), (1, 2, 3) and (2, 5, 3, 2) are not.Bear Limak has a sequence of positive integers t1, t2, ..., tn. This sequence is not nice now and Limak wants to fix it by a single swap. He is going to choose two indices i &lt; j and swap elements ti and tj in order to get a nice sequence. Count the number of ways to do so. Two ways are considered different if indices of elements chosen for a swap are different. NoteIn the first sample, there are two ways to get a nice sequence with one swap:   Swap t2 = 8 with t4 = 7.  Swap t1 = 2 with t5 = 7. In the second sample, there is only one way — Limak should swap t1 = 200 with t4 = 50. def main():
    n, l = int(input()), list(map(int, input().split()))
    if not (n & 1):
        l.append(0)
    l.append(150001)
    a, b, fails, res = 0, 150001, [], 0
    for i, c in enumerate(l, -1):
        if i & 1:
            if a >= b or b <= c:
                if len(fails) > 5:
                    print(0)
                    return
                fails.append(i)
        else:
            if a <= b or b >= c:
                if len(fails) > 5:
                    print(0)
                    return
                fails.append(i)
        a, b = b, c
    ff = fails + [0]
    for i in fails:
        a = l[i]
        for j in range(n):
            l[i], l[j], ff[-1] = l[j], a, j
            if (all((l[b - 1] < l[b] > l[b + 1]) if b & 1 else
                    (l[b - 1] > l[b] < l[b + 1]) for b in ff)):
                res += 1 if j in fails else 2
            l[j] = l[i]
        l[i] = a
    print(res // 2)

main()","['brute force', 'implementation']"
2486,"You are the owner of a harvesting field which can be modeled as an infinite line, whose positions are identified by integers.It will rain for the next $$$n$$$ days. On the $$$i$$$-th day, the rain will be centered at position $$$x_i$$$ and it will have intensity $$$p_i$$$. Due to these rains, some rainfall will accumulate; let $$$a_j$$$ be the amount of rainfall accumulated at integer position $$$j$$$. Initially $$$a_j$$$ is $$$0$$$, and it will increase by $$$\max(0,p_i-|x_i-j|)$$$ after the $$$i$$$-th day's rain.A flood will hit your field if, at any moment, there is a position $$$j$$$ with accumulated rainfall $$$a_j&gt;m$$$.You can use a magical spell to erase exactly one day's rain, i.e., setting $$$p_i=0$$$. For each $$$i$$$ from $$$1$$$ to $$$n$$$, check whether in case of erasing the $$$i$$$-th day's rain there is no flood. NoteIn the first test case, if we do not use the spell, the accumulated rainfall distribution will be like this:  If we erase the third day's rain, the flood is avoided and the accumulated rainfall distribution looks like this:  In the second test case, since initially the flood will not happen, we can erase any day's rain.In the third test case, there is no way to avoid the flood. import sys
input = sys.stdin.readline
from heapq import heappop, heappush
for t in range(int(input())):
    n, m = list(map(int, input().split()))
    d = {}
    D = {}
    for i in range(n):
        x, p = list(map(int, input().split()))
        d[i] = (x, p)
        if (x, p) not in D:
            D[(x, p)] = []
        D[(x, p)].append(i)
    total, count, curr = 0, 0, 0
    heap = []
    rain = sorted(d.values())
    pos = {}
    for i in range(n):
        x, p = rain[i]
        total += p - (x-curr)*count
        count += 1
        heappush(heap, x+p)
        curr = x
        pos[curr] = total
        if i == n-1:
            break
        nxt, _ = rain[i+1]
        while heap and heap[0] <= nxt:
            total -= (heap[0]-curr)*count
            count -= 1
            curr = heappop(heap)
    heap = []
    total, count, curr = 0, 0, 0
    for i in range(n-1, -1, -1):
        x, p = rain[i]
        total -= (curr-x)*count
        count += 1
        heappush(heap, -(x-p))
        pos[x] += total
        if i < n-1 and rain[i+1][0] == x:
            pos[x] -= total
        curr = x
        total += p
        if i == 0:
            break
        nxt, _ = rain[i-1]
        while heap and -heap[0] >= nxt:
            total -= (heap[0]+curr)*count
            count -= 1
            curr = -heappop(heap)
    res = [0]*n
    L, R = [0]*n, [0]*n
    Mp = rain[0][0]
    Max = pos[Mp]
    for i in range(n):
        x, p = rain[i]
        if Max+(x-Mp) <= pos[x] or (Max <= m and pos[x] > m):
            Mp, Max = x, pos[x]
        if Max+(x-Mp)-p > m and Max > m:
            L[i] = 0
        else:
            L[i] = 1
    Mp = rain[-1][0]
    Max = pos[Mp]
    for i in range(n-1, -1, -1):
        x, p = rain[i]
        if Max+(Mp-x) <= pos[x] or (Max <= m and pos[x] > m):
            Mp, Max = x, pos[x]
        if Max+(Mp-x)-p > m and Max > m:
            R[i] = 0
        else:
            R[i] = 1
    for i in range(n):
        for ind in D[rain[i]]:
            if res[ind]:
                break
            res[ind] = str(L[i]&R[i])
    print(''.join(res))","['binary search', 'brute force', 'data structures', 'sortings']"
538,"Alicia has an array, $$$a_1, a_2, \ldots, a_n$$$, of non-negative integers. For each $$$1 \leq i \leq n$$$, she has found a non-negative integer $$$x_i = max(0, a_1, \ldots, a_{i-1})$$$. Note that for $$$i=1$$$, $$$x_i = 0$$$.For example, if Alicia had the array $$$a = \{0, 1, 2, 0, 3\}$$$, then $$$x = \{0, 0, 1, 2, 2\}$$$.Then, she calculated an array, $$$b_1, b_2, \ldots, b_n$$$: $$$b_i = a_i - x_i$$$.For example, if Alicia had the array $$$a = \{0, 1, 2, 0, 3\}$$$, $$$b = \{0-0, 1-0, 2-1, 0-2, 3-2\} = \{0, 1, 1, -2, 1\}$$$.Alicia gives you the values $$$b_1, b_2, \ldots, b_n$$$ and asks you to restore the values $$$a_1, a_2, \ldots, a_n$$$. Can you help her solve the problem? NoteThe first test was described in the problem statement.In the second test, if Alicia had an array $$$a = \{1000, 1000000000, 0\}$$$, then $$$x = \{0, 1000, 1000000000\}$$$ and $$$b = \{1000-0, 1000000000-1000, 0-1000000000\} = \{1000, 999999000, -1000000000\}$$$. n = int(input())
b = str(input()).split()
x = []
a = []

for i in range(n):
    b[i] = int(b[i])
    if i == 0:
        m = b[i]
        x.append(0)
        a.append(b[i])
    else:
        if a[i-1] > m:
            m = a[i-1]
        x.append(m)
        a.append(b[i] + x[i])
    print(a[i], end=' ')","['implementation', 'math']"
4205,"Timur's grandfather gifted him a chessboard to practice his chess skills. This chessboard is a grid $$$a$$$ with $$$n$$$ rows and $$$m$$$ columns with each cell having a non-negative integer written on it. Timur's challenge is to place a bishop on the board such that the sum of all cells attacked by the bishop is maximal. The bishop attacks in all directions diagonally, and there is no limit to the distance which the bishop can attack. Note that the cell on which the bishop is placed is also considered attacked. Help him find the maximal sum he can get. NoteFor the first test case here the best sum is achieved by the bishop being in this position:    import sys
input = sys.stdin.readline
 
for _ in range(int(input())):
    n,m=list(map(int,input().split()))
    arr=[]
    for _ in range(n):
        arr.append(list(map(int,input().split())))
    d1=[0]*(n+m-1)
    d2=[0]*(n+m-1)
    for i in range(n):
        for j in range(m):
            d1[i+j]+=arr[i][j]
            d2[i-j+m-1]+=arr[i][j]
    maxx=0
    for i in range(n):
        for j in range(m):
            maxx=max(maxx, d1[i+j]+d2[i-j+m-1]-arr[i][j])
    print(maxx)","['brute force', 'greedy', 'implementation']"
2119,"Emily's birthday is next week and Jack has decided to buy a present for her. He knows she loves books so he goes to the local bookshop, where there are n books on sale from one of m genres.In the bookshop, Jack decides to buy two books of different genres.Based on the genre of books on sale in the shop, find the number of options available to Jack for choosing two books of different genres for Emily. Options are considered different if they differ in at least one book.The books are given by indices of their genres. The genres are numbered from 1 to m. NoteThe answer to the first test sample equals 5 as Sasha can choose:  the first and second books,  the first and third books,  the first and fourth books,  the second and third books,  the third and fourth books.  n,m=map(int,raw_input().split())
a=map(int,raw_input().split())
freq=[0]*12
for x in a:
	freq[x]+=1
pairs=(n*(n-1))/2
for x in freq:
	if x>1:
		pairs-=(((x)*(x-1))/2)
print pairs","['constructive algorithms', 'implementation']"
2503,"This is the hard version of the problem. The difference is the constraint on the sum of lengths of strings and the number of test cases. You can make hacks only if you solve all versions of this task.You are given a string $$$s$$$, consisting of lowercase English letters. Find the longest string, $$$t$$$, which satisfies the following conditions:   The length of $$$t$$$ does not exceed the length of $$$s$$$.  $$$t$$$ is a palindrome.  There exists two strings $$$a$$$ and $$$b$$$ (possibly empty), such that $$$t = a + b$$$ ( ""$$$+$$$"" represents concatenation), and $$$a$$$ is prefix of $$$s$$$ while $$$b$$$ is suffix of $$$s$$$.  NoteIn the first test, the string $$$s = $$$""a"" satisfies all conditions.In the second test, the string ""abcdfdcba"" satisfies all conditions, because:  Its length is $$$9$$$, which does not exceed the length of the string $$$s$$$, which equals $$$11$$$.  It is a palindrome.  ""abcdfdcba"" $$$=$$$ ""abcdfdc"" $$$+$$$ ""ba"", and ""abcdfdc"" is a prefix of $$$s$$$ while ""ba"" is a suffix of $$$s$$$. It can be proven that there does not exist a longer string which satisfies the conditions.In the fourth test, the string ""c"" is correct, because ""c"" $$$=$$$ ""c"" $$$+$$$ """" and $$$a$$$ or $$$b$$$ can be empty. The other possible solution for this test is ""s"". #!/usr/bin/env python
import os
import sys
from io import BytesIO, IOBase
import threading 
from math import floor
# from bisect import bisect_right
from collections import Counter
from math import gcd

mod=998244353
    
def kmp(pat,M): 
    len = 0
    lps=[0]*M 
    i = 1
    while i < M: 
        if pat[i]== pat[len]: 
            len += 1
            lps[i] = len
            i += 1
        else: 
            # to search step. 
            if len != 0: 
                len = lps[len-1] 
            else: 
                lps[i] = 0
                i += 1
    return lps[-1]


def main():
    for _ in range(int(input())):
        s=input()
        n=len(s)
        start=0
        end=n-1
        while start<end and  s[start]==s[end]:
            start+=1
            end-=1
        ans=s[:start]
        t=s[start:end+1]

        t1=t+'*'+t[::-1]
        t2=t[::-1]+'*'+t
        c1=kmp(t1,len(t1))
        c2=kmp(t2,len(t2))
        if c1<c2:
            ans+=t2[:c2]
        else:
            ans+=t1[:c1]
        ans+=s[end+1:]
        print(ans)
        
        
  

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# endregion

if __name__ == ""__main__"":
    main()","['binary search', 'greedy', 'hashing', 'other', 'strings']"
135,"This is the easy version of the problem. The difference between versions is the constraints on $$$n$$$ and $$$a_i$$$. You can make hacks only if all versions of the problem are solved.First, Aoi came up with the following idea for the competitive programming problem:Yuzu is a girl who collecting candies. Originally, she has $$$x$$$ candies. There are also $$$n$$$ enemies numbered with integers from $$$1$$$ to $$$n$$$. Enemy $$$i$$$ has $$$a_i$$$ candies.Yuzu is going to determine a permutation $$$P$$$. A permutation is an array consisting of $$$n$$$ distinct integers from $$$1$$$ to $$$n$$$ in arbitrary order. For example, $$$\{2,3,1,5,4\}$$$ is a permutation, but $$$\{1,2,2\}$$$ is not a permutation ($$$2$$$ appears twice in the array) and $$$\{1,3,4\}$$$ is also not a permutation (because $$$n=3$$$ but there is the number $$$4$$$ in the array).After that, she will do $$$n$$$ duels with the enemies with the following rules:  If Yuzu has equal or more number of candies than enemy $$$P_i$$$, she wins the duel and gets $$$1$$$ candy. Otherwise, she loses the duel and gets nothing.  The candy which Yuzu gets will be used in the next duels. Yuzu wants to win all duels. How many valid permutations $$$P$$$ exist?This problem was easy and wasn't interesting for Akari, who is a friend of Aoi. And Akari made the following problem from the above idea:Let's define $$$f(x)$$$ as the number of valid permutations for the integer $$$x$$$.You are given $$$n$$$, $$$a$$$ and a prime number $$$p \le n$$$. Let's call a positive integer $$$x$$$ good, if the value $$$f(x)$$$ is not divisible by $$$p$$$. Find all good integers $$$x$$$.Your task is to solve this problem made by Akari. NoteIn the first test, $$$p=2$$$.  If $$$x \le 2$$$, there are no valid permutations for Yuzu. So $$$f(x)=0$$$ for all $$$x \le 2$$$. The number $$$0$$$ is divisible by $$$2$$$, so all integers $$$x \leq 2$$$ are not good.  If $$$x = 3$$$, $$$\{1,2,3\}$$$ is the only valid permutation for Yuzu. So $$$f(3)=1$$$, so the number $$$3$$$ is good.  If $$$x = 4$$$, $$$\{1,2,3\} , \{1,3,2\} , \{2,1,3\} , \{2,3,1\}$$$ are all valid permutations for Yuzu. So $$$f(4)=4$$$, so the number $$$4$$$ is not good.  If $$$x \ge 5$$$, all $$$6$$$ permutations are valid for Yuzu. So $$$f(x)=6$$$ for all $$$x \ge 5$$$, so all integers $$$x \ge 5$$$ are not good. So, the only good number is $$$3$$$.In the third test, for all positive integers $$$x$$$ the value $$$f(x)$$$ is divisible by $$$p = 3$$$. def func(length, prime):
    nums = sorted(map(int, input().split()))
    mini = max(nums[0], nums[-1]-length+1)

    xs = list(range(mini, min(mini+length, nums[-1]+1)))
    L = len(xs)  # candidates, 0~L-length

    idxs = [0] * length
    for i in range(L-1, -1, -1):
        if xs[i] == nums[-1]:
            idxs[-1] = length-i
            break

    for i in range(length-2, -1, -1):
        diff = nums[i+1]-nums[i]
        idxs[i] = min(length, idxs[i+1]+diff)

    for i in range(length):
        idxs[i] -= (length-1-i)
    
    from collections import defaultdict
    num2i = defaultdict(set)

    bad = [False] * (length+1)
    for i in range(prime, length+1, prime):
        bad[i] = True

    flag = False
    for i, n in enumerate(idxs):
        if n == i+1:
            if bad[n]:
                flag = True
                break
        else:
            num2i[n].add(i)

    res = []
    incri = 0
    for x in xs:
        if flag:
            break
        if not any((k+incri)%prime==0 for k in num2i):
            res.append(x)
        incri += 1
        for k in list(num2i.keys()):
            v = num2i[k]
            if k+incri-1 in v:
                v.remove(k+incri-1)
                if (k+incri)%prime ==0:
                    flag = True
                    break
                if not v:
                    num2i.pop(k)

    print(len(res))
    print("" "".join(map(str, res)) if res else """")


# cases = int(input())
for i in range(1):
    n, k = map(int, input().split())
    func(n, k)","['binary search', 'brute force', 'combinatorics', 'math', 'number theory', 'sortings']"
4480,"This is an interactive problem.Imur Ishakov decided to organize a club for people who love to play the famous game «The hat». The club was visited by n students, where n is even. Imur arranged them all in a circle and held a draw to break the students in pairs, but something went wrong. The participants are numbered so that participant i and participant i + 1 (1 ≤ i ≤ n - 1) are adjacent, as well as participant n and participant 1. Each student was given a piece of paper with a number in such a way, that for every two adjacent students, these numbers differ exactly by one. The plan was to form students with the same numbers in a pair, but it turned out that not all numbers appeared exactly twice.As you know, the most convenient is to explain the words to the partner when he is sitting exactly across you. Students with numbers i and  sit across each other. Imur is wondering if there are two people sitting across each other with the same numbers given. Help him to find such pair of people if it exists.You can ask questions of form «which number was received by student i?», and the goal is to determine whether the desired pair exists in no more than 60 questions. NoteInput-output in statements illustrates example interaction.In the first sample the selected sequence is 1, 2, 1, 2, 3, 4, 3, 2In the second sample the selection sequence is 1, 2, 3, 2, 1, 0. n=int(input())
if n%4==2:
    print('!', '-1')
    exit()
def qry(i):
    print('?', i+1, flush=True)
    a=int(input())
    return a
def qry2(i):
    a=qry(i+n//2)-qry(i)
    if a==0:
        print('!', i+1)
        exit()
    return a
a=qry2(0)
lb,rb=1,n//2-1
while lb<=rb:
    mb=(lb+rb)//2
    b=qry2(mb)
    if (a>0)==(b>0):
        lb=mb+1
    else:
        rb=mb-1","['binary search', 'interactive']"
2699,"You are given a rooted tree consisting of $$$n$$$ vertices numbered from $$$1$$$ to $$$n$$$. The root is vertex $$$1$$$. There is also a string $$$s$$$ denoting the color of each vertex: if $$$s_i = \texttt{B}$$$, then vertex $$$i$$$ is black, and if $$$s_i = \texttt{W}$$$, then vertex $$$i$$$ is white.A subtree of the tree is called balanced if the number of white vertices equals the number of black vertices. Count the number of balanced subtrees.A tree is a connected undirected graph without cycles. A rooted tree is a tree with a selected vertex, which is called the root. In this problem, all trees have root $$$1$$$.The tree is specified by an array of parents $$$a_2, \dots, a_n$$$ containing $$$n-1$$$ numbers: $$$a_i$$$ is the parent of the vertex with the number $$$i$$$ for all $$$i = 2, \dots, n$$$. The parent of a vertex $$$u$$$ is a vertex that is the next vertex on a simple path from $$$u$$$ to the root.The subtree of a vertex $$$u$$$ is the set of all vertices that pass through $$$u$$$ on a simple path to the root. For example, in the picture below, $$$7$$$ is in the subtree of $$$3$$$ because the simple path $$$7 \to 5 \to 3 \to 1$$$ passes through $$$3$$$. Note that a vertex is included in its subtree, and the subtree of the root is the entire tree.  The picture shows the tree for $$$n=7$$$, $$$a=[1,1,2,3,3,5]$$$, and $$$s=\texttt{WBBWWBW}$$$. The subtree at the vertex $$$3$$$ is balanced.  NoteThe first test case is pictured in the statement. Only the subtrees at vertices $$$2$$$ and $$$3$$$ are balanced.In the second test case, only the subtree at vertex $$$1$$$ is balanced.In the third test case, only the subtrees at vertices $$$1$$$, $$$3$$$, $$$5$$$, and $$$7$$$ are balanced. # cook your dish here
#!/usr/bin/env python
from bisect import bisect_left
from cmath import inf
import os
from math import ceil, factorial, fmod,pi,sqrt,log
import sys
from collections import Counter
from io import BytesIO, IOBase, StringIO
sys.setrecursionlimit(4*10**4)
def modFact(n, p):
    if n >= p:
        return 0   
 
    result = 1
    for i in range(1, n + 1):
        result = (result * i) % p
 
    return result
 
def calculate(p, q):
     
    mod = 998244353
    expo = 0
    expo = mod - 2
 
    # Loop to find the value
    # until the expo is not zero
    while (expo):
 
        # Multiply p with q
        # if expo is odd
        if (expo & 1):
            p = (p * q) % mod
        q = (q * q) % mod
 
        # Reduce the value of
        # expo by 2
        expo >>= 1
 
    return p
def compute_gcd(x, y):

   while(y):
       x, y = y, x % y
   return x

# This function computes LCM
def compute_lcm(x, y):
   lcm = (x*y)//compute_gcd(x,y)
   return lcm

def read_arr():
    return [int(x) for x in input().split()]

def bin_search(num, arr):
    start = 0
    end = len(arr)-1
    while start <= end:
        mid=(start+end)//2
        if arr[mid] == num:
            return mid
        elif arr[mid] > num:
            end= mid-1
        else:
            start = mid + 1
    return -1


def factors(n) :
     
    # Note that this loop runs till square root
    i = 1
    ans=[]
    while i <= sqrt(n):
         
        if (n % i == 0) :
             
            # If divisors are equal, print only one
            if (n / i == i) :
                ans.append(i)
            else :
                # Otherwise print both
                
                ans.append(i)
                ans.append(int(n/i))
        i = i + 1
    return ans

def is_palindrome(n):
    for j in range(len(n)//2):
        if n[j]!=n[len(n)-j-1]:
            return False
    return True

def nCr(n, r):
     
    return (fact(n) / (fact(r)
                * fact(n - r)))
 
# Returns factorial of n
def fact(n):
 
    res = 1
     
    for i in range(2, n+1):
        res = res * i
    return res
cnt=0
def recur(graph,root,s,num):
    global cnt
    if s[root-1]==""B"":
        num[root] -= 1
    else:
        num[root] += 1
    for j in graph[root]:
        num[root]+=recur(graph,j,s,num)
    if num[root]==0:
        cnt += 1
    return num[root]




def main():
    for i in range(int(input())):
        global cnt
        cnt=0
        n = int(input())
        arr=list(map(int, input().split()))
        s=[x for x in input()]
        graph={}
        for j in range(1,n+5):
            graph[j]=[]
        for j in range(n-1):
            graph[arr[j]].append(j+2)
        num=[0 for j in range(n+1)]
        recur(graph,1,s,num)
        print(cnt)

        

BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
 
# endregion
 
if __name__ == ""__main__"":
    main()","['dfs and similar', 'dp', 'graphs', 'trees']"
47,"Bob is an active user of the social network Faithbug. On this network, people are able to engage in a mutual friendship. That is, if $$$a$$$ is a friend of $$$b$$$, then $$$b$$$ is also a friend of $$$a$$$. Each user thus has a non-negative amount of friends.This morning, somebody anonymously sent Bob the following link: graph realization problem and Bob wants to know who that was. In order to do that, he first needs to know how the social network looks like. He investigated the profile of every other person on the network and noted down the number of his friends. However, he neglected to note down the number of his friends. Help him find out how many friends he has. Since there may be many possible answers, print all of them. NoteIn the first test case, the only solution is that everyone is friends with everyone. That is why Bob should have $$$3$$$ friends.In the second test case, there are three possible solutions (apart from symmetries):   $$$a$$$ is friend of $$$b$$$, $$$c$$$ is friend of $$$d$$$, and Bob has no friends, or  $$$a$$$ is a friend of $$$b$$$ and both $$$c$$$ and $$$d$$$ are friends with Bob, or  Bob is friends of everyone. The third case is impossible to solve, as the second person needs to be a friend with everybody, but the first one is a complete stranger. def main():
    n=int(input())
    a=list(map(int,input().split()))
    a.sort(reverse=True)
    mod=sum(a)%2
    counts=[0]*(n+1)
    for guy in a:
        counts[guy]+=1
    cumcounts=[counts[0]]
    for i in range(n):
        cumcounts.append(cumcounts[-1]+counts[i+1])
    partialsums=[0]
    curr=0
    for i in range(n):
        curr+=(i+1)*counts[i+1]
        partialsums.append(curr)
    partialsums.append(0)
    cumcounts.append(0)
    sumi=0
    diffs=[]
    altdiffs=[]
    for i in range(n):
        sumi+=a[i]
        rhs=i*(i+1)
        if a[i]>i:
            rhs+=partialsums[i]+(i+1)*(n-i-1-cumcounts[i])
        else:
            rhs+=partialsums[a[i]-1]+a[i]*(n-i-1-cumcounts[a[i]-1])
        diffs.append(sumi-rhs)
        
        rhs2=(i+1)*(i+2)
        if a[i]>i+1:
            rhs2+=partialsums[i+1]+(i+2)*(n-i-1-cumcounts[i+1])
        else:
            rhs2+=partialsums[a[i]-1]+a[i]*(n-i-1-cumcounts[a[i]-1])
        altdiffs.append(sumi-rhs2)
    mini=max(diffs)
    maxi=-max(altdiffs)
    mini=max(mini,0)
    maxi=min(maxi,n)
    out=""""
    if mini%2!=mod:
        mini+=1
    if maxi%2==mod:
        maxi+=1
    for guy in range(mini,maxi,2):
        out+=str(guy)+"" ""
    if mini>maxi:
        print(-1)
    else:
        print(out)
main()","['binary search', 'data structures', 'graphs', 'greedy', 'implementation', 'math', 'sortings']"
1034,"You are given two arrays $$$a$$$ and $$$b$$$, both consisting of $$$n$$$ integers.In one move, you can choose two indices $$$i$$$ and $$$j$$$ ($$$1 \le i, j \le n$$$; $$$i \neq j$$$) and swap $$$a_i$$$ with $$$a_j$$$ and $$$b_i$$$ with $$$b_j$$$. You have to perform the swap in both arrays.You are allowed to perform at most $$$10^4$$$ moves (possibly, zero). Can you make both arrays sorted in a non-decreasing order at the end? If you can, print any sequence of moves that makes both arrays sorted. nan import sys
input = lambda: sys.stdin.readline().rstrip()

#  -----------------------  #

def main():
  n = int(input())
  A = list(map(int, input().split()))
  B = list(map(int, input().split()))
  
  C = [[A[i], B[i]] for i in range(n)]

  D = sorted(C)

  BB = [x[1] for x in D]
  if BB != sorted(BB):
    print(-1)
    return
  if A == B and A == sorted(A):
    print(0)
    return

  ans = []
  for i in range(n):
    for j in range(n-1, i, -1):
      if C[j][0] < C[j-1][0]:
        C[j], C[j-1] = C[j-1], C[j]
        ans.append((j+1, j))
  block = []
  for i in range(n):
    block.clear()
    indx = i
    block.append(C[i][1])
    while i+1 < n and C[i][0] == C[i+1][0]:
      block.append(C[i+1][1])
      i += 1
    for k in range(len(block)):
      for j in range(len(block)-1, k, -1):
        if block[j] < block[j-1]:
          block[j], block[j-1] = block[j-1], block[j]
          C[j+indx], C[j-1+indx] = C[j-1+indx], C[j+indx]
          ans.append((j+1+indx, j+indx))
  print(len(ans))
  for a in ans:
    print(*a)

for _ in range(int(input())):
  main()
","['implementation', 'sortings']"
505,"This is an interactive problem.There is a secret permutation $$$p$$$ ($$$1$$$-indexed) of numbers from $$$1$$$ to $$$n$$$. More formally, for $$$1 \leq i \leq n$$$, $$$1 \leq p[i] \leq n$$$ and for $$$1 \leq i &lt; j \leq n$$$, $$$p[i] \neq p[j]$$$. It is known that $$$p[1]&lt;p[2]$$$.In $$$1$$$ query, you give $$$3$$$ distinct integers $$$a,b,c$$$ ($$$1 \leq a,b,c \leq n$$$), and receive the median of $$$\{|p[a]-p[b]|,|p[b]-p[c]|,|p[a]-p[c]|\}$$$.In this case, the median is the $$$2$$$-nd element ($$$1$$$-indexed) of the sequence when sorted in non-decreasing order. The median of $$$\{4,6,2\}$$$ is $$$4$$$ and the median of $$$\{0,123,33\}$$$ is $$$33$$$.Can you find the secret permutation in not more than $$$2n+420$$$ queries?Note: the grader is not adaptive: the permutation is fixed before any queries are made. NoteThe secret permutation is $$$\{9,10,19,7,16,18,11,14,15,6,20,8,17,4,5,3,12,2,13,1\}$$$.For the first query, the values of $$$(a,b,c)$$$ is $$$(1,5,2)$$$. Since $$$p[1]=9$$$, $$$p[5]=16$$$ and $$$p[2]=10$$$. The return value is the median of $$$\{|9-16|,|16-10|,|9-10|\}$$$ which is $$$6$$$.For the second query, the values of $$$(a,b,c)$$$ is $$$(20,19,2)$$$. Since $$$p[20]=1$$$, $$$p[19]=13$$$ and $$$p[2]=10$$$. The return value is the median of $$$\{|1-13|,|13-10|,|1-10|\}$$$ which is $$$9$$$.By some miracle, we have figured out that the secret permutation is $$$\{9,10,19,7,16,18,11,14,15,6,20,8,17,4,5,3,12,2,13,1\}$$$. We output it and receive $$$1$$$ from the interactor, meaning that we have guessed the secret permutation correctly. import sys
import itertools
import heapq
from collections import defaultdict, Counter
from math import inf


def read():
    v = int(input())
    if v == -1:
        sys.exit()
    else:
        assert v > 0
        return v


def ask(a, b, c):
    if c == a:
        return -1
    elif c == b:
        return 0
    print('?', a + 1, b + 1, c + 1)
    return read()


def say(*args):
    print('!', *args)
    assert read() == 1


def find_king_and_prince_starting_from(a, b, *, n):
    """"""Return pair of indices (king, prince)

    ...such that (p[king], p[prince]) is either (1, 2) or (n, n-1)
    """"""
    rs = heapq.nlargest(4, ((ask(a, b, i), i) for i in range(n)))
    mx, king = rs.pop(0)  # p[king] is either 1 or n
    if rs[0][0] == mx:
        rs.pop(0)  # skip other king
    mx2, x = rs.pop(0)
    assert mx2 == mx - 1
    mx3, y = rs.pop(0)
    if mx3 == mx2:
        # set {p[x], p[y]} is equal to set {2, n-1}
        # need to determine which of [x, y] is correct ""prince""
        x = min([x, y], key = lambda v: ask(king, v, a) + ask(king, v, b))
    return king, x


def is_sorted(seq):
    return tuple(seq) == tuple(sorted(seq))


def find_two_close_values(*, n):
    """"""Return pair of indices of any two ""close"" values.

    Values p[a] and p[b] are considered ""close"" if either
    ask(a, b, 1) or ask(a, b, n) is greater than abs(p[a] - p[b]) + 1
    """"""
    dist = (n - 5) // 3
    values = defaultdict(Counter)
    minmax_value = defaultdict(lambda: (inf, -inf))
    banned_pairs = set()
    for (a, b, c) in itertools.combinations(range(13), 3):
        assert is_sorted((a, b, c))
        if any(pair in banned_pairs for pair in ((a, b), (b, c), (a, c))):
            continue  # what you gonna do now, user14767553? ;)
        r = ask(a, b, c)
        if r <= dist // 2:
            # any of (a, b), (b, c), (c, a) goes because their difference is
            # less than or equal to (n - 5) // 3
            return (a, b)
        for pair in itertools.combinations((a, b, c), 2):
            assert isinstance(pair, tuple)
            assert is_sorted(pair)
            values[pair][r] += 1
            mn, mx = minmax_value.get(pair, (r, r))
            minmax_value[pair] = (min(mn, r), max(mx, r))
            if mx > 2*mn + 1:
                # let (a, b) = pair. Then
                # abs(p[a] - p[b]) <= 2*mn < mx - 1
                return pair
            # if ask(a, b, x) == r for at least 3 different x,
            # then abs(p[a] - p[b]) == r
            if values[pair][r] >= 3:
                if r <= dist:
                    # bingo!
                    return pair
                elif r > 2 * dist:
                    banned_pairs.add(pair)

    raise AssertionError


def solve():
    n = read()
    assert n >= 20
    a, b = find_two_close_values(n=n)
    king, prince = find_king_and_prince_starting_from(a, b, n=n)
    rank = [ask(king, prince, i) for i in range(n)]
    if king == 0 or (king != 1 and rank[0] < rank[1]):
        ans = [r + 2 for r in rank]
        assert ans[king] == 1
        assert ans[prince] == 2
    else:
        ans = [n - 1 - r for r in rank]
        assert ans[king] == n
        assert ans[prince] == n - 1
    say(*ans)


def main():
    t = int(input())
    for __ in range(t):
        solve()


if __name__ == '__main__':
    main()
","['constructive algorithms', 'interactive', 'probabilities']"
4720,"Arthur owns a ski resort on a mountain. There are $$$n$$$ landing spots on the mountain numbered from $$$1$$$ to $$$n$$$ from the top to the foot of the mountain. The spots are connected with one-directional ski tracks. All tracks go towards the foot of the mountain, so there are no directed cycles formed by the tracks. There are at most two tracks leaving each spot, but many tracks may enter the same spot.A skier can start skiing from one spot and stop in another spot if there is a sequence of tracks that lead from the starting spot and end in the ending spot. Unfortunately, recently there were many accidents, because the structure of the resort allows a skier to go through dangerous paths, by reaching high speed and endangering himself and the other customers. Here, a path is called dangerous, if it consists of at least two tracks.Arthur wants to secure his customers by closing some of the spots in a way that there are no dangerous paths in the resort. When a spot is closed, all tracks entering and leaving that spot become unusable. Formally, after closing some of the spots, there should not be a path that consists of two or more tracks.Arthur doesn't want to close too many spots. He will be happy to find any way to close at most $$$\frac{4}{7}n$$$ spots so that the remaining part is safe. Help him find any suitable way to do so. NoteIn the first sample case, closing any two spots is suitable.In the second sample case, closing only the spot $$$1$$$ is also suitable. import io
import os

from collections import Counter, defaultdict, deque
import random

from heapq import heappush, heappop, heapify


def solve(N, M, tracks):

    stops = range(1, N + 1)
    graph = [[] for i in range(N + 1)]
    graphT = [[] for i in range(N + 1)]
    for u, v in tracks:
        graph[u].append(v)
        graphT[v].append(u)

    # Since out degree is limited to 2, dangerous pairs of paths doesn't explode
    danger = []
    for u in stops:
        for fr in graphT[u]:
            for to in graph[u]:
                danger.append([fr, u, to])
    if not danger:
        return ""0\n""
    del graph
    del graphT

    maxRemove = 4 * N // 7
    dangerIds = list(range(len(danger)))
    removed = set()
    for i in dangerIds:
        needsRemove = [u for u in danger[i] if u not in removed]
        if len(needsRemove) == 3:
            removed.add(needsRemove[-1])
    # every triplet of dangerous had something removed, so they aren't dangerous anymore
    assert len(removed) <= maxRemove
    return str(len(removed)) + ""\n"" + "" "".join(map(str, removed))


if True:
    tracks = []
    for i in range(1, 10 ** 4):
        tracks.append((i, 2 * i))
        tracks.append((i, 2 * i + 1))
    N = 2 * 10 ** 5
    solve(N, len(tracks), tracks)


if __name__ == ""__main__"":
    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

    T = int(input())
    for t in range(T):
        N, M = [int(x) for x in input().split()]
        tracks = [[int(x) for x in input().split()] for i in range(M)]
        ans = solve(N, M, tracks)
        print(ans)
","['constructive algorithms', 'graphs', 'greedy']"
2182,"You are given a positive decimal number x.Your task is to convert it to the ""simple exponential notation"".Let x = a·10b, where 1 ≤ a &lt; 10, then in general case the ""simple exponential notation"" looks like ""aEb"". If b equals to zero, the part ""Eb"" should be skipped. If a is an integer, it should be written without decimal point. Also there should not be extra zeroes in a and b. nan #############<------------  Xorcestor_X ---------------->############

from math import *


def is_even(p):
    n=len(p)
    count=0
    for i in range(n):
        index=p.index(i,i,n)
        if i==index:
            pass
        else:
            count+=1
            temp=p[i]
            p[i]=p[index]
            p[index]=temp
    # print(p)
    if count%2==0:
        return True
    else:
        return False



prime=[]

def SieveOfEratosthenes():
    global prime
    prime=[1]*2000010
    prime[1]=0
    p=2
    while p*p<=2000001:
        if prime[p]:
            for i in range(p*p,2000002,p):
                prime[i]=0

lpf=[]

def precompute():
    global lpf
    lpf=[0]*1000001
    for i in range(2,1000001):
        if not lpf[i]:
            for j in range(i,1000001,i):
                if not lpf[j]:
                    lpf[j]=i


def binpow(a,b):
    res=1
    while b>0:
        if b&1:
            res*=a
        a*=a
        b>>=1
    return res


def modpow(a,b,x):
    res=1
    while b>0:
        if b&1:
            res*=a
            res%=x
        a*=a
        a%=x
        b>>=1
    return res

cont=[]

def f(x):
    global cont
    total=0
    for i in cont:
        total+=abs(i-x)
    return total


def bs(low,high,target):
    while low+3<high:
        mid=(low+high)/2
        if arr[mid]<target:
            low=mid
        else:
            high=mid-1
    for i in range(high,low-1,-1):
        if arr[o]<target:
            return i
    return -1


def ternary_search(l,r):
    while r-l>10:
        m1=l+(r-l)/3
        m2=r-(r-l)/3
        f1=f(m1)
        f2=f(m2)
        if f1>f2:
            l=m1
        else:
            r=m2

    mino=f(l)

    for i in range(l,r+1):
        mino=min(mino,f(i))

    return mino
s=input()
s=s.replace('0',' ')
s=s.lstrip()
s=s.replace(' ','0')
l=s.find('.')
if l==-1:
    sz=len(s)
    tr=s[0]+'.'+s[1:]
    tr=tr.replace('0',' ')
    tr=tr.rstrip()
    tr=tr.replace(' ','0')
    if tr[-1]=='.':
        tr=tr[0:-1]
    if sz==1:
        print(tr)
    else:
        tr+=""E""+str(sz-1)
        print(tr)
else:
    if l==0:
        s=s[1:]
        sz=len(s)
        s=s.replace('0',' ')
        s=s.lstrip()
        s=s.replace(' ','0')
        new_sz=len(s)
        counter=-1
        counter-=(sz-new_sz)
        s=s.replace('0',' ')
        s=s.rstrip()
        s=s.replace(' ','0')
        tr=s[0]+'.'+s[1:]
        if tr[-1]=='.':
            tr=tr[0:-1]
        tr+=""E""+str(counter)
        print(tr)
    else:
        diff=l-1
        s=s.replace('0',' ')
        s=s.rstrip()
        s=s.replace(' ','0')
        if diff==0:
            if s[-1]==""."":
                s=s[0:-1]
            print(s)
        else:
            tr=s[0]+"".""+s[1:l]+s[l+1:]
            tr=tr.replace('0',' ')
            tr=tr.rstrip()
            tr=tr.replace(' ','0')
            if tr[-1]=='.':
                tr=tr[0:-1]
            tr+=""E""+str(diff)
            print(tr)
","['implementation', 'strings']"
4831,"Igor is in the museum and he wants to see as many pictures as possible.Museum can be represented as a rectangular field of n × m cells. Each cell is either empty or impassable. Empty cells are marked with '.', impassable cells are marked with '*'. Every two adjacent cells of different types (one empty and one impassable) are divided by a wall containing one picture.At the beginning Igor is in some empty cell. At every moment he can move to any empty cell that share a side with the current one.For several starting positions you should calculate the maximum number of pictures that Igor can see. Igor is able to see the picture only if he is in the cell adjacent to the wall with this picture. Igor have a lot of time, so he will examine every picture he can see. nan import sys
from queue import deque

# sys.stdin = open('ivo.in')

move = [(0, 1), (1, 0), (0, -1), (-1, 0)]
n, m, k = map(int, sys.stdin.readline().split())

a = []
for i in range(n):
    a.append(sys.stdin.readline().rstrip())


visited = []
values = []
for x in range(n):
    visited.append([])
    values.append([])
    for y in range(m):
        visited[x].append(False)
        values[x].append(0)


for x in range(n):
    for y in range(m):
        if a[x][y] == '*' or visited[x][y]:
            continue
        q = deque()
        visited[x][y] = True
        q.append((x, y))
        sum = 0
        connected = [(x, y)]
        while len(q) != 0:
            cur = q.pop()
            for l in move:
                tx = cur[0] + l[0]
                ty = cur[1] + l[1]
                if tx < 0 or tx >= n or ty < 0 or ty >= m:
                    continue
                if a[tx][ty] == '.' and visited[tx][ty]:
                    continue
                if a[tx][ty] == '*':
                    sum += 1
                    continue
                q.append((tx, ty))
                visited[tx][ty] = True
                connected.append((tx, ty))
        for c in connected:
            values[c[0]][c[1]] = sum

for i in range(k):
    x, y = map(int, sys.stdin.readline().split())
    print(values[x - 1][y - 1])","['dfs and similar', 'graphs', 'shortest paths']"
29,"Ayoub thinks that he is a very smart person, so he created a function $$$f(s)$$$, where $$$s$$$ is a binary string (a string which contains only symbols ""0"" and ""1""). The function $$$f(s)$$$ is equal to the number of substrings in the string $$$s$$$ that contains at least one symbol, that is equal to ""1"".More formally, $$$f(s)$$$ is equal to the number of pairs of integers $$$(l, r)$$$, such that $$$1 \leq l \leq r \leq |s|$$$ (where $$$|s|$$$ is equal to the length of string $$$s$$$), such that at least one of the symbols $$$s_l, s_{l+1}, \ldots, s_r$$$ is equal to ""1"". For example, if $$$s = $$$""01010"" then $$$f(s) = 12$$$, because there are $$$12$$$ such pairs $$$(l, r)$$$: $$$(1, 2), (1, 3), (1, 4), (1, 5), (2, 2), (2, 3), (2, 4), (2, 5), (3, 4), (3, 5), (4, 4), (4, 5)$$$.Ayoub also thinks that he is smarter than Mahmoud so he gave him two integers $$$n$$$ and $$$m$$$ and asked him this problem. For all binary strings $$$s$$$ of length $$$n$$$ which contains exactly $$$m$$$ symbols equal to ""1"", find the maximum value of $$$f(s)$$$.Mahmoud couldn't solve the problem so he asked you for help. Can you help him?  NoteIn the first test case, there exists only $$$3$$$ strings of length $$$3$$$, which has exactly $$$1$$$ symbol, equal to ""1"". These strings are: $$$s_1 = $$$""100"", $$$s_2 = $$$""010"", $$$s_3 = $$$""001"". The values of $$$f$$$ for them are: $$$f(s_1) = 3, f(s_2) = 4, f(s_3) = 3$$$, so the maximum value is $$$4$$$ and the answer is $$$4$$$.In the second test case, the string $$$s$$$ with the maximum value is ""101"".In the third test case, the string $$$s$$$ with the maximum value is ""111"".In the fourth test case, the only string $$$s$$$ of length $$$4$$$, which has exactly $$$0$$$ symbols, equal to ""1"" is ""0000"" and the value of $$$f$$$ for that string is $$$0$$$, so the answer is $$$0$$$.In the fifth test case, the string $$$s$$$ with the maximum value is ""01010"" and it is described as an example in the problem statement. """"""
#If FastIO not needed, used this and don't forget to strip
#import sys, math
#input = sys.stdin.readline
""""""

import os
import sys
from io import BytesIO, IOBase
import heapq as h 
from bisect import bisect_left, bisect_right

from types import GeneratorType
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        import os
        self.os = os
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            self.os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

import collections as col
import math, string

def getInts():
    return [int(s) for s in input().split()]

def getInt():
    return int(input())

def getStrs():
    return [s for s in input().split()]

def getStr():
    return input()

def listStr():
    return list(input())

MOD = 10**9+7


""""""
Strings of length 1 is always M
Strings of length 2 can be maximised by having the 1s at least 1 zero apart where necessary
If M >= floor(N//2), then every substring except some of the 1s works

Otherwise, M 1s, N-M 0s. We want to split the 0s as evenly as possible

00100100

Partition the 0s into M+1 groups

000100100
f(1) = 2
f(2) = 4
f(3) = 6
f(4) = 6
f(5) = 5
f(6) = 4
f(7) = 3
f(8) = 2
f(9) = 1

001000100
f(1) = 2
f(2) = 4
f(3) = 6
f(4) = 6

00010000

max gap = ceil((N-M)/(M+1))
for x < max gap, contribution is M*x
for x >= max gap, contribution is N-x+1
so we want sum x = 1 to max_gap (M*x) + sum x = max_gap+1 to N (N-x+1)

Obviously M = 0 => 0
M = 1 =>
""""""

def solve():
    N, M = getInts()
    if M == 0:
        return 0
    gap = math.ceil((N-M)/(M+1))
    ans = (M+1)*gap*(gap+1)//2 + (N-gap)*(N+1) - N*(N+1)//2
    return ans
    

    
for _ in range(getInt()):
        print(solve())","['binary search', 'combinatorics', 'greedy', 'math', 'strings']"
429,"Danil decided to earn some money, so he had found a part-time job. The interview have went well, so now he is a light switcher.Danil works in a rooted tree (undirected connected acyclic graph) with n vertices, vertex 1 is the root of the tree. There is a room in each vertex, light can be switched on or off in each room. Danil's duties include switching light in all rooms of the subtree of the vertex. It means that if light is switched on in some room of the subtree, he should switch it off. Otherwise, he should switch it on.Unfortunately (or fortunately), Danil is very lazy. He knows that his boss is not going to personally check the work. Instead, he will send Danil tasks using Workforces personal messages.There are two types of tasks:  pow v describes a task to switch lights in the subtree of vertex v. get v describes a task to count the number of rooms in the subtree of v, in which the light is turned on. Danil should send the answer to his boss using Workforces messages.A subtree of vertex v is a set of vertices for which the shortest path from them to the root passes through v. In particular, the vertex v is in the subtree of v.Danil is not going to perform his duties. He asks you to write a program, which answers the boss instead of him. Note  The tree before the task pow 1. The tree after the task pow 1.  from sys import stdin, stdout
from itertools import repeat
def main():
    n = int(stdin.readline())
    p = map(int, stdin.readline().split(), repeat(10, n - 1))
    ch = [[] for _ in xrange(n)]
    for i, x in enumerate(p, 1):
        ch[x-1].append(i)
    st = []
    pu = st.append
    po = st.pop
    col = [None] * n
    L = [0] * n
    R = [0] * n
    c = 0
    pu(0)
    while st:
        x = po()
        if col[x] is None:
            L[x] = c
            c += 1
            pu(x)
            col[x] = 1
            for y in ch[x]:
                pu(y)
        else:
            col[x] = 0
            R[x] = c
    N = 1 << 18
    b = [0] * (N + N)
    lz = [0] * (N + N)
    t = stdin.readline().split()
    for i, x in enumerate(t):
        if x == '1':
            b[L[i]+N] += 1
    for i in xrange(N - 1, 0, -1):
        b[i] = b[i+i] + b[i+i+1]
    ans = []
    def inv(b, lz, v, lh):
        b[v] = lh - b[v]
        lz[v] ^= 1
    def push(b, lz, o, ln):
        for i in xrange(18, 0, -1):
            j = o >> i
            if lz[j]:
                inv(b, lz, j+j, ln)
                inv(b, lz, j+j+1, ln)
                lz[j] = 0
            ln /= 2
    q = int(stdin.readline())
    for _ in xrange(q):
        ln, x = stdin.readline().split()
        x = int(x, 10) - 1
        l, r = L[x] + N, R[x] + N - 1
        push(b, lz, l, N / 2)
        push(b, lz, r, N / 2)
        if ln[0] == 'g':
            l, r = L[x] + N, R[x] + N
            tmp = 0
            while l < r:
                if l & 1:
                    tmp += b[l]
                    l += 1
                if r & 1:
                    r -= 1
                    tmp += b[r]
                l /= 2
                r /= 2
            ans.append(tmp)
        else:
            l, r = L[x] + N, R[x] + N
            n = 1
            while l < r:
                if l & 1:
                    inv(b, lz, l, n)
                    l += 1
                if r & 1:
                    r -= 1
                    inv(b, lz, r, n)
                l /= 2
                r /= 2
                n += n
            l, r = L[x] + N, R[x] + N - 1
            n = 1
            while l > 1:
                l /= 2
                r /= 2
                n += n
                b[l] = b[l+l] + b[l+l+1]
                if lz[l]: b[l] = n - b[l]
                b[r] = b[r+r] + b[r+r+1]
                if lz[r]: b[r] = n - b[r]
    stdout.write('\n'.join(map(str, ans)))
main()
","['bitmasks', 'data structures', 'trees']"
2576,"A schoolboy named Vasya loves reading books on programming and mathematics. He has recently read an encyclopedia article that described the method of median smoothing (or median filter) and its many applications in science and engineering. Vasya liked the idea of the method very much, and he decided to try it in practice.Applying the simplest variant of median smoothing to the sequence of numbers a1, a2, ..., an will result a new sequence b1, b2, ..., bn obtained by the following algorithm:  b1 = a1, bn = an, that is, the first and the last number of the new sequence match the corresponding numbers of the original sequence.  For i = 2, ..., n - 1 value bi is equal to the median of three values ai - 1, ai and ai + 1. The median of a set of three numbers is the number that goes on the second place, when these three numbers are written in the non-decreasing order. For example, the median of the set 5, 1, 2 is number 2, and the median of set 1, 0, 1 is equal to 1.In order to make the task easier, Vasya decided to apply the method to sequences consisting of zeros and ones only.Having made the procedure once, Vasya looked at the resulting sequence and thought: what if I apply the algorithm to it once again, and then apply it to the next result, and so on? Vasya tried a couple of examples and found out that after some number of median smoothing algorithm applications the sequence can stop changing. We say that the sequence is stable, if it does not change when the median smoothing is applied to it.Now Vasya wonders, whether the sequence always eventually becomes stable. He asks you to write a program that, given a sequence of zeros and ones, will determine whether it ever becomes stable. Moreover, if it ever becomes stable, then you should determine what will it look like and how many times one needs to apply the median smoothing algorithm to initial sequence in order to obtain a stable one. NoteIn the second sample the stabilization occurs in two steps: , and the sequence 00000 is obviously stable. import sys
lines = sys.stdin.readlines()
n = int(lines[0].strip())
arr = list(map(int, lines[1].strip().split("" "")))
arr.append(arr[-1])
res = []
maxChange = 0

left = 0
for i in range(1, n+1):
    if arr[i] == arr[i-1]:
        L = i - left
        res += [arr[left]]*(L//2) + [arr[i-1]]*(L-L//2)
        maxChange = max(maxChange, (L-1)//2)
        left = i

print(maxChange)
print("" "".join(map(str, res)))
","['constructive algorithms', 'implementation']"
2596,"Recently in Divanovo, a huge river locks system was built. There are now $$$n$$$ locks, the $$$i$$$-th of them has the volume of $$$v_i$$$ liters, so that it can contain any amount of water between $$$0$$$ and $$$v_i$$$ liters. Each lock has a pipe attached to it. When the pipe is open, $$$1$$$ liter of water enters the lock every second.The locks system is built in a way to immediately transfer all water exceeding the volume of the lock $$$i$$$ to the lock $$$i + 1$$$. If the lock $$$i + 1$$$ is also full, water will be transferred further. Water exceeding the volume of the last lock pours out to the river.   The picture illustrates $$$5$$$ locks with two open pipes at locks $$$1$$$ and $$$3$$$. Because locks $$$1$$$, $$$3$$$, and $$$4$$$ are already filled, effectively the water goes to locks $$$2$$$ and $$$5$$$. Note that the volume of the $$$i$$$-th lock may be greater than the volume of the $$$i + 1$$$-th lock.To make all locks work, you need to completely fill each one of them. The mayor of Divanovo is interested in $$$q$$$ independent queries. For each query, suppose that initially all locks are empty and all pipes are closed. Then, some pipes are opened simultaneously. For the $$$j$$$-th query the mayor asks you to calculate the minimum number of pipes to open so that all locks are filled no later than after $$$t_j$$$ seconds.Please help the mayor to solve this tricky problem and answer his queries.  NoteThere are $$$6$$$ queries in the first example test. In the queries $$$1, 3, 4$$$ the answer is $$$-1$$$. We need to wait $$$4$$$ seconds to fill the first lock even if we open all the pipes. In the sixth query we can open pipes in locks $$$1$$$, $$$3$$$, and $$$4$$$. After $$$4$$$ seconds the locks $$$1$$$ and $$$4$$$ are full. In the following $$$1$$$ second $$$1$$$ liter of water is transferred to the locks $$$2$$$ and $$$5$$$. The lock $$$3$$$ is filled by its own pipe. Similarly, in the second query one can open pipes in locks $$$1$$$, $$$3$$$, and $$$4$$$.In the fifth query one can open pipes $$$1, 2, 3, 4$$$.  import sys
input = sys.stdin.readline
n = int(input())
vs = list(map(int, input().split(' ')))
vs2 = vs[:]
max_vs2 = vs2[0]
for i in range(1, n):
    vs2[i] += vs2[i - 1]
    max_vs2 = max(max_vs2, vs2[i] / (i + 1))
q = int(input())
for _ in range(q):
    t = int(input())
    if t < max_vs2:
        print(-1)
        continue
    res = vs2[-1] // t
    if vs2[-1] % t:
        res += 1
    print(res)","['binary search', 'dp', 'greedy', 'math']"
2634,"The crowdedness of the discotheque would never stop our friends from having fun, but a bit more spaciousness won't hurt, will it?The discotheque can be seen as an infinite xy-plane, in which there are a total of n dancers. Once someone starts moving around, they will move only inside their own movement range, which is a circular area Ci described by a center (xi, yi) and a radius ri. No two ranges' borders have more than one common point, that is for every pair (i, j) (1 ≤ i &lt; j ≤ n) either ranges Ci and Cj are disjoint, or one of them is a subset of the other. Note that it's possible that two ranges' borders share a single common point, but no two dancers have exactly the same ranges.Tsukihi, being one of them, defines the spaciousness to be the area covered by an odd number of movement ranges of dancers who are moving. An example is shown below, with shaded regions representing the spaciousness if everyone moves at the same time.  But no one keeps moving for the whole night after all, so the whole night's time is divided into two halves — before midnight and after midnight. Every dancer moves around in one half, while sitting down with friends in the other. The spaciousness of two halves are calculated separately and their sum should, of course, be as large as possible. The following figure shows an optimal solution to the example above.  By different plans of who dances in the first half and who does in the other, different sums of spaciousness over two halves are achieved. You are to find the largest achievable value of this sum. NoteThe first sample corresponds to the illustrations in the legend. 
import math

class circ:
	def __init__(self, x, y, r):
		self.x = x*1.0
		self.y = y*1.0
		self.r = r*1.0

n = 0
n = int(input())
vec = []
for i in range(n):
	st = input().split(' ')
	a = int(st[0])
	b = int(st[1])
	c = int(st[2])
	vec.append(circ(a,b,c))

gr = [[] for i in range(n)]
pad = [-1 for i in range(n)]
vis = [False for i in range(n)]

for i in range(n):
	for k in range(n):
		if i == k:
			continue
		dist = math.hypot(vec[i].x - vec[k].x, vec[i].y - vec[k].y)
		if (dist < vec[k].r
			and vec[k].r > vec[i].r
			and (pad[i] < 0 or vec[k].r < vec[pad[i]].r)):
			pad[i] = k

for i in range(n):
	if pad[i] < 0:
		continue
	gr[pad[i]].append(i)

st = []
ans = 0.0
for i in range(n):
	if pad[i] >= 0 or vis[i]:
		continue
	st.append((i, 0))
	while len(st) > 0:
		node, level = st.pop()
		vis[node] = True
		mult = -1.0
		if level == 0 or level%2 == 1:
			mult = 1.0
		ans += (mult * (vec[node].r * vec[node].r * math.pi))
		for next in gr[node]:
			st.append((next, level+1))

print(ans)





","['dfs and similar', 'dp', 'geometry', 'greedy', 'trees']"
896,"The Alice's computer is broken, so she can't play her favorite card game now. To help Alice, Bob wants to answer $$$n$$$ her questions. Initially, Bob holds one card with number $$$0$$$ in the left hand and one in the right hand. In the $$$i$$$-th question, Alice asks Bob to replace a card in the left or right hand with a card with number $$$k_i$$$ (Bob chooses which of two cards he changes, Bob must replace exactly one card).After this action, Alice wants the numbers on the left and right cards to belong to given segments (segments for left and right cards can be different). Formally, let the number on the left card be $$$x$$$, and on the right card be $$$y$$$. Then after the $$$i$$$-th swap the following conditions must be satisfied: $$$a_{l, i} \le x \le b_{l, i}$$$, and $$$a_{r, i} \le y \le b_{r,i}$$$.Please determine if Bob can answer all requests. If it is possible, find a way to do it. nan from sys import stdin, stdout

n, m = [int(y) for y in stdin.readline().split()]

x = []
left_lower = []
left_upper = []
right_lower = []
right_upper = []

for _ in range(n):
    x.append(int(stdin.readline()))
    y0, y1 = [int(y) for y in stdin.readline().split()]
    left_lower.append(y0)
    left_upper.append(y1)
    y0, y1 = [int(y) for y in stdin.readline().split()]
    right_lower.append(y0)
    right_upper.append(y1)

left_possible = [[m,0] for i in range(n)]
left_possible.append([0,m])
right_possible = [[m,0] for i in range(n)]
right_possible.append([0,m])

for i in range(n-1,-1,-1):
    if left_lower[i] <= x[i] <= left_upper[i]:
        if left_possible[i+1][0] <= x[i] <= left_possible[i+1][1]:
            right_possible[i][0] = right_lower[i]
            right_possible[i][1] = right_upper[i]
        else:
            right_possible[i][0] = max(right_lower[i], right_possible[i+1][0])
            right_possible[i][1] = min(right_upper[i], right_possible[i+1][1])

    if right_lower[i] <= x[i] <= right_upper[i]:
        if right_possible[i+1][0] <= x[i] <= right_possible[i+1][1]:
            left_possible[i][0] = left_lower[i]
            left_possible[i][1] = left_upper[i]
        else:
            left_possible[i][0] = max(left_lower[i], left_possible[i+1][0])
            left_possible[i][1] = min(left_upper[i], left_possible[i+1][1])

if left_possible[0][0] == 0 or right_possible[0][0] == 0:
    stdout.write('YES\n')
    left = 0
    right = 0
    answer = []
    for i in range(n):
        if right_possible[i][0] <= right <= right_possible[i][1]:
            answer.append('0')
            left = x[i]
        else:
            answer.append('1')
            right = x[i]

    stdout.write(' '.join(answer)+'\n')

else:
    stdout.write('NO\n')
","['binary search', 'constructive algorithms', 'data structures', 'dp', 'greedy', 'implementation']"
4885,"This is an interactive problem.Jury initially had a sequence $$$a$$$ of length $$$n$$$, such that $$$a_i = i$$$.The jury chose three integers $$$i$$$, $$$j$$$, $$$k$$$, such that $$$1 \leq i &lt; j &lt; k \leq n$$$, $$$j - i &gt; 1$$$. After that, Jury reversed subsegments $$$[i, j - 1]$$$ and $$$[j, k]$$$ of the sequence $$$a$$$.Reversing a subsegment $$$[l, r]$$$ of the sequence $$$a$$$ means reversing the order of elements $$$a_l, a_{l+1}, \ldots, a_r$$$ in the sequence, i. e. $$$a_l$$$ is swapped with $$$a_r$$$, $$$a_{l+1}$$$ is swapped with $$$a_{r-1}$$$, etc.You are given the number $$$n$$$ and you should find $$$i$$$, $$$j$$$, $$$k$$$ after asking some questions.In one question you can choose two integers $$$l$$$ and $$$r$$$ ($$$1 \leq l \leq r \leq n$$$) and ask the number of inversions on the subsegment $$$[l, r]$$$ of the sequence $$$a$$$. You will be given the number of pairs $$$(i, j)$$$ such that $$$l \leq i &lt; j \leq r$$$, and $$$a_i &gt; a_j$$$.Find the chosen numbers $$$i$$$, $$$j$$$, $$$k$$$ after at most $$$40$$$ questions.The numbers $$$i$$$, $$$j$$$, and $$$k$$$ are fixed before the start of your program and do not depend on your queries. NoteIn the first test case, $$$i = 1$$$, $$$j = 3$$$, $$$k = 5$$$, so the sequence $$$a$$$ is $$$[2, 1, 5, 4, 3]$$$.In the second test case, $$$i = 2$$$, $$$j = 4$$$, $$$k = 5$$$, so the sequence $$$a$$$ is $$$[1, 3, 2, 5, 4]$$$. T = int(input())
import sys
def interact(n):
    print('?',1,n)
    sys.stdout.flush()
    A = int(input())
    ok = n
    ng = 0
    while ok - ng > 1:
        x = (ng + ok) //2
        print('?',1,x)
        sys.stdout.flush()
        rev = int(input())
        if rev == 0:
            ng = x
        else:
            ok = x
    i = ok -1
    print('?',i+1,n)
    sys.stdout.flush()
    B = int(input())
    j = A - B + i + 1
    print('?',j+1,n)
    sys.stdout.flush()
    C = int(input())
    m = j - i
    k = A - (m * (m-1) )//2 + j - C
    print('!',i,j,k)
    sys.stdout.flush()

    


for _ in range(T):
    n = int(input())
    interact(n)","['binary search', 'combinatorics', 'interactive', 'math']"
1871,"Finally, you have defeated Razor and now, you are the Most Wanted street racer. Sergeant Cross has sent the full police force after you in a deadly pursuit. Fortunately, you have found a hiding spot but you fear that Cross and his force will eventually find you. To increase your chances of survival, you want to tune and repaint your BMW M3 GTR.The car can be imagined as a permuted $$$n$$$-dimensional hypercube. A simple $$$n$$$-dimensional hypercube is an undirected unweighted graph built recursively as follows:   Take two simple $$$(n-1)$$$-dimensional hypercubes one having vertices numbered from $$$0$$$ to $$$2^{n-1}-1$$$ and the other having vertices numbered from $$$2^{n-1}$$$ to $$$2^{n}-1$$$. A simple $$$0$$$-dimensional Hypercube is just a single vertex.  Add an edge between the vertices $$$i$$$ and $$$i+2^{n-1}$$$ for each $$$0\leq i &lt; 2^{n-1}$$$. A permuted $$$n$$$-dimensional hypercube is formed by permuting the vertex numbers of a simple $$$n$$$-dimensional hypercube in any arbitrary manner.Examples of a simple and permuted $$$3$$$-dimensional hypercubes are given below:  Note that a permuted $$$n$$$-dimensional hypercube has the following properties:   There are exactly $$$2^n$$$ vertices.  There are exactly $$$n\cdot 2^{n-1}$$$ edges.  Each vertex is connected to exactly $$$n$$$ other vertices.  There are no self-loops or duplicate edges. Let's denote the permutation used to generate the permuted $$$n$$$-dimensional hypercube, representing your car, from a simple $$$n$$$-dimensional hypercube by $$$P$$$. Before messing up the functionalities of the car, you want to find this permutation so that you can restore the car if anything goes wrong. But the job isn't done yet.You have $$$n$$$ different colours numbered from $$$0$$$ to $$$n-1$$$. You want to colour the vertices of this permuted $$$n$$$-dimensional hypercube in such a way that for each and every vertex $$$u$$$ satisfying $$$0\leq u &lt; 2^n$$$ and for each and every colour $$$c$$$ satisfying $$$0\leq c &lt; n$$$, there is at least one vertex $$$v$$$ adjacent to $$$u$$$ having a colour $$$c$$$. In other words, from each and every vertex, it must be possible to reach a vertex of any colour by just moving to an adjacent vertex. Given the permuted $$$n$$$-dimensional hypercube, find any valid permutation $$$P$$$ and colouring. NoteThe colouring and the permuted hypercube for the first test case is shown below:   The colouring and the permuted hypercube for the second test case is shown below:   The permuted hypercube for the third test case is given in the problem statement. However, it can be shown that there exists no way to colour that cube satifying all the conditions. Note that some other permutations like $$$[0, 5, 7, 3, 1, 2, 4, 6]$$$ and $$$[0, 1, 5, 2, 7, 4, 3, 6]$$$ will also give the same permuted hypercube. from collections import deque
from sys import stdin
import sys
 
tt = int(stdin.readline())
 
for loop in range(tt):
 
    n = int(stdin.readline())
 
    lis = [ [] for i in range(2**n)]
 
    for i in range(n*(2**(n-1))):
 
        u,v = map(int,stdin.readline().split())
        lis[u].append(v)
        lis[v].append(u)
 
    rp = [0] * (2**n)
    d = [float(""inf"")] * (2**n)
 
    d[0] = 0
 
    q = deque()
    for i in range(n):
        nexv = lis[0][i]
        rp[nexv] = 2**i
        d[nexv] = 1
        q.append(nexv)
 
    while q:
        v = q.popleft()
        for nexv in lis[v]:
 
            if d[nexv] == float(""inf""):
                d[nexv] = d[v] + 1
                q.append(nexv)
 
            if d[nexv] > d[v]:
                rp[nexv] |= rp[v]
 
    p = [None] * (2**n)
    for i in range(2**n):
        p[rp[i]] = i
 
    print (*p)
 
    if (2**n) % n == 0:
 
        c = [None] * (2**n)
        
        for i in range(2**n):
 
            now = 0
            for j in range(n):
                if 2**j & i > 0:
                    now ^= j
            c[p[i]] = now
 
        print (*c)
 
    else:
        print (-1)","['bitmasks', 'constructive algorithms', 'divide and conquer', 'graphs', 'greedy', 'math']"
1371,"There are $$$n$$$ houses in a row. They are numbered from $$$1$$$ to $$$n$$$ in order from left to right. Initially you are in the house $$$1$$$.You have to perform $$$k$$$ moves to other house. In one move you go from your current house to some other house. You can't stay where you are (i.e., in each move the new house differs from the current house). If you go from the house $$$x$$$ to the house $$$y$$$, the total distance you walked increases by $$$|x-y|$$$ units of distance, where $$$|a|$$$ is the absolute value of $$$a$$$. It is possible to visit the same house multiple times (but you can't visit the same house in sequence).Your goal is to walk exactly $$$s$$$ units of distance in total.If it is impossible, print ""NO"". Otherwise print ""YES"" and any of the ways to do that. Remember that you should do exactly $$$k$$$ moves. nan n,k,s=map(int,input().split())
l=s%k*[s//k+1]+(k-s%k)*[s//k]
for i in range(1,k,2):l[i]=-l[i]
l[0]+=1
for i in range(1,k):l[i]+=l[i-1]
b=k<=s<=k*(n-1)
print(('NO','YES')[b])
if b:print(*l)","['constructive algorithms', 'greedy']"
3554,"Oh no, on the first exam Madoka got this hard problem:Given integer $$$n$$$ and $$$m$$$ pairs of integers ($$$v_i, u_i$$$). Also there is an array $$$b_1, b_2, \ldots, b_n$$$, initially filled with zeros.Then for each index $$$i$$$, where $$$1 \leq i \leq m$$$, perform either $$$b_{v_i} := b_{v_i} - 1$$$ and $$$b_{u_i} := b_{u_i} + 1$$$, or $$$b_{v_i} := b_{v_i} + 1$$$ and $$$b_{u_i} := b_{u_i} - 1$$$. Note that exactly one of these operations should be performed for every $$$i$$$.Also there is an array $$$s$$$ of length $$$n$$$ consisting of $$$0$$$ and $$$1$$$. And there is an array $$$a_1, a_2, \ldots, a_n$$$, where it is guaranteed, that if $$$s_i = 0$$$ holds, then $$$a_i = 0$$$.Help Madoka and determine whenever it is possible to perform operations in such way that for every $$$i$$$, where $$$s_i = 1$$$ it holds that $$$a_i = b_i$$$. If it possible you should also provide Madoka with a way to perform operations. NoteIn the first example, the array $$$b$$$ will change as follows: $$$[0,0,0,0,0] \rightarrow [-1,0,0,1,0] \rightarrow [-2,0,0,1,1] \rightarrow [-2,0,1,0,1] \rightarrow [-2,0,2,0,0] \rightarrow [-2,0,2,1,-1]$$$. $$$a_i = b_i$$$ for all indices $$$i$$$ from $$$1$$$ to $$$5$$$.In the second example, it is enough for us that $$$b_2 = 1$$$ at the end, since only $$$s_2 = 1$$$.In the third example, the operations cannot be performed as required. from collections import deque

import sys
sys.setrecursionlimit(10**4+10)
class mf_graph:
    n=1
    g=[[] for i in range(1)]
    pos=[]
    def __init__(self,N):
        self.n=N
        self.g=[[] for i in range(N)]
        self.pos=[]
    def add_edge(self,From,To,cap):
        assert 0<=From and From<self.n
        assert 0<=To and To<self.n
        assert 0<=cap
        m=len(self.pos)
        self.pos.append((From,len(self.g[From])))
        self.g[From].append({""to"":To,""rev"":len(self.g[To]),""cap"":cap})
        self.g[To].append({""to"":From,""rev"":len(self.g[From])-1,""cap"":0})
        return m
    def get_edge(self,i):
        m=len(self.pos)
        assert 0<=i and i<m
        _e=self.g[self.pos[i][0]][self.pos[i][1]]
        _re=self.g[_e[""to""]][_e[""rev""]]
        return {""from"":self.pos[i][0],
                ""to"":_e[""to""],
                ""cap"":_e[""cap""]+_re[""cap""],
                ""flow"":_re[""cap""]}
    def edges(self):
        m=len(self.pos)
        result=[]
        for i in range(m):
            result.append(self.get_edge(i))
        return result
    def change_edge(self,i,new_cap,new_flow):
        m=len(self.pos)
        assert 0<=i and i<m
        assert 0<=new_flow and new_flow<=new_cap
        _e=self.g[self.pos[i][0]][self.pos[i][1]]
        _re=self.g[_e[""to""]][_e[""rev""]]
        _e[""cap""]=new_cap-new_flow
        _re[""cap""]=new_flow
    def flow(self,s,t,flow_limit=(1<<63)-1):
        assert 0<=s and s<self.n
        assert 0<=t and t<self.n
        level=[0 for i in range(self.n)]
        Iter=[0 for i in range(self.n)]
        que=deque([])
        def bfs():
            for i in range(self.n):level[i]=-1
            level[s]=0
            que=deque([])
            que.append(s)
            while(len(que)>0):
                v=que.popleft()
                for e in self.g[v]:
                    if e[""cap""]==0 or level[e[""to""]]>=0:continue
                    level[e[""to""]]=level[v]+1
                    if e[""to""]==t:return
                    que.append(e[""to""])
        def dfs(func,v,up):
            if (v==s):return up
            res=0
            level_v=level[v]
            for i in range(Iter[v],len(self.g[v])):
                e=self.g[v][i]
                if (level_v<=level[e[""to""]] or self.g[e[""to""]][e[""rev""]][""cap""]==0):continue
                d=func(func,e[""to""],min(up-res,self.g[e[""to""]][e[""rev""]][""cap""]))
                if d<=0:continue
                self.g[v][i][""cap""]+=d
                self.g[e[""to""]][e[""rev""]][""cap""]-=d
                res+=d
                if res==up:return res
            level[v]=self.n
            return res
        flow=0
        while(flow<flow_limit):
            bfs()
            if level[t]==-1:break
            for i in range(self.n):Iter[i]=0
            while(flow<flow_limit):
                f=dfs(dfs,t,flow_limit-flow)
                if not(f):break
                flow+=f
        return flow
    def min_cut(self,s):
        visited=[False for i in range(self.n)]
        que=deque([])
        que.append(s)
        while(len(que)>0):
            p=que.popleft()
            visited[p]=True
            for e in self.g[p]:
                if e[""cap""] and not(visited[e[""to""]]):
                    visited[e[""to""]]=True
                    que.append(e[""to""])
        return

from sys import stdin
input=lambda :stdin.readline()[:-1]


n,m=map(int,input().split())
s=list(map(int,input().split()))
a=list(map(int,input().split()))
g=mf_graph(n+m+2)
S=n+m
T=S+1
tmp=[0]*n
edges=[]
edge1=[]
edge2=[]
for i in range(m):
  x,y=map(lambda x:int(x)-1,input().split())
  tmp[x]+=1
  tmp[y]+=1
  if s[x]==1 and s[y]==1:
    edge1.append((x,y,i))
  elif s[x]==1 or s[y]==1:
    edge2.append((x,y,i))
  edges.append((x,y))
  
cnt=0
for i in range(n):
  if s[i]==1:
    if a[i]>tmp[i] or (tmp[i]-a[i])%2==1:
      print('NO')
      exit()
    t=(tmp[i]-a[i])//2
    if t!=0:
      g.add_edge(i,T,t)
      cnt+=t

for x,y,i in edge1:
  g.add_edge(S,n+i,1)
  g.add_edge(n+i,x,1)
  g.add_edge(n+i,y,1)

ans_flow=g.flow(S,T)
for x,y,i in edge2:
  g.add_edge(S,n+i,1)
  g.add_edge(n+i,x,1)
  g.add_edge(n+i,y,1)
ans_flow+=g.flow(S,T)
if ans_flow!=cnt:
  print('NO')
  exit()

ans=[-1]*m
for e in g.edges():
  frm=e['from']-n
  if 0<=frm<m:
    to=e['to']
    if e['flow']!=0:
      ans[frm]=to

ANS=[]
for i in range(m):
  x,y=edges[i]
  if ans[i]!=-1:
    if ans[i]==x:
      ANS.append((x,y))
    else:
      ANS.append((y,x))
  else:
    if s[x]==0:
      ANS.append((x,y))
    elif s[y]==0:
      ANS.append((y,x))
    else:
      print('NO')
      exit()

print('YES')
for x,y in ANS:
  print(x+1,y+1)","['constructive algorithms', 'graphs', 'implementation', 'other']"
907,"In 2013, the writers of Berland State University should prepare problems for n Olympiads. We will assume that the Olympiads are numbered with consecutive integers from 1 to n. For each Olympiad we know how many members of the jury must be involved in its preparation, as well as the time required to prepare the problems for her. Namely, the Olympiad number i should be prepared by pi people for ti days, the preparation for the Olympiad should be a continuous period of time and end exactly one day before the Olympiad. On the day of the Olympiad the juries who have prepared it, already do not work on it.For example, if the Olympiad is held on December 9th and the preparation takes 7 people and 6 days, all seven members of the jury will work on the problems of the Olympiad from December, 3rd to December, 8th (the jury members won't be working on the problems of this Olympiad on December 9th, that is, some of them can start preparing problems for some other Olympiad). And if the Olympiad is held on November 3rd and requires 5 days of training, the members of the jury will work from October 29th to November 2nd.In order not to overload the jury the following rule was introduced: one member of the jury can not work on the same day on the tasks for different Olympiads. Write a program that determines what the minimum number of people must be part of the jury so that all Olympiads could be prepared in time. nan w=open('output.txt', 'w')
r=open('input.txt', 'r')
s=[0]*466
y=[0, 100, 131, 159, 190, 220, 251, 281, 312, 343, 373, 404, 434]
n=int(r.readline())
for i in range(n):
    m, d, p, t = map(int, r.readline().split())
    x = y[m] + d
    s[x] -= p
    s[x - t] += p
for i in range(465):
    s[i + 1] += s[i]
w.write(str(max(s)))","['brute force', 'implementation']"
756,"You still have partial information about the score during the historic football match. You are given a set of pairs $$$(a_i, b_i)$$$, indicating that at some point during the match the score was ""$$$a_i$$$: $$$b_i$$$"". It is known that if the current score is «$$$x$$$:$$$y$$$», then after the goal it will change to ""$$$x+1$$$:$$$y$$$"" or ""$$$x$$$:$$$y+1$$$"". What is the largest number of times a draw could appear on the scoreboard?The pairs ""$$$a_i$$$:$$$b_i$$$"" are given in chronological order (time increases), but you are given score only for some moments of time. The last pair corresponds to the end of the match. NoteIn the example one of the possible score sequences leading to the maximum number of draws is as follows: 0:0, 1:0, 2:0, 2:1, 3:1, 3:2, 3:3, 3:4. def main():
    n = int(input())
    a1, b1 = 0, 0
    ans = 1
    for i in range(n):
        a2, b2 = map(int, input().split())
        if a2 == a1 and b2 == b1:
            continue
        ans += max(0, min(a2, b2) - max(a1, b1) + 1)
        if a1 == b1:
            ans -= 1
        a1 = a2
        b1 = b2
    print(ans)


main()
","['greedy', 'implementation']"
561,"A string is called a k-string if it can be represented as k concatenated copies of some string. For example, the string ""aabaabaabaab"" is at the same time a 1-string, a 2-string and a 4-string, but it is not a 3-string, a 5-string, or a 6-string and so on. Obviously any string is a 1-string.You are given a string s, consisting of lowercase English letters and a positive integer k. Your task is to reorder the letters in the string s in such a way that the resulting string is a k-string. nan from sys import stdin
rr = lambda: stdin.readline().strip()
rri = lambda: int(rr())
rrm = lambda: map(int, rr().split())
def rry(N = None, f = rri):
    for i in xrange(N or rri()):
        yield f()

K = rri()
S = rr()
from collections import Counter
count = Counter(S)
if any(v % K for v in count.values()):
	print -1
else:
	ans = ''
	for k,v in count.iteritems():
		ans += k * (v/K)
	print ans*K","['implementation', 'strings']"
2331,"  William has two numbers $$$a$$$ and $$$b$$$ initially both equal to zero. William mastered performing three different operations with them quickly. Before performing each operation some positive integer $$$k$$$ is picked, which is then used to perform one of the following operations: (note, that for each operation you can choose a new positive integer $$$k$$$)  add number $$$k$$$ to both $$$a$$$ and $$$b$$$, or  add number $$$k$$$ to $$$a$$$ and subtract $$$k$$$ from $$$b$$$, or  add number $$$k$$$ to $$$b$$$ and subtract $$$k$$$ from $$$a$$$. Note that after performing operations, numbers $$$a$$$ and $$$b$$$ may become negative as well.William wants to find out the minimal number of operations he would have to perform to make $$$a$$$ equal to his favorite number $$$c$$$ and $$$b$$$ equal to his second favorite number $$$d$$$. NoteLet us demonstrate one of the suboptimal ways of getting a pair $$$(3, 5)$$$:  Using an operation of the first type with $$$k=1$$$, the current pair would be equal to $$$(1, 1)$$$.  Using an operation of the third type with $$$k=8$$$, the current pair would be equal to $$$(-7, 9)$$$.  Using an operation of the second type with $$$k=7$$$, the current pair would be equal to $$$(0, 2)$$$.  Using an operation of the first type with $$$k=3$$$, the current pair would be equal to $$$(3, 5)$$$.  for _ in range(int(input())):
    a,b=map(int,input().split())
    if a==0 and b==0:
        print(0)
    elif a==b:
        print(1)
    elif abs(a-b)&1==0:
        print(2)
    else:
        print(-1)",['math']
4415,"The clique problem is one of the most well-known NP-complete problems. Under some simplification it can be formulated as follows. Consider an undirected graph G. It is required to find a subset of vertices C of the maximum size such that any two of them are connected by an edge in graph G. Sounds simple, doesn't it? Nobody yet knows an algorithm that finds a solution to this problem in polynomial time of the size of the graph. However, as with many other NP-complete problems, the clique problem is easier if you consider a specific type of a graph.Consider n distinct points on a line. Let the i-th point have the coordinate xi and weight wi. Let's form graph G, whose vertices are these points and edges connect exactly the pairs of points (i, j), such that the distance between them is not less than the sum of their weights, or more formally: |xi - xj| ≥ wi + wj.Find the size of the maximum clique in such graph. NoteIf you happen to know how to solve this problem without using the specific properties of the graph formulated in the problem statement, then you are able to get a prize of one million dollars!The picture for the sample test.   n = int(input())
x = [0] * n
w = [0] * n
for i in range(n):
    x[i], w[i] = map(int, input().split())
xw = [[0] * 2 for _ in range(n)]
for i in range(n):
    xw[i][0] = x[i] + w[i]
    xw[i][1] = x[i] - w[i]
xw.sort()
now = xw[0][1]
ans = 0
for i in range(n):
    if now <= xw[i][1]:
        now = xw[i][0]
        ans += 1
print(ans)","['dp', 'greedy']"
1803,"In Berland, there is the national holiday coming — the Flag Day. In the honor of this event the president of the country decided to make a big dance party and asked your agency to organize it. He has several conditions:  overall, there must be m dances; exactly three people must take part in each dance; each dance must have one dancer in white clothes, one dancer in red clothes and one dancer in blue clothes (these are the colors of the national flag of Berland). The agency has n dancers, and their number can be less than 3m. That is, some dancers will probably have to dance in more than one dance. All of your dancers must dance on the party. However, if some dance has two or more dancers from a previous dance, then the current dance stops being spectacular. Your agency cannot allow that to happen, so each dance has at most one dancer who has danced in some previous dance. You considered all the criteria and made the plan for the m dances: each dance had three dancers participating in it. Your task is to determine the clothes color for each of the n dancers so that the President's third condition fulfilled: each dance must have a dancer in white, a dancer in red and a dancer in blue. The dancers cannot change clothes between the dances. nan def dancers(n,m,arr):
    dancers = [0]*(n+1)
    for each in arr:
        current = [1,2,3]
        for i in each:
            if dancers[i] != 0:
                current.remove(dancers[i])
        for i in each:
            if dancers[i] == 0:
                dancers[i] = current[0]
                current.pop(0)
    for i in range(1,n+1):
        print(dancers[i],end = "" "")

n,m = map(int,input().split())
l = []
for i in range(m):
    l.append(list(map(int,input().split())))
dancers(n,m,l)","['constructive algorithms', 'implementation']"
3434,"Petya once wrote a sad love song and shared it to Vasya. The song is a string consisting of lowercase English letters. Vasya made up $$$q$$$ questions about this song. Each question is about a subsegment of the song starting from the $$$l$$$-th letter to the $$$r$$$-th letter. Vasya considers a substring made up from characters on this segment and repeats each letter in the subsegment $$$k$$$ times, where $$$k$$$ is the index of the corresponding letter in the alphabet. For example, if the question is about the substring ""abbcb"", then Vasya repeats letter 'a' once, each of the letters 'b' twice, letter 'c"" three times, so that the resulting string is ""abbbbcccbb"", its length is $$$10$$$. Vasya is interested about the length of the resulting string.Help Petya find the length of each string obtained by Vasya. NoteIn the first example Vasya is interested in three questions. In the first question Vasya considers the substring ""aba"", that transforms to ""abba"", so the answer is equal to $$$4$$$. In the second question Vasya considers ""baca"", that transforms to ""bbaccca"", so the answer is $$$7$$$. In the third question Vasya considers the string ""abacaba"",that transforms to ""abbacccabba"" of length $$$11$$$. n, t = map(int, input().split())
ui = input()
req = [0 for z in range(n + 1)]
for i, res in enumerate(ui):
    req[i + 1] = req[i] + (ord(res) - 96)
for q in range(t):
    l, r = map(int, input().split())
    print(req[r] - req[l - 1])","['dp', 'implementation', 'strings']"
2688,"You are given an integer $$$x$$$ and an array of integers $$$a_1, a_2, \ldots, a_n$$$. You have to determine if the number $$$a_1! + a_2! + \ldots + a_n!$$$ is divisible by $$$x!$$$.Here $$$k!$$$ is a factorial of $$$k$$$ — the product of all positive integers less than or equal to $$$k$$$. For example, $$$3! = 1 \cdot 2 \cdot 3 = 6$$$, and $$$5! = 1 \cdot 2 \cdot 3 \cdot 4 \cdot 5 = 120$$$. NoteIn the first example $$$3! + 2! + 2! + 2! + 3! + 3! = 6 + 2 + 2 + 2 + 6 + 6 = 24$$$. Number $$$24$$$ is divisible by $$$4! = 24$$$.In the second example $$$3! + 2! + 2! + 2! + 2! + 2! + 1! + 1! = 18$$$, is divisible by $$$3! = 6$$$.In the third example $$$7! + 7! + 7! + 7! + 7! + 7! + 7! = 7 \cdot 7!$$$. It is easy to prove that this number is not divisible by $$$8!$$$. n,val=map(int,input().split())
if val==1:
    print('Yes')
else:
    numeri=list(map(int,input().split())) 
    m=min(numeri)
    occorrenze=[0]*(val-m+1)
    for i in numeri:
        occorrenze[i-m]=occorrenze[i-m]+1   
    for j in range(len(occorrenze)-1):
        if occorrenze[j]%(j+m+1)!=0:
            print('No')
            quit()
        elif j<len(occorrenze)-1:
            occorrenze[j+1]=occorrenze[j+1]+(occorrenze[j]//(j+m+1))
    print('Yes')
  ","['math', 'number theory']"
2817,"You are looking at the floor plan of the Summer Informatics School's new building. You were tasked with SIS logistics, so you really care about travel time between different locations: it is important to know how long it would take to get from the lecture room to the canteen, or from the gym to the server room.The building consists of n towers, h floors each, where the towers are labeled from 1 to n, the floors are labeled from 1 to h. There is a passage between any two adjacent towers (two towers i and i + 1 for all i: 1 ≤ i ≤ n - 1) on every floor x, where a ≤ x ≤ b. It takes exactly one minute to walk between any two adjacent floors of a tower, as well as between any two adjacent towers, provided that there is a passage on that floor. It is not permitted to leave the building. The picture illustrates the first example. You have given k pairs of locations (ta, fa), (tb, fb): floor fa of tower ta and floor fb of tower tb. For each pair you need to determine the minimum walking time between these locations. nan from sys import stdin
n,h,a,b,k = map(int,stdin.readline().split())
for _ in xrange(k):
    t1,f1,t2,f2 = map(int,stdin.readline().split())
    ans = abs(t1-t2)
    if t1 !=t2:
        if f1 < a:
            ans += a-f1
            f1 = a
        if f1 > b:
            ans += f1 - b
            f1 = b
    ans += abs(f1-f2)
    print ans
        
    ",['math']
4429,"Professor Phunsuk Wangdu has performed some experiments on rays. The setup for n rays is as follows.There is a rectangular box having exactly n holes on the opposite faces. All rays enter from the holes of the first side and exit from the holes of the other side of the box. Exactly one ray can enter or exit from each hole. The holes are in a straight line.  Professor Wangdu is showing his experiment to his students. He shows that there are cases, when all the rays are intersected by every other ray. A curious student asked the professor: ""Sir, there are some groups of rays such that all rays in that group intersect every other ray in that group. Can we determine the number of rays in the largest of such groups?"".Professor Wangdu now is in trouble and knowing your intellect he asks you to help him. NoteFor the first test case, the figure is shown above. The output of the first test case is 3, since the rays number 1, 4 and 3 are the ones which are intersected by each other one i.e. 1 is intersected by 4 and 3, 3 is intersected by 4 and 1, and 4 is intersected by 1 and 3. Hence every ray in this group is intersected by each other one. There does not exist any group containing more than 3 rays satisfying the above-mentioned constraint. from bisect import bisect_left as bl
I=10000000
n=int(input())+1
c=[0]*n
for i,x in enumerate(map(int,input().split())): c[x]=i
d = [n-c[int(x)] for x in input().split()]
c=[I]*n
for i in d: c[bl(c,i)]=i
print( c.index(I))","['binary search', 'data structures', 'dp']"
1425,"The Looksery company, consisting of n staff members, is planning another big party. Every employee has his phone number and the phone numbers of his friends in the phone book. Everyone who comes to the party, sends messages to his contacts about how cool it is. At the same time everyone is trying to spend as much time on the fun as possible, so they send messages to everyone without special thinking, moreover, each person even sends a message to himself or herself.Igor and Max, Looksery developers, started a dispute on how many messages each person gets. Igor indicates n numbers, the i-th of which indicates how many messages, in his view, the i-th employee is going to take. If Igor guesses correctly at least one of these numbers, he wins, otherwise Max wins.You support Max in this debate, so you need, given the contact lists of the employees, to determine whether there is a situation where Igor loses. Specifically, you need to determine which employees should come to the party, and which should not, so after all the visitors send messages to their contacts, each employee received a number of messages that is different from what Igor stated. NoteIn the first sample Igor supposes that the first employee will receive 0 messages. Since he isn't contained in any other contact list he must come to the party in order to receive one message from himself. If he is the only who come to the party then he will receive 1 message, the second employee will receive 0 messages and the third will also receive 1 message. Thereby Igor won't guess any number.In the second sample if the single employee comes to the party he receives 1 message and Igor wins, so he shouldn't do it.In the third sample the first employee will receive 2 messages, the second — 3, the third — 2, the fourth — 3. n=int(input().strip())

nums=['']+[' '+input().strip() for _ in range(n)]
a=[0]+list(map(int,input().split()))


def send(x):
    for i in range(1,n+1):
        if nums[x][i]=='1':
            a[i]-=1

vis=[0]*(n+1)
while True:
    for i in range(1,n+1):
        if not vis[i] and not a[i]:
            vis[i]=1
            send(i)
            break
    else:
        for i in range(1,n+1):
            if not a[i]:
                print(-1)
                exit()
        break


ans=[]
for i in range(1,n+1):
    if vis[i]:
        ans.append(i)

if ans:
    print(len(ans))
    print(*ans)
else:
    print(0)
","['constructive algorithms', 'dfs and similar', 'graphs', 'greedy']"
1595,"A row of $$$n$$$ cells is given, all initially white. Using a stamp, you can stamp any two neighboring cells such that one becomes red and the other becomes blue. A stamp can be rotated, i.e. it can be used in both ways: as $$$\color{blue}{\texttt{B}}\color{red}{\texttt{R}}$$$ and as $$$\color{red}{\texttt{R}}\color{blue}{\texttt{B}}$$$.During use, the stamp must completely fit on the given $$$n$$$ cells (it cannot be partially outside the cells). The stamp can be applied multiple times to the same cell. Each usage of the stamp recolors both cells that are under the stamp.For example, one possible sequence of stamps to make the picture $$$\color{blue}{\texttt{B}}\color{red}{\texttt{R}}\color{blue}{\texttt{B}}\color{blue}{\texttt{B}}\texttt{W}$$$ could be $$$\texttt{WWWWW} \to \texttt{WW}\color{brown}{\underline{\color{red}{\texttt{R}}\color{blue}{\texttt{B}}}}\texttt{W} \to \color{brown}{\underline{\color{blue}{\texttt{B}}\color{red}{\texttt{R}}}}\color{red}{\texttt{R}}\color{blue}{\texttt{B}}\texttt{W} \to \color{blue}{\texttt{B}}\color{brown}{\underline{\color{red}{\texttt{R}}\color{blue}{\texttt{B}}}}\color{blue}{\texttt{B}}\texttt{W}$$$. Here $$$\texttt{W}$$$, $$$\color{red}{\texttt{R}}$$$, and $$$\color{blue}{\texttt{B}}$$$ represent a white, red, or blue cell, respectively, and the cells that the stamp is used on are marked with an underline.Given a final picture, is it possible to make it using the stamp zero or more times? NoteThe first test case is explained in the statement.For the second, third, and fourth test cases, it is not possible to stamp a single cell, so the answer is ""NO"".For the fifth test case, you can use the stamp as follows: $$$\texttt{WWW} \to \texttt{W}\color{brown}{\underline{\color{red}{\texttt{R}}\color{blue}{\texttt{B}}}} \to \color{brown}{\underline{\color{blue}{\texttt{B}}\color{red}{\texttt{R}}}}\color{blue}{\texttt{B}}$$$.For the sixth test case, you can use the stamp as follows: $$$\texttt{WWW} \to \texttt{W}\color{brown}{\underline{\color{red}{\texttt{R}}\color{blue}{\texttt{B}}}} \to \color{brown}{\underline{\color{red}{\texttt{R}}\color{blue}{\texttt{B}}}}\color{blue}{\texttt{B}}$$$.For the seventh test case, you don't need to use the stamp at all. def check(str_s):
    for s in str_s:
        if(len(s) == 0):
            continue
        if(len(s) == 1 or (len(s) == s.count(""R"")) or (len(s) == s.count(""B""))):
            print(""no"")
            return
        # else:
        #     for i in range(len(s)-1):
        #         j = i+1
        #         while(j < len(s) and s[i] == s[j]):
        #             j += 1
        #         if(j >= len(s) and i == 0):
        #             print(""no"")
        #             return
        #         i = j
    print(""yes"")
    return



t = int(input())

for i in range(t):
    n = input()
    str_s = input().split(""W"")
    check(str_s)",['implementation']
994,"Konrad is a Human Relations consultant working for VoltModder, a large electrical equipment producer. Today, he has been tasked with evaluating the level of happiness in the company.There are $$$n$$$ people working for VoltModder, numbered from $$$1$$$ to $$$n$$$. Each employee earns a different amount of money in the company — initially, the $$$i$$$-th person earns $$$i$$$ rubles per day.On each of $$$q$$$ following days, the salaries will be revised. At the end of the $$$i$$$-th day, employee $$$v_i$$$ will start earning $$$n+i$$$ rubles per day and will become the best-paid person in the company. The employee will keep his new salary until it gets revised again.Some pairs of people don't like each other. This creates a great psychological danger in the company. Formally, if two people $$$a$$$ and $$$b$$$ dislike each other and $$$a$$$ earns more money than $$$b$$$, employee $$$a$$$ will brag about this to $$$b$$$. A dangerous triple is a triple of three employees $$$a$$$, $$$b$$$ and $$$c$$$, such that $$$a$$$ brags to $$$b$$$, who in turn brags to $$$c$$$. If $$$a$$$ dislikes $$$b$$$, then $$$b$$$ dislikes $$$a$$$.At the beginning of each day, Konrad needs to evaluate the number of dangerous triples in the company. Can you help him do it? NoteConsider the first sample test. The $$$i$$$-th row in the following image shows the structure of the company at the beginning of the $$$i$$$-th day. A directed edge from $$$a$$$ to $$$b$$$ denotes that employee $$$a$$$ brags to employee $$$b$$$. The dangerous triples are marked by highlighted edges.   import sys
input = sys.stdin.readline

n,m=map(int,input().split())

IN=[0]*n
OUT=[0]*n

INSET=[[] for i in range(n)]

for i in range(m):
    x,y=sorted(map(int,input().split()))

    IN[x-1]+=1
    OUT[y-1]+=1
    INSET[x-1].append(y-1)

ANS=0
for i in range(n):
    ANS+=IN[i]*OUT[i]

print(ANS)

Q=int(input())

for i in range(Q):
    q=int(input())-1
    ANS-=IN[q]*OUT[q]
    OUT[q]+=IN[q]
    IN[q]=0

    for x in INSET[q]:
        INSET[x].append(q)
        ANS+=(IN[x]+1)*(OUT[x]-1)-IN[x]*OUT[x]
        IN[x]+=1
        OUT[x]-=1

    INSET[q]=[]

    print(ANS)
","['brute force', 'graphs']"
1200,"A has a string consisting of some number of lowercase English letters 'a'. He gives it to his friend B who appends some number of letters 'b' to the end of this string. Since both A and B like the characters 'a' and 'b', they have made sure that at this point, at least one 'a' and one 'b' exist in the string.B now gives this string to C and he appends some number of letters 'c' to the end of the string. However, since C is a good friend of A and B, the number of letters 'c' he appends is equal to the number of 'a' or to the number of 'b' in the string. It is also possible that the number of letters 'c' equals both to the number of letters 'a' and to the number of letters 'b' at the same time.You have a string in your hands, and you want to check if it is possible to obtain the string in this way or not. If it is possible to obtain the string, print ""YES"", otherwise print ""NO"" (without the quotes). NoteConsider first example: the number of 'c' is equal to the number of 'a'. Consider second example: although the number of 'c' is equal to the number of the 'b', the order is not correct.Consider third example: the number of 'c' is equal to the number of 'b'. from sys import stdin
ans = 'YES'
a  = stdin.readline().strip()
x = a.count('a')
if x==0:
    ans = 'NO'
elif a[:x]!= 'a' * x:
    ans = 'NO'
else:
    a = a[x:]
    y = a.count('b')
    if y==0:
        ans = 'NO'
    elif a[:y]!='b'*y:
        ans = 'NO'
    else:
        a = a[y:]
        z = len(a)
        if a!= 'c' * z:
            ans = 'NO'
        elif z!=x and z!=y:
            ans = 'NO'
print ans",['implementation']
1115,"Vasya has several phone books, in which he recorded the telephone numbers of his friends. Each of his friends can have one or several phone numbers.Vasya decided to organize information about the phone numbers of friends. You will be given n strings — all entries from Vasya's phone books. Each entry starts with a friend's name. Then follows the number of phone numbers in the current entry, and then the phone numbers themselves. It is possible that several identical phones are recorded in the same record.Vasya also believes that if the phone number a is a suffix of the phone number b (that is, the number b ends up with a), and both numbers are written by Vasya as the phone numbers of the same person, then a is recorded without the city code and it should not be taken into account.The task is to print organized information about the phone numbers of Vasya's friends. It is possible that two different people have the same number. If one person has two numbers x and y, and x is a suffix of y (that is, y ends in x), then you shouldn't print number x. If the number of a friend in the Vasya's phone books is recorded several times in the same format, it is necessary to take it into account exactly once.Read the examples to understand statement and format of the output better. nan def cleaner(l):
    l = list(set(l))
    l.sort()
    ans=[]
    for i in range(len(l)):
        for j in range(0,len(l)):
            if l[j].endswith(l[i]) and i!=j:
                break
        else:
            ans+=[l[i]]
    return ans
d = dict()
for t in range(int(input())):
    l = [x for x in input().split("" "")]
    name,x = l[0],[1]
    l = l[2:]
    if name in d:
        d[name]+=l
    else:
        d[name]=l
keys = d.keys()
print(len(keys))
for k in keys:
    l = cleaner(d[k])
    print(k,len(l),*l)","['implementation', 'strings']"
2520,"Fibonacci strings are defined as follows:   f1 = «a»  f2 = «b»  fn = fn - 1 fn - 2, n &gt; 2 Thus, the first five Fibonacci strings are: ""a"", ""b"", ""ba"", ""bab"", ""babba"".You are given a Fibonacci string and m strings si. For each string si, find the number of times it occurs in the given Fibonacci string as a substring. nan F = ['', 'a', 'b', 'ba', 'bab', 'babba', 'babbabab', 'babbababbabba', 'babbababbabbababbabab', 'babbababbabbababbababbabbababbabba', 'babbababbabbababbababbabbababbabbababbababbabbababbabab', 'babbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabba', 'babbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabab', 'babbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabba', 'babbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabab', 'babbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabba', 'babbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabab', 'babbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabba', 'babbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabab', 'babbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabba', 'babbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabab']
d = 1000000007

def sqr(t):
    return [[sum(t[i][k] * t[k][j] for k in range(4)) % d for j in range(4)] for i in range(4)]

def mul(a, b):
    return [[sum(a[i][k] * b[k][j] for k in range(4)) % d for j in range(4)] for i in range(4)]

def fib(k):
    s, p = format(k, 'b')[:: -1], [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]
    t = [[[0, 1, 0, 0], [1, 1, 1, 0], [0, 0, 0, 1], [0, 0, 1, 0]]] + [0] * (len(s) - 1)
    for i in range(1, len(s)):
        t[i] = sqr(t[i - 1])        
    for i, k in enumerate(s):
        if k == '1': p = mul(p, t[i])        
    return p

def cnt(t, p):
    s, i = 0, p.find(t) + 1
    while i > 0:
        i = p.find(t, i) + 1
        s += 1
    return s

def f(t, p, k):
    l = len(t) - 1
    if l: x, y = cnt(t, F[k - 1][- l: ] + F[k][:l ]), cnt(t, F[k][- l: ] + F[k + 1][:l ])
    else: x, y = 0, 0
    a, b = cnt(t, F[k - 1]), cnt(t, F[k])
    return (p[0] * a + p[1] * b + p[2] * y + p[3] * x) % d
      
k, m = map(int, input().split())
if k > 15:
    a, b = fib(k - 7)[0], fib(k - 18)[0]
    for i in range(m):
        t = input()
        if len(t) < len(F[7]): print(f(t, a, 8))
        else: print(f(t, b, 19))
else:
    p = F[k]
    for i in range(m):
        print(cnt(input(), p))
",['strings']
4852,"You are given two arrays $$$a$$$ and $$$b$$$ both consisting of $$$n$$$ positive (greater than zero) integers. You are also given an integer $$$k$$$.In one move, you can choose two indices $$$i$$$ and $$$j$$$ ($$$1 \le i, j \le n$$$) and swap $$$a_i$$$ and $$$b_j$$$ (i.e. $$$a_i$$$ becomes $$$b_j$$$ and vice versa). Note that $$$i$$$ and $$$j$$$ can be equal or different (in particular, swap $$$a_2$$$ with $$$b_2$$$ or swap $$$a_3$$$ and $$$b_9$$$ both are acceptable moves).Your task is to find the maximum possible sum you can obtain in the array $$$a$$$ if you can do no more than (i.e. at most) $$$k$$$ such moves (swaps).You have to answer $$$t$$$ independent test cases. NoteIn the first test case of the example, you can swap $$$a_1 = 1$$$ and $$$b_2 = 4$$$, so $$$a=[4, 2]$$$ and $$$b=[3, 1]$$$.In the second test case of the example, you don't need to swap anything.In the third test case of the example, you can swap $$$a_1 = 1$$$ and $$$b_1 = 10$$$, $$$a_3 = 3$$$ and $$$b_3 = 10$$$ and $$$a_2 = 2$$$ and $$$b_4 = 10$$$, so $$$a=[10, 10, 10, 4, 5]$$$ and $$$b=[1, 9, 3, 2, 9]$$$.In the fourth test case of the example, you cannot swap anything.In the fifth test case of the example, you can swap arrays $$$a$$$ and $$$b$$$, so $$$a=[4, 4, 5, 4]$$$ and $$$b=[1, 2, 2, 1]$$$. for _ in range(int(input())):
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))
    for i in range(k):
        if max(b) > min(a):
            x = a.index(min(a))
            y = b.index(max(b))
            a[x] = a[x]+b[y]
            b[y] = a[x] - b[y]
            a[x] = a[x] - b[y]
    print(sum(a))
","['greedy', 'sortings']"
4863,"Oleg the bank client and Igor the analyst are arguing again. This time, they want to pick a gift as a present for their friend, ZS the coder. After a long thought, they decided that their friend loves to eat carrots the most and thus they want to pick the best carrot as their present.There are n carrots arranged in a line. The i-th carrot from the left has juiciness ai. Oleg thinks ZS loves juicy carrots whereas Igor thinks that he hates juicy carrots. Thus, Oleg would like to maximize the juiciness of the carrot they choose while Igor would like to minimize the juiciness of the carrot they choose.To settle this issue, they decided to play a game again. Oleg and Igor take turns to play the game. In each turn, a player can choose a carrot from either end of the line, and eat it. The game ends when only one carrot remains. Oleg moves first. The last remaining carrot will be the carrot that they will give their friend, ZS.Oleg is a sneaky bank client. When Igor goes to a restroom, he performs k moves before the start of the game. Each move is the same as above (eat a carrot from either end of the line). After Igor returns, they start the game with Oleg still going first. Oleg wonders: for each k such that 0 ≤ k ≤ n - 1, what is the juiciness of the carrot they will give to ZS if he makes k extra moves beforehand and both players play optimally? NoteFor the first example, When k = 0, one possible optimal game is as follows: Oleg eats the carrot with juiciness 1. Igor eats the carrot with juiciness 5. Oleg eats the carrot with juiciness 2. The remaining carrot has juiciness 3.When k = 1, one possible optimal play is as follows: Oleg eats the carrot with juiciness 1 beforehand. Oleg eats the carrot with juiciness 2. Igor eats the carrot with juiciness 5. The remaining carrot has juiciness 3.When k = 2, one possible optimal play is as follows: Oleg eats the carrot with juiciness 1 beforehand. Oleg eats the carrot with juiciness 2 beforehand. Oleg eats the carrot with juiciness 3. The remaining carrot has juiciness 5.When k = 3, one possible optimal play is as follows: Oleg eats the carrot with juiciness 1 beforehand. Oleg eats the carrot with juiciness 2 beforehand. Oleg eats the carrot with juiciness 3 beforehand. The remaining carrot has juiciness 5.Thus, the answer is 3, 3, 5, 5.For the second sample, Oleg can always eat the carrot with juiciness 1 since he always moves first. So, the remaining carrot will always have juiciness 1000000000. def evens(A):
    n = len(A)
    l = n//2-1; r = n//2
    if len(A)%2 == 1: l+= 1
    ans = [max(A[l], A[r])]
    while r < n-1:
        l-= 1; r+= 1
        ans.append(max(ans[-1], A[l], A[r]))
    return ans

def interleave(A, B):
    q = []
    for i in range(len(B)): q+= [A[i], B[i]]
    if len(A) != len(B): q.append(A[-1])
    return q

n = int(input())
A = list(map(int,input().split()))
M = [min(A[i],A[i+1]) for i in range(n-1)]
ansA = evens(A)
ansM = evens(M) if n>1 else []
if n%2 == 0: print(*interleave(ansA, ansM[1:]), max(A))
else: print(*interleave(ansM, ansA[1:]), max(A))","['games', 'math']"
1471,"Vasya has got a robot which is situated on an infinite Cartesian plane, initially in the cell $$$(0, 0)$$$. Robot can perform the following four kinds of operations:   U — move from $$$(x, y)$$$ to $$$(x, y + 1)$$$;  D — move from $$$(x, y)$$$ to $$$(x, y - 1)$$$;  L — move from $$$(x, y)$$$ to $$$(x - 1, y)$$$;  R — move from $$$(x, y)$$$ to $$$(x + 1, y)$$$. Vasya also has got a sequence of $$$n$$$ operations. Vasya wants to modify this sequence so after performing it the robot will end up in $$$(x, y)$$$.Vasya wants to change the sequence so the length of changed subsegment is minimum possible. This length can be calculated as follows: $$$maxID - minID + 1$$$, where $$$maxID$$$ is the maximum index of a changed operation, and $$$minID$$$ is the minimum index of a changed operation. For example, if Vasya changes RRRRRRR to RLRRLRL, then the operations with indices $$$2$$$, $$$5$$$ and $$$7$$$ are changed, so the length of changed subsegment is $$$7 - 2 + 1 = 6$$$. Another example: if Vasya changes DDDD to DDRD, then the length of changed subsegment is $$$1$$$. If there are no changes, then the length of changed subsegment is $$$0$$$. Changing an operation means replacing it with some operation (possibly the same); Vasya can't insert new operations into the sequence or remove them.Help Vasya! Tell him the minimum length of subsegment that he needs to change so that the robot will go from $$$(0, 0)$$$ to $$$(x, y)$$$, or tell him that it's impossible. NoteIn the first example the sequence can be changed to LULUU. So the length of the changed subsegment is $$$3 - 1 + 1 = 3$$$.In the second example the given sequence already leads the robot to $$$(x, y)$$$, so the length of the changed subsegment is $$$0$$$.In the third example the robot can't end his path in the cell $$$(x, y)$$$. n=int(input())
s=list(input())
a,b = map(int, input().split())
L=s.count('L')
U=s.count('U')
R=s.count('R')
D=s.count('D')
x=0
y=0
xmin=0
ymin=0
minn=2*n
while x+y<2*n:
    if abs(a-(R-L))+abs(b-(U-D))>y-x and y!=n:
        i=s[y]
        if i=='L':
            L-=1
        elif i=='R':
            R-=1
        elif i=='D':
            D-=1
        elif i=='U':
            U-=1 
        y+=1
    elif abs(a-(R-L))+abs(b-(U-D))<=y-x or y==n:
        if y-x<minn and abs(a-(R-L))+abs(b-(U-D))<=y-x:
            minn=y-x
        i=s[x]
        if i=='L':
            L+=1
        elif i=='R':
            R+=1
        elif i=='D':
            D+=1
        elif i=='U':
            U+=1
        x+=1

            
if abs(a)+abs(b)>len(s):
    print(-1)
elif (len(s)-(abs(a)+abs(b)))%2!=0:
    print(-1)
else:
    print(minn)
    ","['binary search', 'two pointers']"
633,"You are given a string $$$s$$$ consisting only of first $$$20$$$ lowercase Latin letters ('a', 'b', ..., 't').Recall that the substring $$$s[l; r]$$$ of the string $$$s$$$ is the string $$$s_l s_{l + 1} \dots s_r$$$. For example, the substrings of ""codeforces"" are ""code"", ""force"", ""f"", ""for"", but not ""coder"" and ""top"".You can perform the following operation no more than once: choose some substring $$$s[l; r]$$$ and reverse it (i.e. the string $$$s_l s_{l + 1} \dots s_r$$$ becomes $$$s_r s_{r - 1} \dots s_l$$$).Your goal is to maximize the length of the maximum substring of $$$s$$$ consisting of distinct (i.e. unique) characters.The string consists of distinct characters if no character in this string appears more than once. For example, strings ""abcde"", ""arctg"" and ""minecraft"" consist of distinct characters but strings ""codeforces"", ""abacaba"" do not consist of distinct characters. nan import sys
range = xrange
input = raw_input

orda = ord('a')
S = [ord(c) - orda for c in input()]
n = len(S)

best = -1
count = [0]*(2**20)
for i in range(n):
    c = 0
    j = i
    while j < n and c & (1 << S[j]) == 0:
        c ^= 1 << S[j]
        count[c] = 1
        j += 1

big = 2**20
bitsize = [0]
for i in range(1, big):
    bitsize.append(1 +  bitsize[i - (1 <<( i.bit_length() - 1))])

for i in range(big):
    if count[i] == 0:
        bitsize[i] = 0

DP = [0]*big
for i in reversed(range(big)):
    ii = (big - 1) ^ i
    besta = bitsize[ii]
    
    while ii:
        b = ii & (~ii + 1)
        if DP[i ^ b] > besta:
            besta = DP[i ^ b]
        ii ^= b
    DP[i] = besta

print max(DP[i] + bitsize[i] for i in range(big))
","['bitmasks', 'dp']"
670,"Piegirl found the red button. You have one last chance to change the inevitable end.The circuit under the button consists of n nodes, numbered from 0 to n - 1. In order to deactivate the button, the n nodes must be disarmed in a particular order. Node 0 must be disarmed first. After disarming node i, the next node to be disarmed must be either node (2·i) modulo n or node (2·i) + 1 modulo n. The last node to be disarmed must be node 0. Node 0 must be disarmed twice, but all other nodes must be disarmed exactly once. Your task is to find any such order and print it. If there is no such order, print -1. nan n=int(input())
if n&1:
	print(-1)
else:
	D,R=[False]*(10**6),[0]*(10**6)
	i,j=0,0
	while True:
		D[j]=True
		R[i]=j
		i+=1
		if not D[(j+n)>>1]:
			j=(j+n)>>1
		elif not D[j>>1]:
			j=j>>1
		else:
			break
	print("" "".join(str(R[i]) for i in range(n,-1,-1)))
","['combinatorics', 'dfs and similar', 'dsu', 'graphs', 'greedy']"
3646,"You are given $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$. Each of $$$a_i$$$ has between $$$3$$$ and $$$5$$$ divisors. Consider $$$a = \prod a_i$$$ — the product of all input integers. Find the number of divisors of $$$a$$$. As this number may be very large, print it modulo prime number $$$998244353$$$. NoteIn the first case, $$$a = 19305$$$. Its divisors are $$$1, 3, 5, 9, 11, 13, 15, 27, 33, 39, 45, 55, 65, 99, 117, 135, 143, 165, 195, 297, 351, 429, 495, 585, 715, 1287, 1485, 1755, 2145, 3861, 6435, 19305$$$ — a total of $$$32$$$.In the second case, $$$a$$$ has four divisors: $$$1$$$, $$$86028121$$$, $$$86028157$$$, and $$$7400840699802997 $$$.In the third case $$$a = 202600445671925364698739061629083877981962069703140268516570564888699 375209477214045102253766023072401557491054453690213483547$$$.In the fourth case, $$$a=512=2^9$$$, so answer equals to $$$10$$$. import math
import sys
from decimal import Decimal



n=int(input())
d={}
f={}
s=set()
for j in range(n):
    i=int(input())
    f.setdefault(i,0)
    f[i]+=1
    x=i**.25
    x=int(x)
    y=i**.5
    y=int(y)
    if x**4==i:
        d.setdefault(x,0)
        d[x]+=4
    elif y*y==i:
        x=int(i**.5)
        d.setdefault(x, 0)
        d[x] += 2
    elif int(i**(1./3)) ** 3 == i:
        x=int(math.pow(i,1/3))
        d.setdefault(x,0)
        d[x]+=3
    elif (1+int(i**(1./3))) ** 3 == i:
        x=int(math.pow(i,1/3))+1
        d.setdefault(x,0)
        d[x]+=3
    elif (int(i**(1./3))-1) ** 3 == i:
        x=int(math.pow(i,1/3))-1
        d.setdefault(x,0)
        d[x]+=3
    else:
       s.add(i)
rem=set()
# print(d)
# print(s)
for i in s:
    if i in rem:
        continue
    for j in s:
        if i==j:
            continue
        if math.gcd(i,j)!=1:
            a,b,c=math.gcd(i,j),i//math.gcd(i,j),j//math.gcd(i,j)
            d.setdefault(a,0)
            d.setdefault(b,0)
            d.setdefault(c,0)
            d[a]+=f[i]
            d[b]+=f[i]
            if j not in rem:
                d[c]+=f[j]
                d[a]+=f[j]
            rem.add(i)
            rem.add(j)
            break
for i in s:
    if i in rem:
        continue
    for j in d:
        if i%j==0:
            d[j]+=f[i]
            d.setdefault(i//j,0)
            d[i//j]+=f[i]
            rem.add(i)
            break
k=-1
for i in s:
    if i not in rem:
        d[k]=f[i]
        k-=1
        d[k]=f[i]
        k-=1
ans=1

#print(rem,d)
for k in d:
    ans*=d[k]+1
    ans=ans%998244353
print(ans)
sys.stdout.flush()","['interactive', 'math', 'number theory']"
3662,"You have a string s = s1s2...s|s|, where |s| is the length of string s, and si its i-th character. Let's introduce several definitions:  A substring s[i..j] (1 ≤ i ≤ j ≤ |s|) of string s is string sisi + 1...sj.  The prefix of string s of length l (1 ≤ l ≤ |s|) is string s[1..l].  The suffix of string s of length l (1 ≤ l ≤ |s|) is string s[|s| - l + 1..|s|]. Your task is, for any prefix of string s which matches a suffix of string s, print the number of times it occurs in string s as a substring. nan 
def z_advanced(s):
    """"""An advanced computation of Z-values of a string.""""""

    Z = [0] * len(s)
    Z[0] = len(s)

    rt = 0
    lt = 0

    for k in range(1, len(s)):
        if k > rt:
            # If k is outside the current Z-box, do naive computation.
            n = 0
            while n + k < len(s) and s[n] == s[n + k]:
                n += 1
            Z[k] = n
            if n > 0:
                lt = k
                rt = k + n - 1
        else:
            # If k is inside the current Z-box, consider two cases.

            p = k - lt  # Pair index.
            right_part_len = rt - k + 1

            if Z[p] < right_part_len:
                Z[k] = Z[p]
            else:
                i = rt + 1
                while i < len(s) and s[i] == s[i - k]:
                    i += 1
                Z[k] = i - k

                lt = k
                rt = i - 1
    return Z

def kmptab(s):
    tab = [0]*len(s)
    i = 1
    j = 0
    while i < len(s):
        if s[i] == s[j]:
            tab[i] = j + 1
            i += 1
            j += 1
        else:
            if j != 0:
                j = tab[j-1]
            else:
                i += 1
    return tab

if __name__ == '__main__':
    s = input()
    tab = kmptab(s)
    my_set = set()
    i = len(s)
    while i != 0:
        my_set.add(i)
        i = tab[i-1]
    V = []
    dict = {}
    for i in my_set:
        V.append(i)
        dict[i] = 0
    Z = z_advanced(s)

    v = []
    V.sort()
    my_tab = [0]*(len(s)+1)
    # print(Z)
    for i in Z:
        my_tab[i] += 1
    somme = 0
    # print(my_tab)
    for i in range(len(my_tab)-1, -1, -1):

        my_tab[i] += somme
        somme = my_tab[i]
    # print(my_tab)
    for i in dict:
        dict[i] = my_tab[i]
        v.append((dict[i], i))
    v.sort(key=lambda tup: tup[1])
    print(len(v))
    for i in v:
        print(str(i[1]) + "" "" + str(i[0]))
","['dp', 'other', 'strings', 'two pointers']"
4004,"Vasya trains to compose crossword puzzles. He can only compose crosswords of a very simplе type so far. All of them consist of exactly six words; the words can be read only from top to bottom vertically and from the left to the right horizontally. The words are arranged in the form of a rectangular ""eight"" or infinity sign, not necessarily symmetrical.The top-left corner of the crossword coincides with the top-left corner of the rectangle. The same thing is correct for the right-bottom corners. The crossword can't degrade, i.e. it always has exactly four blank areas, two of which are surrounded by letters. Look into the output for the samples for clarification.Help Vasya — compose a crossword of the described type using the given six words. It is allowed to use the words in any order. nan from itertools import permutations
v = []
for p in permutations(input() for i in range(6)):
    if len(p[1]) != len(p[0]) + len(p[2]) - 1 or len(p[4]) != len(p[3]) + len(p[5]) - 1:
        continue
    elif p[0][0] != p[3][0] or p[0][-1] != p[4][0]:
        continue
    elif p[1][0] != p[3][-1] or p[1][len(p[0]) - 1] != p[4][len(p[3]) - 1] or p[1][-1] != p[5][0]:
        continue
    elif p[2][0] != p[4][-1] or p[2][-1] != p[5][-1]:
        continue
    else:
        x, y, c = '.' * (len(p[1]) - len(p[0])), '.' * (len(p[1]) - len(p[2])), []
        c.append(p[0] + x)
        for i in range(1, len(p[3]) - 1):
            c.append(p[3][i] + '.' * (len(p[0]) - 2) + p[4][i] + x)
        c.append(p[1])
        for i in range(1, len(p[5]) - 1):
            c.append(y + p[4][len(p[3]) + i - 1] + '.' * (len(p[2]) - 2) + p[5][i])
        c.append(y + p[2])
        v.append(c)
print('\n'.join(sorted(v)[0]) if v else 'Impossible')",['implementation']
2528,"You are given a text that consists of lowercase Latin letters, spaces and punctuation marks (dot, comma, exclamation mark and question mark). A word is defined as a sequence of consecutive Latin letters.Your task is to add spaces to the text by the following rules:  if there is no punctuation mark between two words, then they should be separated by exactly one space  there should be no spaces before each punctuation mark  there should be exactly one space after each punctuation mark It is guaranteed that there is at least one word between any two punctuation marks. The text begins and ends with a Latin letter. nan x=input()
m=('.',',','?','!')
for i in range(len(x)-1):
    if x[i] in m and x[i + 1] != ' ':
        print(x[i] + ' ', end='')
    elif not(x[i]==' ' and x[i+1]==' ' or x[i]==' ' and x[i+1] in m):
        print(x[i],end='')
print(x[len(x)-1])","['implementation', 'strings']"
598,"A sequence of $$$n$$$ numbers is called permutation if it contains all numbers from $$$1$$$ to $$$n$$$ exactly once. For example, the sequences [$$$3, 1, 4, 2$$$], [$$$1$$$] and [$$$2,1$$$] are permutations, but [$$$1,2,1$$$], [$$$0,1$$$] and [$$$1,3,4$$$] — are not.For a permutation $$$p$$$ of even length $$$n$$$ you can make an array $$$b$$$ of length $$$\frac{n}{2}$$$ such that:   $$$b_i = \max(p_{2i - 1}, p_{2i})$$$ for $$$1 \le i \le \frac{n}{2}$$$ For example, if $$$p$$$ = [$$$2, 4, 3, 1, 5, 6$$$], then:   $$$b_1 = \max(p_1, p_2) = \max(2, 4) = 4$$$  $$$b_2 = \max(p_3, p_4) = \max(3,1)=3$$$  $$$b_3 = \max(p_5, p_6) = \max(5,6) = 6$$$  As a result, we made $$$b$$$ = $$$[4, 3, 6]$$$.For a given array $$$b$$$, find the lexicographically minimal permutation $$$p$$$ such that you can make the given array $$$b$$$ from it.If $$$b$$$ = [$$$4,3,6$$$], then the lexicographically minimal permutation from which it can be made is $$$p$$$ = [$$$1,4,2,3,5,6$$$], since:   $$$b_1 = \max(p_1, p_2) = \max(1, 4) = 4$$$  $$$b_2 = \max(p_3, p_4) = \max(2, 3) = 3$$$  $$$b_3 = \max(p_5, p_6) = \max(5, 6) = 6$$$ A permutation $$$x_1, x_2, \dots, x_n$$$ is lexicographically smaller than a permutation $$$y_1, y_2 \dots, y_n$$$ if and only if there exists such $$$i$$$ ($$$1 \le i \le n$$$) that $$$x_1=y_1, x_2=y_2, \dots, x_{i-1}=y_{i-1}$$$ and $$$x_i&lt;y_i$$$. NoteThe first test case is parsed in the problem statement. import collections
import math
import bisect
import sys
import heapq
import itertools
#import functools

def solve():
    n = int(input())
    arr = [int(i) for i in sys.stdin.readline().split()]
    dic = {}
    for i, num in enumerate(arr):
        dic[num] = i
    if len(dic) != n // 2 or n not in dic:
        print(-1)
        return

    output = [-1] * n
    for num in dic:
        output[dic[num] * 2 + 1] = num
    
    h = []
    for num in range(n, 0, -1):
        if num in dic:
            heapq.heappush(h, -dic[num] * 2)
        elif not h:
            print(-1)
            return
        else:
            output[-heapq.heappop(h)] = num
    print(' '.join(map(str, output)))

    
    

t = int(input())
for _ in range(t):
    solve()","['binary search', 'constructive algorithms', 'data structures', 'greedy', 'math']"
3641,"You have a bag of size $$$n$$$. Also you have $$$m$$$ boxes. The size of $$$i$$$-th box is $$$a_i$$$, where each $$$a_i$$$ is an integer non-negative power of two.You can divide boxes into two parts of equal size. Your goal is to fill the bag completely.For example, if $$$n = 10$$$ and $$$a = [1, 1, 32]$$$ then you have to divide the box of size $$$32$$$ into two parts of size $$$16$$$, and then divide the box of size $$$16$$$. So you can fill the bag with boxes of size $$$1$$$, $$$1$$$ and $$$8$$$.Calculate the minimum number of divisions required to fill the bag of size $$$n$$$. nan 
t = int(input())
 
for _ in range(t):
 
    n, m = map(int, input().split(' '))
    a = list(map(int, input().strip().split(' ')))
 

    if sum(a) < n: print(""-1""); continue
    b = [0 for _ in range(64)]
 
    for z in a:
        for q in range(64):
            b[q] += (z>>q)&1
 
 
    tar = [0 for _ in range(64)]
    for q in range(64):
        tar[q] += (n>>q)&1
 
    # clear directs
    for i in range(64):
        if tar[i] == 1 and b[i] >= 1:
            tar[i] -= 1
            b[i] -= 1


    # combine up
 
    splits = 0

    for i in range(63):
        if tar[i] == 0: continue
        for j in range(i):
            if b[j] > 1:
                b[j+1] += b[j]//2
                b[j] = b[j]%2
        if tar[i] == 1 and b[i] >= 1:
            tar[i] -= 1
            b[i] -= 1
            continue
        for j in range(i+1, 64):
            if b[j] >= 1:
                splits += 1
                b[j] -= 1
                b[i] -= 1
                break
            else:
                b[j] += 1
                splits += 1
        



 
    print(splits)","['bitmasks', 'greedy']"
1406,"Valery is a PE teacher at a school in Berland. Soon the students are going to take a test in long jumps, and Valery has lost his favorite ruler! However, there is no reason for disappointment, as Valery has found another ruler, its length is l centimeters. The ruler already has n marks, with which he can make measurements. We assume that the marks are numbered from 1 to n in the order they appear from the beginning of the ruler to its end. The first point coincides with the beginning of the ruler and represents the origin. The last mark coincides with the end of the ruler, at distance l from the origin. This ruler can be repesented by an increasing sequence a1, a2, ..., an, where ai denotes the distance of the i-th mark from the origin (a1 = 0, an = l).Valery believes that with a ruler he can measure the distance of d centimeters, if there is a pair of integers i and j (1 ≤ i ≤ j ≤ n), such that the distance between the i-th and the j-th mark is exactly equal to d (in other words, aj - ai = d). Under the rules, the girls should be able to jump at least x centimeters, and the boys should be able to jump at least y (x &lt; y) centimeters. To test the children's abilities, Valery needs a ruler to measure each of the distances x and y. Your task is to determine what is the minimum number of additional marks you need to add on the ruler so that they can be used to measure the distances x and y. Valery can add the marks at any integer non-negative distance from the origin not exceeding the length of the ruler. NoteIn the first sample it is impossible to initially measure the distance of 230 centimeters. For that it is enough to add a 20 centimeter mark or a 230 centimeter mark.In the second sample you already can use the ruler to measure the distances of 185 and 230 centimeters, so you don't have to add new marks.In the third sample the ruler only contains the initial and the final marks. We will need to add two marks to be able to test the children's skills. from collections import defaultdict

class LongJumps():
    def __init__(self, n, l, x, y, a):
        self.n, self.l, self.x, self.y, self.a = n,l,x,y,a

    def get_markers(self):
        st = defaultdict(set)
        req_pts = [self.x,self.y]
        exist_check = defaultdict(bool)
        value_check = defaultdict(bool)
        for v in self.a:
            exist_check[v] = True

        for v in self.a:
            for i in range(len(req_pts)):
                if v - req_pts[i] >= 0:
                    st[v - req_pts[i]].add(i)
                    if exist_check[v - req_pts[i]]:
                        value_check[i] = True
                if v + req_pts[i] <= l:
                    st[v+req_pts[i]].add(i)
                    if exist_check[v + req_pts[i]]:
                        value_check[i] = True

        if value_check[0] and value_check[1]:
            print(0)
            return

        sol_status = 2
        status1_marker = None
        for v in st:
            if len(st[v]) == 2:
                sol_status = 1
                status1_marker = v
            elif len(st[v]) == 1:
                if exist_check[v]:
                    sol_status = 1
                    status1_marker = req_pts[1-st[v].pop()]
        
        if sol_status == 1:
            print(1)
            print(status1_marker)
            return
        else:
            print(2)
            print(x, y)

n, l, x, y = list(map(int,input().strip(' ').split(' ')))
a = list(map(int,input().strip(' ').split(' ')))
lj = LongJumps(n,l,x,y,a)
lj.get_markers()","['binary search', 'greedy', 'implementation']"
1606,"Petya loves hockey very much. One day, as he was watching a hockey match, he fell asleep. Petya dreamt of being appointed to change a hockey team's name. Thus, Petya was given the original team name w and the collection of forbidden substrings s1, s2, ..., sn. All those strings consist of uppercase and lowercase Latin letters. String w has the length of |w|, its characters are numbered from 1 to |w|.First Petya should find all the occurrences of forbidden substrings in the w string. During the search of substrings the case of letter shouldn't be taken into consideration. That is, strings ""aBC"" and ""ABc"" are considered equal.After that Petya should perform the replacement of all letters covered by the occurrences. More formally: a letter in the position i should be replaced by any other one if for position i in string w there exist pair of indices l, r (1 ≤ l ≤ i ≤ r ≤ |w|) such that substring w[l ... r] is contained in the collection s1, s2, ..., sn, when using case insensitive comparison. During the replacement the letter's case should remain the same. Petya is not allowed to replace the letters that aren't covered by any forbidden substring.Letter letter (uppercase or lowercase) is considered lucky for the hockey players. That's why Petya should perform the changes so that the letter occurred in the resulting string as many times as possible. Help Petya to find such resulting string. If there are several such strings, find the one that comes first lexicographically.Note that the process of replacements is not repeated, it occurs only once. That is, if after Petya's replacements the string started to contain new occurrences of bad substrings, Petya pays no attention to them. nan from sys import stdin,stdout
input=stdin.readline
print=stdout.write
n = int(input())
a = []
for i in range(n):
    a.append(input().rstrip())
w = list(input().rstrip())
c = input().rstrip()
m = len(w)
z = []
i = 0
while i < m:
    for j in range(n):
        if w[i].lower() == a[j][0].lower():
            if i + len(a[j]) <= m:
                f = 1
                for k in range(i,i+len(a[j])):
                    if w[k].lower() != a[j][k-i].lower():
                        f=0
                        break
                if f:
                    if len(z)!=0:
                        if z[-1][1]>=i:
                            z[-1][1]=max(i+len(a[j])-1,z[-1][1])
                        else:
                            z.append([i,i+len(a[j])-1])
                    else:
                        z.append([i,i+len(a[j])-1])
    i += 1
for i in z:
    for k in range(i[0],i[1]+1):
        if w[k].isupper():
            if w[k] != c.upper():
                w[k] = c.upper()
            else:
                if w[k] != ""A"":
                    w[k] = ""A""
                else:
                    w[k] = ""B""
        else:
            if w[k] != c.lower():
                w[k] = c.lower()
            else:
                if w[k] != ""a"":
                    w[k] = ""a""
                else:
                    w[k] = ""b""
print("""".join(w))","['implementation', 'strings']"
810,"Little Timofey likes integers a lot. Unfortunately, he is very young and can't work with very big integers, so he does all the operations modulo his favorite prime m. Also, Timofey likes to look for arithmetical progressions everywhere.One of his birthday presents was a sequence of distinct integers a1, a2, ..., an. Timofey wants to know whether he can rearrange the elements of the sequence so that is will be an arithmetical progression modulo m, or not.Arithmetical progression modulo m of length n with first element x and difference d is sequence of integers x, x + d, x + 2d, ..., x + (n - 1)·d, each taken modulo m. nan def solve(n, m, a):
    if n == 0:
        return 0, 1
    if n == 1:
        return a[0], 1
    d = (a[1]-a[0]) % m
    if d < 0: d += m
    st = set(a)
    cnt = 0
    for v in a:
        cnt += ((v + d) % m) in st
    cnt = n-cnt
    d = (d * pow(cnt, m-2, m)) % m
    now = a[0]
    while (now + m - d) % m in st:
        now = (now + m - d) % m
    for i in range(n):
        if (now + i*d) % m not in st:
            return -1, -1
    return now, d


m, n = map(int, input().split())
a = list(map(int, input().split()))
if n * 2 > m:
    st = set(a)
    b = [i for i in range(m) if i not in st]
    f, d = solve(len(b), m, b)
    f = (f + d * (m-n)) % m
else:
    f, d = solve(n, m, a)
if f < 0 or d < 0:
    print(-1)
else:
    print(f, d)



# Made By Mostafa_Khaled","['brute force', 'implementation', 'math', 'number theory']"
2114,"Efim just received his grade for the last test. He studies in a special school and his grade can be equal to any positive decimal fraction. First he got disappointed, as he expected a way more pleasant result. Then, he developed a tricky plan. Each second, he can ask his teacher to round the grade at any place after the decimal point (also, he can ask to round to the nearest integer). There are t seconds left till the end of the break, so Efim has to act fast. Help him find what is the maximum grade he can get in no more than t seconds. Note, that he can choose to not use all t seconds. Moreover, he can even choose to not round the grade at all.In this problem, classic rounding rules are used: while rounding number to the n-th digit one has to take a look at the digit n + 1. If it is less than 5 than the n-th digit remain unchanged while all subsequent digits are replaced with 0. Otherwise, if the n + 1 digit is greater or equal to 5, the digit at the position n is increased by 1 (this might also change some other digits, if this one was equal to 9) and all subsequent digits are replaced with 0. At the end, all trailing zeroes are thrown away.For example, if the number 1.14 is rounded to the first decimal place, the result is 1.1, while if we round 1.5 to the nearest integer, the result is 2. Rounding number 1.299996121 in the fifth decimal place will result in number 1.3. NoteIn the first two samples Efim initially has grade 10.245. During the first second Efim can obtain grade 10.25, and then 10.3 during the next second. Note, that the answer 10.30 will be considered incorrect.In the third sample the optimal strategy is to not perform any rounding at all. n,t=map(int,raw_input().split())
x,y=map(str,raw_input().split('.'))
#x,y=raw_input().split('.')
#if n==145730 and t==93881:
#    print x[:-1]+'3'
#    exit()
ans=chk=0
p=[i for i in y]
P=range(len(p))
q=[i for i in x]

z=0

def sol(ans):
    t=-len(ans)-1
    ans[-1]=chr(ord(ans[-1])+1)
    for i in range(-1,t,-1):
        if ans[i]==':' and i>t+1:
            ans[i]='0'
            ans[i-1]=chr(ord(ans[i-1])+1)
        elif ans[i]==':':
            ans[i]='10'
        else:
            break
    print ''.join(ans)

for i in P:
    if i==0 and ord(p[i])>=53:
#        print int(x)+1
        sol(q)
        exit()
    elif ord(p[i])>=53:
        p[i-1]=chr(ord(p[i-1])+1)
        t-=1
        z=1
        p=p[:i]
        P=P[:i]
        break

if z==1 and t>0:
    tmp=-len(p)-1
    for i in range(-1,tmp,-1):
        if p[0]==':' or ord(p[0])>=53:
#            print int(x)+1
            sol(q)
            exit()
        elif ord(p[i])>=53:
            p[i-1]=chr(ord(p[i-1])+1)
            p[i]='0'
            t-=1
        elif ord(p[i])<53:
            break
        if t==0:
            break
syo=''.join(p)
syo=syo.rstrip('0')
print x+'.'+syo","['dp', 'implementation', 'math']"
70,"Not so long ago, Vlad came up with an interesting function: $$$f_a(x)=\left\lfloor\frac{x}{a}\right\rfloor + x \bmod a$$$, where $$$\left\lfloor\frac{x}{a}\right\rfloor$$$ is $$$\frac{x}{a}$$$, rounded down, $$$x \bmod a$$$ — the remainder of the integer division of $$$x$$$ by $$$a$$$.For example, with $$$a=3$$$ and $$$x=11$$$, the value $$$f_3(11) = \left\lfloor\frac{11}{3}\right\rfloor + 11 \bmod 3 = 3 + 2 = 5$$$.The number $$$a$$$ is fixed and known to Vlad. Help Vlad find the maximum value of $$$f_a(x)$$$ if $$$x$$$ can take any integer value from $$$l$$$ to $$$r$$$ inclusive ($$$l \le x \le r$$$). NoteIn the first sample:  $$$f_3(1) = \left\lfloor\frac{1}{3}\right\rfloor + 1 \bmod 3 = 0 + 1 = 1$$$,  $$$f_3(2) = \left\lfloor\frac{2}{3}\right\rfloor + 2 \bmod 3 = 0 + 2 = 2$$$,  $$$f_3(3) = \left\lfloor\frac{3}{3}\right\rfloor + 3 \bmod 3 = 1 + 0 = 1$$$,  $$$f_3(4) = \left\lfloor\frac{4}{3}\right\rfloor + 4 \bmod 3 = 1 + 1 = 2$$$ As an answer, obviously, $$$f_3(2)$$$ and $$$f_3(4)$$$ are suitable. t = int(input())
if t>0:
    for i in range(t):
        l,r,a = map(int, input().split())
        if a>r:
            print(r//a + r%a)
        else:
            if r//a == l//a:
                print(r//a + r%a)
            elif r//a - l//a == 1:
                r1 = r//a + r%a
                l1 = l//a + (a-1)%a
                if r1>l1:
                    print(r1)
                else:
                    print(l1)
            else:
                r1 = r//a + r%a
                l1 = r//a - 1 + (a-1)%a
                if r1>l1:
                    print(r1)
                else:
                    print(l1)",['math']
4078,"Acacius is studying strings theory. Today he came with the following problem.You are given a string $$$s$$$ of length $$$n$$$ consisting of lowercase English letters and question marks. It is possible to replace question marks with lowercase English letters in such a way that a string ""abacaba"" occurs as a substring in a resulting string exactly once?Each question mark should be replaced with exactly one lowercase English letter. For example, string ""a?b?c"" can be transformed into strings ""aabbc"" and ""azbzc"", but can't be transformed into strings ""aabc"", ""a?bbc"" and ""babbc"".Occurrence of a string $$$t$$$ of length $$$m$$$ in the string $$$s$$$ of length $$$n$$$ as a substring is a index $$$i$$$ ($$$1 \leq i \leq n - m + 1$$$) such that string $$$s[i..i+m-1]$$$ consisting of $$$m$$$ consecutive symbols of $$$s$$$ starting from $$$i$$$-th equals to string $$$t$$$. For example string ""ababa"" has two occurrences of a string ""aba"" as a substring with $$$i = 1$$$ and $$$i = 3$$$, but there are no occurrences of a string ""aba"" in the string ""acba"" as a substring.Please help Acacius to check if it is possible to replace all question marks with lowercase English letters in such a way that a string ""abacaba"" occurs as a substring in a resulting string exactly once. NoteIn first example there is exactly one occurrence of a string ""abacaba"" in the string ""abacaba"" as a substring.In second example seven question marks can be replaced with any seven lowercase English letters and with ""abacaba"" in particular.In sixth example there are two occurrences of a string ""abacaba"" as a substring. # raw_input()
# map(int,raw_input().split())
# for _ in xrange(input()):
# print ""Case #""+str(_+1)+"": ""+
if __name__ == ""__main__"":
    for _ in xrange(input()):
        x=list('abacaba')
        n=input()
        s=list(raw_input())
        q=sum(s[i:i+7]==x for i in xrange(n-6))
        if q>1:
            print 'NO'
        elif q==1:
            print 'YES'
            print ''.join(['d' if i=='?' else i for i in s])
        else:
            b=True
            for i in xrange(n-6):
                if all(s[i+j] in (x[j],'?') for j in xrange(7)):
                    t=s[i:i+7]
                    s[i:i+7]=x
                    z=['d' if k=='?' else k for k in s]
                    q=sum(z[k:k+7]==x for k in xrange(n-6))
                    if q==1:
                        print 'YES'
                        print ''.join(z)
                        b=False
                        break
                    s[i:i+7]=t
            if b:
                print 'NO' ","['brute force', 'implementation', 'strings']"
1995,"Vova's house is an array consisting of $$$n$$$ elements (yeah, this is the first problem, I think, where someone lives in the array). There are heaters in some positions of the array. The $$$i$$$-th element of the array is $$$1$$$ if there is a heater in the position $$$i$$$, otherwise the $$$i$$$-th element of the array is $$$0$$$.Each heater has a value $$$r$$$ ($$$r$$$ is the same for all heaters). This value means that the heater at the position $$$pos$$$ can warm up all the elements in range $$$[pos - r + 1; pos + r - 1]$$$.Vova likes to walk through his house while he thinks, and he hates cold positions of his house. Vova wants to switch some of his heaters on in such a way that each element of his house will be warmed up by at least one heater. Vova's target is to warm up the whole house (all the elements of the array), i.e. if $$$n = 6$$$, $$$r = 2$$$ and heaters are at positions $$$2$$$ and $$$5$$$, then Vova can warm up the whole house if he switches all the heaters in the house on (then the first $$$3$$$ elements will be warmed up by the first heater and the last $$$3$$$ elements will be warmed up by the second heater).Initially, all the heaters are off.But from the other hand, Vova didn't like to pay much for the electricity. So he wants to switch the minimum number of heaters on in such a way that each element of his house is warmed up by at least one heater.Your task is to find this number of heaters or say that it is impossible to warm up the whole house. NoteIn the first example the heater at the position $$$2$$$ warms up elements $$$[1; 3]$$$, the heater at the position $$$3$$$ warms up elements $$$[2, 4]$$$ and the heater at the position $$$6$$$ warms up elements $$$[5; 6]$$$ so the answer is $$$3$$$.In the second example the heater at the position $$$1$$$ warms up elements $$$[1; 3]$$$ and the heater at the position $$$5$$$ warms up elements $$$[3; 5]$$$ so the answer is $$$2$$$.In the third example there are no heaters so the answer is -1.In the fourth example the heater at the position $$$3$$$ warms up elements $$$[1; 5]$$$, the heater at the position $$$6$$$ warms up elements $$$[4; 8]$$$ and the heater at the position $$$10$$$ warms up elements $$$[8; 10]$$$ so the answer is $$$3$$$. from __future__ import print_function # for PyPy2
from collections import Counter, OrderedDict
from itertools import permutations as perm
from collections import deque
from sys import stdin
from bisect import *
from heapq import *
import math
 
g   = lambda : stdin.readline().strip()
gl  = lambda : g().split()
gil = lambda : [int(var) for var in gl()]
gfl = lambda : [float(var) for var in gl()]
gcl = lambda : list(g())
gbs = lambda : [int(var) for var in g()]
mod = int(1e9)+7
inf = float(""inf"")

n, r = gil()
a = gil()

# n, r = 999, 19
# a = [1]*n

pairs = []

for i in range(n):
	if a[i]:
		pairs.append((max(0, i-r+1), min(n-1, i+r-1)))

pairs.sort(key=lambda x: [x[0], -x[1]], reverse=True)

# print(pairs)

flag = True if pairs else False
end = 0
cnt = 0
prev = -1
# print(pairs)
# print(0)
while pairs:
	e = -1
	while pairs and pairs[-1][0] <= end:
		e = max(e, pairs.pop()[1])

	if e < 0:
		flag = False
		break
	else:
		cnt += 1
		# print(e)
		end = e+1
		prev = e
		if e == n-1: break

print(cnt if flag and prev >= n-1 else -1)
","['greedy', 'two pointers']"
2414,"You're given an undirected graph with $$$n$$$ nodes and $$$m$$$ edges. Nodes are numbered from $$$1$$$ to $$$n$$$.The graph is considered harmonious if and only if the following property holds:  For every triple of integers $$$(l, m, r)$$$ such that $$$1 \le l &lt; m &lt; r \le n$$$, if there exists a path going from node $$$l$$$ to node $$$r$$$, then there exists a path going from node $$$l$$$ to node $$$m$$$. In other words, in a harmonious graph, if from a node $$$l$$$ we can reach a node $$$r$$$ through edges ($$$l &lt; r$$$), then we should able to reach nodes $$$(l+1), (l+2), \ldots, (r-1)$$$ too.What is the minimum number of edges we need to add to make the graph harmonious?  NoteIn the first example, the given graph is not harmonious (for instance, $$$1 &lt; 6 &lt; 7$$$, node $$$1$$$ can reach node $$$7$$$ through the path $$$1 \rightarrow 2 \rightarrow 7$$$, but node $$$1$$$ can't reach node $$$6$$$). However adding the edge $$$(2, 4)$$$ is sufficient to make it harmonious.In the second example, the given graph is already harmonious. from sys import stdin
from itertools import repeat
def main():
    n, m = map(int, stdin.readline().split())
    dat = map(int, stdin.read().split(), repeat(10, 2 * m))
    par = range(n + 1)
    st = []
    pu = st.append
    for i in xrange(m):
        x, y = dat[i*2], dat[i*2+1]
        while x != par[x]:
            pu(x)
            x = par[x]
        pu(x)
        while y != par[y]:
            pu(y)
            y = par[y]
        for x in st:
            par[x] = y
        del st[:]
    l = range(n + 1)
    r = range(n + 1)
    c = [0] * (n + 1)
    s = set()
    for i in xrange(1, n + 1):
        x = i
        while x != par[x]:
            pu(x)
            x = par[x]
        for y in st:
            par[y] = x
        del st[:]
        if l[x] > i:
            l[x] = i
        if r[x] < i:
            r[x] = i
        c[x] += 1
        if x == i:
            s.add(x)
    ans = 0
    f = 1
    while f:
        f = 0
        t = s.copy()
        for i in s:
            if c[i] == r[i] - l[i] + 1 or i not in t:
                continue
            for j in xrange(l[i], r[i] + 1):
                x = j
                while x != par[x]:
                    pu(x)
                    x = par[x]
                if x != i:
                    f = 1
                    if l[i] > l[x]:
                        l[i] = l[x]
                    if r[i] < r[x]:
                        r[i] = r[x]
                    c[i] += c[x]
                    pu(x)
                    ans += 1
                    t.remove(x)
                for y in st:
                    par[y] = i
                del st[:]
        s = t
    print ans
main()
","['constructive algorithms', 'dfs and similar', 'dsu', 'graphs', 'greedy', 'sortings']"
3188,"Maxim wants to buy some games at the local game shop. There are $$$n$$$ games in the shop, the $$$i$$$-th game costs $$$c_i$$$.Maxim has a wallet which can be represented as an array of integers. His wallet contains $$$m$$$ bills, the $$$j$$$-th bill has value $$$a_j$$$.Games in the shop are ordered from left to right, Maxim tries to buy every game in that order.When Maxim stands at the position $$$i$$$ in the shop, he takes the first bill from his wallet (if his wallet is empty then he proceeds to the next position immediately) and tries to buy the $$$i$$$-th game using this bill. After Maxim tried to buy the $$$n$$$-th game, he leaves the shop.Maxim buys the $$$i$$$-th game if and only if the value of the first bill (which he takes) from his wallet is greater or equal to the cost of the $$$i$$$-th game. If he successfully buys the $$$i$$$-th game, the first bill from his wallet disappears and the next bill becomes first. Otherwise Maxim leaves the first bill in his wallet (this bill still remains the first one) and proceeds to the next game.For example, for array $$$c = [2, 4, 5, 2, 4]$$$ and array $$$a = [5, 3, 4, 6]$$$ the following process takes place: Maxim buys the first game using the first bill (its value is $$$5$$$), the bill disappears, after that the second bill (with value $$$3$$$) becomes the first one in Maxim's wallet, then Maxim doesn't buy the second game because $$$c_2 &gt; a_2$$$, the same with the third game, then he buys the fourth game using the bill of value $$$a_2$$$ (the third bill becomes the first one in Maxim's wallet) and buys the fifth game using the bill of value $$$a_3$$$.Your task is to get the number of games Maxim will buy. NoteThe first example is described in the problem statement.In the second example Maxim cannot buy any game because the value of the first bill in his wallet is smaller than the cost of any game in the shop.In the third example the values of the bills in Maxim's wallet are large enough to buy any game he encounter until he runs out of bills in his wallet. n,m = map(int,raw_input().split())
nums = list(map(int,raw_input().split()))
arr = list(map(int,raw_input().split()))
ans = 0
for i in range(n):
  if arr and arr[0] >= nums[i]:
    arr.pop(0)
    ans += 1
print ans",['implementation']
3799,"Given $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$. You can perform the following operation on them:  select any element $$$a_i$$$ ($$$1 \le i \le n$$$) and divide it by $$$2$$$ (round down). In other words, you can replace any selected element $$$a_i$$$ with the value $$$\left \lfloor \frac{a_i}{2}\right\rfloor$$$ (where $$$\left \lfloor x \right\rfloor$$$ is – round down the real number $$$x$$$). Output the minimum number of operations that must be done for a sequence of integers to become strictly increasing (that is, for the condition $$$a_1 \lt a_2 \lt \dots \lt a_n$$$ to be satisfied). Or determine that it is impossible to obtain such a sequence. Note that elements cannot be swapped. The only possible operation is described above.For example, let $$$n = 3$$$ and a sequence of numbers $$$[3, 6, 5]$$$ be given. Then it is enough to perform two operations on it:   Write the number $$$\left \lfloor \frac{6}{2}\right\rfloor = 3$$$ instead of the number $$$a_2=6$$$ and get the sequence $$$[3, 3, 5]$$$;  Then replace $$$a_1=3$$$ with $$$\left \lfloor \frac{3}{2}\right\rfloor = 1$$$ and get the sequence $$$[1, 3, 5]$$$. The resulting sequence is strictly increasing because $$$1 \lt 3 \lt 5$$$. NoteThe first test case is analyzed in the statement.In the second test case, it is impossible to obtain a strictly increasing sequence.In the third test case, the sequence is already strictly increasing. #https://codeforces.com/blog/entry/71884
import sys
input = sys.stdin.readline
from math import inf, gcd, log, log2, floor, ceil, sqrt
from collections import Counter, defaultdict, deque
from heapq import heappush, heappop, heapify
from functools import lru_cache
from itertools import permutations, accumulate

############ ---- Input Functions ---- ############
def inp():
    return(int(input()))
def inlt():
    return(list(map(int,input().split())))
def insr():
    s = input()
    return(list(s[:len(s) - 1]))
def invr():
    return(map(int,input().split()))

def solve(n,arr):
 
    if n == 1:
        return 0

    if arr[-1] == 0:
        return -1
 
    ans = 0
    for i in range(n-2,-1,-1):
        if arr[i] == 0 and i != 0:
            return -1
        while arr[i] != 0 and arr[i] >= arr[i+1]:
            arr[i] = arr[i] // 2
            ans += 1
        if arr[i] == 0 and i != 0:
            return -1
 
    return ans
    

t = inp()
for k in range(t):
    n = inp()
    arr = inlt()
    print(solve(n,arr))

","['greedy', 'implementation']"
1421,"You are given $$$n$$$ strings $$$s_1, s_2, \dots, s_n$$$ of length at most $$$\mathbf{8}$$$. For each string $$$s_i$$$, determine if there exist two strings $$$s_j$$$ and $$$s_k$$$ such that $$$s_i = s_j + s_k$$$. That is, $$$s_i$$$ is the concatenation of $$$s_j$$$ and $$$s_k$$$. Note that $$$j$$$ can be equal to $$$k$$$.Recall that the concatenation of strings $$$s$$$ and $$$t$$$ is $$$s + t = s_1 s_2 \dots s_p t_1 t_2 \dots t_q$$$, where $$$p$$$ and $$$q$$$ are the lengths of strings $$$s$$$ and $$$t$$$ respectively. For example, concatenation of ""code"" and ""forces"" is ""codeforces"". NoteIn the first test case, we have the following:   $$$s_1 = s_2 + s_2$$$, since $$$\texttt{abab} = \texttt{ab} + \texttt{ab}$$$. Remember that $$$j$$$ can be equal to $$$k$$$.  $$$s_2$$$ is not the concatenation of any two strings in the list.  $$$s_3 = s_2 + s_5$$$, since $$$\texttt{abc} = \texttt{ab} + \texttt{c}$$$.  $$$s_4$$$ is not the concatenation of any two strings in the list.  $$$s_5$$$ is not the concatenation of any two strings in the list.  Since only $$$s_1$$$ and $$$s_3$$$ satisfy the conditions, only the first and third bits in the answer should be $$$\texttt{1}$$$, so the answer is $$$\texttt{10100}$$$. #import io, os
#input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

t=int(input())
for _ in range(t):
  n=int(input())
  words=[]
  prefs={}
  suffs={}
  for i in range(n):
    word=input()
    words.append(word)
    if not word in prefs:
      prefs.update({word:1})
    else:
      prefs.update({word:prefs[word]+1})
    if not word in suffs:     
      suffs.update({word:1})
    else:
      suffs.update({word:suffs[word]+1})
  bina=""""
  for i in words:#
    flag=False
    for j in range(len(i)-1):
      a=i[:(j+1)]
      b=i[j+1:]
      if a in prefs and b in suffs:
        flag=True
    if flag:
      bina+=""1""
    else:
      bina+=""0""
  print(bina)","['brute force', 'data structures', 'strings']"
2059,"Consider the following problem: given an array $$$a$$$ containing $$$n$$$ integers (indexed from $$$0$$$ to $$$n-1$$$), find $$$\max\limits_{0 \leq l \leq r \leq n-1} \sum\limits_{l \leq i \leq r} (r-l+1) \cdot a_i$$$. In this problem, $$$1 \leq n \leq 2\,000$$$ and $$$|a_i| \leq 10^6$$$.In an attempt to solve the problem described, Alice quickly came up with a blazing-fast greedy algorithm and coded it. Her implementation in pseudocode is as follows:function find_answer(n, a)    # Assumes n is an integer between 1 and 2000, inclusive    # Assumes a is a list containing n integers: a[0], a[1], ..., a[n-1]    res = 0    cur = 0    k = -1    for i = 0 to i = n-1        cur = cur + a[i]        if cur &lt; 0            cur = 0            k = i        res = max(res, (i-k)*cur)    return resAlso, as you can see, Alice's idea is not entirely correct. For example, suppose $$$n = 4$$$ and $$$a = [6, -8, 7, -42]$$$. Then, find_answer(n, a) would return $$$7$$$, but the correct answer is $$$3 \cdot (6-8+7) = 15$$$.You told Alice that her solution is incorrect, but she did not believe what you said.Given an integer $$$k$$$, you are to find any sequence $$$a$$$ of $$$n$$$ integers such that the correct answer and the answer produced by Alice's algorithm differ by exactly $$$k$$$. Note that although the choice of $$$n$$$ and the content of the sequence is yours, you must still follow the constraints earlier given: that $$$1 \leq n \leq 2\,000$$$ and that the absolute value of each element does not exceed $$$10^6$$$. If there is no such sequence, determine so. NoteThe first sample corresponds to the example given in the problem statement.In the second sample, one answer is $$$n = 7$$$ with $$$a = [30, -12, -99, 123, -2, 245, -300]$$$, in which case find_answer(n, a) returns $$$1098$$$, while the correct answer is $$$1710$$$. k = int(input())
# (s+x)(l+1) - sx = k, s + lx + x = k
a = []
for l in range(1, 2001):
    if 0 <= k + (l+1) < l * 10**6:
        s = k + (l+1)
        a.append(-1)
        a.append(s % 10**6)
        s = s - s % 10**6
        for i in range(1, l):
            a.append(10**6)
        break
print(len(a))
for x in a:
    print(x, end=' ')",['constructive algorithms']
1480,"There is an automatic door at the entrance of a factory. The door works in the following way:  when one or several people come to the door and it is closed, the door immediately opens automatically and all people immediately come inside,  when one or several people come to the door and it is open, all people immediately come inside,  opened door immediately closes in d seconds after its opening,  if the door is closing and one or several people are coming to the door at the same moment, then all of them will have enough time to enter and only after that the door will close. For example, if d = 3 and four people are coming at four different moments of time t1 = 4, t2 = 7, t3 = 9 and t4 = 13 then the door will open three times: at moments 4, 9 and 13. It will close at moments 7 and 12.It is known that n employees will enter at moments a, 2·a, 3·a, ..., n·a (the value a is positive integer). Also m clients will enter at moments t1, t2, ..., tm.Write program to find the number of times the automatic door will open. Assume that the door is initially closed. NoteIn the first example the only employee will come at moment 3. At this moment the door will open and will stay open until the moment 7. At the same moment of time the client will come, so at first he will enter and only after it the door will close. Thus the door will open one time. BigNum = 10 ** 20

n, m, a, d = map(int, input().split(' '))
ts = [0] + list(map(int, input().split(' '))) + [BigNum]

def empsInRange(l, r):
    em1 = l // a + 1
    em2 = r // a
    return (em1, min(em2, n))

empDoorGroup = d // a + 1

def moveEmps(emps, last):
    em1, em2 = emps
    if em1 > em2:
        return last, 0
    
    if em1 * a <= last + d:
        gr1 = (last + d - em1 * a) // a
        em1 += 1 + gr1
    
    if em1 > em2:
        return last, 0

    doorGroups = (em2 - em1 + 1 + empDoorGroup - 1) // empDoorGroup
    last = (em1 + empDoorGroup * (doorGroups - 1)) * a

    return last, doorGroups

res = 0
last = -BigNum

for i in range(1, len(ts)):
    #print(i, ' ------------ ')
    emps = empsInRange(ts[i - 1], ts[i])
    #print(ts[i-1], ts[i], emps, last)
    last, inc = moveEmps(emps, last)
    #print('last:', last, ' inc:', inc)
    res += inc

    if ts[i] < BigNum and last + d < ts[i]:
        res += 1
        last = ts[i]
    #print('temp res:', res)

print(res)
",['implementation']
2627,"You are given an array $$$a$$$ of length $$$n$$$, which initially is a permutation of numbers from $$$1$$$ to $$$n$$$. In one operation, you can choose an index $$$i$$$ ($$$1 \leq i &lt; n$$$) such that $$$a_i &lt; a_{i + 1}$$$, and remove either $$$a_i$$$ or $$$a_{i + 1}$$$ from the array (after the removal, the remaining parts are concatenated). For example, if you have the array $$$[1, 3, 2]$$$, you can choose $$$i = 1$$$ (since $$$a_1 = 1 &lt; a_2 = 3$$$), then either remove $$$a_1$$$ which gives the new array $$$[3, 2]$$$, or remove $$$a_2$$$ which gives the new array $$$[1, 2]$$$.Is it possible to make the length of this array equal to $$$1$$$ with these operations? NoteFor the first two test cases and the fourth test case, we can operate as follow (the bolded elements are the pair chosen for that operation):$$$[\text{1}, \textbf{2}, \textbf{3}] \rightarrow [\textbf{1}, \textbf{2}] \rightarrow [\text{1}]$$$$$$[\text{3}, \textbf{1}, \textbf{2}, \text{4}] \rightarrow [\text{3}, \textbf{1}, \textbf{4}] \rightarrow [\textbf{3}, \textbf{4}] \rightarrow [\text{4}]$$$$$$[\textbf{2}, \textbf{4}, \text{6}, \text{1}, \text{3}, \text{5}] \rightarrow [\textbf{4}, \textbf{6}, \text{1}, \text{3}, \text{5}] \rightarrow [\text{4}, \text{1}, \textbf{3}, \textbf{5}] \rightarrow [\text{4}, \textbf{1}, \textbf{5}] \rightarrow [\textbf{4}, \textbf{5}] \rightarrow [\text{4}]$$$ from sys import stdin,stdout
t=int(stdin.readline())
for _ in range(t):
    n=int(stdin.readline())
    arr = [int(x) for x in stdin.readline().split()]

    def solve(arr,n):
        if arr[-1]<arr[0]:
            return ""NO""
        return ""YES""
    print(solve(arr,n))
","['constructive algorithms', 'data structures', 'greedy']"
2890,"Valera takes part in the Berland Marathon. The marathon race starts at the stadium that can be represented on the plane as a square whose lower left corner is located at point with coordinates (0, 0) and the length of the side equals a meters. The sides of the square are parallel to coordinate axes.As the length of the marathon race is very long, Valera needs to have extra drink during the race. The coach gives Valera a bottle of drink each d meters of the path. We know that Valera starts at the point with coordinates (0, 0) and runs counter-clockwise. That is, when Valera covers a meters, he reaches the point with coordinates (a, 0). We also know that the length of the marathon race equals nd + 0.5 meters. Help Valera's coach determine where he should be located to help Valera. Specifically, determine the coordinates of Valera's positions when he covers d, 2·d, ..., n·d meters. nan a, d = [float(el) for el in input().split()]
n = int(input())

for i in range(1, n+1):
    k = i*d % (4*a)
    m = k // a
    if m == 0:
        x, y = k % a, 0
    elif m == 1:
        x, y = a , k % a
    elif m == 2:
        x, y = a - k % a, a
    elif m == 3: 
        x, y = 0, a - k % a 
    print('%s %s' % (x, y))","['implementation', 'math']"
1519,"Bob is a competitive programmer. He wants to become red, and for that he needs a strict training regime. He went to the annual meeting of grandmasters and asked $$$n$$$ of them how much effort they needed to reach red.""Oh, I just spent $$$x_i$$$ hours solving problems"", said the $$$i$$$-th of them. Bob wants to train his math skills, so for each answer he wrote down the number of minutes ($$$60 \cdot x_i$$$), thanked the grandmasters and went home. Bob could write numbers with leading zeroes — for example, if some grandmaster answered that he had spent $$$2$$$ hours, Bob could write $$$000120$$$ instead of $$$120$$$.Alice wanted to tease Bob and so she took the numbers Bob wrote down, and for each of them she did one of the following independently:   rearranged its digits, or  wrote a random number. This way, Alice generated $$$n$$$ numbers, denoted $$$y_1$$$, ..., $$$y_n$$$.For each of the numbers, help Bob determine whether $$$y_i$$$ can be a permutation of a number divisible by $$$60$$$ (possibly with leading zeroes). NoteIn the first example, there is one rearrangement that yields a number divisible by $$$60$$$, and that is $$$360$$$.In the second example, there are two solutions. One is $$$060$$$ and the second is $$$600$$$.In the third example, there are $$$6$$$ possible rearrangments: $$$025$$$, $$$052$$$, $$$205$$$, $$$250$$$, $$$502$$$, $$$520$$$. None of these numbers is divisible by $$$60$$$.In the fourth example, there are $$$3$$$ rearrangements: $$$228$$$, $$$282$$$, $$$822$$$.In the fifth example, none of the $$$24$$$ rearrangements result in a number divisible by $$$60$$$.In the sixth example, note that $$$000\dots0$$$ is a valid solution. t = int(input())
for x in range(t):
	s = input()
	ans = 0
	f = 0
	fl = 0
	for i in s:
		q = int(i)
		if i == '0':
			f += 1
		elif q % 2 == 0 :
			fl = 1
		ans += q
	if (ans % 3 == 0 and f and fl) or ans == 0 or (ans % 3 == 0 and f > 1):
		print('red')
	else:
		print('cyan')
","['math', 'other']"
4168,"Bajtek, known for his unusual gifts, recently got an integer array $$$x_0, x_1, \ldots, x_{k-1}$$$.Unfortunately, after a huge array-party with his extraordinary friends, he realized that he'd lost it. After hours spent on searching for a new toy, Bajtek found on the arrays producer's website another array $$$a$$$ of length $$$n + 1$$$. As a formal description of $$$a$$$ says, $$$a_0 = 0$$$ and for all other $$$i$$$ ($$$1 \le i \le n$$$) $$$a_i = x_{(i-1)\bmod k} + a_{i-1}$$$, where $$$p \bmod q$$$ denotes the remainder of division $$$p$$$ by $$$q$$$.For example, if the $$$x = [1, 2, 3]$$$ and $$$n = 5$$$, then:  $$$a_0 = 0$$$,  $$$a_1 = x_{0\bmod 3}+a_0=x_0+0=1$$$,  $$$a_2 = x_{1\bmod 3}+a_1=x_1+1=3$$$,  $$$a_3 = x_{2\bmod 3}+a_2=x_2+3=6$$$,  $$$a_4 = x_{3\bmod 3}+a_3=x_0+6=7$$$,  $$$a_5 = x_{4\bmod 3}+a_4=x_1+7=9$$$. So, if the $$$x = [1, 2, 3]$$$ and $$$n = 5$$$, then $$$a = [0, 1, 3, 6, 7, 9]$$$.Now the boy hopes that he will be able to restore $$$x$$$ from $$$a$$$! Knowing that $$$1 \le k \le n$$$, help him and find all possible values of $$$k$$$ — possible lengths of the lost array. NoteIn the first example, any $$$k$$$ is suitable, since $$$a$$$ is an arithmetic progression.Possible arrays $$$x$$$:  $$$[1]$$$ $$$[1, 1]$$$ $$$[1, 1, 1]$$$ $$$[1, 1, 1, 1]$$$  $$$[1, 1, 1, 1, 1]$$$In the second example, Bajtek's array can have three or five elements.Possible arrays $$$x$$$:  $$$[1, 2, 2]$$$ $$$[1, 2, 2, 1, 2]$$$For example, $$$k = 4$$$ is bad, since it leads to $$$6 + x_0 = 8$$$ and $$$0 + x_0 = 1$$$, which is an obvious contradiction.In the third example, only $$$k = n$$$ is good.Array $$$[1, 4, -2]$$$ satisfies the requirements.Note that $$$x_i$$$ may be negative. n = int(input())
a = list(map(int,input().split()))
b = [a[0]]
for i in range(1,n):
    b.append(a[i]-a[i-1])
cnt = 0
d = []
for i in range(n):
    check=False
    for j in range(n):
        if b[j]!=b[j%(i+1)]:
            check=True
    if not check:
        d.append(i+1)
print(len(d))
for i in d:
    print(i,end=' ')",['implementation']
3930,"You are given an array a with n elements. Each element of a is either 0 or 1.Let's denote the length of the longest subsegment of consecutive elements in a, consisting of only numbers one, as f(a). You can change no more than k zeroes to ones to maximize f(a). nan n,k=map(int,input().split())
l=list(map(int,input().split()))
ki=i=s=0; po=1
for j in range(n):
  s+=(l[j]==0)
  while s>k: s-=(l[i]==0); i+=1
  if j-i>ki-po: po,ki=i,j
print(ki-po+1)
l[po:ki+1]=[1]*(ki-po+1)
print(' '.join(map(str,l)))
","['binary search', 'dp', 'two pointers']"
4083,"A substring of some string is called the most frequent, if the number of its occurrences is not less than number of occurrences of any other substring.You are given a set of strings. A string (not necessarily from this set) is called good if all elements of the set are the most frequent substrings of this string. Restore the non-empty good string with minimum length. If several such strings exist, restore lexicographically minimum string. If there are no good strings, print ""NO"" (without quotes).A substring of a string is a contiguous subsequence of letters in the string. For example, ""ab"", ""c"", ""abc"" are substrings of string ""abc"", while ""ac"" is not a substring of that string.The number of occurrences of a substring in a string is the number of starting positions in the string where the substring occurs. These occurrences could overlap.String a is lexicographically smaller than string b, if a is a prefix of b, or a has a smaller letter at the first position where a and b differ. NoteOne can show that in the first sample only two good strings with minimum length exist: ""cfmailru"" and ""mailrucf"". The first string is lexicographically minimum. def cm(s1,s2):
    for i in range(1, len(s1)):
        if s1[:i] == s2[-i:] :
            s = s2 + s1[i:]
            if len(s) == len(set(list(s))):
                return s
        if s2[:i] == s1[-i:]:
            s = s1 + s2[i:]
            if len(s) == len(set(list(s))):
                return s
    return None

n = int(input())
a = []
for i in range(n):
    na = []
    s = input()
    if len(s) != len(set(list(s))):
        print('NO')
        exit()
    for sa in a:
        if len(set(list(s)).intersection(set(list(sa)))) == 0:
            na.append(sa)
        else:
            if s in sa:
                s = sa
            elif sa in s:
                pass
            else:
                ms = cm(s, sa)
                if ms is None:
                    print('NO')
                    exit()
                else:
                    s = ms
    a = na + [s]
    #print(a)
print(''.join(sorted(a)))","['graphs', 'greedy', 'strings']"
3678,"Vasya has an array a consisting of positive integer numbers. Vasya wants to divide this array into two non-empty consecutive parts (the prefix and the suffix) so that the sum of all elements in the first part equals to the sum of elements in the second part. It is not always possible, so Vasya will move some element before dividing the array (Vasya will erase some element and insert it into an arbitrary position).Inserting an element in the same position he was erased from is also considered moving.Can Vasya divide the array after choosing the right element to move and its new position? NoteIn the first example Vasya can move the second element to the end of the array.In the second example no move can make the division possible.In the third example Vasya can move the fourth element by one position to the left. import math
def f():
 n=int(input())
 s1=0
 s2=0
 m1={}
 m2={}
 A=list(map(int,input().split()))
 if n==1:
  print(""NO"")
  return
 for i in A:
  s2+=i
  if i in m2:
   m2[i]+=1
  else:
   m2[i]=1
 for i in A:
  if (s1-s2)%2==0:
   d=(s1-s2)//2
   if d<0 and -d in m2 and m2[-d]>0:
    print(""YES"")
    return
   elif d in m1 and m1[d]>0:
    print(""YES"")
    return
  s1+=i
  s2-=i
  if i in m1:
   m1[i]+=1
  else:
   m1[i]=1
  m2[i]-=1
 print(""NO"")
 return
f()
","['binary search', 'data structures', 'implementation']"
2833,"Today, Wet Shark is given n integers. Using any of these integers no more than once, Wet Shark wants to get maximum possible even (divisible by 2) sum. Please, calculate this value for Wet Shark. Note, that if Wet Shark uses no integers from the n integers, the sum is an even integer 0. NoteIn the first sample, we can simply take all three integers for a total sum of 6.In the second sample Wet Shark should take any four out of five integers 999 999 999. total = 0
min_odd = 1000000001

n = input()
numbers = raw_input().split(' ')

for i in range(0, n):
    x = int(numbers[i])
    total += x
    
    if x % 2 == 1:
        min_odd = min(x, min_odd)

print((total - min_odd) if total % 2 == 1 else total)",['implementation']
1672,"Misha and Grisha are funny boys, so they like to use new underground. The underground has n stations connected with n - 1 routes so that each route connects two stations, and it is possible to reach every station from any other.The boys decided to have fun and came up with a plan. Namely, in some day in the morning Misha will ride the underground from station s to station f by the shortest path, and will draw with aerosol an ugly text ""Misha was here"" on every station he will pass through (including s and f). After that on the same day at evening Grisha will ride from station t to station f by the shortest path and will count stations with Misha's text. After that at night the underground workers will wash the texts out, because the underground should be clean. The boys have already chosen three stations a, b and c for each of several following days, one of them should be station s on that day, another should be station f, and the remaining should be station t. They became interested how they should choose these stations s, f, t so that the number Grisha will count is as large as possible. They asked you for help. NoteIn the first example on the first day if s = 1, f = 2, t = 3, Misha would go on the route 1  2, and Grisha would go on the route 3  1  2. He would see the text at the stations 1 and 2. On the second day, if s = 3, f = 2, t = 3, both boys would go on the route 3  1  2. Grisha would see the text at 3 stations.In the second examle if s = 1, f = 3, t = 2, Misha would go on the route 1  2  3, and Grisha would go on the route 2  3 and would see the text at both stations. import os
import sys
from io import BytesIO, IOBase
from types import GeneratorType
from collections import defaultdict
BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
sys.setrecursionlimit(3*10**5)


def bootstrap(f, stack=[]):
    def wrappedfunc(*args, **kwargs):
        if stack:
            return f(*args, **kwargs)
        else:
            to = f(*args, **kwargs)
            while True:
                if type(to) is GeneratorType:
                    stack.append(to)
                    to = next(to)
                else:
                    stack.pop()
                    if not stack:
                        break
                    to = stack[-1].send(to)
            return to
    return wrappedfunc






MA=10**5+1
level=20
tree=[[] for i in range(MA)]
depth=[0 for i in range(MA)]
parent=[[0 for i in range(level)] for j in range(MA)]


@bootstrap
def dfs(cur,prev):
    depth[cur] = depth[prev] + 1
    parent[cur][0] = prev
    for i in range(len(tree[cur])):
        if (tree[cur][i] != prev):
            yield dfs(tree[cur][i], cur)

    yield

def precomputeSparseMatrix(n):
    for i in range(1,level):
        for node in range(1,n+1):
            if (parent[node][i-1] != -1):
                parent[node][i] =parent[parent[node][i-1]][i-1]


def lca(u,v):
    if (depth[v] < depth[u]):
        u,v=v,u

    diff = depth[v] - depth[u]


    for i in range(level):
        if ((diff >> i) & 1):
            v = parent[v][i]


    if (u == v):
        return u

    i=level-1
    while(i>=0):

        if (parent[u][i] != parent[v][i]):
            u = parent[u][i]
            v = parent[v][i]

        i+=-1

    return parent[u][0]



def add(a,b):
    tree[a].append(b)
    tree[b].append(a)

def res(s,t,f):
    p=lca(t,f)
    q=lca(s,f)
    if p==q:
        r=depth[lca(s,t)]-depth[p]
        return min(depth[p] + depth[f] - 2 * depth[p] + 1+r, depth[q] + depth[f] - 2 * depth[q] + 1+r)


    return min(depth[p]+depth[f]-2*depth[p]+1,depth[q]+depth[f]-2*depth[q]+1)








n,q=map(int,input().split())
p=list(map(int,input().split()))






for j in range(n-1):
    tree[p[j]].append(j+2)
    tree[j+2].append(p[j])

dfs(1,0)
precomputeSparseMatrix(n)
for j in range(q):
    a,b,c=map(int,input().split())
    print(max(res(a,b,c),res(a,c,b),res(b,c,a)))






















","['dfs and similar', 'graphs', 'trees']"
3977,"You're given an array of $$$n$$$ integers between $$$0$$$ and $$$n$$$ inclusive.In one operation, you can choose any element of the array and replace it by the MEX of the elements of the array (which may change after the operation).For example, if the current array is $$$[0, 2, 2, 1, 4]$$$, you can choose the second element and replace it by the MEX of the present elements  — $$$3$$$. Array will become $$$[0, 3, 2, 1, 4]$$$.You must make the array non-decreasing, using at most $$$2n$$$ operations.It can be proven that it is always possible. Please note that you do not have to minimize the number of operations. If there are many solutions, you can print any of them. –An array $$$b[1 \ldots n]$$$ is non-decreasing if and only if $$$b_1 \le b_2 \le \ldots \le b_n$$$.The MEX (minimum excluded) of an array is the smallest non-negative integer that does not belong to the array. For instance:  The MEX of $$$[2, 2, 1]$$$ is $$$0$$$, because $$$0$$$ does not belong to the array.  The MEX of $$$[3, 1, 0, 1]$$$ is $$$2$$$, because $$$0$$$ and $$$1$$$ belong to the array, but $$$2$$$ does not.  The MEX of $$$[0, 3, 1, 2]$$$ is $$$4$$$ because $$$0$$$, $$$1$$$, $$$2$$$ and $$$3$$$ belong to the array, but $$$4$$$ does not. It's worth mentioning that the MEX of an array of length $$$n$$$ is always between $$$0$$$ and $$$n$$$ inclusive. NoteIn the first test case, the array is already non-decreasing ($$$2 \le 2 \le 3$$$).Explanation of the second test case (the element modified by each operation is colored in red):   $$$a = [2, 1, 0]$$$ ; the initial MEX is $$$3$$$.  $$$a = [2, 1, \color{red}{3}]$$$ ; the new MEX is $$$0$$$.  $$$a = [\color{red}{0}, 1, 3]$$$ ; the new MEX is $$$2$$$.  The final array is non-decreasing: $$$0 \le 1 \le 3$$$. Explanation of the third test case:   $$$a = [0, 7, 3, 1, 3, 7, 7]$$$ ; the initial MEX is $$$2$$$.  $$$a = [0, \color{red}{2}, 3, 1, 3, 7, 7]$$$ ; the new MEX is $$$4$$$.  $$$a = [0, 2, 3, 1, \color{red}{4}, 7, 7]$$$ ; the new MEX is $$$5$$$.  $$$a = [0, 2, 3, 1, \color{red}{5}, 7, 7]$$$ ; the new MEX is $$$4$$$.  $$$a = [0, 2, 3, \color{red}{4}, 5, 7, 7]$$$ ; the new MEX is $$$1$$$.  The final array is non-decreasing: $$$0 \le 2 \le 3 \le 4 \le 5 \le 7 \le 7$$$.  def mex(l):
  s=set(l)
  for i in range(len(l)+1):
    if i not in s:
      return i
for _ in range(int(input())):
    n = int(input())
    l = list(map(int,input().split()))[:n]
    k = 0
    j = 0
    x =[]
    while j<n:
        m = mex(l)
        if m==n:
            while j<n and l[j]==j:
                j+=1
            if j<n and l[j]!=j:
                k+=1
                x+=[j+1]
                l[j]=m
        else:
            k+=1
            x+=[m+1]
            l[m]=m
    print(k)
    print(*x)
                
                
    
    
","['brute force', 'constructive algorithms', 'sortings']"
2259,"This problem is the most boring one you've ever seen. Given a sequence of integers a1, a2, ..., an and a non-negative integer h, our goal is to partition the sequence into two subsequences (not necessarily consist of continuous elements). Each element of the original sequence should be contained in exactly one of the result subsequences. Note, that one of the result subsequences can be empty.Let's define function f(ai, aj) on pairs of distinct elements (that is i ≠ j) in the original sequence. If ai and aj are in the same subsequence in the current partition then f(ai, aj) = ai + aj otherwise f(ai, aj) = ai + aj + h. Consider all possible values of the function f for some partition. We'll call the goodness of this partiotion the difference between the maximum value of function f and the minimum value of function f.Your task is to find a partition of the given sequence a that have the minimal possible goodness among all possible partitions. NoteIn the first sample the values of f are as follows: f(1, 2) = 1 + 2 + 2 = 5, f(1, 3) = 1 + 3 + 2 = 6 and f(2, 3) = 2 + 3 = 5. So the difference between maximum and minimum values of f is 1.In the second sample the value of h is large, so it's better for one of the sub-sequences to be empty. def finddiff(A, other, h):
  max1 = A[-1] + A[-2]
  min1 = A[0]+ A[1]
  min2 = other + A[0] + h
  max2 = other + A[-1] + h
  return max(max1,max2) - min(min1,min2)
n, h = map(int, raw_input().split())
numbers = map(int, raw_input().split())
savenum = -1
num = numbers[:]
numbers.sort()
min1 = numbers[-1]+numbers[-2]-numbers[0]-numbers[1]
if n > 2:
  for i in [0,1,2,-1,-2,-3]:
    minp = finddiff( numbers[:i] + numbers[i+1:], numbers[i], h)
    #print numbers[:i] + numbers[i+1:], numbers[i], minp
    if minp < min1:
      savenum = numbers[i]
      min1 = minp
print min1
one = False
for i in range(n):
  if num[i] == savenum and not one:
    print 2,
    one = True
  else:
    print 1,
","['constructive algorithms', 'greedy', 'sortings']"
4187,"Little C loves number «3» very much. He loves all things about it.Now he has a positive integer $$$n$$$. He wants to split $$$n$$$ into $$$3$$$ positive integers $$$a,b,c$$$, such that $$$a+b+c=n$$$ and none of the $$$3$$$ integers is a multiple of $$$3$$$. Help him to find a solution. nan 
n = int(input())

if n % 2 != 0:
    n = n - 1
    a = n // 2
    b = n - a
    while a % 3 == 0 or b % 3 == 0:
        a = a + 1
        b = b - 1
    print(1 , a , b)
else:
    n = n - 2
    a = n // 2
    b = n - a
    while a % 3 == 0 or b % 3 == 0:
        a = a + 1
        b = b - 1
    print(2 , a , b)
    ",['math']
2423,"You are given a graph consisting of $$$n$$$ vertices and $$$m$$$ edges. It is not guaranteed that the given graph is connected. Some edges are already directed and you can't change their direction. Other edges are undirected and you have to choose some direction for all these edges.You have to direct undirected edges in such a way that the resulting graph is directed and acyclic (i.e. the graph with all edges directed and having no directed cycles). Note that you have to direct all undirected edges.You have to answer $$$t$$$ independent test cases. NoteExplanation of the second test case of the example:Explanation of the third test case of the example: 
from collections import defaultdict, deque
for _ in range(int(input())):
    n,m = map(int,input().split())
    gr0 = defaultdict(list)
    gr1 = defaultdict(list)
    edges = []
    indeg = [0]*(n+1)
    for i in range(m):
        t,x,y = map(int,input().split())
        if t==0:
            edges.append([x,y])
        else:
            gr0[x].append(y)
            indeg[y]+=1
    q = deque()
    # vis = {}
    for i in range(1,n+1):
        if indeg[i]==0:
            q.append(i)
            # vis[i] = 1
    cnt = 0
    top = []
    while q:
        s = q.popleft()
        top.append(s)
        for i in gr0[s]:
            indeg[i]-=1
            if indeg[i]==0:
                q.append(i)
        cnt+=1

    if cnt!=n:
        print(""NO"")
        continue
    mp = {}
    for i in range(n):
        mp[top[i]] = i
    for x,y in edges:
        if mp[x]<mp[y]:
            gr0[x].append(y)
        else:
            gr0[y].append(x)
    print(""YES"")
    for i in gr0.keys():
        for j in gr0[i]:
            print(i,j)



","['constructive algorithms', 'dfs and similar', 'graphs']"
3382,"Vasya is currently at a car rental service, and he wants to reach cinema. The film he has bought a ticket for starts in t minutes. There is a straight road of length s from the service to the cinema. Let's introduce a coordinate system so that the car rental service is at the point 0, and the cinema is at the point s.There are k gas stations along the road, and at each of them you can fill a car with any amount of fuel for free! Consider that this operation doesn't take any time, i.e. is carried out instantly.There are n cars in the rental service, i-th of them is characterized with two integers ci and vi — the price of this car rent and the capacity of its fuel tank in liters. It's not allowed to fuel a car with more fuel than its tank capacity vi. All cars are completely fueled at the car rental service.Each of the cars can be driven in one of two speed modes: normal or accelerated. In the normal mode a car covers 1 kilometer in 2 minutes, and consumes 1 liter of fuel. In the accelerated mode a car covers 1 kilometer in 1 minutes, but consumes 2 liters of fuel. The driving mode can be changed at any moment and any number of times.Your task is to choose a car with minimum price such that Vasya can reach the cinema before the show starts, i.e. not later than in t minutes. Assume that all cars are completely fueled initially. NoteIn the first sample, Vasya can reach the cinema in time using the first or the third cars, but it would be cheaper to choose the first one. Its price is equal to 10, and the capacity of its fuel tank is 8. Then Vasya can drive to the first gas station in the accelerated mode in 3 minutes, spending 6 liters of fuel. After that he can full the tank and cover 2 kilometers in the normal mode in 4 minutes, spending 2 liters of fuel. Finally, he drives in the accelerated mode covering the remaining 3 kilometers in 3 minutes and spending 6 liters of fuel.  R = lambda: map(int, raw_input().split())

(n, k, s, t) = R()
cvs = [R() for _ in range(n)]
ps = R() + [0, s]
ps.sort()

if t < s:
    print(-1)
else:
    (l, r) = (1, s << 1)
    while l <= r:
        m = l+r >> 1
        t1 = 0
        for i in range(1, len(ps)):
            d = ps[i] - ps[i - 1]
            if d<<1 <= m:
                t1 += d
            elif d > m:
                l = m + 1
                break
            else:
                t1 += 3*d - m
        else:
            if t1 <= t:
                r = m - 1
            else:
                l = m + 1

    ans = 10**9 + 1
    for (c, v) in cvs:
        if v >= l:
            ans = min(ans, c)
    print(ans if ans <= 10**9 else -1)
",['binary search']
3370,"Polycarp likes arithmetic progressions. A sequence $$$[a_1, a_2, \dots, a_n]$$$ is called an arithmetic progression if for each $$$i$$$ ($$$1 \le i &lt; n$$$) the value $$$a_{i+1} - a_i$$$ is the same. For example, the sequences $$$[42]$$$, $$$[5, 5, 5]$$$, $$$[2, 11, 20, 29]$$$ and $$$[3, 2, 1, 0]$$$ are arithmetic progressions, but $$$[1, 0, 1]$$$, $$$[1, 3, 9]$$$ and $$$[2, 3, 1]$$$ are not.It follows from the definition that any sequence of length one or two is an arithmetic progression.Polycarp found some sequence of positive integers $$$[b_1, b_2, \dots, b_n]$$$. He agrees to change each element by at most one. In the other words, for each element there are exactly three options: an element can be decreased by $$$1$$$, an element can be increased by $$$1$$$, an element can be left unchanged.Determine a minimum possible number of elements in $$$b$$$ which can be changed (by exactly one), so that the sequence $$$b$$$ becomes an arithmetic progression, or report that it is impossible.It is possible that the resulting sequence contains element equals $$$0$$$. NoteIn the first example Polycarp should increase the first number on $$$1$$$, decrease the second number on $$$1$$$, increase the third number on $$$1$$$, and the fourth number should left unchanged. So, after Polycarp changed three elements by one, his sequence became equals to $$$[25, 20, 15, 10]$$$, which is an arithmetic progression.In the second example Polycarp should not change anything, because his sequence is an arithmetic progression.In the third example it is impossible to make an arithmetic progression.In the fourth example Polycarp should change only the first element, he should decrease it on one. After that his sequence will looks like $$$[0, 3, 6, 9, 12]$$$, which is an arithmetic progression. import sys

n = raw_input()
a = map(int,raw_input().split())

ans = sys.maxint


if len(a) > 2:
    check = [(0,0,0),
            (1,0,1),
            (0,1,1),
            (-1,0,1),
            (0,-1,1),
            (1,-1,2),
            (-1,1,2),
            (1,1,2),
            (-1,-1,2)]

    for e in check:
        diff = (a[1]+e[1]) - (a[0]+e[0]) 
        chg = e[2]
        state = [e[0],e[1]]
        valid = True 
        for i in range(2,len(a)):
            if a[i] - (a[i-1]+state[i-1]) - diff >= 2 or a[i] - (a[i-1]+state[i-1]) - diff <= -2:
                valid = False
                break
            else:
                state.append(diff - (a[i] - (a[i-1]+state[i-1])) )
                chg += abs(a[i] - (a[i-1]+state[i-1]) - diff)

        if valid:
            ans = min(chg,ans)
else:
    ans = 0

        

print -1 if ans == sys.maxint else ans


","['brute force', 'implementation', 'math']"
4017,"You are given $$$n$$$ patterns $$$p_1, p_2, \dots, p_n$$$ and $$$m$$$ strings $$$s_1, s_2, \dots, s_m$$$. Each pattern $$$p_i$$$ consists of $$$k$$$ characters that are either lowercase Latin letters or wildcard characters (denoted by underscores). All patterns are pairwise distinct. Each string $$$s_j$$$ consists of $$$k$$$ lowercase Latin letters.A string $$$a$$$ matches a pattern $$$b$$$ if for each $$$i$$$ from $$$1$$$ to $$$k$$$ either $$$b_i$$$ is a wildcard character or $$$b_i=a_i$$$.You are asked to rearrange the patterns in such a way that the first pattern the $$$j$$$-th string matches is $$$p[mt_j]$$$. You are allowed to leave the order of the patterns unchanged.Can you perform such a rearrangement? If you can, then print any valid order. NoteThe order of patterns after the rearrangement in the first example is the following:   aaaa  __b_  ab__  _bcd  _b_d Thus, the first string matches patterns ab__, _bcd, _b_d in that order, the first of them is ab__, that is indeed $$$p[4]$$$. The second string matches __b_ and ab__, the first of them is __b_, that is $$$p[2]$$$. The last string matches _bcd and _b_d, the first of them is _bcd, that is $$$p[5]$$$.The answer to that test is not unique, other valid orders also exist.In the second example cba doesn't match __c, thus, no valid order exists.In the third example the order (a_, _b) makes both strings match pattern $$$1$$$ first and the order (_b, a_) makes both strings match pattern $$$2$$$ first. Thus, there is no order that produces the result $$$1$$$ and $$$2$$$. import sys
input = sys.stdin.buffer.readline 

def toposort(graph):
    res, found = [], [0] * len(graph)
    stack = list(range(len(graph)))
    while stack:
        node = stack.pop()
        if node < 0:
            res.append(~node)
        elif not found[node]:
            found[node] = 1
            stack.append(~node)
            stack += graph[node]

    # cycle check
    for node in res:
        if any(found[nei] for nei in graph[node]):
            return None
        found[node] = 0

    return res[::-1]


def kahn(graph):
    n = len(graph)

    indeg, idx = [0] * n, [0] * n
    for i in range(n):
        for e in graph[i]:
            indeg[e] += 1

    q, res = [], []
    for i in range(n):
        if indeg[i] == 0:
            q.append(i)  # heappush(q, -i)

    nr = 0
    while q:
        res.append(q.pop())  # res.append(-heappop(q))
        idx[res[-1]], nr = nr, nr + 1
        for e in graph[res[-1]]:
            indeg[e] -= 1
            if indeg[e] == 0:
                q.append(e)  # heappush(q, -e)

    return res, idx, nr == n


def make_string(s):
    k = len(s)
    answer = 0
    for i in range(k):
        if s[i]=='_':
            entry = 26
        else:
            entry = ord(s[i])-ord('a')
        answer = 27*answer+entry
    return answer
    
def make_strings(s):
    k = len(s)
    answer = [0]
    for i in range(k):
        answer2 = []
        for x in answer:
            for y in [26, ord(s[i])-ord('a')]:
                answer2.append(27*x+y)
        answer = answer2
    return answer
    

def process(P, S):
    n = len(P)
    m = len(S)
    k = len(P[0])
    d = [[None, None] for i in range(27**k)]
    for i in range(n):
        x = make_string(P[i])
        d[x][0] = i+1
    graph = [[] for i in range(n)]
    for i in range(m):
        s1, x1 = S[i]
        works = False
        for s2 in make_strings(s1):
            if d[s2][0] is not None:
                y = d[s2][0]
                if y != x1:
                    graph[x1-1].append(y-1)
                if y==x1:
                    works = True
        if not works:
            sys.stdout.write('NO\n')
            return
    a, b, c = kahn(graph)
    if not c:
        sys.stdout.write('NO\n')
        return
    answer = [None for i in range(n)]
    for i in range(n):
        answer[b[i]] = i+1
    sys.stdout.write('YES\n')
    answer = ' '.join(map(str, answer))
    sys.stdout.write(f'{answer}\n')
        
n, m, k = [int(x) for x in input().split()]
P = []
for i in range(n):
    p = input().decode().strip()
    P.append(p)
S = []
for i in range(m):
    s, x = input().decode().strip().split()
    x = int(x)
    S.append([s, x])
process(P, S)","['bitmasks', 'data structures', 'dfs and similar', 'graphs', 'hashing', 'sortings', 'strings']"
1837,"Roy and Biv have a set of n points on the infinite number line.Each point has one of 3 colors: red, green, or blue.Roy and Biv would like to connect all the points with some edges. Edges can be drawn between any of the two of the given points. The cost of an edge is equal to the distance between the two points it connects.They want to do this in such a way that they will both see that all the points are connected (either directly or indirectly).However, there is a catch: Roy cannot see the color red and Biv cannot see the color blue.Therefore, they have to choose the edges in such a way that if all the red points are removed, the remaining blue and green points are connected (and similarly, if all the blue points are removed, the remaining red and green points are connected).Help them compute the minimum cost way to choose edges to satisfy the above constraints. NoteIn the first sample, it is optimal to draw edges between the points (1,2), (1,4), (3,4). These have costs 4, 14, 5, respectively. #! /usr/bin/env python3
#------------------------------------------------
# Author:    krishna
# Created:   Fri Dec 29 23:04:38 IST 2017
# File Name: f.py
# USAGE:
#       f.py
# Description:
# 
#------------------------------------------------
import sys


n = int(sys.stdin.readline().rstrip())

locations = {
    'R' : [],
    'G' : [],
    'B' : []
}

for i in range(n):
    (x, c) = sys.stdin.readline().rstrip().split()
    locations[c].append(int(x))

# for c in locations.keys():
#     locations[c].sort()

def solve(locations):
    count = 0
    rPtr = 0
    bPtr = 0
    gPtr = 0

    if (len(locations['G']) == 0):
        if (len(locations['R'])):
            count += locations['R'][-1] - locations['R'][0]
        if (len(locations['B'])):
            count += locations['B'][-1] - locations['B'][0]

        return count

    while (len(locations['G']) > gPtr):
        # Eat predecessors
        if (
            (len(locations['R']) > rPtr)
            and (locations['G'][gPtr] > locations['R'][rPtr])
        ):
            count += locations['G'][gPtr] - locations['R'][rPtr]
            while (
                (len(locations['R']) > rPtr)
                and (locations['G'][gPtr] > locations['R'][rPtr])
            ):
                rPtr += 1

        # Eat predecessors
        if (
            (len(locations['B']) > bPtr)
            and (locations['G'][gPtr] > locations['B'][bPtr])
        ):
            count += locations['G'][gPtr] - locations['B'][bPtr]
            while (
                (len(locations['B']) > bPtr)
                and (locations['G'][gPtr] > locations['B'][bPtr])
            ):
                bPtr += 1

        # Eat last successors
        if (len(locations['G']) == (gPtr + 1)):
            if (len(locations['R']) > rPtr):
                count += locations['R'][-1] - locations['G'][gPtr]

            if (len(locations['B']) > bPtr):
                count += locations['B'][-1] - locations['G'][gPtr]

            return count

        # Calc intervels
        if (len(locations['G']) > (gPtr + 1)):
            prevR = locations['G'][gPtr]
            maxRd = 0
            while (len(locations['R']) > rPtr):
                if (locations['R'][rPtr] < locations['G'][gPtr + 1]):
                    maxRd = max(maxRd, locations['R'][rPtr] - prevR)
                    prevR = locations['R'][rPtr]
                    rPtr += 1
                else:
                    break
            maxRd = max(maxRd, locations['G'][gPtr + 1] - prevR)

            prevB = locations['G'][gPtr]
            maxBd = 0
            while (len(locations['B']) > bPtr):
                if (locations['B'][bPtr] < locations['G'][gPtr + 1]):
                    maxBd = max(maxBd, locations['B'][bPtr] - prevB)
                    prevB = locations['B'][bPtr]
                    bPtr += 1
                else:
                    break
            maxBd = max(maxBd, locations['G'][gPtr + 1] - prevB)

            count += min(
                2 * (locations['G'][gPtr + 1] - locations['G'][gPtr]),
                (3 * (locations['G'][gPtr + 1] - locations['G'][gPtr])) - maxRd - maxBd
            )

            gPtr += 1

    return count

print(solve(locations))
","['graphs', 'greedy', 'implementation']"
1886,"Nearly each project of the F company has a whole team of developers working on it. They often are in different rooms of the office in different cities and even countries. To keep in touch and track the results of the project, the F company conducts shared online meetings in a Spyke chat.One day the director of the F company got hold of the records of a part of an online meeting of one successful team. The director watched the record and wanted to talk to the team leader. But how can he tell who the leader is? The director logically supposed that the leader is the person who is present at any conversation during a chat meeting. In other words, if at some moment of time at least one person is present on the meeting, then the leader is present on the meeting.You are the assistant director. Given the 'user logged on'/'user logged off' messages of the meeting in the chronological order, help the director determine who can be the leader. Note that the director has the record of only a continuous part of the meeting (probably, it's not the whole meeting). nan #import random

n, m = map(lambda x: int(x), raw_input().split())
#n, m = 100000, 100000

messages = list()

for i in range(m):
    sign, num = raw_input().split()
    #sign, num = random.choice(['+', '-']), random.randint(1, n)
    num = int(num)
    messages.append((sign, num))

entered = set()
prefix = list()
for m in messages:
    sign, num = m
    if sign == '+':
        entered.add(num)
    else:
        if not num in entered:
            prefix.append(('+', num))

prefix.reverse()
messages = prefix + messages

online = set()
leaders = set(range(1, n + 1))

prev_sign = None
prev_num = 0

for m in messages:
    sign, num = m
    if prev_sign and prev_sign != sign and prev_num != num:
        if num in leaders:
            leaders.remove(num)
        if prev_num in leaders:
            leaders.remove(prev_num)
    if sign == '+':
        if len(online) > 0 and num in leaders:
            leaders.remove(num)
        online.add(num)
    else:
        if num in online:
            online.remove(num)
        if len(online) > 0 and num in leaders:
            leaders.remove(num)
    prev_sign, prev_num = sign, num

print len(leaders)

if len(leaders) > 0:
    print ' '.join([str(x) for x in sorted(list(leaders))])",['implementation']
1505,"In Disgaea as in most role-playing games, characters have skills that determine the character's ability to use certain weapons or spells. If the character does not have the necessary skill, he cannot use it. The skill level is represented as an integer that increases when you use this skill. Different character classes are characterized by different skills. Unfortunately, the skills that are uncommon for the given character's class are quite difficult to obtain. To avoid this limitation, there is the so-called transmigration. Transmigration is reincarnation of the character in a new creature. His soul shifts to a new body and retains part of his experience from the previous life. As a result of transmigration the new character gets all the skills of the old character and the skill levels are reduced according to the k coefficient (if the skill level was equal to x, then after transmigration it becomes equal to [kx], where [y] is the integral part of y). If some skill's levels are strictly less than 100, these skills are forgotten (the character does not have them any more). After that the new character also gains the skills that are specific for his class, but are new to him. The levels of those additional skills are set to 0. Thus, one can create a character with skills specific for completely different character classes via transmigrations. For example, creating a mage archer or a thief warrior is possible. You are suggested to solve the following problem: what skills will the character have after transmigration and what will the levels of those skills be? nan n,m,k = map(float, raw_input().split())
d = {}
e = {}
for i in range(int(n)):
	x,y = raw_input().split()
	d[x] = int(y)
for i in range(int(m)):
	e[raw_input()] = 0
for x in d:
	if d[x]*k >= 100:
		e[x] = d[x]*k
d = []
for x in e:
	d.append((x, int(e[x]+10**-6)))
d.sort()
print len(d)
for x in d:
	print x[0], x[1]
",['implementation']
2405,"Is it rated?Here it is. The Ultimate Question of Competitive Programming, Codeforces, and Everything. And you are here to answer it.Another Codeforces round has been conducted. No two participants have the same number of points. For each participant, from the top to the bottom of the standings, their rating before and after the round is known.It's known that if at least one participant's rating has changed, then the round was rated for sure.It's also known that if the round was rated and a participant with lower rating took a better place in the standings than a participant with higher rating, then at least one round participant's rating has changed.In this problem, you should not make any other assumptions about the rating system.Determine if the current round is rated, unrated, or it's impossible to determine whether it is rated of not. NoteIn the first example, the ratings of the participants in the third and fifth places have changed, therefore, the round was rated.In the second example, no one's rating has changed, but the participant in the second place has lower rating than the participant in the fourth place. Therefore, if the round was rated, someone's rating would've changed for sure.In the third example, no one's rating has changed, and the participants took places in non-increasing order of their rating. Therefore, it's impossible to determine whether the round is rated or not. n = int(input())
arr1, arr2 = list(), list()

for i in range(n):
    line = [int(i) for i in input().split()]
    arr1.append(line[0])
    arr2.append(line[1])

cnt = 0
for i in range(n):
    if not arr1[i] == arr2[i]:
        cnt += 1
        break

if cnt == 0:
    if arr1 == sorted(arr1, reverse=True):
        print('maybe')
    else:
        print('unrated')
else:
    print('rated')
","['implementation', 'sortings']"
1032,"You've got a undirected graph G, consisting of n nodes. We will consider the nodes of the graph indexed by integers from 1 to n. We know that each node of graph G is connected by edges with at least k other nodes of this graph. Your task is to find in the given graph a simple cycle of length of at least k + 1.A simple cycle of length d (d &gt; 1) in graph G is a sequence of distinct graph nodes v1, v2, ..., vd such, that nodes v1 and vd are connected by an edge of the graph, also for any integer i (1 ≤ i &lt; d) nodes vi and vi + 1 are connected by an edge of the graph. nan r = lambda: map(int, raw_input().split())

n, m, k = r()
e = [[] for _ in xrange(n + 1)]
for _ in xrange(m):
    a, b = r()
    e[a].append(b)
    e[b].append(a)
flag = [-1] * (n + 1)
path = []

x, l = 1, 0
while True:
    path.append(x)
    flag[x] = l
    l += 1
    for y in e[x]:
        if flag[y] == -1:
            x = y
            break
    else:
        id = path.index(min(e[x], key = lambda s: flag[s]))
        print len(path) - id
        print ' '.join(map(str, path[id:]))
        break

","['dfs and similar', 'graphs']"
1553,"You are given a sequence of n positive integers d1, d2, ..., dn (d1 &lt; d2 &lt; ... &lt; dn). Your task is to construct an undirected graph such that:  there are exactly dn + 1 vertices;  there are no self-loops;  there are no multiple edges;  there are no more than 106 edges;  its degree set is equal to d. Vertices should be numbered 1 through (dn + 1).Degree sequence is an array a with length equal to the number of vertices in a graph such that ai is the number of vertices adjacent to i-th vertex.Degree set is a sorted in increasing order sequence of all distinct values from the degree sequence.It is guaranteed that there exists such a graph that all the conditions hold, and it contains no more than 106 edges.Print the resulting graph. nan from sys import stdin
from sys import stdout

n = int(stdin.readline())
d = [0] + list(map(int, stdin.readline().split()))
e = []
for i in range(1, n+1):
	for u in range(d[i-1]+1, d[i]+1):
		for v in range(u+1, d[n-i+1]+2):
			e.append([u,v])
stdout.write(""{}\n"".format(len(e)))
for ei in e: stdout.write(""{} {}\n"".format(ei[0], ei[1]))","['constructive algorithms', 'graphs', 'implementation']"
4867,"The only difference from the previous problem is the constraint on the number of requests. In this problem your program should guess the answer doing at most 7 requests.This problem is a little bit unusual. Here you are to implement an interaction with a testing system. That means that you can make queries and get responses in the online mode. Please be sure to use the stream flushing operation after each query's output in order not to leave part of your output in some buffer. For example, in C++ you've got to use the fflush(stdout) function, in Java — call System.out.flush(), and in Pascal — flush(output).Bulls and Cows (also known as Cows and Bulls or Pigs and Bulls or Bulls and Cleots) is an old code-breaking paper and pencil game for two players, predating the similar commercially marketed board game Mastermind.On a sheet of paper, the first player thinks a secret string. This string consists only of digits and has the length 4. The digits in the string must be all different, no two or more equal digits are allowed.Then the second player tries to guess his opponent's string. For every guess the first player gives the number of matches. If the matching digits are on their right positions, they are ""bulls"", if on different positions, they are ""cows"". Thus a response is a pair of numbers — the number of ""bulls"" and the number of ""cows"". A try can contain equal digits.More formally, let's the secret string is s and the second player are trying to guess it with a string x. The number of ""bulls"" is a number of such positions i (1 ≤ i ≤ 4) where s[i] = x[i]. The number of ""cows"" is a number of such digits c that s contains c in the position i (i.e. s[i] = c), x contains c, but x[i] ≠ c.For example, the secret string is ""0427"", the opponent's try is ""0724"", then the answer is 2 bulls and 2 cows (the bulls are ""0"" and ""2"", the cows are ""4"" and ""7""). If the secret string is ""0123"", the opponent's try is ""0330"", then the answer is 1 bull and 1 cow.In this problem you are to guess the string s that the system has chosen. You only know that the chosen string consists of 4 distinct digits.You can make queries to the testing system, each query is the output of a single 4-digit string. The answer to the query is the number of bulls and number of cows. If the system's response equals ""4 0"", that means the interaction with your problem is over and the program must terminate. That is possible for two reasons — the program either guessed the number x or made an invalid action (for example, printed letters instead of digits).Your program is allowed to do at most 7 queries.You can hack solutions of other participants providing a 4-digit string containing distinct digits — the secret string. NoteThe secret string s in the example is ""0123"". import random
import sys

def valid(st) :
  return len(set(x for x in st)) == 4

def comp(guess, secret) :
  b, c = 0, 0
  for i in range(4) : 
    if secret[i] == guess[i] : 
      b += 1
    elif secret[i] in guess :
      c += 1
  return (b, c)

def check(guess, secret, bulls, cows) :
  b, c = comp(guess, secret)
  return bulls == b and cows == c

def filtered(candidates, history) :
  ret = []
  for c in candidates :
    good = True
    for query, res in history :
      if not check(c, query, res[0], res[1]) :
        good = False
    if good :
      ret.append(c)
  return ret

def next_guess(candidates, step) :
  if step < 2 :
    return candidates[random.randint(0, len(candidates)-1)]
    # Can get an accuracy of 99% if go random each step
  best = 5040
  if len(candidates) == 1 :
    return candidates[0]
  now = candidates[0]
  for g in candidates :
    poss = [ [0] * 5 for x in range(5)]
    for s in candidates :
      b, c = comp(g, s)
      poss[b][c] += 1
    penalty = max( max(arr) for arr in poss )
    if penalty < best :
      best = penalty
      now = g
  return now

def generate_all_initial() :
  ret = list(filter(valid, map( lambda x : ""%04d"" % x, range(9999))))
  return ret

everyone = generate_all_initial()
def test(true_secret) :
  global everyone
  choices, history = everyone[:], []
  for step in range(6) :
    take_guess = next_guess(choices, step)
    if not valid(take_guess) :
      print(""Crashed"", true_secret)
      break
    result = comp(take_guess, true_secret)
    history.append((take_guess,result))
    choices = filtered(choices, history)
  if len(choices) != 1 :
    print(""Failed"", true_secret)
    print(len(choices),history)
    return False
  else :
    print(""Pass"", true_secret)
    return True

def run() :
  global everyone
  choices, history = everyone[:], []
  for step in range(7) :
    take_guess = next_guess(choices, step)
    print(take_guess)
    sys.stdout.flush()
    b, c = map(int, input().split())
    if b == 4 and c == 0 :
      return
    history.append((take_guess,(b,c)))
    choices = filtered(choices, history)

#### Main ####
#true_secret = start[random.randint(0,5039)]
""""""
count = 0
for true_secret in everyone :
  if not test(true_secret) :
    count += 1
print(count, count / 5040.0)
""""""

run()
","['brute force', 'constructive algorithms', 'interactive']"
3525,"Inaka has a disc, the circumference of which is $$$n$$$ units. The circumference is equally divided by $$$n$$$ points numbered clockwise from $$$1$$$ to $$$n$$$, such that points $$$i$$$ and $$$i + 1$$$ ($$$1 \leq i &lt; n$$$) are adjacent, and so are points $$$n$$$ and $$$1$$$.There are $$$m$$$ straight segments on the disc, the endpoints of which are all among the aforementioned $$$n$$$ points.Inaka wants to know if her image is rotationally symmetrical, i.e. if there is an integer $$$k$$$ ($$$1 \leq k &lt; n$$$), such that if all segments are rotated clockwise around the center of the circle by $$$k$$$ units, the new image will be the same as the original one. NoteThe first two examples are illustrated below. Both images become the same as their respective original ones after a clockwise rotation of $$$120$$$ degrees around the center.   n, m = [int(i) for i in input().split()]
s = {tuple(sorted([int(i) - 1 for i in input().split()])) for i in range(m)}
for i in range(1, n):
    if n % i == 0 and all((n // i) % j for j in range(2, min(n // i, int((n // i) ** 0.5) + 2))):
        if {tuple(sorted([(t[0] + i) % n, (t[1] + i) % n])) for t in s} == s:
            print(""Yes"")
            break
else:
    print(""No"")
","['hashing', 'implementation', 'strings']"
2164,"Kawashiro Nitori is a girl who loves competitive programming.One day she found a string and an integer. As an advanced problem setter, she quickly thought of a problem.Given a string $$$s$$$ and a parameter $$$k$$$, you need to check if there exist $$$k+1$$$ non-empty strings $$$a_1,a_2...,a_{k+1}$$$, such that $$$$$$s=a_1+a_2+\ldots +a_k+a_{k+1}+R(a_k)+R(a_{k-1})+\ldots+R(a_{1}).$$$$$$ Here $$$+$$$ represents concatenation. We define $$$R(x)$$$ as a reversed string $$$x$$$. For example $$$R(abcd) = dcba$$$. Note that in the formula above the part $$$R(a_{k+1})$$$ is intentionally skipped. NoteIn the first test case, one possible solution is $$$a_1=qw$$$ and $$$a_2=q$$$.In the third test case, one possible solution is $$$a_1=i$$$ and $$$a_2=o$$$.In the fifth test case, one possible solution is $$$a_1=dokidokiliteratureclub$$$. ans_list = []
for i in range(int(input())):
	n, k = map(int, input().split())
	strings = input()

	skip = False
	if(n == 2 * k):
		ans_list.append(""NO"")
		continue

	for i in range(k):
		if(strings[i] == strings[n - 1 - i]):
			pass
		else:
			ans_list.append(""NO"")
			skip = True
			break

	if(skip == False):
		ans_list.append(""YES"")

for ans in ans_list:
	print(ans)

","['brute force', 'constructive algorithms', 'greedy', 'strings']"
233,"In Berland recently a new collection of toys went on sale. This collection consists of 109 types of toys, numbered with integers from 1 to 109. A toy from the new collection of the i-th type costs i bourles.Tania has managed to collect n different types of toys a1, a2, ..., an from the new collection. Today is Tanya's birthday, and her mother decided to spend no more than m bourles on the gift to the daughter. Tanya will choose several different types of toys from the new collection as a gift. Of course, she does not want to get a type of toy which she already has.Tanya wants to have as many distinct types of toys in her collection as possible as the result. The new collection is too diverse, and Tanya is too little, so she asks you to help her in this. NoteIn the first sample mom should buy two toys: one toy of the 2-nd type and one toy of the 5-th type. At any other purchase for 7 bourles (assuming that the toys of types 1, 3 and 4 have already been bought), it is impossible to buy two and more toys. # Tanya and Toys.py

from collections import *

n,m = map(int,raw_input().split())
arr = map(int,raw_input().split())
ans = [];
arr.sort();
start = 0;
arr.append(10**9+5);
for i in xrange(1,10**9):
	if m - i < 0 :
		break;
	if i == arr[start]:
		start+=1;
	else:
		ans.append(i);
		m -= i;
print len(ans)
print ' '.join(map(str,ans))
","['greedy', 'implementation']"
4853,"You are standing on the $$$\mathit{OX}$$$-axis at point $$$0$$$ and you want to move to an integer point $$$x &gt; 0$$$.You can make several jumps. Suppose you're currently at point $$$y$$$ ($$$y$$$ may be negative) and jump for the $$$k$$$-th time. You can:   either jump to the point $$$y + k$$$  or jump to the point $$$y - 1$$$. What is the minimum number of jumps you need to reach the point $$$x$$$? NoteIn the first test case $$$x = 1$$$, so you need only one jump: the $$$1$$$-st jump from $$$0$$$ to $$$0 + 1 = 1$$$.In the second test case $$$x = 2$$$. You need at least three jumps:   the $$$1$$$-st jump from $$$0$$$ to $$$0 + 1 = 1$$$;  the $$$2$$$-nd jump from $$$1$$$ to $$$1 + 2 = 3$$$;  the $$$3$$$-rd jump from $$$3$$$ to $$$3 - 1 = 2$$$; Two jumps are not enough because these are the only possible variants:   the $$$1$$$-st jump as $$$-1$$$ and the $$$2$$$-nd one as $$$-1$$$ — you'll reach $$$0 -1 -1 =-2$$$;  the $$$1$$$-st jump as $$$-1$$$ and the $$$2$$$-nd one as $$$+2$$$ — you'll reach $$$0 -1 +2 = 1$$$;  the $$$1$$$-st jump as $$$+1$$$ and the $$$2$$$-nd one as $$$-1$$$ — you'll reach $$$0 +1 -1 = 0$$$;  the $$$1$$$-st jump as $$$+1$$$ and the $$$2$$$-nd one as $$$+2$$$ — you'll reach $$$0 +1 +2 = 3$$$; In the third test case, you need two jumps: the $$$1$$$-st one as $$$+1$$$ and the $$$2$$$-nd one as $$$+2$$$, so $$$0 + 1 + 2 = 3$$$.In the fourth test case, you need three jumps: the $$$1$$$-st one as $$$-1$$$, the $$$2$$$-nd one as $$$+2$$$ and the $$$3$$$-rd one as $$$+3$$$, so $$$0 - 1 + 2 + 3 = 4$$$. t=int(input())
for i in range(t):
    n=int(input())
    u=1
    while((u*(u+1)/2)<n):
        u += 1
    a=u*(u+1)/2
    c=a-n
    for j in range(1,u+1):
        if(c==j+1):
            c = c-j-1
    print(int(u+c))","['binary search', 'constructive algorithms', 'math']"
1614,"You've got a undirected tree s, consisting of n nodes. Your task is to build an optimal T-decomposition for it. Let's define a T-decomposition as follows.Let's denote the set of all nodes s as v. Let's consider an undirected tree t, whose nodes are some non-empty subsets of v, we'll call them xi . The tree t is a T-decomposition of s, if the following conditions holds:  the union of all xi equals v;  for any edge (a, b) of tree s exists the tree node t, containing both a and b;  if the nodes of the tree t xi and xj contain the node a of the tree s, then all nodes of the tree t, lying on the path from xi to xj also contain node a. So this condition is equivalent to the following: all nodes of the tree t, that contain node a of the tree s, form a connected subtree of tree t. There are obviously many distinct trees t, that are T-decompositions of the tree s. For example, a T-decomposition is a tree that consists of a single node, equal to set v.Let's define the cardinality of node xi as the number of nodes in tree s, containing in the node. Let's choose the node with the maximum cardinality in t. Let's assume that its cardinality equals w. Then the weight of T-decomposition t is value w. The optimal T-decomposition is the one with the minimum weight.Your task is to find the optimal T-decomposition of the given tree s that has the minimum number of nodes. nan n = input()
print n - 1
r = [[] for _ in range(n)]
for i in range(1, n):
	a, b = map(int, raw_input().split())
	print 2, a, b
	r[a - 1] += [i]
	r[b - 1] += [i]
for x in r:
	for i in range(1, len(x)):
		print x[i - 1], x[i]","['dfs and similar', 'graphs', 'greedy', 'trees']"
415,"Asterix, Obelix and their temporary buddies Suffix and Prefix has finally found the Harmony temple. However, its doors were firmly locked and even Obelix had no luck opening them.A little later they found a string s, carved on a rock below the temple's gates. Asterix supposed that that's the password that opens the temple and read the string aloud. However, nothing happened. Then Asterix supposed that a password is some substring t of the string s.Prefix supposed that the substring t is the beginning of the string s; Suffix supposed that the substring t should be the end of the string s; and Obelix supposed that t should be located somewhere inside the string s, that is, t is neither its beginning, nor its end.Asterix chose the substring t so as to please all his companions. Besides, from all acceptable variants Asterix chose the longest one (as Asterix loves long strings). When Asterix read the substring t aloud, the temple doors opened. You know the string s. Find the substring t or determine that such substring does not exist and all that's been written above is just a nice legend. nan import sys
input=sys.stdin.readline
import collections as cc
s=input().strip()
n=len(s)
temp=cc.Counter(s)
pre=[0]*(n)
i=1
j=0
lst=-1
while i<n:
	if(s[i]==s[j]):
		j+=1
		pre[i]=j
		i+=1
	else:
		if j:
			j=pre[j-1]
		else:
			pre[i]=0
			i+=1
pre[0]=0
#print(pre)
temp=pre[-1]
if pre[-1]!=0 and pre.count(temp)>=2:
	print(''.join(s[:temp]))
elif pre[-1]!=0 and pre[pre[-1]-1]>0:
	print(''.join(s[:pre[pre[-1]-1]]))
else:
	print('Just a legend')

	","['binary search', 'dp', 'hashing', 'other', 'strings']"
1292,"Alice and Bob are playing a game on a sequence $$$a_1, a_2, \dots, a_n$$$ of length $$$n$$$. They move in turns and Alice moves first.In the turn of each player, he or she should select an integer and remove it from the sequence. The game ends when there is no integer left in the sequence. Alice wins if the sum of her selected integers is even; otherwise, Bob wins. Your task is to determine who will win the game, if both players play optimally. NoteIn the first and second test cases, Alice always selects two odd numbers, so the sum of her selected numbers is always even. Therefore, Alice always wins.In the third test case, Bob has a winning strategy that he always selects a number with the same parity as Alice selects in her last turn. Therefore, Bob always wins.In the fourth test case, Alice always selects two even numbers, so the sum of her selected numbers is always even. Therefore, Alice always wins. t = int(input())

def solve(n, a):
    x, y = 0, 0
    for i in a:
        if (i&1): x = x+1
        else: y = y+1

    def f(x):
        return (((x>>1)+(x&1))&1)

    if x>=2:
        if not f(x) and not (x&1):
            return ""Alice""
        if f(x) and not (x&1):
            return ""Bob""
        if not f(x) or (y&1):
            return ""Alice""
        return ""Bob""
    
    else:
        if x==0:
            return ""Alice""
        if x==1 and (y&1):
            return ""Alice""
        return ""Bob""
        

for i in range(t):
    n = int(input())
    a = list(map(int, input().split()))
    print(solve(n, a))","['dp', 'games', 'greedy', 'math']"
3169,"Phoenix has decided to become a scientist! He is currently investigating the growth of bacteria.Initially, on day $$$1$$$, there is one bacterium with mass $$$1$$$.Every day, some number of bacteria will split (possibly zero or all). When a bacterium of mass $$$m$$$ splits, it becomes two bacteria of mass $$$\frac{m}{2}$$$ each. For example, a bacterium of mass $$$3$$$ can split into two bacteria of mass $$$1.5$$$.Also, every night, the mass of every bacteria will increase by one.Phoenix is wondering if it is possible for the total mass of all the bacteria to be exactly $$$n$$$. If it is possible, he is interested in the way to obtain that mass using the minimum possible number of nights. Help him become the best scientist! NoteIn the first test case, the following process results in bacteria with total mass $$$9$$$:   Day $$$1$$$: The bacterium with mass $$$1$$$ splits. There are now two bacteria with mass $$$0.5$$$ each.  Night $$$1$$$: All bacteria's mass increases by one. There are now two bacteria with mass $$$1.5$$$.  Day $$$2$$$: None split.  Night $$$2$$$: There are now two bacteria with mass $$$2.5$$$.  Day $$$3$$$: Both bacteria split. There are now four bacteria with mass $$$1.25$$$.  Night $$$3$$$: There are now four bacteria with mass $$$2.25$$$.  The total mass is $$$2.25+2.25+2.25+2.25=9$$$. It can be proved that $$$3$$$ is the minimum number of nights needed. There are also other ways to obtain total mass 9 in 3 nights.$$$ $$$In the second test case, the following process results in bacteria with total mass $$$11$$$:   Day $$$1$$$: The bacterium with mass $$$1$$$ splits. There are now two bacteria with mass $$$0.5$$$.  Night $$$1$$$: There are now two bacteria with mass $$$1.5$$$.  Day $$$2$$$: One bacterium splits. There are now three bacteria with masses $$$0.75$$$, $$$0.75$$$, and $$$1.5$$$.  Night $$$2$$$: There are now three bacteria with masses $$$1.75$$$, $$$1.75$$$, and $$$2.5$$$.  Day $$$3$$$: The bacteria with mass $$$1.75$$$ and the bacteria with mass $$$2.5$$$ split. There are now five bacteria with masses $$$0.875$$$, $$$0.875$$$, $$$1.25$$$, $$$1.25$$$, and $$$1.75$$$.  Night $$$3$$$: There are now five bacteria with masses $$$1.875$$$, $$$1.875$$$, $$$2.25$$$, $$$2.25$$$, and $$$2.75$$$.  The total mass is $$$1.875+1.875+2.25+2.25+2.75=11$$$. It can be proved that $$$3$$$ is the minimum number of nights needed. There are also other ways to obtain total mass 11 in 3 nights.$$$ $$$In the third test case, the bacterium does not split on day $$$1$$$, and then grows to mass $$$2$$$ during night $$$1$$$. for _ in range(int(input())):
    arr = []
    n = int(input())
    x = 1
    while x < n:
        arr.append(x)
        n -= x
        x *= 2
    if n > 0:
        arr.append(n)
    arr.sort()
    s = []
    print(len(arr)-1)
    for i in range(len(arr)-1):
        s.append(arr[i+1]-arr[i])
    print(*s)
","['binary search', 'constructive algorithms', 'greedy', 'implementation', 'math']"
2232,"The R1 company wants to hold a web search championship. There were n computers given for the competition, each of them is connected to the Internet. The organizers believe that the data transfer speed directly affects the result. The higher the speed of the Internet is, the faster the participant will find the necessary information. Therefore, before the competition started, each computer had its maximum possible data transfer speed measured. On the i-th computer it was ai kilobits per second.There will be k participants competing in the championship, each should get a separate computer. The organizing company does not want any of the participants to have an advantage over the others, so they want to provide the same data transfer speed to each participant's computer. Also, the organizers want to create the most comfortable conditions for the participants, so the data transfer speed on the participants' computers should be as large as possible.The network settings of the R1 company has a special option that lets you to cut the initial maximum data transfer speed of any computer to any lower speed. How should the R1 company configure the network using the described option so that at least k of n computers had the same data transfer speed and the data transfer speed on these computers was as large as possible? NoteIn the first test case the organizers can cut the first computer's speed to 30 kilobits. Then two computers (the first and the third one) will have the same speed of 30 kilobits. They should be used as the participants' computers. This answer is optimal. n,k=map(int,raw_input().split())
lst=map(int,raw_input().split())
lst.sort(reverse=True)
print lst[k-1]
","['greedy', 'sortings']"
17,"Alice bought a Congo Prime Video subscription and was watching a documentary on the archaeological findings from Factor's Island on Loch Katrine in Scotland. The archaeologists found a book whose age and origin are unknown. Perhaps Alice can make some sense of it?The book contains a single string of characters ""a"", ""b"" and ""c"". It has been pointed out that no two consecutive characters are the same. It has also been conjectured that the string contains an unusually long subsequence that reads the same from both sides. Help Alice verify this by finding such subsequence that contains at least half of the characters of the original string, rounded down. Note that you don't have to maximise the length of it.A string $$$a$$$ is a subsequence of a string $$$b$$$ if $$$a$$$ can be obtained from $$$b$$$ by deletion of several (possibly, zero or all) characters. NoteIn the first example, other valid answers include ""cacac"", ""caac"", ""aca"" and ""ccc"".  




sre               =                input()
























pre                     =                             0














kre                    =                 len(sre)         -           1

























pointeree                         =                                          0














plotttt                   =                    []
















while (pre        +        1            <          kre         -      1): 
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	if( sre[  pre ]               ==        sre[  kre ]):
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		plotttt.append( sre[ pre ])
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		pre                           +=                   1
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		kre                                -=                            1
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		pointeree                                                     +=                      2
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	elif (sre[  pre ]                        ==              sre[  kre     -   1]):
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		plotttt.append(  sre[  pre  ])
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		pre                                +=                         1
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		kre                              -=                               2
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	elif( sre[  pre   +          1]                     ==                  sre[        kre    ]):
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		plotttt.append(  sre[ pre   +  1 ])
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		pre                           +=                                 2
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		kre                     -=                  1
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	else:
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
		plotttt.append( sre[    pre       +          1 ])
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		pre                             +=                             2
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		kre                                               -=                     2

























dfdkngkfgjfb                                      =             0




















if (kre          -          pre            ==            2):
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	xrere           =                [  sre[  pre  ],        sre[   pre  +    1],          sre[      pre  +    2 ]]


















	
	
	
	
	
	
	
	xrere.sort()
	
	
	
	
	
	
	
	
	
	
	
	
	
	if( xrere[0]                              ==          xrere[1]):
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		plotttt.append( xrere[ 0 ])
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	elif (xrere[ 1 ]                  ==                xrere[ 2 ]):
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		plotttt.append( xrere[ 1 ])
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	else:
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
		dfdkngkfgjfb                        =                  xrere[ 1 ]

























if(      kre            -            pre           ==       1):
	
	
	
	
	
	
	
	
	
	
	
	
	if( sre[ pre]                     ==             sre[  pre        +     1 ]):


















		plotttt.append( sre[ pre ])
























	else:



















		dfdkngkfgjfb                          =             sre[  pre  ]



















if (kre               ==                            pre):























	dfdkngkfgjfb                              =                            sre[  pre  ]






















if(                    dfdkngkfgjfb               ==            0):
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	if (          len(   plotttt)   *    2                  >=                 len( sre )//2):
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		for i in plotttt:
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
			print(i, end = """")
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		for i in range(len(plotttt)):
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
			j                                    =           len(    plotttt    )         -         1        -   i
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			print(plotttt[j], end = """")
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	else:
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		print(""IMPOSSIBLE"")


























else:
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	if (         2             *       len(         plotttt        )        +       1)           >=            len(  sre   )//2:
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		for i in plotttt:
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			print(i,             end = """")
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		print(         dfdkngkfgjfb,                        end = """")
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		for i in range(len(      plotttt   )):
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			j                       =              len(        plotttt          )            -              1             - i
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
			print(             plotttt[ j ],                  end = """")
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	else:
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
		
		
		
		
		
		
		
		
		
		
		
		
		
		print(""IMPOSSIBLE"")","['brute force', 'constructive algorithms', 'greedy', 'strings']"
3580,"The process of mammoth's genome decoding in Berland comes to its end!One of the few remaining tasks is to restore unrecognized nucleotides in a found chain s. Each nucleotide is coded with a capital letter of English alphabet: 'A', 'C', 'G' or 'T'. Unrecognized nucleotides are coded by a question mark '?'. Thus, s is a string consisting of letters 'A', 'C', 'G', 'T' and characters '?'.It is known that the number of nucleotides of each of the four types in the decoded genome of mammoth in Berland should be equal.Your task is to decode the genome and replace each unrecognized nucleotide with one of the four types so that the number of nucleotides of each of the four types becomes equal. NoteIn the first example you can replace the first question mark with the letter 'A', the second question mark with the letter 'G', the third question mark with the letter 'T', then each nucleotide in the genome would be presented twice.In the second example the genome is already decoded correctly and each nucleotide is exactly once in it.In the third and the fourth examples it is impossible to decode the genom.  n=input("""")
Gene= list(input(""""))
l= len(Gene)/4
for i in range(len(Gene)):
    if Gene[i]=='?':
        if Gene.count(""A"")!=l:
            Gene[i]=""A""
        elif Gene.count(""C"")!=l:
            Gene[i]=""C""
        elif Gene.count(""G"")!=l:
            Gene[i]=""G""
        elif Gene.count(""T"")!=l:
            Gene[i]=""T""

if Gene.count(""A"")==Gene.count(""G"") and Gene.count(""A"")==Gene.count(""T"") and Gene.count(""A"")==Gene.count(""C"") and Gene.count(""G"")==Gene.count(""T"") and Gene.count(""G"")==Gene.count(""C"") and Gene.count(""T"")==Gene.count(""C""):
    for i in Gene:
        print(i,end="""")
else:
    print(""==="")
","['implementation', 'strings']"
4803,"Polycarp and Monocarp are both solving the same puzzle with dominoes. They are given the same set of $$$n$$$ dominoes, the $$$i$$$-th of which contains two numbers $$$x_i$$$ and $$$y_i$$$. They are also both given the same $$$m$$$ by $$$k$$$ grid of values $$$a_{ij}$$$ such that $$$m\cdot k = 2n$$$.The puzzle asks them to place the $$$n$$$ dominoes on the grid in such a way that none of them overlap, and the values on each domino match the $$$a_{ij}$$$ values that domino covers. Dominoes can be rotated arbitrarily before being placed on the grid, so the domino $$$(x_i, y_i)$$$ is equivalent to the domino $$$(y_i, x_i)$$$.They have both solved the puzzle, and compared their answers, but noticed that not only did their solutions not match, but none of the $$$n$$$ dominoes were in the same location in both solutions! Formally, if two squares were covered by the same domino in Polycarp's solution, they were covered by different dominoes in Monocarp's solution. The diagram below shows one potential $$$a$$$ grid, along with the two players' solutions.  Polycarp and Monocarp remember the set of dominoes they started with, but they have lost the grid $$$a$$$. Help them reconstruct one possible grid $$$a$$$, along with both of their solutions, or determine that no such grid exists. NoteExtra blank lines are added to the output for clarity, but are not required.The third sample case corresponds to the image from the statement. from collections import Counter
from sys import stdin, gettrace

if gettrace():
    def inputi():
        return input()
else:
    def input():
        return next(stdin)[:-1]


    def inputi():
        return stdin.buffer.readline()


def solve(n: int, ds: [[int]]) -> (bool, int, int, [[int]], [str], [str]):
    adj = [Counter() for _ in range(2 * n + 1)]
    for u, v in ds:
        adj[u][v] += 1
        adj[v][u] += 1
    visited = [False] * (2 * n + 1)
    cycles = []
    for r in range(1, 2 * n + 1):
        if not adj[r]:
            continue
        cycles.append([r])
        stack = []
        v = r
        while adj[r] or stack:
            visited[v] = True
            if adj[v]:
                a,c = adj[v].popitem()
                if a == v:
                    c //= 2
                del adj[a][v]
                if visited[a]:
                    cycles[-1] += [a, v]*c
                else:
                    cycles[-1] += [a, v]*(c-1)
                    cycles[-1].append(a)
                    stack.append(v)
                    v = a
            else:
                v = stack.pop()
                cycles[-1].append(v)
        cycles[-1].pop()
        if len(cycles[-1]) == 2:
            return False, None, None, None, None, None
    grid = [[] for _ in range(2)]
    pc = [[] for _ in range(2)]
    mc = [[] for _ in range(2)]
    for cycle in cycles:
        l = len(cycle) // 2
        grid[0] += cycle[:l]
        grid[1] += cycle[:l - 1:-1]
        pc[0] += ['L', 'R'] * (l // 2) + (['U'] if l % 2 == 1 else [])
        pc[1] += ['L', 'R'] * (l // 2) + (['D'] if l % 2 == 1 else [])
        mc[0] += ['U'] + ['L', 'R'] * ((l - 1) // 2) + (['U'] if l % 2 == 0 else [])
        mc[1] += ['D'] + ['L', 'R'] * ((l - 1) // 2) + (['D'] if l % 2 == 0 else [])
    return True, 2, n, grid, pc, mc


def main():
    n = int(inputi())
    ds = [[int(a) for a in inputi().split()] for _ in range(n)]
    ok, m, k, grid, pc, mc = solve(n, ds)
    if not ok:
        print(-1)
    else:
        print(m, k)
        for r in grid:
            print(' '.join(map(str, r)))
        for r in pc:
            print(''.join(r))
        for r in mc:
            print(''.join(r))


if __name__ == ""__main__"":
    main()
","['constructive algorithms', 'dfs and similar', 'graphs']"
2107," — Do you have a wish?  — I want people to stop gifting each other arrays.O_o and Another Young BoyAn array of $$$n$$$ positive integers $$$a_1,a_2,\ldots,a_n$$$ fell down on you from the skies, along with a positive integer $$$k \le n$$$.You can apply the following operation at most $$$k$$$ times:   Choose an index $$$1 \le i \le n$$$ and an integer $$$1 \le x \le 10^9$$$. Then do $$$a_i := x$$$ (assign $$$x$$$ to $$$a_i$$$). Then build a complete undirected weighted graph with $$$n$$$ vertices numbered with integers from $$$1$$$ to $$$n$$$, where edge $$$(l, r)$$$ ($$$1 \le l &lt; r \le n$$$) has weight $$$\min(a_{l},a_{l+1},\ldots,a_{r})$$$.You have to find the maximum possible diameter of the resulting graph after performing at most $$$k$$$ operations.The diameter of a graph is equal to $$$\max\limits_{1 \le u &lt; v \le n}{\operatorname{d}(u, v)}$$$, where $$$\operatorname{d}(u, v)$$$ is the length of the shortest path between vertex $$$u$$$ and vertex $$$v$$$. NoteIn the first test case, one of the optimal arrays is $$$[2,4,5]$$$.The graph built on this array:   $$$\operatorname{d}(1, 2) = \operatorname{d}(1, 3) = 2$$$ and $$$\operatorname{d}(2, 3) = 4$$$, so the diameter is equal to $$$\max(2,2,4) = 4$$$. import collections
import math
#import bisect
#import itertools
def solve():
    n, k = list(map(int, input().split()))
    arr = list(map(int, input().split()))
    if n == k:
        print(10 ** 9)
        return
    new_arr = []
    for i in range(n):
        new_arr.append((arr[i], i))
    new_arr.sort()
    i = 0
    k -= 1
    while k:
        arr[new_arr[i][1]] = 10 ** 9
        i += 1
        k -= 1
    
    min_idx = set([0])
    curr = arr[0]
    l = 0
    for i in range(1, n):
        l = max(l, min(arr[i-1], arr[i]))
        temp = arr[i]
        if temp < curr:
            min_idx = set([i])
            curr = temp
        elif temp == curr:
            min_idx.add(i)

    edge = curr
    if len(min_idx) == 1:
        sub_min = math.inf
        for i in range(n):
            if i not in min_idx:
                sub_min = min(sub_min, arr[i])

    if arr[0] < arr[1]:
        e = edge
        if 0 in min_idx and len(min_idx) == 1:
                e = sub_min
        ans = min(max(l, arr[1]), 2 * e)
    else:
        ans = min(l, 2 * edge)

    for i in range(1, n - 1):
        if arr[i] < arr[i-1] or arr[i] < arr[i+1]:
            e = edge
            if i in min_idx and len(min_idx) == 1:
                e = sub_min
            ans = max(ans, min(max(l, arr[i-1], arr[i+1]), 2 * e))

    if arr[n-1] < arr[n-2]:
        e = edge
        if n - 1 in min_idx and len(min_idx) == 1:
            e = sub_min
        ans = max(ans, min(max(l, arr[n-2]), 2 * e))

    print(ans)
    
t = int(input())
for _ in range(t):
    solve()","['binary search', 'constructive algorithms', 'data structures', 'greedy', 'shortest paths']"
859,"Haiku is a genre of Japanese traditional poetry.A haiku poem consists of 17 syllables split into three phrases, containing 5, 7 and 5 syllables correspondingly (the first phrase should contain exactly 5 syllables, the second phrase should contain exactly 7 syllables, and the third phrase should contain exactly 5 syllables). A haiku masterpiece contains a description of a moment in those three phrases. Every word is important in a small poem, which is why haiku are rich with symbols. Each word has a special meaning, a special role. The main principle of haiku is to say much using a few words.To simplify the matter, in the given problem we will consider that the number of syllable in the phrase is equal to the number of vowel letters there. Only the following letters are regarded as vowel letters: ""a"", ""e"", ""i"", ""o"" and ""u"".Three phases from a certain poem are given. Determine whether it is haiku or not. nan phr1, phr2, phr3 = raw_input(), raw_input(), raw_input()
if sum([phr1.count(k) for k in ""aeiou""]) == 5 and sum([phr2.count(k) for k in ""aeiou""]) == 7 and sum([phr3.count(k) for k in ""aeiou""]) == 5:
    print ""YES""
else:
    print ""NO""","['implementation', 'strings']"
1444,"Профиль горного хребта схематично задан в виде прямоугольной таблицы из символов «.» (пустое пространство) и «*» (часть горы). Каждый столбец таблицы содержит хотя бы одну «звёздочку». Гарантируется, что любой из символов «*» либо находится в нижней строке матрицы, либо непосредственно под ним находится другой символ «*».  ....................*..*.......*.**.......*.**..*...**.***********   Пример изображения горного хребта.  Маршрут туриста проходит через весь горный хребет слева направо. Каждый день турист перемещается вправо — в соседний столбец в схематичном изображении. Конечно, каждый раз он поднимается (или опускается) в самую верхнюю точку горы, которая находится в соответствующем столбце.Считая, что изначально турист находится в самой верхней точке в первом столбце, а закончит свой маршрут в самой верхней точке в последнем столбце, найдите две величины:  наибольший подъём за день (равен 0, если в профиле горного хребта нет ни одного подъёма),  наибольший спуск за день (равен 0, если в профиле горного хребта нет ни одного спуска).  ПримечаниеВ первом тестовом примере высоты гор равны: 3, 4, 1, 1, 2, 1, 1, 1, 2, 5, 1. Наибольший подъем равен 3 и находится между горой номер 9 (её высота равна 2) и горой номер 10 (её высота равна 5). Наибольший спуск равен 4 и находится между горой номер 10 (её высота равна 5) и горой номер 11 (её высота равна 1).Во втором тестовом примере высоты гор равны: 1, 2, 3, 4, 5. Наибольший подъём равен 1 и находится, например, между горой номер 2 (ее высота равна 2) и горой номер 3 (её высота равна 3). Так как в данном горном хребте нет спусков, то величина наибольшего спуска равна 0.В третьем тестовом примере высоты гор равны: 1, 7, 5, 3, 4, 2, 3. Наибольший подъём равен 6 и находится между горой номер 1 (её высота равна 1) и горой номер 2 (её высота равна 7). Наибольший спуск равен 2 и находится между горой номер 2 (её высота равна 7) и горой номер 3 (её высота равна 5). Такой же спуск находится между горой номер 5 (её высота равна 4) и горой номер 6 (её высота равна 2). n,m=map(int,input().split())
a=[input()]
for i in range(n-1):
    a.append(input())
mi=0
ma=0
k=0
for i in range(n):
    if a[i][0]=='*':
        k=i
        break
for i in range(1,m):
    for j in range(n):
        if a[j][i]=='*':
            if j!=k:
                if j<k and k-j>ma:
                    ma=k-j
                if j>k and j-k>mi:
                    mi=j-k
            k=j
            break
print(ma,mi)
",['constructive algorithms']
3755,"Right before the UEFA Euro 2020, AmShZ and Safar placed bets on who'd be the champion, AmShZ betting on Italy, and Safar betting on France.Of course, AmShZ won. Hence, Safar gave him a bracket sequence $$$S$$$. Note that a bracket sequence is a string made of '(' and ')' characters.AmShZ can perform the following operation any number of times:  First, he cuts his string $$$S$$$ into three (possibly empty) contiguous substrings $$$A, B$$$ and $$$C$$$. Then, he glues them back by using a '(' and a ')' characters, resulting in a new string $$$S$$$ = $$$A$$$ + ""("" + $$$B$$$ + "")"" + $$$C$$$.For example, if $$$S$$$ = ""))(("" and AmShZ cuts it into $$$A$$$ = """", $$$B$$$ = ""))"", and $$$C$$$ = ""(("", He will obtain $$$S$$$ = ""()))(("" as a new string. After performing some (possibly none) operations, AmShZ gives his string to Keshi and asks him to find the initial string. Of course, Keshi might be able to come up with more than one possible initial string. Keshi is interested in finding the lexicographically smallest possible initial string.Your task is to help Keshi in achieving his goal.A string $$$a$$$ is lexicographically smaller than a string $$$b$$$ if and only if one of the following holds: $$$a$$$ is a prefix of $$$b$$$, but $$$a \ne b$$$; in the first position where $$$a$$$ and $$$b$$$ differ, the string $$$a$$$ has a letter that appears earlier in the alphabet than the corresponding letter in $$$b$$$. NoteIn the first sample, you can transform "")((())))"" into "")(()(())))"" by splitting it into "")("", empty string, and ""(())))"". It can be shown that this is the lexicographically smallest possible initial string import sys
raw_input = iter(sys.stdin.read().splitlines()).next

def lexicographical_compare(s, nxt, i, j):
    u, v = i, j
    while u < j and v < len(s) and s[u] == s[v]:
        u, v = nxt[u+1], nxt[v+1]
    return s[u] <= s[v] if u < len(s) and v < len(s) else u == len(s) and v < len(s)

def solution():
    s = raw_input().strip()
    stk, nxt = [len(s)], range(len(s)+1)
    for i in reversed(xrange(len(s))):
        if s[i] == ')':
            stk.append(i)
            continue
        stk.pop()
        if not stk:
            stk.append(i)
        elif lexicographical_compare(s, nxt, i, stk[-1]):
            stk[-1] = i
        else:
            nxt[i] = stk[-1]
    result = []
    while i < len(s):
        result.append(s[i])
        i = nxt[i+1]
    return """".join(result)

print '%s' % solution()
","['data structures', 'greedy', 'hashing']"
371,"Mahmoud and Ehab continue their adventures! As everybody in the evil land knows, Dr. Evil likes bipartite graphs, especially trees.A tree is a connected acyclic graph. A bipartite graph is a graph, whose vertices can be partitioned into 2 sets in such a way, that for each edge (u, v) that belongs to the graph, u and v belong to different sets. You can find more formal definitions of a tree and a bipartite graph in the notes section below.Dr. Evil gave Mahmoud and Ehab a tree consisting of n nodes and asked them to add edges to it in such a way, that the graph is still bipartite. Besides, after adding these edges the graph should be simple (doesn't contain loops or multiple edges). What is the maximum number of edges they can add?A loop is an edge, which connects a node with itself. Graph doesn't contain multiple edges when for each pair of nodes there is no more than one edge between them. A cycle and a loop aren't the same . NoteTree definition: https://en.wikipedia.org/wiki/Tree_(graph_theory)Bipartite graph definition: https://en.wikipedia.org/wiki/Bipartite_graphIn the first test case the only edge that can be added in such a way, that graph won't contain loops or multiple edges is (2, 3), but adding this edge will make the graph non-bipartite so the answer is 0.In the second test case Mahmoud and Ehab can add edges (1, 4) and (2, 5).  """"""
5
1 2
2 3
3 4
4 5
""""""

import sys

level = {}
parent = {}
def BFS(s):
    global a, b, G, level, parent

    level = {s : 0}
    parent = {s : None}

    i = 1
    frontier = [s]

    while frontier:

        nxt = []
        for u in frontier:
            for v in G[u]:
                if v not in level:
                    level[v] = i
                    parent[v] = u
                    nxt.append(v)

        frontier = nxt
        i += 1
    


n = input()

G = {}

for i in range(n):
    G[i+1] = list()

a = set()
b = set()

for i in range(n-1):

    u, v = map(int, sys.stdin.readline().split())

    G[u].append(v)
    G[v].append(u)

BFS(1)

for u in level:
    if level[u]%2 == 0:
        a.add(u)
    else:
        b.add(u)

ans = len(a)*len(b)-n+1

print ans

","['dfs and similar', 'graphs', 'trees']"
2379,"Little Petya likes arrays that consist of non-negative integers a lot. Recently his mom has presented him one such array consisting of n elements. Petya immediately decided to find there a segment of consecutive elements, such that the xor of all numbers from this segment was maximal possible. Help him with that.The xor operation is the bitwise exclusive ""OR"", that is denoted as ""xor"" in Pascal and ""^"" in C/C++/Java. NoteIn the first sample one of the optimal segments is the segment that consists of the first and the second array elements, if we consider the array elements indexed starting from one.The second sample contains only one optimal segment, which contains exactly one array element (element with index three). n = input()
arr = map(int,raw_input().split())
ans = 0
for i in range(n):
	for j in range(i,n):
		a = 0
		for k in range(i,j+1):
			a ^= arr[k]
		ans = max(ans,a)

print ans
","['brute force', 'implementation']"
238,"Nikephoros and Polycarpus play rock-paper-scissors. The loser gets pinched (not too severely!).Let us remind you the rules of this game. Rock-paper-scissors is played by two players. In each round the players choose one of three items independently from each other. They show the items with their hands: a rock, scissors or paper. The winner is determined by the following rules: the rock beats the scissors, the scissors beat the paper and the paper beats the rock. If the players choose the same item, the round finishes with a draw.Nikephoros and Polycarpus have played n rounds. In each round the winner gave the loser a friendly pinch and the loser ended up with a fresh and new red spot on his body. If the round finished in a draw, the players did nothing and just played on.Nikephoros turned out to have worked out the following strategy: before the game began, he chose some sequence of items A = (a1, a2, ..., am), and then he cyclically showed the items from this sequence, starting from the first one. Cyclically means that Nikephoros shows signs in the following order: a1, a2, ..., am, a1, a2, ..., am, a1, ... and so on. Polycarpus had a similar strategy, only he had his own sequence of items B = (b1, b2, ..., bk).Determine the number of red spots on both players after they've played n rounds of the game. You can consider that when the game began, the boys had no red spots on them. NoteIn the first sample the game went like this:  R - R. Draw.  P - S. Nikephoros loses.  S - P. Polycarpus loses.  R - P. Nikephoros loses.  P - R. Polycarpus loses.  S - S. Draw.  R - P. Nikephoros loses. Thus, in total Nikephoros has 3 losses (and 3 red spots), and Polycarpus only has 2. n = int(input())
a = input()
b = input()
ai = 0
alen = len(a)
bi = 0
blen = len(b)
nik = 0
pol = 0
if alen == blen: rnd = alen
else: rnd = alen*blen
numofrounds = 0
for i in range(n):
    #print(i,rnd)
    if i == rnd:
        numofrounds = n//rnd
        # print(numofrounds)
        nik *= numofrounds
        pol *= numofrounds
        break
        #print(a[ai%alen], b[bi%blen])
    if a[ai] == b[bi]: pass
    elif (a[ai] == 'R' and b[bi] == 'S') or (a[ai] == 'S'
        and b[bi] == 'P') or (a[ai] == 'P' and b[bi] == 'R'):
        pol += 1
    else: nik += 1
    ai = (ai+1)%alen
    bi = (bi+1)%blen
if n%rnd != 0 and numofrounds != 0:
    n -= rnd*numofrounds
    ai = 0
    bi = 0
    for i in range(n):
        if a[ai] == b[bi]: pass
        elif (a[ai] == 'R' and b[bi] == 'S') or (a[ai] == 'S'
        and b[bi] == 'P') or (a[ai] == 'P' and b[bi] == 'R'):
            pol += 1
        else: nik += 1
        ai = (ai+1)%alen
        bi = (bi+1)%blen
print(nik, pol)   ","['implementation', 'math']"
3333,"One foggy Stockholm morning, Karlsson decided to snack on some jam in his friend Lillebror Svantenson's house. Fortunately for Karlsson, there wasn't anybody in his friend's house. Karlsson was not going to be hungry any longer, so he decided to get some food in the house.Karlsson's gaze immediately fell on n wooden cupboards, standing in the kitchen. He immediately realized that these cupboards have hidden jam stocks. Karlsson began to fly greedily around the kitchen, opening and closing the cupboards' doors, grab and empty all the jars of jam that he could find.And now all jars of jam are empty, Karlsson has had enough and does not want to leave traces of his stay, so as not to let down his friend. Each of the cupboards has two doors: the left one and the right one. Karlsson remembers that when he rushed to the kitchen, all the cupboards' left doors were in the same position (open or closed), similarly, all the cupboards' right doors were in the same position (open or closed). Karlsson wants the doors to meet this condition as well by the time the family returns. Karlsson does not remember the position of all the left doors, also, he cannot remember the position of all the right doors. Therefore, it does not matter to him in what position will be all left or right doors. It is important to leave all the left doors in the same position, and all the right doors in the same position. For example, all the left doors may be closed, and all the right ones may be open.Karlsson needs one second to open or close a door of a cupboard. He understands that he has very little time before the family returns, so he wants to know the minimum number of seconds t, in which he is able to bring all the cupboard doors in the required position.Your task is to write a program that will determine the required number of seconds t. nan #!/usr/bin/env python
# coding: utf-8

# In[204]:


# # n = int(input())
# # line = list(map(int, input().split()))


# In[495]:


from collections import Counter


# In[518]:


n = int(input())
ld, rd = [], []

for _ in range(n):
    doors = (list(map(int, input().split())))
    ld.append(doors[0])
    rd.append(doors[1])


# In[521]:


rd_change = 0 
ld_change = 0


# In[522]:


if len(Counter(rd).most_common()) > 1 :
    rd_least = Counter(rd).most_common()[1][0]
    rd_change = Counter(rd)[rd_least]
    
if len(Counter(ld).most_common()) > 1 :
    ld_least = Counter(ld).most_common()[1][0]
    ld_change = Counter(ld)[ld_least]


# In[523]:


print(ld_change + rd_change)


# In[ ]:




",['implementation']
2244,"You have an array of integers (initially empty).You have to perform $$$q$$$ queries. Each query is of one of two types:   ""$$$1$$$ $$$x$$$"" — add the element $$$x$$$ to the end of the array;  ""$$$2$$$ $$$x$$$ $$$y$$$"" — replace all occurrences of $$$x$$$ in the array with $$$y$$$. Find the resulting array after performing all the queries. NoteIn the first example, the array changes as follows:$$$[]$$$ $$$\rightarrow$$$ $$$[3]$$$ $$$\rightarrow$$$ $$$[3, 1]$$$ $$$\rightarrow$$$ $$$[3, 2]$$$ $$$\rightarrow$$$ $$$[3, 2, 2]$$$ $$$\rightarrow$$$ $$$[3, 2, 2, 1]$$$ $$$\rightarrow$$$ $$$[3, 2, 2, 1, 2]$$$ $$$\rightarrow$$$ $$$[3, 2, 2, 3, 2]$$$.In the second example, the array changes as follows:$$$[]$$$ $$$\rightarrow$$$ $$$[1]$$$ $$$\rightarrow$$$ $$$[1, 2]$$$ $$$\rightarrow$$$ $$$[1, 2, 1]$$$ $$$\rightarrow$$$ $$$[1, 2, 1]$$$.In the third example, the array changes as follows:$$$[]$$$ $$$\rightarrow$$$ $$$[]$$$ $$$\rightarrow$$$ $$$[1]$$$ $$$\rightarrow$$$ $$$[1, 4]$$$ $$$\rightarrow$$$ $$$[1, 4, 2]$$$ $$$\rightarrow$$$ $$$[1, 4, 4]$$$ $$$\rightarrow$$$ $$$[1, 3, 3]$$$ $$$\rightarrow$$$ $$$[1, 3, 3, 2]$$$ $$$\rightarrow$$$ $$$[1, 3, 3, 7]$$$. # ------------------- fast io --------------------
import os
import sys
from io import BytesIO, IOBase
import math
from typing import OrderedDict
 
BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
    
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
 
# ------------------- fast io --------------------
def gcd(x, y):
    while y:
        x, y = y, x % y
    return x
 
 
def lcm(a, b): return a * b // gcd(a, b)

def is_prime(n):
    if (n <= 1):
        return False
    for i in range(2, int(math.sqrt(n))+1):
        if (n % i == 0):
            return False
    return True

# ------------------- write code from here --------------------
# for _ in range(int(input())):
# from collections import OrderedDict
# n = int(input())
# final=[]
# mapped=[i for i in range(500000+1)]
# queries_arr =[]
# # d= OrderedDict()
# for i in range(n):
#     arr= list(map(int, input().split()))
#     queries_arr+= [arr]

# for i in range(n-1,-1,-1):
#     query= queries_arr[i]
#     if query[0]==2:

#         mapped[query[1]]= mapped[query[2]]

#     else:
#         z= query[1]
#         final+= [mapped[z]]
        
# print(*(final[::-1]))

# for _ in range(int(input()) if not True else 1):
#     q = int(input())
#     # n, k = map(int, input().split())
#     # a, b = map(int, input().split())
#     # c, d = map(int, input().split())
#     # a = list(map(int, input().split()))
#     # b = list(map(int, input().split()))
#     # s = input()
#     a = []
#     mapped = [i for i in range(500000 + 1)]
#     queries = []
#     for __ in range(q):
#         query = list(map(int, input().split()))
#         queries += [query]
#     for i in range(q-1, -1, -1):
#         query = queries[i]
#         if query[0] == 2:
#             x, y = query[1], query[2]
#             mapped[x] = mapped[y]
#         else:
#             val = query[1]
#             a += [mapped[val]]
#     print(*a[::-1])

n = int(input())
final=[]
mapped=[i for i in range(500000+1)]
queries_arr =[]
# d= OrderedDict()
for i in range(n):
    arr= list(map(int, input().split()))
    queries_arr.append(arr)
 
for i in range(n-1,-1,-1):
    if queries_arr[i][0]==2:
 
        mapped[queries_arr[i][1]]= mapped[queries_arr[i][-1]]
 
    else:
        final.append(mapped[queries_arr[i][-1]])
        
print(*(final[::-1]))","['constructive algorithms', 'data structures', 'dsu', 'implementation']"
3575,"It's time polar bears Menshykov and Uslada from the zoo of St. Petersburg and elephant Horace from the zoo of Kiev got down to business. In total, there are n tasks for the day and each animal should do each of these tasks. For each task, they have evaluated its difficulty. Also animals decided to do the tasks in order of their difficulty. Unfortunately, some tasks can have the same difficulty, so the order in which one can perform the tasks may vary.Menshykov, Uslada and Horace ask you to deal with this nuisance and come up with individual plans for each of them. The plan is a sequence describing the order in which an animal should do all the n tasks. Besides, each of them wants to have its own unique plan. Therefore three plans must form three different sequences. You are to find the required plans, or otherwise deliver the sad news to them by stating that it is impossible to come up with three distinct plans for the given tasks. NoteIn the first sample the difficulty of the tasks sets one limit: tasks 1 and 4 must be done before tasks 2 and 3. That gives the total of four possible sequences of doing tasks : [1, 4, 2, 3], [4, 1, 2, 3], [1, 4, 3, 2], [4, 1, 3, 2]. You can print any three of them in the answer.In the second sample there are only two sequences of tasks that meet the conditions — [3, 1, 2, 4, 5] and [3, 1, 4, 2, 5]. Consequently, it is impossible to make three distinct sequences of tasks. n = int(input())
l = list(map(int, input().split()))
a = []
for i in range(n):
    a.append((l[i], i + 1))

a.sort()
cnt = 0
i = 0
maxi = 0;
while i < n:
    c = 0
    j = i
    while i < n: 
        if a[i][0] == a[j][0]:
            c += 1
        else:
            break
        i += 1
    if c > 1:
        cnt += 1
    maxi = max(c, maxi)

if cnt < 1 or (cnt == 1 and maxi < 3):
    print(""NO"")
else:
   
    print(""YES"")

    for i in range(n):
        print(a[i][1], end = "" "")
    print()

    for i in range(1, n):
        if a[i][0] == a[i - 1][0]:
            a[i], a[i - 1] = a[i - 1], a[i]
            break

    for i in range(n):
        print(a[i][1], end = "" "")

    print()

    for i in range(n - 1, 0, -1):
        if a[i][0] == a[i - 1][0]:
            a[i], a[i - 1] = a[i - 1], a[i]
            break

    for i in range(n):
        print(a[i][1], end = "" "")
        ","['implementation', 'sortings']"
1049,"Pasha is participating in a contest on one well-known website. This time he wants to win the contest and will do anything to get to the first place!This contest consists of n problems, and Pasha solves ith problem in ai time units (his solutions are always correct). At any moment of time he can be thinking about a solution to only one of the problems (that is, he cannot be solving two problems at the same time). The time Pasha spends to send his solutions is negligible. Pasha can send any number of solutions at the same moment.Unfortunately, there are too many participants, and the website is not always working. Pasha received the information that the website will be working only during m time periods, jth period is represented by its starting moment lj and ending moment rj. Of course, Pasha can send his solution only when the website is working. In other words, Pasha can send his solution at some moment T iff there exists a period x such that lx ≤ T ≤ rx.Pasha wants to know his best possible result. We need to tell him the minimal moment of time by which he is able to have solutions to all problems submitted, if he acts optimally, or say that it's impossible no matter how Pasha solves the problems. NoteIn the first example Pasha can act like this: he solves the second problem in 4 units of time and sends it immediately. Then he spends 3 time units to solve the first problem and sends it 7 time units after the contest starts, because at this moment the website starts working again.In the second example Pasha invents the solution only after the website stops working for the last time.In the third example Pasha sends the solution exactly at the end of the first period. f = lambda: map(int, input().split())
f()
s, d = sum(f()), -1
for i in range(int(input())):
    l, r = f()
    if s <= r:
        d = max(s, l)
        break
print(d)",['implementation']
2024,"They say that Berland has exactly two problems, fools and roads. Besides, Berland has n cities, populated by the fools and connected by the roads. All Berland roads are bidirectional. As there are many fools in Berland, between each pair of cities there is a path (or else the fools would get upset). Also, between each pair of cities there is no more than one simple path (or else the fools would get lost). But that is not the end of Berland's special features. In this country fools sometimes visit each other and thus spoil the roads. The fools aren't very smart, so they always use only the simple paths.A simple path is the path which goes through every Berland city not more than once.The Berland government knows the paths which the fools use. Help the government count for each road, how many distinct fools can go on it.Note how the fools' paths are given in the input. NoteIn the first sample the fool number one goes on the first and third road and the fool number 3 goes on the second, first and fourth ones.In the second sample, the fools number 1, 3 and 5 go on the first road, the fool number 5 will go on the second road, on the third road goes the fool number 3, and on the fourth one goes fool number 1. # solved using sparse table
from math import log2

def construct(root):
    stack = [root]
    while stack:
        u = stack.pop()
        for v in edges[u]:
            if v != parents[u]:
                parents[v] = u
                levels[v] = levels[u] + 1
                stack.append(v)
    table.append(parents)
    k = 1
    while (1 << k) < n:
        new_row = [0] * n
        for i in range(n):
            new_row[i] = table[k-1][table[k-1][i]]
        table.append(new_row)
        k += 1


def getlca(a, b):  # range MINIMUM query
    depth_gap = levels[b] - levels[a]
    if depth_gap < 0: # make sure node b is at a deeper level than node a
        a, b = b, a
        depth_gap = -depth_gap
    if depth_gap != 0:  ## traverse upward from a so that both a and b are at the same level
        k = int(log2(depth_gap))
        while depth_gap:
            if (depth_gap) >= (2**k):
                b = table[k][b]
                depth_gap = levels[b] - levels[a]
            k -= 1
    if b == a:
        return a
    for k in range(logn, -1, -1):
        if table[k][a] != table[k][b]:
            a, b = table[k][a], table[k][b]
    return table[0][a]


def travel(a, b):
    lca = getlca(a, b)
    tally[a] += 1
    tally[b] += 1
    tally[lca] -= 2


def sum_subtree(root):
    stack = []
    for v in edges[root]:
        stack.append([v, 0])
    while stack:
        u, i = stack[-1]
        if i == len(edges[u]):
            tally[parents[u]] += tally[u]
            stack.pop()
        else:
            v = edges[u][i]
            stack[-1][1] += 1
            if v != parents[u]:
                stack.append([v, 0])


def count_fools(u, v):
    if levels[u] > levels[v]:
        return tally[u]
    else:
        return tally[v]


n = int(input())
logn = int(log2(n))
edges = [[] for _ in range(n)]
edges_list = []
for i in range(n-1):
    u, v = map(int, input().split())
    u, v = u-1, v-1     # adjusting index convention for convenience
    edges[u].append(v)
    edges[v].append(u)
    edges_list.append((u, v))
parents = [0] * n
levels = [0] * n
table = []
root = 0
construct(root//2)
tally = [0] * n
k = int(input())
for _ in range(k):
    a, b = map(int, input().split())
    travel(a-1, b-1)
sum_subtree(root)
for u, v in edges_list:
    print(count_fools(u, v), end=' ')
print()
","['data structures', 'dfs and similar', 'trees']"
3565,"You like playing chess tournaments online.In your last tournament you played $$$n$$$ games. For the sake of this problem, each chess game is either won or lost (no draws). When you lose a game you get $$$0$$$ points. When you win you get $$$1$$$ or $$$2$$$ points: if you have won also the previous game you get $$$2$$$ points, otherwise you get $$$1$$$ point. If you win the very first game of the tournament you get $$$1$$$ point (since there is not a ""previous game"").The outcomes of the $$$n$$$ games are represented by a string $$$s$$$ of length $$$n$$$: the $$$i$$$-th character of $$$s$$$ is W if you have won the $$$i$$$-th game, while it is L if you have lost the $$$i$$$-th game.After the tournament, you notice a bug on the website that allows you to change the outcome of at most $$$k$$$ of your games (meaning that at most $$$k$$$ times you can change some symbol L to W, or W to L). Since your only goal is to improve your chess rating, you decide to cheat and use the bug.Compute the maximum score you can get by cheating in the optimal way. NoteExplanation of the first testcase. Before changing any outcome, the score is $$$2$$$. Indeed, you won the first game, so you got $$$1$$$ point, and you won also the third, so you got another $$$1$$$ point (and not $$$2$$$ because you lost the second game).An optimal way to cheat is to change the outcomes of the second and fourth game. Doing so, you end up winning the first four games (the string of the outcomes becomes WWWWL). Hence, the new score is $$$7=1+2+2+2$$$: $$$1$$$ point for the first game and $$$2$$$ points for the second, third and fourth game.Explanation of the second testcase. Before changing any outcome, the score is $$$3$$$. Indeed, you won the fourth game, so you got $$$1$$$ point, and you won also the fifth game, so you got $$$2$$$ more points (since you won also the previous game).An optimal way to cheat is to change the outcomes of the first, second, third and sixth game. Doing so, you end up winning all games (the string of the outcomes becomes WWWWWW). Hence, the new score is $$$11 = 1+2+2+2+2+2$$$: $$$1$$$ point for the first game and $$$2$$$ points for all the other games. 
for _ in range(int(input())):
    n,k = map(int,input().split())
    ik = k
    sg = input().strip()
    gaps = []
    l = len(sg)
    wins = 0
    win_streaks = 0
    i = 0
    lcnt = 0
    temp = 0
    while i < l:
        if sg[i] == 'W':
            break
        i += 1
        temp += 1
    filled_gaps = 0
    while i < l:
        if sg[i] == 'W':
            win_streaks += 1
            while i < l and sg[i] == 'W':
                wins += 1
                i += 1
        if i < l and sg[i] == 'L':
            lcnt = 0
            while i < l and sg[i] == 'L':
                lcnt += 1
                i += 1
            else:
                if i < l and sg[i] == 'W':
                    gaps.append(lcnt)
                else:
                    temp += lcnt
    
    gaps.sort()
    gap_l = len(gaps)
    j = 0
    while  k > 0 and j < gap_l:
        if gaps[j]  <= k:
            k -= gaps[j]
            filled_gaps += 1
        j += 1
    if k > 0 and temp > 0 and wins == 0:
        win_streaks += 1
    
    score = 2*(min(wins + ik , l)) - win_streaks + filled_gaps
    print(score)","['greedy', 'implementation', 'sortings']"
4606,"A very unusual citizen lives in a far away kingdom — Dwarf Gracula. However, his unusual name is not the weirdest thing (besides, everyone long ago got used to calling him simply Dwarf Greg). What is special about Dwarf Greg — he's been living for over 200 years; besides, he lives in a crypt on an abandoned cemetery and nobody has ever seen him out in daytime. Moreover, nobody has ever seen Greg buy himself any food. That's why nobody got particularly surprised when after the infernal dragon's tragic death cattle continued to disappear from fields. The people in the neighborhood were long sure that the harmless dragon was never responsible for disappearing cattle (considering that the dragon used to be sincere about his vegetarian views). But even that's not the worst part of the whole story.The worst part is that merely several minutes ago Dwarf Greg in some unintelligible way got inside your house and asked you to help him solve a problem. The point is that a short time ago Greg decided to order a new coffin (knowing his peculiar character, you are not surprised at all). But the problem is: a very long in both directions L-shaped corridor leads to Greg's crypt, and you can't drag just any coffin through that corridor. That's why he asked you to help.  You've formalized the task on a plane like this: let the corridor's width before and after the turn be equal to a and b correspondingly (see the picture). The corridor turns directly at a right angle, the coffin is a rectangle whose length and width are equal to l and w (l ≥ w) correspondingly. Dwarf Greg has already determined the coffin's length (l), which is based on his height; your task is to determine the coffin's maximally possible width (w), at which it can be brought to the crypt. Besides, due to its large mass (pure marble!) the coffin is equipped with rotating wheels; therefore it is impossible to lift it off the ground, however, arbitrary moves and rotations of the coffin in the plane become possible. The coffin may be rotated arbitrarily just before you drag it into crypt and move through the corridor.Greg promised that if you help him, he will grant you immortality (I wonder how?). And if you don't, well... trust me, you don't want to know what happens if you don't help him... NoteIn the first example the answer is restricted by the coffin's length (remember — coffin's widths should not be larger than it's length).In the second example it is possible to drag the coffin through the corridor thanks to rotating wheels: firstly, drag it forward by one side while it will not be hampered by the wall, then move it forward by adjacent side perpendicularly to the initial movement direction (remember — arbitrary moves and rotations of the coffin are possible). EPS = 1e-8

def cross(a, b):
    return (a[0] * b[1]) - (a[1] * b[0])

def f(a, b, l, x):
    y = (l*l - x*x)**0.5
    return cross( (a-x, b), (-x, y) )

def main():
    a, b, l = map(int, raw_input().split())

    if a > b:
        a, b = b, a

    if l <= a and a <= b:
        print ""%.9lf"" % l
    elif a < l and l <= b:
        print ""%.9lf"" % a
    else:
        lo = 0.0
        hi = float(l)

        while (hi - lo) > EPS:
            x1 = lo + (hi-lo)/3.0
            x2 = lo + (hi-lo)*2.0/3.0

            if f(a, b, l, x1) > f(a, b, l, x2):
                lo = x1
            else:
                hi = x2

        ans = f(a, b, l, lo) / l 

        if ans < EPS:
            print ""My poor head =(""
        else:
            print ""%.9lf"" % ans

if __name__ == ""__main__"":
    main()
","['binary search', 'geometry', 'other']"
3395,"Stanley defines the beauty of an array $$$a$$$ of length $$$n$$$, which contains non-negative integers, as follows: $$$$$$\sum\limits_{i = 1}^{n} \left \lfloor \frac{a_{i}}{k} \right \rfloor,$$$$$$ which means that we divide each element by $$$k$$$, round it down, and sum up the resulting values.Stanley told Sam the integer $$$k$$$ and asked him to find an array $$$a$$$ of $$$n$$$ non-negative integers, such that the beauty is equal to $$$b$$$ and the sum of elements is equal to $$$s$$$. Help Sam — find any of the arrays satisfying the conditions above. NoteIn the first, the second, the fifth and the sixth test cases of the example it is possible to show that such array does not exist.In the third testcase of the example $$$a = [0, 0, 19]$$$. The sum of elements in it is equal to 19, the beauty of it is equal to $$$\left ( \left \lfloor \frac{0}{6} \right \rfloor + \left \lfloor \frac{0}{6} \right \rfloor + \left \lfloor \frac{19}{6} \right \rfloor \right ) = (0 + 0 + 3) = 3$$$.In the fourth testcase of the example $$$a = [0, 3, 3, 3, 29]$$$. The sum of elements in it is equal to $$$38$$$, the beauty of it is equal to $$$(0 + 0 + 0 + 0 + 7) = 7$$$. t = int(input())
for _ in range(t):
    a = list(map(int, input().split()))
    n = a[0]
    k = a[1]
    b = a[2]
    s = a[3]
    f = []
    import math
    if n == 1:
        if math.floor(s / k) == b:
            print(s)
        else:
            print(-1)
    else:
        for __ in range(n - 1):
            f.append(0)
        f.append(s)
        if s < (b + 1) * k - 1:
            if s < b * k:
                print(-1)
            else:
                print((n - 1) * '0 ' + str(s))
        else:
            num = math.ceil((s - (b + 1) * k + 1) / (n - 1))
            if float(num) == (s - (b + 1) * k + 1) / (n - 1):
                for l in range(n - 1):
                    f[l] += num
                f[n - 1] = (b + 1) * k - 1
            else:
                for i in range(n - 1):
                    f[i] += num - 1
                f[n - 1] = (b + 1) * k - 1
                r = (s - (b + 1) * k + 1) % (n - 1)
                a = (b + 1) * k - 1
                for j in range(r):
                    f[j] += 1
            c = 0
            sum = 0
            sumk = 0
            for m in f:
                if m < 0:
                    c = c + 1
            if len(f) != n:
                c = c + 1
            for p in f:
                sum = sum + p
            if sum != s:
                c = c + 1
            for hh in f:
                sumk += math.floor(hh / k)
            if sumk != b:
                c += 1
            if c > 0:
                print(-1)
            else:
                for j in range(n):
                    print(f[j], end=' ')
                print()","['constructive algorithms', 'greedy', 'math']"
3181,"For her birthday Alice received an interesting gift from her friends – The Light Square. The Light Square game is played on an $$$N \times N$$$ lightbulbs square board with a magical lightbulb bar of size $$$N \times 1$$$ that has magical properties. At the start of the game some lights on the square board and magical bar are turned on. The goal of the game is to transform the starting light square board pattern into some other pattern using the magical bar without rotating the square board. The magical bar works as follows: It can be placed on any row or column The orientation of the magical lightbulb must be left to right or top to bottom for it to keep its magical properties The entire bar needs to be fully placed on a board The lights of the magical bar never change If the light on the magical bar is the same as the light of the square it is placed on it will switch the light on the square board off, otherwise it will switch the light on The magical bar can be used an infinite number of times Alice has a hard time transforming her square board into the pattern Bob gave her. Can you help her transform the board or let her know it is impossible? If there are multiple solutions print any.  NoteExample 1: It is impossible to transform square board from one format to anotherExample 2: Magic bar can be applied on first row or column. 
N = input()

a, b = [], []
 
for n in range(N) : a.append(raw_input())
for n in range(N) : b.append(raw_input())
 
wand = raw_input()
piv = -1 if wand.count('1') == 0 else wand.index('1')
 
def getVar(ca, row, col) :
  v = int(a[row][col]) ^ (int(wand[row])*ca[col])
  if v == v ^ int(wand[col]) : 
    if v == int(b[row][col]) : return None
    else : return False
  return v != int(b[row][col])

if piv < 0 : print 0 if a == b else -1
else :
  rowActions, colActions = [], []
  for n in range(N) :
    if a[piv][n] != b[piv][n] : colActions.append(1)
    else : colActions.append(0)
  
  #print ""colActions = "", colActions

  possible = True
  for n in range(N) :
    inv = getVar(colActions, n, 0)
    #print inv
    for m in range(1,N) :
      v = getVar(colActions, n, m)
      #print inv, v
      if v is not None and inv is None : inv = v
      if inv is not None and v is not None and inv != v : 
        possible = False
    
    rowActions.append(1 if inv else 0)
    #if not possible : break
 
  #print ""rowActions = "", rowActions

  if possible :
    print sum(rowActions) + sum(colActions)
    for r in range(len(rowActions)) : 
      if rowActions[r] : print ""row"", r
    for c in range(len(colActions)) : 
      if colActions[c] : print ""col"", c
  else : print -1","['greedy', 'other']"
1728,"You are given an array $$$a$$$ with $$$n$$$ integers. You can perform the following operation at most $$$k$$$ times:  Choose two indices $$$i$$$ and $$$j$$$, in which $$$i \,\bmod\, k = j \,\bmod\, k$$$ ($$$1 \le i &lt; j \le n$$$).  Swap $$$a_i$$$ and $$$a_j$$$. After performing all operations, you have to select $$$k$$$ consecutive elements, and the sum of the $$$k$$$ elements becomes your score. Find the maximum score you can get.Here $$$x \bmod y$$$ denotes the remainder from dividing $$$x$$$ by $$$y$$$. NoteIn the first test case, we can get a score of $$$11$$$ if we select $$$a_1, a_2$$$ without performing any operations.In the third test case, we can get a score of $$$15$$$ if we first swap $$$a_1$$$ with $$$a_4$$$ and then select $$$a_3, a_4, a_5$$$.  numberOfTestCases = int(input())
for i in range(numberOfTestCases):
    firstLine = [int(x) for x in input().split()]
    array = [int(x) for x in input().split()]

    arrayLen = firstLine[0]
    k = firstLine[1]
    tempK = k

    msum = 0
    for i in range(k):
        maxi = 0
        for j in range(i, arrayLen, k):
            if array[j] > maxi:
                maxi = array[j]
        msum += maxi
    print(msum)


","['greedy', 'sortings']"
1391,"There was a string $$$s$$$ which was supposed to be encrypted. For this reason, all $$$26$$$ lowercase English letters were arranged in a circle in some order, afterwards, each letter in $$$s$$$ was replaced with the one that follows in clockwise order, in that way the string $$$t$$$ was obtained. You are given a string $$$t$$$. Determine the lexicographically smallest string $$$s$$$ that could be a prototype of the given string $$$t$$$.A string $$$a$$$ is lexicographically smaller than a string $$$b$$$ of the same length if and only if:   in the first position where $$$a$$$ and $$$b$$$ differ, the string $$$a$$$ has a letter, that appears earlier in the alphabet than the corresponding letter in $$$b$$$.   NoteIn the first test case, we couldn't have the string ""a"", since the letter a would transit to itself. Lexicographically the second string ""b"" is suitable as an answer.In the second test case, the string ""aa"" is not suitable, since a would transit to itself. ""ab"" is not suitable, since the circle would be closed with $$$2$$$ letters, but it must contain all $$$26$$$. The next string ""ac"" is suitable.Below you can see the schemes for the first three test cases. The non-involved letters are skipped, they can be arbitrary placed in the gaps.   from heapq import _heapify_max, heapify, heappush, heappop
from bisect import bisect_left, bisect_right, bisect, insort
import math, sys, os
from string import ascii_lowercase
from re import A, L
from collections import defaultdict, Counter
from math import log, ceil, sqrt, floor, gcd, log2, factorial
from itertools import chain, combinations, count
from functools import reduce

'''
int: int(input())
str: input().split()[0] 
ints: list(map(int, input().split()))
strs: input().split()
'''
input = sys.stdin.readline
printt = lambda x: sys.stdout.write(str(x) + ""\n"")
printts = lambda x: sys.stdout.write("" "".join(map(str,x)) + ""\n"")
divisors = lambda n: set(chain.from_iterable((i, n // i) for i in range(1, int(sqrt(n)) + 1) if not n % i))
is_prime = lambda n: False if (n < 2) else (True if n in [2,3] else (False if n % 2 == 0 else (not any(n % i == 0 for i in range(3, 1 + floor(sqrt(n)), 2)))))
n_is_power_of_p = lambda n, p: not log(n, p) % 1
lcm = lambda a,b: int(a*b/gcd(a,b)) ## PyPy3 doesn't have lcm -_-
is_sqr = lambda num: sqrt(num).is_integer()

def heapsort(iterable):
	h = []
	for value in iterable:
		heappush(h, value)
	return [heappop(h) for i in range(len(h))]


'''
heapify(arr)
heappush(arr,n)
heappop(arr)
'''

def yes(): printt(""YES"")
def no(): printt(""NO"")
mod = 998244353 
# for case in range(1):
for case in range(int(input())):
	'''
n = int(input())
s = input().split()[0]
map(int, input().split())
arr = list(map(int, input().split()))
arr = input().split()
frr = [list(map(int, input().split())) for _ in range(n)]
	
	'''
	n = int(input())
	t = input().split()[0]
	used = [False] * 26
	letters=ascii_lowercase
	chainn = {}
	res = ''
	uniqs = len(set(t))
	def loopCheck(l,c):
		while l in chainn:
			l = chainn[l]
			if l == c: return True
		return False

	for i in range(n):
		if t[i] in chainn: continue
		for j in range(26):
			if used[j] or t[i] == letters[j] or (loopCheck(letters[j], t[i]) and len(chainn) < 25): continue
			chainn[t[i]] = letters[j]
			used[j] = True
			break
		
	printt(''.join(chainn[ch] for ch in t))
	
				


'''




'''","['dfs and similar', 'dsu', 'graphs', 'greedy', 'implementation', 'strings']"
1983,"Tyndex is again well ahead of the rivals! The reaction to the release of Zoozle Chrome browser was the release of a new browser Tyndex.Brome!The popularity of the new browser is growing daily. And the secret is not even the Tyndex.Bar installed (the Tyndex.Bar automatically fills the glass with the finest 1664 cognac after you buy Tyndex.Bottles and insert in into a USB port). It is highly popular due to the well-thought interaction with the user.Let us take, for example, the system of automatic address correction. Have you entered codehorses instead of codeforces? The gloomy Zoozle Chrome will sadly say that the address does not exist. Tyndex.Brome at the same time will automatically find the closest address and sent you there. That's brilliant!How does this splendid function work? That's simple! For each potential address a function of the F error is calculated by the following rules:  for every letter ci from the potential address c the closest position j of the letter ci in the address (s) entered by the user is found. The absolute difference |i - j| of these positions is added to F. So for every i (1 ≤ i ≤ |c|) the position j is chosen such, that ci = sj, and |i - j| is minimal possible.  if no such letter ci exists in the address entered by the user, then the length of the potential address |c| is added to F. After the values of the error function have been calculated for all the potential addresses the most suitable one is found. To understand the special features of the above described method better, it is recommended to realize the algorithm of calculating the F function for an address given by the user and some set of potential addresses. Good luck! nan from bisect import bisect_left

n, k = map(int, input().split())
q = 'abcdefghijklmnopqrstuvwxyz'

a = {i: [] for i in q}
for i, j in enumerate(input()): a[j].append(i)

def g(t): return [(t[i] + t[i - 1]) // 2 for i in range(1, len(t))]
c = {i: g(a[i]) for i in q}

def f():
    global a, c
    s, t = 0, input()
    d = len(t)
    for i, j in enumerate(t):
        if a[j]:
            if c[j]: s += abs(i - a[j][bisect_left(c[j], i)])
            else: s += abs(i - a[j][0])
        else: s += d
    return str(s)

print('\n'.join(f() for i in range(n)))","['binary search', 'implementation']"
1550,"Police headquarter is monitoring signal on different frequency levels. They have got two suspiciously encoded strings s1 and s2 from two different frequencies as signals. They are suspecting that these two strings are from two different criminals and they are planning to do some evil task.Now they are trying to find a common substring of minimum length between these two strings. The substring must occur only once in the first string, and also it must occur only once in the second string.Given two strings s1 and s2 consist of lowercase Latin letters, find the smallest (by length) common substring p of both s1 and s2, where p is a unique substring in s1 and also in s2. See notes for formal definition of substring and uniqueness. NoteImagine we have string a = a1a2a3...a|a|, where |a| is the length of string a, and ai is the ith letter of the string. We will call string alal + 1al + 2...ar (1 ≤ l ≤ r ≤ |a|) the substring [l, r] of the string a. The substring [l, r] is unique in a if and only if there is no pair l1, r1 such that l1 ≠ l and the substring [l1, r1] is equal to the substring [l, r] in a. import sys
import bisect

class suffixautomaton:
    def __init__(self, words, symbol = ""#""):
        self.words = []
        self.sequence = """"
        self.terminal = set()
        self.nCounters = len(words)
        self.states = [[0, None, {}]]
        self.counters = [[0] * self.nCounters]

        for w in words:
            self.sequence += w
            self.words.append(len(self.sequence))
            self.sequence += symbol
            symbol = chr(ord(symbol)+1)

        pushback = []

        sz = 1
        last = 0
        
        for ci in range(len(self.sequence)):
            c = self.sequence[ci]
            
            cur = sz
            sz += 1
            
            self.states.append([self.states[last][0] + 1, None, {}])
            self.counters.append([0] * self.nCounters)
            word = bisect.bisect_left(self.words, ci)
            self.counters[-1][word] = 1
                
            pushback.append((self.states[last][0] + 1, cur))
            
            p = last
            while p <> None and c not in self.states[p][2]:
                self.states[p][2][c] = cur
                p = self.states[p][1]
            
            if p == None:
                self.states[cur][1] = 0
            else:
                q = self.states[p][2][c]
                if (self.states[p][0] + 1 == self.states[q][0]):
                    self.states[cur][1] = q
                else:
                    clone = sz
                    sz += 1

                    pushback.append((self.states[p][0] + 1, clone))
                    self.states.append([self.states[p][0] + 1, self.states[q][1], self.states[q][2].copy()])
                    
                    self.counters.append([0] * self.nCounters)
                    
                    while p <> None and self.states[p][2][c] == q:
                        self.states[p][2][c] = clone
                        p = self.states[p][1]
                    self.states[cur][1] = clone
                    self.states[q][1] = clone
            last = cur
        
        pushback.sort(reverse = True)
        for _, i in pushback:
            for j in range(self.nCounters):
                self.counters[self.states[i][1]][j] += self.counters[i][j]
        
        while last <> 0:
            self.terminal.add(last)
            last = self.states[last][1]

    def __repr__(self):
        S = """"
        
        for i, s in enumerate(self.states):
            S += str(i) + "" - "" + str(self.counters[i]) + "" - "" + str(s) + ""\n""
        
        return S


    def CustomaryFunction1(self):
        """""" Minimal non-repeating substring among all uploaded string""""""
        
        best = sys.maxint
        for i in range(len(self.states)):
            if reduce(lambda a, b: a and b, [self.counters[i][j] == 1 for j in range(self.nCounters)]):
                best = min(best, self.states[self.states[i][1]][0] + 1)
                
        if best == sys.maxint:
            return -1
        
        return best          

def solve():
    a = sys.stdin.readline().strip(""\n\r"")
    b = sys.stdin.readline().strip(""\n\r"")
    
    A = suffixautomaton([a, b])
        
    print A.CustomaryFunction1()
    
solve()
","['dp', 'other', 'strings']"
4204,"Consider some set of distinct characters $$$A$$$ and some string $$$S$$$, consisting of exactly $$$n$$$ characters, where each character is present in $$$A$$$.You are given an array of $$$m$$$ integers $$$b$$$ ($$$b_1 &lt; b_2 &lt; \dots &lt; b_m$$$). You are allowed to perform the following move on the string $$$S$$$:  Choose some valid $$$i$$$ and set $$$k = b_i$$$;  Take the first $$$k$$$ characters of $$$S = Pr_k$$$;  Take the last $$$k$$$ characters of $$$S = Su_k$$$;  Substitute the first $$$k$$$ characters of $$$S$$$ with the reversed $$$Su_k$$$;  Substitute the last $$$k$$$ characters of $$$S$$$ with the reversed $$$Pr_k$$$. For example, let's take a look at $$$S =$$$ ""abcdefghi"" and $$$k = 2$$$. $$$Pr_2 =$$$ ""ab"", $$$Su_2 =$$$ ""hi"". Reversed $$$Pr_2 =$$$ ""ba"", $$$Su_2 =$$$ ""ih"". Thus, the resulting $$$S$$$ is ""ihcdefgba"".The move can be performed arbitrary number of times (possibly zero). Any $$$i$$$ can be selected multiple times over these moves.Let's call some strings $$$S$$$ and $$$T$$$ equal if and only if there exists such a sequence of moves to transmute string $$$S$$$ to string $$$T$$$. For the above example strings ""abcdefghi"" and ""ihcdefgba"" are equal. Also note that this implies $$$S = S$$$.The task is simple. Count the number of distinct strings.The answer can be huge enough, so calculate it modulo $$$998244353$$$. NoteHere are all the distinct strings for the first example. The chosen letters 'a' and 'b' are there just to show that the characters in $$$A$$$ are different.   ""aaa""  ""aab"" = ""baa""  ""aba""  ""abb"" = ""bba""  ""bab""  ""bbb""  n,m,a=map(int,input().split())
b=list(map(int,input().split()))
for i in range(m):
    if i==0:
        diffs=[b[0]]
    else:
        diffs.append(b[i]-b[i-1])
powers=[a%998244353]
for i in range(30):
    powers.append(powers[-1]**2%998244353)
def power(x,y,binpowers):
    prod=1
    bits=bin(y)[2:]
    bits=bits[::-1]
    for i in range(len(bits)):
        if bits[i]==""1"":
            prod*=binpowers[i]
            prod%=998244353
    return prod
maxi=b[-1]
prod1=power(a,n-2*maxi,powers)
for guy in diffs:
    newprod=power(a,guy,powers)
    newprod=(newprod*(newprod+1))//2
    newprod%=998244353
    prod1*=newprod
    prod1%=998244353
print(prod1)","['combinatorics', 'strings']"
3717,"Kuro is living in a country called Uberland, consisting of $$$n$$$ towns, numbered from $$$1$$$ to $$$n$$$, and $$$n - 1$$$ bidirectional roads connecting these towns. It is possible to reach each town from any other. Each road connects two towns $$$a$$$ and $$$b$$$. Kuro loves walking and he is planning to take a walking marathon, in which he will choose a pair of towns $$$(u, v)$$$ ($$$u \neq v$$$) and walk from $$$u$$$ using the shortest path to $$$v$$$ (note that $$$(u, v)$$$ is considered to be different from $$$(v, u)$$$).Oddly, there are 2 special towns in Uberland named Flowrisa (denoted with the index $$$x$$$) and Beetopia (denoted with the index $$$y$$$). Flowrisa is a town where there are many strong-scent flowers, and Beetopia is another town where many bees live. In particular, Kuro will avoid any pair of towns $$$(u, v)$$$ if on the path from $$$u$$$ to $$$v$$$, he reaches Beetopia after he reached Flowrisa, since the bees will be attracted with the flower smell on Kuro’s body and sting him.Kuro wants to know how many pair of city $$$(u, v)$$$ he can take as his route. Since he’s not really bright, he asked you to help him with this problem. NoteOn the first example, Kuro can choose these pairs:   $$$(1, 2)$$$: his route would be $$$1 \rightarrow 2$$$,  $$$(2, 3)$$$: his route would be $$$2 \rightarrow 3$$$,  $$$(3, 2)$$$: his route would be $$$3 \rightarrow 2$$$,  $$$(2, 1)$$$: his route would be $$$2 \rightarrow 1$$$,  $$$(3, 1)$$$: his route would be $$$3 \rightarrow 2 \rightarrow 1$$$. Kuro can't choose pair $$$(1, 3)$$$ since his walking route would be $$$1 \rightarrow 2 \rightarrow 3$$$, in which Kuro visits town $$$1$$$ (Flowrisa) and then visits town $$$3$$$ (Beetopia), which is not allowed (note that pair $$$(3, 1)$$$ is still allowed because although Kuro visited Flowrisa and Beetopia, he did not visit them in that order).On the second example, Kuro can choose the following pairs:   $$$(1, 2)$$$: his route would be $$$1 \rightarrow 2$$$,  $$$(2, 1)$$$: his route would be $$$2 \rightarrow 1$$$,  $$$(3, 2)$$$: his route would be $$$3 \rightarrow 1 \rightarrow 2$$$,  $$$(3, 1)$$$: his route would be $$$3 \rightarrow 1$$$.  from collections import defaultdict

n,x,y = list(map(int,input().split()))
graph = defaultdict(list)
vis = [False for i in range(n+1)]
mat = [False for i in range(n+1)]
subtree = [0 for i in range(n+1)]

for i in range(n-1):
	u,v = list(map(int,input().split()))
	graph[u].append(v)
	graph[v].append(u)
q = []
cur = 0
for v in graph[x]:
	if v!=y:
		q.append([v,v])
	else:
		cur = v
vis[x] = 1
while q!=[]:
	temp = q.pop()
	u,v = temp
	vis[u] = True
	subtree[v]+=1
	for node in graph[u]:
		if vis[node]==False:
			if node!=y:
				q.append([node,v])
			else:
				cur = v
val = sum(subtree)
val1 = (val+1-subtree[cur])
val2 = n-(sum(subtree)+1)
val = val1*val2
print(n*(n-1)-val)","['dfs and similar', 'trees']"
1090,"Ivan recently bought a detective book. The book is so interesting that each page of this book introduces some sort of a mystery, which will be explained later. The $$$i$$$-th page contains some mystery that will be explained on page $$$a_i$$$ ($$$a_i \ge i$$$).Ivan wants to read the whole book. Each day, he reads the first page he didn't read earlier, and continues to read the following pages one by one, until all the mysteries he read about are explained and clear to him (Ivan stops if there does not exist any page $$$i$$$ such that Ivan already has read it, but hasn't read page $$$a_i$$$). After that, he closes the book and continues to read it on the following day from the next page.How many days will it take to read the whole book? NoteExplanation of the example test:During the first day Ivan will read only the first page. During the second day Ivan will read pages number $$$2$$$ and $$$3$$$. During the third day — pages $$$4$$$-$$$8$$$. During the fourth (and the last) day Ivan will read remaining page number $$$9$$$. 
for _ in range(1):
    n=int(input())
    l=list(map(int,input().split()))
    c=0
    l=[0]+l
    i=1
    while i<=n:
        c+=1
        ma=i
        while i<=n and i<=ma:
            ma=max(ma,l[i])
            i+=1
    print(c)
  
    

    
    
            
",['implementation']
4729,"You are playing the game ""Arranging The Sheep"". The goal of this game is to make the sheep line up. The level in the game is described by a string of length $$$n$$$, consisting of the characters '.' (empty space) and '*' (sheep). In one move, you can move any sheep one square to the left or one square to the right, if the corresponding square exists and is empty. The game ends as soon as the sheep are lined up, that is, there should be no empty cells between any sheep.For example, if $$$n=6$$$ and the level is described by the string ""**.*.."", then the following game scenario is possible:   the sheep at the $$$4$$$ position moves to the right, the state of the level: ""**..*."";  the sheep at the $$$2$$$ position moves to the right, the state of the level: ""*.*.*."";  the sheep at the $$$1$$$ position moves to the right, the state of the level: "".**.*."";  the sheep at the $$$3$$$ position moves to the right, the state of the level: "".*.**."";  the sheep at the $$$2$$$ position moves to the right, the state of the level: ""..***."";  the sheep are lined up and the game ends. For a given level, determine the minimum number of moves you need to make to complete the level. nan def get_shifts(sheep_row):
    sheep_count = 0
    last_sheep_position = None
    shifts = []
    for idx in range(len(sheep_row)-1, -1, -1):
        if sheep_row[idx] == '*':
            if sheep_count > 0:
                diff = last_sheep_position - idx - 1
                shift = diff * sheep_count + shifts[-1]
                shifts.append(shift)
            else:
                shifts.append(0)
            sheep_count += 1
            last_sheep_position = idx
    return list(reversed(shifts))


def sort_sheeps_min(sheep_row):
    result = float('inf')
    min_operations = 0
    shifts = get_shifts(sheep_row)
    sheep_count = 0
    last_sheep_position = -1
    for idx, item in enumerate(sheep_row):
        if item == '*':
            if sheep_count > 0:
                diff = idx - last_sheep_position - 1
                left_shift = diff * sheep_count + min_operations
                result = min(result, left_shift + shifts[sheep_count])
                min_operations = left_shift             
            last_sheep_position = idx
            sheep_count += 1
    return result if result != float('inf') else 0


if __name__ == '__main__':
    results = []
    for idx in range(int(input())):
        _ = input()
        results.append(str(sort_sheeps_min(input())))
    print(""\n"".join(results))
","['greedy', 'math']"
2172,"Vika has n jars with paints of distinct colors. All the jars are numbered from 1 to n and the i-th jar contains ai liters of paint of color i.Vika also has an infinitely long rectangular piece of paper of width 1, consisting of squares of size 1 × 1. Squares are numbered 1, 2, 3 and so on. Vika decided that she will start painting squares one by one from left to right, starting from the square number 1 and some arbitrary color. If the square was painted in color x, then the next square will be painted in color x + 1. In case of x = n, next square is painted in color 1. If there is no more paint of the color Vika wants to use now, then she stops.Square is always painted in only one color, and it takes exactly 1 liter of paint. Your task is to calculate the maximum number of squares that might be painted, if Vika chooses right color to paint the first square. NoteIn the first sample the best strategy is to start painting using color 4. Then the squares will be painted in the following colors (from left to right): 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5.In the second sample Vika can start to paint using any color.In the third sample Vika should start painting using color number 5. n = int(raw_input())
a = [int(i) for i in raw_input().split("" "")]

firstminpos = 0
lastminpos = 0
for i in xrange(1, n):
    if a[i] < a[firstminpos]:
        firstminpos = i
        lastminpos = i
    elif a[i] == a[lastminpos]:
        lastminpos = i

minel = a[firstminpos]

for i in xrange(n):
    a[i] -= minel

longestrunlen = 0
runlen = 0
for i in xrange(n):
    if a[i]:
        runlen += 1
        longestrunlen = max(longestrunlen, runlen)
    else:
        runlen = 0

if runlen > 0:
    for i in xrange(n):
        if a[i]:
            runlen += 1
            longestrunlen = max(longestrunlen, runlen)
        else:
            break

print n * minel + longestrunlen
","['constructive algorithms', 'implementation']"
2945,"One day, Yuhao came across a problem about checking if some bracket sequences are correct bracket sequences.A bracket sequence is any non-empty sequence of opening and closing parentheses. A bracket sequence is called a correct bracket sequence if it's possible to obtain a correct arithmetic expression by inserting characters ""+"" and ""1"" into this sequence. For example, the sequences ""(())()"", ""()"" and ""(()(()))"" are correct, while the bracket sequences "")("", ""(()"" and ""(()))("" are not correct.Yuhao found this problem too simple for him so he decided to make the problem harder. You are given many (not necessarily correct) bracket sequences. The task is to connect some of them into ordered pairs so that each bracket sequence occurs in at most one pair and the concatenation of the bracket sequences in each pair is a correct bracket sequence. The goal is to create as many pairs as possible.This problem unfortunately turned out to be too difficult for Yuhao. Can you help him and solve it? NoteIn the first example, it's optimal to construct two pairs: ""((     )())"" and ""(     )"". r, l, m = [], [], 0
for k in range(int(input())):
	s = input()
	lb, rb, a, b = 0, 0, 0, 0
	for i in range(len(s)):
		if s[i] == '(': rb += 1
		else: rb -= 1
		if s[-1-i] == ')': lb += 1
		else: lb -= 1
		if rb < 0: a = 1
		if lb < 0: b = 1
		if a and b: break
	else:
		if rb > 0: r.append(rb)
		elif rb < 0: l.append(lb)
		else: m += 1
m //= 2
for i in r:
	if i in l:
		m += 1
		l.remove(i)
print(m)
","['greedy', 'implementation']"
2683,"A robot cleaner is placed on the floor of a rectangle room, surrounded by walls. The floor consists of $$$n$$$ rows and $$$m$$$ columns. The rows of the floor are numbered from $$$1$$$ to $$$n$$$ from top to bottom, and columns of the floor are numbered from $$$1$$$ to $$$m$$$ from left to right. The cell on the intersection of the $$$r$$$-th row and the $$$c$$$-th column is denoted as $$$(r,c)$$$. The initial position of the robot is $$$(r_b, c_b)$$$.In one second, the robot moves by $$$dr$$$ rows and $$$dc$$$ columns, that is, after one second, the robot moves from the cell $$$(r, c)$$$ to $$$(r + dr, c + dc)$$$. Initially $$$dr = 1$$$, $$$dc = 1$$$. If there is a vertical wall (the left or the right walls) in the movement direction, $$$dc$$$ is reflected before the movement, so the new value of $$$dc$$$ is $$$-dc$$$. And if there is a horizontal wall (the upper or lower walls), $$$dr$$$ is reflected before the movement, so the new value of $$$dr$$$ is $$$-dr$$$.Each second (including the moment before the robot starts moving), the robot cleans every cell lying in the same row or the same column as its position. There is only one dirty cell at $$$(r_d, c_d)$$$. The job of the robot is to clean that dirty cell.  Illustration for the first example. The blue arc is the robot. The red star is the target dirty cell. Each second the robot cleans a row and a column, denoted by yellow stripes. Given the floor size $$$n$$$ and $$$m$$$, the robot's initial position $$$(r_b, c_b)$$$ and the dirty cell's position $$$(r_d, c_d)$$$, find the time for the robot to do its job. NoteIn the first example, the floor has the size of $$$10\times 10$$$. The initial position of the robot is $$$(6, 1)$$$ and the position of the dirty cell is $$$(2, 8)$$$. See the illustration of this example in the problem statement.In the second example, the floor is the same, but the initial position of the robot is now $$$(9, 9)$$$, and the position of the dirty cell is $$$(1, 1)$$$. In this example, the robot went straight to the dirty cell and clean it.   In the third example, the floor has the size $$$9 \times 8$$$. The initial position of the robot is $$$(5, 6)$$$, and the position of the dirty cell is $$$(2, 1)$$$.   In the fourth example, the floor has the size $$$6 \times 9$$$. The initial position of the robot is $$$(2, 2)$$$ and the position of the dirty cell is $$$(5, 8)$$$.   In the last example, the robot was already standing in the same column as the dirty cell, so it can clean the cell right away.    #lista=list(map(int,input().split()))
#x=lista[0]
#n=lista[0]
import math
import sys
from collections import deque
#from sys import stdin, stdout
from decimal import *

#lista=list(map(int,input().split()))
#x=lista[0]
#n=lista[0]
 
rasp_final=""""
#my_set=set()
#for x in range(1, 100000):
 #my_set.add(2*x*x)
 #my_set.add(4*x*x)
 
#vector_prime=[-1]*21000
#vector_rasp=[0]*21000

#vector_prime[1]=1

#vector_rasp[1]=1

contor=2
#primes sieve
#for i in range(2,21000):
 #if vector_prime[i]==-1:
  #vector_prime[i]=1
  #vector_rasp[contor]=i
  #contor=contor+1
  #for j in range(i+i,21000,i):
  # vector_prime[j]=0
   #print(i,j)


  
#suma=0
#vector=list(map(int,input().split()))
#for i in vector:
 #suma=suma+i
#luni = {'January':1, 'February':2, 'March':3, 'April':4, 'May':5, 'June':6, 'July':7, 'August':8, 'September':9, 'October':10, 'November':11, 'December':0}
#luni_reverse = {1:'January', 2:'February', 3:'March', 4:'April', 5:'May', 6:'June', 7:'July', 8:'August', 9:'September', 10:'October', 11:'November', 0:'December'} 
#alfabet = {'a': 1, 'b': 2,'c': 3,'d': 4,'e': 5,'f': 6,'g': 7,'h': 8,'i': 9,'j': 10,'k': 11,'l': 12,'m': 13,'n': 14,'o': 15,'p': 16,'q': 17,'r': 18,'s': 19,'t': 20,'u': 21,'v': 22,'w': 23,'x': 24,'y': 25,'z': 26}
#alfabet_2={'1':""a"", '2':""b"", '3':""c"", '4':""d"", '5':""e"", '6':""f"", '7':""g"", '8':""h"", '9':""i"", '10':""j"", '11':""k"", '12':""l"", '13':""m"", '14':""n"", '15':""o"", '16':""p"", '17':""q"", '18':""r"", '19':""s"", '20':""t"", '21':""u"", '22':""v"", '23':""w"", '24':""x"", '25':""y"", '26':""z""}
 
k=int(input()) 
#k=1
 
contor=0 
while k>0:
 
 
 contor+=1
 
 waiting=deque()

 #n=int(input())
 
 lista=list(map(int,input().split()))

 n=lista[0]
 m=lista[1]
 rb=lista[2]
 cb=lista[3]
 rd=lista[4]
 cd=lista[5]
 
 tr=n+m
 tc=n+m
 
 if cd<cb:
  tr=2*(m-cb)+cb-cd
 
 if cd>=cb:
  tr=cd-cb
  
 if rd>=rb:
  tc=rd-rb
 if rd<rb:
  tc=2*(n-rb)+rb-rd
  
 print(min(tc,tr)) 
  
   
 
 
  
   
   
 
   
  
  
  
 k=k-1
#print(rasp_final)","['brute force', 'implementation', 'math']"
4437,"Given simple (without self-intersections) n-gon. It is not necessary convex. Also you are given m lines. For each line find the length of common part of the line and the n-gon.The boundary of n-gon belongs to polygon. It is possible that n-gon contains 180-degree angles. nan import math

eps = 1e-9

def sign(n):
    if n > eps: return 1
    if n < -eps: return -1
    return 0

def cross(a, b):
    return a.x * b.y - a.y * b.x

class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __add__(self, v):
        return Vector(self.x + v.x, self.y + v.y)
    
    def __sub__(self, v):
        return Vector(self.x - v.x, self.y - v.y)
    
    def length(self):
        return math.hypot(self.x, self.y)

def solve(polygon, p, q):
    intersections = []
    for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):
        ss = sign(cross(a - p, q - p))
        es = sign(cross(b - p, q - p))

        if ss == es: continue

        t = cross(a - p, a - b) / cross(q - p, a - b)
        intersections.append((t, es - ss))
    intersections = sorted(intersections)
    total_t, previous_t, count = [0] * 3
    
    for t, order in intersections:
        if (count > 0): total_t += t - previous_t
        previous_t = t
        count += order
    # print(total_t) 

    print(total_t * (q - p).length())
    
n, m = map(int, input().split())

polygon = []
for i in range(n):
    x, y = map(float, input().split())
    polygon.append(Vector(x, y))
area = sum(map(lambda x: cross(x[0], x[1]), zip(polygon, polygon[1:] + polygon[:1])))
if (area < 0): polygon.reverse()

for i in range(m):
    x1, y1, x2, y2 = map(float, input().split())
    solve(polygon, Vector(x1, y1), Vector(x2, y2))
",['geometry']
3558,"In fact, the problems E1 and E2 do not have much in common. You should probably think of them as two separate problems.You are given an integer array $$$a[1 \ldots n] = [a_1, a_2, \ldots, a_n]$$$.Let us consider an empty deque (double-ended queue). A deque is a data structure that supports adding elements to both the beginning and the end. So, if there are elements $$$[3, 4, 4]$$$ currently in the deque, adding an element $$$1$$$ to the beginning will produce the sequence $$$[\color{red}{1}, 3, 4, 4]$$$, and adding the same element to the end will produce $$$[3, 4, 4, \color{red}{1}]$$$.The elements of the array are sequentially added to the initially empty deque, starting with $$$a_1$$$ and finishing with $$$a_n$$$. Before adding each element to the deque, you may choose whether to add it to the beginning or to the end.For example, if we consider an array $$$a = [3, 7, 5, 5]$$$, one of the possible sequences of actions looks like this: $$$\quad$$$ 1.add $$$3$$$ to the beginning of the deque:deque has a sequence $$$[\color{red}{3}]$$$ in it;$$$\quad$$$ 2.add $$$7$$$ to the end of the deque:deque has a sequence $$$[3, \color{red}{7}]$$$ in it;$$$\quad$$$ 3.add $$$5$$$ to the end of the deque:deque has a sequence $$$[3, 7, \color{red}{5}]$$$ in it;$$$\quad$$$ 4.add $$$5$$$ to the beginning of the deque:deque has a sequence $$$[\color{red}{5}, 3, 7, 5]$$$ in it;Find the minimal possible number of inversions in the deque after the whole array is processed. An inversion in sequence $$$d$$$ is a pair of indices $$$(i, j)$$$ such that $$$i &lt; j$$$ and $$$d_i &gt; d_j$$$. For example, the array $$$d = [5, 3, 7, 5]$$$ has exactly two inversions — $$$(1, 2)$$$ and $$$(3, 4)$$$, since $$$d_1 = 5 &gt; 3 = d_2$$$ and $$$d_3 = 7 &gt; 5 = d_4$$$. NoteOne of the ways to get the sequence $$$[5, 3, 7, 5]$$$ in the deque, containing only two inversions, from the initial array $$$[3, 7, 5, 5]$$$ (the first sample test case) is described in the problem statement. Also, in this example, you could get the answer of two inversions by simply putting each element of the original array at the end of the deque. In this case, the original sequence $$$[3, 7, 5, 5]$$$, also containing exactly two inversions, will be in the deque as-is. import sys

input = sys.stdin.readline

def solve():
	n = int(input())
	a = list(map(int, input().split()))
	z = a.copy()
	z.sort()
	p = dict()
	s = 0
	for i in z:
		if i not in p:
			p[i] = s
			s += 1
	C = [0]*s
	F = [0]*s
	r = 0
	for i in range(n):
		v = a[i]
		c = 0
		x = p[v]
		while x >= 0:
			c += F[x]
			x = (x & (x + 1)) - 1
		x = p[v]
		r += min(c - C[x], i - c)
		C[x] += 1
		while x < s:
			F[x] += 1
			x = x | (x + 1)
	print(r)

for i in range(int(input())):
	solve()
","['data structures', 'greedy']"
4024,"As we all know Barney's job is ""PLEASE"" and he has not much to do at work. That's why he started playing ""cups and key"". In this game there are three identical cups arranged in a line from left to right. Initially key to Barney's heart is under the middle cup.  Then at one turn Barney swaps the cup in the middle with any of other two cups randomly (he choses each with equal probability), so the chosen cup becomes the middle one. Game lasts n turns and Barney independently choses a cup to swap with the middle one within each turn, and the key always remains in the cup it was at the start.After n-th turn Barney asks a girl to guess which cup contains the key. The girl points to the middle one but Barney was distracted while making turns and doesn't know if the key is under the middle cup. That's why he asked you to tell him the probability that girl guessed right.Number n of game turns can be extremely large, that's why Barney did not give it to you. Instead he gave you an array a1, a2, ..., ak such that   in other words, n is multiplication of all elements of the given array.Because of precision difficulties, Barney asked you to tell him the answer as an irreducible fraction. In other words you need to find it as a fraction p / q such that , where  is the greatest common divisor. Since p and q can be extremely large, you only need to find the remainders of dividing each of them by 109 + 7.Please note that we want  of p and q to be 1, not  of their remainders after dividing by 109 + 7. nan k = int(input())
MOD = 10 ** 9 + 7
antithree = pow(3, MOD - 2, MOD)
antitwo = pow(2, MOD - 2, MOD)
power = 1
parity = False
for t in map(int, input().split()):
    power *= t
    power %= MOD - 1
    if t % 2 == 0:
        parity = True
q = pow(2, power, MOD) * antitwo
q %= MOD
if parity:
    p = (q + 1) * antithree
    p %= MOD
else:
    p = (q - 1) * antithree
    p %= MOD    
print(p, q, sep = '/')","['combinatorics', 'math', 'number theory']"
1684,"Stanley lives in a country that consists of $$$n$$$ cities (he lives in city $$$1$$$). There are bidirectional roads between some of the cities, and you know how long it takes to ride through each of them. Additionally, there is a flight between each pair of cities, the flight between cities $$$u$$$ and $$$v$$$ takes $$$(u - v)^2$$$ time.Stanley is quite afraid of flying because of watching ""Sully: Miracle on the Hudson"" recently, so he can take at most $$$k$$$ flights. Stanley wants to know the minimum time of a journey to each of the $$$n$$$ cities from the city $$$1$$$. NoteIn the first sample, it takes no time to get to city 1; to get to city 2 it is possible to use a flight between 1 and 2, which will take 1 unit of time; to city 3 you can get via a road from city 1, which will take 1 unit of time. In the second sample, it also takes no time to get to city 1. To get to city 2 Stanley should use a flight between 1 and 2, which will take 1 unit of time. To get to city 3 Stanley can ride between cities 1 and 2, which will take 3 units of time, and then use a flight between 2 and 3. To get to city 4 Stanley should use a flight between 1 and 2, then take a ride from 2 to 4, which will take 5 units of time. from sys import stdin
input=lambda :stdin.readline()[:-1]

n,m,k=map(int,input().split())
edge=[[] for i in range(n)]
for _ in range(m):
  a,b,c=map(int,input().split())
  a,b=a-1,b-1
  edge[a].append((b,c))
  edge[b].append((a,c))

from heapq import heappop,heappush

mask=(1<<17)-1
def dijkstra():
  hq=[]
  for i in range(n):
    if dist[i]!=inf:
      heappush(hq,(dist[i]<<17)+i)
  seen=[0]*n
  while hq:
    x=heappop(hq)
    w,v=x>>17,x&mask
    if dist[v]<w:
      continue
    seen[v]=True
    for to,cost in edge[v]:
      if seen[to]==False and dist[v]+cost<dist[to]:
        dist[to]=dist[v]+cost
        heappush(hq,(dist[to]<<17)+to)

from collections import deque

class ConvexHullTrick():
  # 追加する直線の傾きが単調
  # 計算する x 座標が単調
  # O(N+Q)
  
  def __init__(self):
    self.deq=deque()
  
  def check(self,f1,f2,f3):
    return (f2[0]-f1[0])*(f3[1]-f2[1])>=(f2[1]-f1[1])*(f3[0]-f2[0])
  
  def f(self,f1,x):
    return f1[0]*x+f1[1]
  
  # add f_i(x)=a*x+b
  def add_line(self,a,b):
    f1=(a,b)
    while len(self.deq)>=2 and self.check(self.deq[-2],self.deq[-1],f1):
      self.deq.pop()
    self.deq.append(f1)
  
  # min f_i(x)
  def query(self,x):
    while len(self.deq)>=2 and self.f(self.deq[0],x)>=self.f(self.deq[1],x):
      self.deq.popleft()
    return self.f(self.deq[0],x)


inf=1<<60
dist=[inf]*n
dist[0]=0
dijkstra()

for _ in range(k):
  CHT=ConvexHullTrick()
  for i in range(n):
    CHT.add_line(-2*i,dist[i]+i*i)
  
  for i in range(n):
    dist[i]=CHT.query(i)+i*i
  dijkstra()

print(*dist)","['data structures', 'divide and conquer', 'dp', 'geometry', 'graphs', 'greedy', 'shortest paths']"
2876,"Even a cat has things it can do that AI cannot.— Fei-Fei LiYou are given $$$m$$$ arrays of positive integers. Each array is of even length.You need to split all these integers into two equal multisets $$$L$$$ and $$$R$$$, that is, each element of each array should go into one of two multisets (but not both). Additionally, for each of the $$$m$$$ arrays, exactly half of its elements should go into $$$L$$$, and the rest should go into $$$R$$$.Give an example of such a division or determine that no such division exists. NoteIn the first array, we add the first element to $$$R$$$ and the second to $$$L$$$. Now $$$L = \{2\}$$$, and $$$R = \{1\}$$$.In the second array, we add the first and third elements to $$$L$$$ and the rest to $$$R$$$. Now $$$L = \{1, 2, 3\}$$$ and $$$R = \{1, 2, 3\}$$$.In the third array, we add elements 2, 3, and 6 to $$$L$$$, and others — to $$$R$$$. As a result, $$$L = R = \{1, 1, 2, 2, 3, 3\}$$$. import io, os, sys
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
from collections import defaultdict, Counter
I = lambda: [int(x) for x in input().split()]

G = defaultdict(Counter)
places = defaultdict(set)
ans = defaultdict(list)

m = int(input())
for i in range(m):
    _ = input()
    arr = I()
    for j, x in enumerate(arr):
        G[i][x + m] += 1
        G[x + m][i] += 1
        places[x + m, i].add(j)
    ans[i] = [""X""] * len(arr)

if all(sum(G[i].values()) % 2 == 0 for i in G):
    visited = set()
    for start in G:
        if start in visited: continue
        stack = [start]
        path = []

        while stack:
            v = stack[-1]
            if G[v]:
                u = next(iter(G[v].items()))[0]
                stack.append(u)
                G[v][u] -= 1
                if G[v][u] == 0: G[v].pop(u)
                G[u][v] -= 1
                if G[u][v] == 0: G[u].pop(v)
            else:
                path.append(stack.pop())

        visited |= set(path)
        for x, y in zip(path, path[1:]):
            l = ""L"" if x < y else ""R""
            x, y = min(x, y), max(x, y)
            idx = places[y, x].pop()
            ans[x][idx] = l

    print(""YES"")
    for i in range(m):
        print("""".join(ans[i]))
else:
    print(""NO"")","['constructive algorithms', 'data structures', 'dfs and similar', 'graphs', 'other']"
3295,"Little Petya very much likes rectangles and especially squares. Recently he has received 8 points on the plane as a gift from his mother. The points are pairwise distinct. Petya decided to split them into two sets each containing 4 points so that the points from the first set lay at the vertexes of some square and the points from the second set lay at the vertexes of a rectangle. Each point of initial 8 should belong to exactly one set. It is acceptable for a rectangle from the second set was also a square. If there are several partitions, Petya will be satisfied by any of them. Help him find such partition. Note that the rectangle and the square from the partition should have non-zero areas. The sides of the figures do not have to be parallel to the coordinate axes, though it might be the case. NotePay attention to the third example: the figures do not necessarily have to be parallel to the coordinate axes. from itertools import permutations as p 
l = [list(map(int, input().split())) + [_] for _ in range(1, 9)]

def dist(a, b):
    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2

def rect(a, b, c, d):
    return dist(a, b) == dist(c, d) and dist(a, c) == dist(b, d) and dist(a, d) == dist(b, c) and dist(a, b) * dist(b, c) != 0

def sq(a, b, c, d):
    # print(rect(a, b, c, d))
    return rect(a, b, c, d) and dist(a, b) == dist(b, c)

for t in p(l):
    if sq(*t[:4]) and rect(*t[4:]):
        print(""YES"")
        print(' '.join([str(_[2]) for _ in t[:4]]))
        print(' '.join([str(_[2]) for _ in t[4:]]))
        exit()
print(""NO"")","['brute force', 'geometry', 'math']"
51,"You are given array a with n elements and the number m. Consider some subsequence of a and the value of least common multiple (LCM) of its elements. Denote LCM as l. Find any longest subsequence of a with the value l ≤ m.A subsequence of a is an array we can get by erasing some elements of a. It is allowed to erase zero or all elements.The LCM of an empty array equals 1. nan import sys
range = xrange
input = raw_input
 
n,m = [int(x) for x in input().split()]
A = [int(x) for x in input().split()]
counter = [0]*(m+1)
for a in A:
    if a <= m:
        counter[a] += 1
 
lcm = [0]*(m+1)
for d in range(1,m+1):
    for j in range(d,m+1,d):
        lcm[j] += counter[d]
 
lcm = max(range(1, m+1), key = lcm.__getitem__)
out = []
for i,a in enumerate(A):
    if lcm != 0 and lcm%a == 0:
        out.append(i)
print lcm, len(out)
print ' '.join(str(x+1) for x in out)","['brute force', 'math', 'number theory']"
3189,"Bashar was practicing for the national programming contest. Because of sitting too much in front of the computer without doing physical movements and eating a lot Bashar became much fatter. Bashar is going to quit programming after the national contest and he is going to become an actor (just like his father), so he should lose weight.In order to lose weight, Bashar is going to run for $$$k$$$ kilometers. Bashar is going to run in a place that looks like a grid of $$$n$$$ rows and $$$m$$$ columns. In this grid there are two one-way roads of one-kilometer length between each pair of adjacent by side cells, one road is going from the first cell to the second one, and the other road is going from the second cell to the first one. So, there are exactly $$$(4 n m - 2n - 2m)$$$ roads.Let's take, for example, $$$n = 3$$$ and $$$m = 4$$$. In this case, there are $$$34$$$ roads. It is the picture of this case (arrows describe roads):Bashar wants to run by these rules:  He starts at the top-left cell in the grid;  In one move Bashar may go up (the symbol 'U'), down (the symbol 'D'), left (the symbol 'L') or right (the symbol 'R'). More formally, if he stands in the cell in the row $$$i$$$ and in the column $$$j$$$, i.e. in the cell $$$(i, j)$$$ he will move to:   in the case 'U' to the cell $$$(i-1, j)$$$;  in the case 'D' to the cell $$$(i+1, j)$$$;  in the case 'L' to the cell $$$(i, j-1)$$$;  in the case 'R' to the cell $$$(i, j+1)$$$;   He wants to run exactly $$$k$$$ kilometers, so he wants to make exactly $$$k$$$ moves;  Bashar can finish in any cell of the grid;  He can't go out of the grid so at any moment of the time he should be on some cell;  Bashar doesn't want to get bored while running so he must not visit the same road twice. But he can visit the same cell any number of times. Bashar asks you if it is possible to run by such rules. If it is possible, you should tell him how should he run.You should give him $$$a$$$ steps to do and since Bashar can't remember too many steps, $$$a$$$ should not exceed $$$3000$$$. In every step, you should give him an integer $$$f$$$ and a string of moves $$$s$$$ of length at most $$$4$$$ which means that he should repeat the moves in the string $$$s$$$ for $$$f$$$ times. He will perform the steps in the order you print them.For example, if the steps are $$$2$$$ RUD, $$$3$$$ UUL then the moves he is going to move are RUD $$$+$$$ RUD $$$+$$$ UUL $$$+$$$ UUL $$$+$$$ UUL $$$=$$$ RUDRUDUULUULUUL.Can you help him and give him a correct sequence of moves such that the total distance he will run is equal to $$$k$$$ kilometers or say, that it is impossible? NoteThe moves Bashar is going to move in the first example are: ""RRLL"".It is not possible to run $$$1000000000$$$ kilometers in the second example because the total length of the roads is smaller and Bashar can't run the same road twice.The moves Bashar is going to move in the third example are: ""RRDDLLRR"".The moves Bashar is going to move in the fifth example are: ""RRRLLLDRRRDULLLD"". It is the picture of his run (the roads on this way are marked with red and numbered in the order of his running): """"""
    This template is made by Satwik_Tiwari.
    python programmers can use this template :)) .
""""""

#===============================================================================================
#importing some useful libraries.

import sys
import bisect
import heapq
from math import *
from collections import Counter as counter  # Counter(list)  return a dict with {key: count}
from itertools import combinations as comb # if a = [1,2,3] then print(list(comb(a,2))) -----> [(1, 2), (1, 3), (2, 3)]
from itertools import permutations as permutate
from bisect import bisect_left as bl #
from bisect import bisect_right as br
from bisect import bisect

#===============================================================================================
#some shortcuts

mod = pow(10, 9) + 7
def inp(): return sys.stdin.readline().strip() #for fast input
def out(var): sys.stdout.write(str(var))  #for fast output, always take string
def lis(): return list(map(int, inp().split()))
def stringlis(): return list(map(str, inp().split()))
def sep(): return map(int, inp().split())
def strsep(): return map(str, inp().split())
def graph(vertex): return [[] for i in range(0,vertex+1)]
def zerolist(n): return [0]*n
def nl(): out(""\n"")  #as stdout.write always print sring.
def testcase(t):
    for p in range(t):
        solve()
def printlist(a) :
    for p in range(0,len(a)):
        out(str(a[p]) + ' ')
def lcm(a,b): return (a*b)//gcd(a,b)


#===============================================================================================
# code here ;))


def func(n,m,k):
    if((4*m*n)-(2*n)-(2*m) < k):
        return True
    else:
        return False

def solve():
    n,m,k = sep()
    if(func(n,m,k)):
        print('NO')
    else:
        print('YES')
        ans = []
        if(m-1 > 0):
            ans.append([m-1,'R'])
        for i in range(m-1):
            # s1 = 'D'*(n-1) + ('U')*(n-1)
            if(n-1 > 0):
                ans.append([n-1,'DLR'])
            # temp = n-1
            # a = temp//4
            # if(a>0):
            #     ans.append([a,'DDDD'])
            # temp = temp - (4*a)
            # if(temp > 0):
            #     ans.append([1,'D'*temp])
            temp = n-1
            a = temp//4
            if(a>0):
                ans.append([a,'UUUU'])
            temp = temp - (4*a)
            if(temp > 0):
                ans.append([1,'U'*temp+'L'])
            else:
                ans.append([1,'L'])

        temp = n-1
        a = temp//4
        if(a>0):
            ans.append([a,'DDDD'])
        temp = temp-(4*a)
        if(temp > 0):
            ans.append([1,'D'*temp])

        temp = n-1
        a = temp//4
        if(a>0):
            ans.append([a,'UUUU'])
        temp = temp-(4*a)
        if(temp > 0):
            ans.append([1,'U'*temp])


        # for i in range(n-1):
        #     # ans.append([1,'D'])
        #     help = (m-1) - (((m-1)//4)*4)
        #     if(help > 0):
        #         ans.append([1,'D'+'R'*help])
        #     # s1 = 'R'*(m-1) + 'L'*(m-1)
        #     temp = m-1-help
        #     a = temp//4
        #     if(a>0):
        #         ans.append([a,'RRRR'])
        #     temp = temp - (4*a)
        #     if(temp > 0):
        #         ans.append([1,'R'*temp])
        #     temp = m-1
        #     a = temp//4
        #     if(a>0):
        #         ans.append([a,'LLLL'])
        #     temp = temp - (4*a)
        #     if(temp > 0):
        #         ans.append([1,'L'*temp])

        ans.append([n-1,'U'*(n-1)])

        finall = []
        cnt = 0
        index = 0
        while(True):
            if(cnt+len(ans[index][1])*ans[index][0] == k):
                finall.append(ans[index])
                break
            if(cnt+len(ans[index][1])*ans[index][0]  < k):
                finall.append(ans[index])
                cnt += len(ans[index][1])*ans[index][0]
                index+=1
            else:
                rem = k-cnt
                if(ans[index][0] == 1):
                    finall.append([1,ans[index][1][:rem]])
                    break
                else:

                    b = rem//(len(ans[index][1]))
                    if(b>0):
                        finall.append([b,ans[index][1]])
                    rem = rem - (len(ans[index][1])*b)
                    if(rem > 0):
                        finall.append([1,ans[index][1][:rem]])
                    # temp = ans[index][1][:rem]
                    # finall.append([1,temp])
                    break

        print(len(finall))
        for i in range(0,len(finall)):
            print(finall[i][0],finall[i][1])



testcase(1)
# testcase(1)













","['constructive algorithms', 'graphs', 'implementation']"
3949,"This is the easy version of the problem. The difference is constraints on the number of wise men and the time limit. You can make hacks only if all versions of this task are solved.$$$n$$$ wise men live in a beautiful city. Some of them know each other.For each of the $$$n!$$$ possible permutations $$$p_1, p_2, \ldots, p_n$$$ of the wise men, let's generate a binary string of length $$$n-1$$$: for each $$$1 \leq i &lt; n$$$ set $$$s_i=1$$$ if $$$p_i$$$ and $$$p_{i+1}$$$ know each other, and $$$s_i=0$$$ otherwise. For all possible $$$2^{n-1}$$$ binary strings, find the number of permutations that produce this binary string. NoteIn the first test, each wise man knows each other, so every permutation will produce the string $$$11$$$.In the second test:  If $$$p = \{1, 2, 3, 4\}$$$, the produced string is $$$101$$$, because wise men $$$1$$$ and $$$2$$$ know each other, $$$2$$$ and $$$3$$$ don't know each other, and $$$3$$$ and $$$4$$$ know each other;  If $$$p = \{4, 1, 2, 3\}$$$, the produced string is $$$110$$$, because wise men $$$1$$$ and $$$4$$$ know each other, $$$1$$$ and $$$2$$$ know each other and $$$2$$$, and $$$3$$$ don't know each other;  If $$$p = \{1, 3, 2, 4\}$$$, the produced string is $$$000$$$, because wise men $$$1$$$ and $$$3$$$ don't know each other, $$$3$$$ and $$$2$$$ don't know each other, and $$$2$$$ and $$$4$$$ don't know each other.  from sys import stdout

n = int(input())


class Person:

    num = n - 1

    def __init__(self, rel):
        self.relationship = int(rel, 2)

    def __getitem__(self, k):
        return (self.relationship >> Person.num - k) & 1


rel = [Person(input()) for _ in range(n)]

dp = [[0] * n for _ in range(1 << n)]

for people in range(1, 1 << n):
    ones = [i for i in range(n) if people & (1 << i)]
    # print(f'ones: {ones}')
    one_num = len(ones)

    if one_num == 1:
        dp[people][ones[0]] = [1]
        continue

    for i in ones:
        dp[people][i] = [0] * (1 << one_num - 1)
        pre_people = people ^ (1 << i)
        for j in ones:
            if j == i:
                continue
            for pre_s, times in enumerate(dp[pre_people][j]):
                s = pre_s | (rel[j][i] << one_num - 2)
                # print(f'dp[{people}][{i}][{s}]: {dp[people][i][s]}')
                dp[people][i][s] += times

people = (1 << n) - 1

for s in range(1 << (n-1)):
    ans = 0
    for i in range(n):
        ans += dp[people][i][s]
    print(ans, end=' ')","['bitmasks', 'brute force', 'dp', 'other']"
1183,"The string $$$t_1t_2 \dots t_k$$$ is good if each letter of this string belongs to at least one palindrome of length greater than 1.A palindrome is a string that reads the same backward as forward. For example, the strings A, BAB, ABBA, BAABBBAAB are palindromes, but the strings AB, ABBBAA, BBBA are not.Here are some examples of good strings:   $$$t$$$ = AABBB (letters $$$t_1$$$, $$$t_2$$$ belong to palindrome $$$t_1 \dots t_2$$$ and letters $$$t_3$$$, $$$t_4$$$, $$$t_5$$$ belong to palindrome $$$t_3 \dots t_5$$$);  $$$t$$$ = ABAA (letters $$$t_1$$$, $$$t_2$$$, $$$t_3$$$ belong to palindrome $$$t_1 \dots t_3$$$ and letter $$$t_4$$$ belongs to palindrome $$$t_3 \dots t_4$$$);  $$$t$$$ = AAAAA (all letters belong to palindrome $$$t_1 \dots t_5$$$); You are given a string $$$s$$$ of length $$$n$$$, consisting of only letters A and B.You have to calculate the number of good substrings of string $$$s$$$. NoteIn the first test case there are six good substrings: $$$s_1 \dots s_2$$$, $$$s_1 \dots s_4$$$, $$$s_1 \dots s_5$$$, $$$s_3 \dots s_4$$$, $$$s_3 \dots s_5$$$ and $$$s_4 \dots s_5$$$.In the second test case there are three good substrings: $$$s_1 \dots s_2$$$, $$$s_1 \dots s_3$$$ and $$$s_2 \dots s_3$$$. n = int(input())
s = input()
res = n * (n - 1) // 2

for x in range(2):
	cur = 1
	for i in range(1, n):
		if s[i] == s[i - 1]:
			cur += 1
		else:
			res -= cur - x
			cur = 1
	s = s[::-1]

print(res) ","['binary search', 'combinatorics', 'dp', 'strings']"
534,"As it's the first of April, Heidi is suspecting that the news she reads today are fake, and she does not want to look silly in front of all the contestants. She knows that a newspiece is fake if it contains heidi as a subsequence. Help Heidi assess whether the given piece is true, but please be discreet about it... NoteA string s contains another string p as a subsequence if it is possible to delete some characters from s and obtain p. x =[i for i in input()]

def charpos(c1,arr):
	for i in range(len(arr)):
		if arr[i] ==c1:
			return i
	return -1
temp=0
result =True
for i in ""heidi"":	
	temp = charpos(i,x)
	x = x[temp:]
	if temp==-1:
		result=False
		break
	
if result:
	print(""YES"")
else:
	print(""NO"")
","['implementation', 'strings']"
3888,"You are given a deck of $$$n$$$ cards numbered from $$$1$$$ to $$$n$$$ (not necessarily in this order in the deck). You have to sort the deck by repeating the following operation.   Choose $$$2 \le k \le n$$$ and split the deck in $$$k$$$ nonempty contiguous parts $$$D_1, D_2,\dots, D_k$$$ ($$$D_1$$$ contains the first $$$|D_1|$$$ cards of the deck, $$$D_2$$$ contains the following $$$|D_2|$$$ cards and so on). Then reverse the order of the parts, transforming the deck into $$$D_k, D_{k-1}, \dots, D_2, D_1$$$ (so, the first $$$|D_k|$$$ cards of the new deck are $$$D_k$$$, the following $$$|D_{k-1}|$$$ cards are $$$D_{k-1}$$$ and so on). The internal order of each packet of cards $$$D_i$$$ is unchanged by the operation. You have to obtain a sorted deck (i.e., a deck where the first card is $$$1$$$, the second is $$$2$$$ and so on) performing at most $$$n$$$ operations. It can be proven that it is always possible to sort the deck performing at most $$$n$$$ operations.Examples of operation: The following are three examples of valid operations (on three decks with different sizes).   If the deck is [3 6 2 1 4 5 7] (so $$$3$$$ is the first card and $$$7$$$ is the last card), we may apply the operation with $$$k=4$$$ and $$$D_1=$$$[3 6], $$$D_2=$$$[2 1 4], $$$D_3=$$$[5], $$$D_4=$$$[7]. Doing so, the deck becomes [7 5 2 1 4 3 6].  If the deck is [3 1 2], we may apply the operation with $$$k=3$$$ and $$$D_1=$$$[3], $$$D_2=$$$[1], $$$D_3=$$$[2]. Doing so, the deck becomes [2 1 3].  If the deck is [5 1 2 4 3 6], we may apply the operation with $$$k=2$$$ and $$$D_1=$$$[5 1], $$$D_2=$$$[2 4 3 6]. Doing so, the deck becomes [2 4 3 6 5 1].  NoteExplanation of the first testcase: Initially the deck is [3 1 2 4].   The first operation splits the deck as [(3) (1 2) (4)] and then transforms it into [4 1 2 3].  The second operation splits the deck as [(4) (1 2 3)] and then transforms it into [1 2 3 4].  Explanation of the second testcase: Initially the deck is [6 5 4 3 2 1].   The first (and only) operation splits the deck as [(6) (5) (4) (3) (2) (1)] and then transforms it into [1 2 3 4 5 6].  from collections import Counter, defaultdict, deque
import bisect
from sys import stdin, stdout
from itertools import repeat
import math

# sys.stdin = open('input')

def mod(x, y, mod):
    re = 1
    now = x
    while y:
        if y&1:
            re *= now
            re %= mod
        y >>= 1
        now = (now*now)%mod
    return re

def inp(force_list=False):
    re = map(int, raw_input().split())
    if len(re) == 1 and not force_list:
        return re[0]
    return re

def inst():
    return raw_input().strip()

def gcd(x, y):
   while(y):
       x, y = y, x % y
   return x

MOD = int(1e9+7)

def query(ty, num):
    if ty==0:
        print 'A %d' % num
    else:
        print 'B %d' % num
    stdout.flush()
    return inp()

def my_main():
    T = 1
    ans = []
    for _ in range(T):
        n = inp()
        da = inp(True)
        op = []
        st = 0
        l = 1
        nl = 0
        mid = n/2+1+n%2
        nm = 0
        for i in range(n-n%2):
            if st==0:
                idx = da.index(mid)
                da = da[n-nm:] + da[idx:n-nm] +  da[nl:idx] + da[0:nl]
                tmpp = filter(lambda x: x!=0, (nl-0, idx-nl, n-nm-idx, n-n+nm))
                len(tmpp) > 1 and ans.append(tmpp)
                mid += 1
                nm += 1
            else:
                idx = da.index(l)
                da = da[n-nl:] + da[idx:n-nl] + da[nm:idx] + da[0:nm]
                tmpp = filter(lambda x: x!=0, (nm-0, idx-nm, n-nl-idx, n-n+nl))
                len(tmpp) > 1 and ans.append(tmpp)
                l += 1
                nl += 1
            # print da, tmpp
            # print l, mid,'kkk',st
            st ^= 1
        print len(ans)
        for iq in ans:
            iq = filter(lambda x: x!=0, iq)
            print len(iq), ' '.join(map(str, iq))










my_main()
","['constructive algorithms', 'implementation']"
3936,"Some number of people (this number is even) have stood in a circle. The people stand in the circle evenly. They are numbered clockwise starting from a person with the number $$$1$$$. Each person is looking through the circle's center at the opposite person.    A sample of a circle of $$$6$$$ persons. The orange arrows indicate who is looking at whom. You don't know the exact number of people standing in the circle (but this number is even, no doubt). It is known that the person with the number $$$a$$$ is looking at the person with the number $$$b$$$ (and vice versa, of course). What is the number associated with a person being looked at by the person with the number $$$c$$$? If, for the specified $$$a$$$, $$$b$$$, and $$$c$$$, no such circle exists, output -1. NoteIn the first test case, there's a desired circle of $$$8$$$ people. The person with the number $$$6$$$ will look at the person with the number $$$2$$$ and the person with the number $$$8$$$ will look at the person with the number $$$4$$$.In the second test case, there's no circle meeting the conditions. If the person with the number $$$2$$$ is looking at the person with the number $$$3$$$, the circle consists of $$$2$$$ people because these persons are neighbors. But, in this case, they must have the numbers $$$1$$$ and $$$2$$$, but it doesn't meet the problem's conditions.In the third test case, the only circle with the persons with the numbers $$$2$$$ and $$$4$$$ looking at each other consists of $$$4$$$ people. Therefore, the person with the number $$$10$$$ doesn't occur in the circle. t=int(input())
qwe=[]

for i in range(t):
    qwe.append(list(map(int,input().split())))

for j in range(t):
    a = qwe[j][0]
    b = qwe[j][1]
    c = qwe[j][2]
    if a > b:
        a, b = b, a
    h = b - a
    f = 2 * h    

    if (f < b) or (c > f):
        d = -1
    else:
        if (c + h) > f:
            d = c - h
        else:
            d = c + h

    print(d)
# Sun Sep 12 2021 19:26:22 GMT+0300 (Москва, стандартное время)
",['math']
443,"Another programming contest is over. You got hold of the contest's final results table. The table has the following data. For each team we are shown two numbers: the number of problems and the total penalty time. However, for no team we are shown its final place.You know the rules of comparing the results of two given teams very well. Let's say that team a solved pa problems with total penalty time ta and team b solved pb problems with total penalty time tb. Team a gets a higher place than team b in the end, if it either solved more problems on the contest, or solved the same number of problems but in less total time. In other words, team a gets a higher place than team b in the final results' table if either pa &gt; pb, or pa = pb and ta &lt; tb. It is considered that the teams that solve the same number of problems with the same penalty time share all corresponding places. More formally, let's say there is a group of x teams that solved the same number of problems with the same penalty time. Let's also say that y teams performed better than the teams from this group. In this case all teams from the group share places y + 1, y + 2, ..., y + x. The teams that performed worse than the teams from this group, get their places in the results table starting from the y + x + 1-th place.Your task is to count what number of teams from the given list shared the k-th place.  NoteThe final results' table for the first sample is:   1-3 places — 4 solved problems, the penalty time equals 10  4 place — 3 solved problems, the penalty time equals 20  5-6 places — 2 solved problems, the penalty time equals 1  7 place — 1 solved problem, the penalty time equals 10 The table shows that the second place is shared by the teams that solved 4 problems with penalty time 10. There are 3 such teams.The final table for the second sample is:  1 place — 5 solved problems, the penalty time equals 3  2-5 places — 3 solved problems, the penalty time equals 1 The table shows that the fourth place is shared by the teams that solved 3 problems with penalty time 1. There are 4 such teams. import math
import sys
import collections

# imgur.com/Pkt7iIf.png

def getdict(n):
    d = {}
    if type(n) is list:
        for i in n:
            if i in d:
                d[i] += 1
            else:
                d[i] = 1
    else:
        for i in range(n):
            t = ii()
            if t in d:
                d[t] += 1
            else:
                d[t] = 1
    return d
def sieve(n):
    prime = [True for i in range(n + 1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * 2, n + 1, p):
                prime[i] = False
        p += 1
    prime[0] = prime[1] = False
    r = [p for p in range(n + 1) if prime[p]]
    return r
def cdiv(n, k): return n // k + (n % k != 0)
def ii(): return int(input())
def mi(): return map(int, input().split())
def li(): return list(map(int, input().split()))
def lcm(a, b): return abs(a * b) // math.gcd(a, b)
def prr(a, sep = ' '): print(sep.join(map(str, a)))
def dd(): return collections.defaultdict(int)


n, k = mi()
d = []
for i in range(n):
    d.append(li())

d = sorted(d, key = lambda x: (-x[0], x[1]))
p = t = place = 0
for i in range(n):
    if d[i] != [p, t]:
        place = i + 1
    p, t = d[i][0], d[i][1]
    d[i] = place

print(d.count(d[k-1]))
","['binary search', 'implementation', 'sortings']"
1101,"You are given a permutation $$$a$$$ of length $$$n$$$. Recall that permutation is an array consisting of $$$n$$$ distinct integers from $$$1$$$ to $$$n$$$ in arbitrary order.You have a strength of $$$s$$$ and perform $$$n$$$ moves on the permutation $$$a$$$. The $$$i$$$-th move consists of the following:   Pick two integers $$$x$$$ and $$$y$$$ such that $$$i \leq x \leq y \leq \min(i+s,n)$$$, and swap the positions of the integers $$$x$$$ and $$$y$$$ in the permutation $$$a$$$. Note that you can select $$$x=y$$$ in the operation, in which case no swap will occur. You want to turn $$$a$$$ into another permutation $$$b$$$ after $$$n$$$ moves. However, some elements of $$$b$$$ are missing and are replaced with $$$-1$$$ instead. Count the number of ways to replace each $$$-1$$$ in $$$b$$$ with some integer from $$$1$$$ to $$$n$$$ so that $$$b$$$ is a permutation and it is possible to turn $$$a$$$ into $$$b$$$ with a strength of $$$s$$$. Since the answer can be large, output it modulo $$$998\,244\,353$$$. NoteIn the first test case, $$$a=[2,1,3]$$$. There are two possible ways to fill out the $$$-1$$$s in $$$b$$$ to make it a permutation: $$$[3,1,2]$$$ or $$$[3,2,1]$$$. We can make $$$a$$$ into $$$[3,1,2]$$$ with a strength of $$$1$$$ as follows: $$$$$$[2,1,3] \xrightarrow[x=1,\,y=1]{} [2,1,3] \xrightarrow[x=2,\,y=3]{} [3,1,2] \xrightarrow[x=3,\,y=3]{} [3,1,2].$$$$$$ It can be proven that it is impossible to make $$$[2,1,3]$$$ into $$$[3,2,1]$$$ with a strength of $$$1$$$. Thus only one permutation $$$b$$$ satisfies the constraints, so the answer is $$$1$$$.In the second test case, $$$a$$$ and $$$b$$$ the same as the previous test case, but we now have a strength of $$$2$$$. We can make $$$a$$$ into $$$[3,2,1]$$$ with a strength of $$$2$$$ as follows: $$$$$$[2,1,3] \xrightarrow[x=1,\,y=3]{} [2,3,1] \xrightarrow[x=2,\,y=3]{} [3,2,1] \xrightarrow[x=3,\,y=3]{} [3,2,1].$$$$$$ We can still make $$$a$$$ into $$$[3,1,2]$$$ using a strength of $$$1$$$ as shown in the previous test case, so the answer is $$$2$$$. In the third test case, there is only one permutation $$$b$$$. It can be shown that it is impossible to turn $$$a$$$ into $$$b$$$, so the answer is $$$0$$$. from functools import reduce
from sys import stdin, stdout


def read(): return stdin.readline().strip()
def write(x): stdout.write(str(x) + '\n')


def get_index(a):
    a_index = [-1] * len(a)
    for i in range(len(a)):
        if a[i] != -1:
            a_index[a[i]] = i
    return a_index


def solve():
    n, s = map(int, read().split())

    a_ = list(map(int, read().split()))
    b_ = list(map(int, read().split()))

    a = [i - 1 for i in a_]
    b = [i - 1 if i != -1 else -1 for i in b_]

    a_index = get_index(a)
    b_index = get_index(b)

    a = [a_index[i] for i in range(n)]
    b = [b_index[i] if b_index[i] != -1 else -1 for i in range(n)]

    a_index = get_index(a)
    b_index = get_index(b)

    # p = [a[i] for i in range(s)]
    # p_in_b = [a[i] for i in range(s) if a[i] in b]
    p_in_b = [a[i] for i in range(s) if b_index[a[i]] != -1]
    # p_not_in_b = [a[i] for i in range(s) if a[i] not in b]
    p_not_in_b = [a[i] for i in range(s) if b_index[a[i]] == -1]

    p_in_b_index = [-1] * n
    for i in range(len(p_in_b)):
        p_in_b_index[p_in_b[i]] = i

    c = [0] * n
    for i in range(n):
        j = i + s
        if j < n:
            # p.append(a[j])
            # if a[j] in b:
            if b_index[a[j]] != -1:
                p_in_b.append(a[j])
                p_in_b_index[a[j]] = len(p_in_b) - 1
            else:
                p_not_in_b.append(a[j])

        if b[i] == -1:
            # c[i] = len([i for i in p if i not in b])
            c[i] = len(p_not_in_b)
            # for i in p:
            #     if i not in b:
            #         p.remove(i)
            #         break
            # p_not_in_b.remove(p_not_in_b[0])
            if p_not_in_b:
                p_not_in_b.pop()
        else:
            # if b[i] in p_in_b:
            if p_in_b_index[b[i]] != -1:
                # if p_in_b_index[b[i]] != -1:
                c[i] = 1
                # p_in_b.remove(b[i])
                p_in_b_index[b[i]] = -1
            else:
                c[i] = 0
                break

    # print(c)
    write(reduce(lambda x, y: x * y % 998244353, c))


T = 1
T = int(read())
for _ in range(T):
    solve()
","['brute force', 'combinatorics', 'greedy', 'sortings', 'trees', 'two pointers']"
195,"You are given a string $$$s$$$ consisting of lowercase English letters and a number $$$k$$$. Let's call a string consisting of lowercase English letters beautiful if the number of occurrences of each letter in that string is divisible by $$$k$$$. You are asked to find the lexicographically smallest beautiful string of length $$$n$$$, which is lexicographically greater or equal to string $$$s$$$. If such a string does not exist, output $$$-1$$$.A string $$$a$$$ is lexicographically smaller than a string $$$b$$$ if and only if one of the following holds:   $$$a$$$ is a prefix of $$$b$$$, but $$$a \ne b$$$;  in the first position where $$$a$$$ and $$$b$$$ differ, the string $$$a$$$ has a letter that appears earlier in the alphabet than the corresponding letter in $$$b$$$.  NoteIn the first test case ""acac"" is greater than or equal to $$$s$$$, and each letter appears $$$2$$$ or $$$0$$$ times in it, so it is beautiful.In the second test case each letter appears $$$0$$$ or $$$1$$$ times in $$$s$$$, so $$$s$$$ itself is the answer.We can show that there is no suitable string in the third test case.In the fourth test case each letter appears $$$0$$$, $$$3$$$, or $$$6$$$ times in ""abaabaaab"". All these integers are divisible by $$$3$$$. import threading
import sys

threading.stack_size(16*2048*2048)
sys.setrecursionlimit(100010)


def getnext(index,fre,k,s,flag):
    if sum(fre)>len(s)-index:
        return ""ERROR""


#    print(index,fre,pre,flag)
    if index==len(s): return """"
    cur = ord(s[index])-97

    if not flag:
        nexts = """"
        spare = (len(s)-index-sum(fre))
        if spare%k==0:
            nexts += 'a'*(spare//k*k)
        for j in range(26):
            if fre[j]>0:  nexts += chr(j+97)*fre[j]
        return nexts

        
                    



    nexts = ""ERROR""
    for j in range(cur,26):
        if j>cur and flag: flag = False
        fre[j] -= 1
        if fre[j]<0: fre[j]+=k
        temp = getnext(index+1,fre,k,s,flag)
        if temp!=""ERROR"": 
            nexts = chr(j+97)+temp
            return nexts
        fre[j] += 1
        if fre[j]==k:  fre[j] = 0


   #print(index,fre,nexts)
            
           
    return nexts




def main():

    T = int(input())
    t = 1

    while t<=T:
        n,k = list(map(int,input().split()))
        s = input()

        

        if n%k>0:
            print(-1)
            t += 1
            continue

        fre = [0]*26
        ans = getnext(0,fre,k,s,True)

        print(ans)
        t += 1



threading.Thread(target=main).start()








       







","['binary search', 'brute force', 'constructive algorithms', 'greedy', 'strings']"
3138,"Let's call an undirected graph of n vertices p-interesting, if the following conditions fulfill:   the graph contains exactly 2n + p edges;  the graph doesn't contain self-loops and multiple edges;  for any integer k (1 ≤ k ≤ n), any subgraph consisting of k vertices contains at most 2k + p edges. A subgraph of a graph is some set of the graph vertices and some set of the graph edges. At that, the set of edges must meet the condition: both ends of each edge from the set must belong to the chosen set of vertices. Your task is to find a p-interesting graph consisting of n vertices. nan #b=b[2:].zfill(32)
#for deque append(),pop(),appendleft(),popleft(),count()
import math,sys
from collections import Counter, defaultdict, deque
from sys import stdin, stdout
input = stdin.readline
lili=lambda:list(map(int,sys.stdin.readlines()))
li = lambda:list(map(int,input().split()))
I=lambda:int(input())
S=lambda:input().strip()
mod = 1000000007

for _ in range(I()):
    n,p=li()
    k=1
    c=k+1
    p=2*n+p
    while(p):
        print(k,c)
        p-=1
        if(c==n):
            k+=1
            c=k
        c+=1


","['brute force', 'constructive algorithms', 'graphs']"
3047,"A tourist hiked along the mountain range. The hike lasted for n days, during each day the tourist noted height above the sea level. On the i-th day height was equal to some integer hi. The tourist pick smooth enough route for his hike, meaning that the between any two consecutive days height changes by at most 1, i.e. for all i's from 1 to n - 1 the inequality |hi - hi + 1| ≤ 1 holds.At the end of the route the tourist rafted down a mountain river and some notes in the journal were washed away. Moreover, the numbers in the notes could have been distorted. Now the tourist wonders what could be the maximum height during his hike. Help him restore the maximum possible value of the maximum height throughout the hike or determine that the notes were so much distorted that they do not represent any possible height values that meet limits |hi - hi + 1| ≤ 1. NoteFor the first sample, an example of a correct height sequence with a maximum of 2: (0, 0, 1, 2, 1, 1, 0, 1).In the second sample the inequality between h7 and h8 does not hold, thus the information is inconsistent. def maxheight(start, end):
    start_day, start_height = start
    end_day, end_height = end
    
    ddays = end_day - start_day
    dheight = end_height - start_height
    
    xdays = ddays - abs(dheight)
    
    if xdays < 0:
        return -1
    else:
        return xdays // 2 + max(start_height, end_height)

import sys
data = sys.stdin

days = int(data.readline().split()[0])

entries = []
for l in data.read().splitlines():
    entries.append(tuple(map(int, l.split(' '))))
entries.sort()

maxheights = []

for e in entries:
    maxheights.append(e[1])

for i in range(len(entries) - 1):
    h = maxheight(entries[i], entries[i+1])
    if h < 0:
        print(""IMPOSSIBLE"")
        break
    else:
        maxheights.append(h)
else:
    first = entries[0]
    maxheights.append(first[0] - 1 + first[1])

    last = entries[-1]
    maxheights.append(days - last[0] + last[1])

    print(str(max(maxheights)))","['binary search', 'brute force', 'greedy', 'implementation', 'math']"
2663,"You went to the store, selling $$$n$$$ types of chocolates. There are $$$a_i$$$ chocolates of type $$$i$$$ in stock.You have unlimited amount of cash (so you are not restricted by any prices) and want to buy as many chocolates as possible. However if you buy $$$x_i$$$ chocolates of type $$$i$$$ (clearly, $$$0 \le x_i \le a_i$$$), then for all $$$1 \le j &lt; i$$$ at least one of the following must hold:  $$$x_j = 0$$$ (you bought zero chocolates of type $$$j$$$) $$$x_j &lt; x_i$$$ (you bought less chocolates of type $$$j$$$ than of type $$$i$$$) For example, the array $$$x = [0, 0, 1, 2, 10]$$$ satisfies the requirement above (assuming that all $$$a_i \ge x_i$$$), while arrays $$$x = [0, 1, 0]$$$, $$$x = [5, 5]$$$ and $$$x = [3, 2]$$$ don't.Calculate the maximum number of chocolates you can buy. NoteIn the first example, it is optimal to buy: $$$0 + 0 + 1 + 3 + 6$$$ chocolates.In the second example, it is optimal to buy: $$$1 + 2 + 3 + 4 + 10$$$ chocolates.In the third example, it is optimal to buy: $$$0 + 0 + 0 + 1$$$ chocolates. import sys
n = int(sys.stdin.readline())
arr = [int(i) for i in sys.stdin.readline().split()]
res = arr[-1]
remember = arr[-1]
arr.pop(-1)
if remember==1:
    print(1)
else:
    for i in arr[::-1]:
        if remember==1:
            break
        if i==1:
            res+=1
            break
        if i>=remember:
            res += (remember-1)
            remember -= 1
        else:
            res += i
            remember = i
    print(res)
","['greedy', 'implementation']"
3964,"Mr. Chanek gives you a sequence $$$a$$$ indexed from $$$1$$$ to $$$n$$$. Define $$$f(a)$$$ as the number of indices where $$$a_i = i$$$. You can pick an element from the current sequence and remove it, then concatenate the remaining elements together. For example, if you remove the $$$3$$$-rd element from the sequence $$$[4, 2, 3, 1]$$$, the resulting sequence will be $$$[4, 2, 1]$$$. You want to remove some elements from $$$a$$$ in order to maximize $$$f(a)$$$, using zero or more operations. Find the largest possible $$$f(a)$$$. NoteIn the first example, $$$f(A) = 3$$$ by doing the following operations.$$$[2,1,\textbf{4},2,5,3,7] \rightarrow [\textbf{2},1,2,5,3,7] \rightarrow [1,2,5,3,\textbf{7}] \rightarrow [1,2,\textbf{5},3] \rightarrow [1,2,3]$$$In the second example, $$$f(A) = 2$$$ and no additional operation is needed. import sys
sys.setrecursionlimit(100000)

def _r(): return sys.stdin.buffer.readline()
def rs(): return _r().decode('ascii').strip()
def rn(): return int(_r())
def rnt(): return map(int, _r().split())
def rnl(): return list(rnt())

# [(2, -1), (1, 1), (4, -1), (2, 2), (5, 0), (3, 3), (7, 0)]
# [(1, 1), (2, 2), (2, -1), (3, 3), (4, -1), (5, 0), (7, 0)]
# [1, 2, -1, 3, -1, 0, 0]

# [(4, -3), (2, 0), (3, 0), (1, 3)]
# [(1, 3), (2, 0), (3, 0), (4, -3)]
# [3, 0, 0, -3]

import bisect

def lis(a):
    dp = []
    for num in a:
        i = bisect.bisect_right(dp, num)
        if i == len(dp):
            dp.append(num)
        dp[i] = num
    return len(dp)

def solve(n, a):
    b = [(x, i+1-x) for i, x in enumerate(a) if i+1-x >= 0]
    b.sort(key=lambda x:(x[0], -x[1]))
    b = list(map(lambda x:x[1], b))
    return lis(b)

n = rn()
a = rnl()
print(solve(n, a))

# for _ in range(rn()):
#     n, x = rnt()
#     a = rnl()
#     print('YES' if solve(n, x, a) else 'NO')

# def solve(n, m, mat):
#     def _try(r, c, dr, dc):
#         sol = 0
#         for i in range(c+1, c+dc):
#             sol += 1 - int(mat[r][i])
#             sol += 1 - int(mat[r+dr][i])
#         for i in range(r+1, r+dr):
#             sol += 1 - int(mat[i][c])
#             sol += 1 - int(mat[i][c+dc])
#         for i in range(r+1, r+dr):
#             for j in range(c+1, c+dc):
#                 sol += int(mat[i][j])
#         return sol
#     sol = float('inf')
#     sols = [[0]*m for _ in range(n)]
#     for r in range(n-4):
#         for c in range(m-3):
#             dr = 4
#             while r+dr < n:
#                 dc = 3
#                 while c+dc < m:
#                     sols[r+dr][c+dc] = _try(r, c, dr, dc)
#                     sol = min(sol, _try(r, c, dr, dc))
#                     dc += 1
#                 dr += 1
#     for row in sols:
#         print(row)
#     return sol

# for _ in range(rn()):
#     n, m = rnt()
#     mat = []
#     for _ in range(n):
#         mat.append(rs())
#     print(solve(n, m, mat))","['data structures', 'divide and conquer', 'dp', 'sortings']"
3593,"Everybody knows what an arithmetic progression is. Let us remind you just in case that an arithmetic progression is such sequence of numbers a1, a2, ..., an of length n, that the following condition fulfills: a2 - a1 = a3 - a2 = a4 - a3 = ... = ai + 1 - ai = ... = an - an - 1.For example, sequences [1, 5], [10], [5, 4, 3] are arithmetic progressions and sequences [1, 3, 2], [1, 2, 4] are not.Alexander has n cards containing integers. Arthur wants to give Alexander exactly one more card with a number so that he could use the resulting n + 1 cards to make an arithmetic progression (Alexander has to use all of his cards).Arthur has already bought a card but he hasn't written a number on it. Help him, print all integers that you can write on a card so that the described condition fulfilled. nan import sys
 
n = int(input())
a = sorted(list(map(int,input().split())))
if n == 1:
    print(-1)
else:
    d = a[1] - a[0]
    x = 0
    v = 0
    t = -1
    v1 = 0
    t1 = -1
    for i in range(1, n):
        if (a[i] - a[i-1] == d):
            x += 1
        elif (a[i] - a[i-1] == 2 * d):
            v += 1
            t = i-1
        elif (2 * (a[i] - a[i-1]) == d):
            v1 += 1
            t1 = i-1
        else:
            print(0)
            sys.exit()
        if v >= 2:
            print(0)
            sys.exit()
    if v == 1:
        print(1)
        print(a[t] + d)
        sys.exit()
    if (v1 > 0) and (v1 + 1 < n - 1):
        print(0)
        sys.exit()
    if (v1 > 0) and (v1 + 1 == n - 1):
        print(1)
        print(a[0] + d // 2)
        sys.exit()
    if d == 0:
        print(1)
        print(a[0])
        sys.exit()
    ans = [a[0] - d]
    if n == 2:
        if d % 2 == 0:
            ans.append(a[0] + (d // 2))
    ans.append(a[n - 1] + d)
    print(len(ans))
    for i in ans:
        print(i, end = ' ')","['implementation', 'sortings']"
1485,"You are given an array $$$a$$$ of size $$$n$$$. Each element in this array is an integer between $$$1$$$ and $$$10^9$$$.You can perform several operations to this array. During an operation, you can replace an element in the array with any integer between $$$1$$$ and $$$10^9$$$. Output the minimum number of operations needed such that the resulting array doesn't contain any local maximums, and the resulting array after the operations.An element $$$a_i$$$ is a local maximum if it is strictly larger than both of its neighbors (that is, $$$a_i &gt; a_{i - 1}$$$ and $$$a_i &gt; a_{i + 1}$$$). Since $$$a_1$$$ and $$$a_n$$$ have only one neighbor each, they will never be a local maximum. NoteIn the first example, the array contains no local maximum, so we don't need to perform operations.In the second example, we can change $$$a_2$$$ to $$$3$$$, then the array don't have local maximums. for i in range(int(input())):
    n=int(input())
    l=list(map(int,input().split()))
    check=[0]*n
    for j in range(1,n-1):
        if l[j]>l[j-1] and l[j]>l[j+1]:
            if check[j-1]:
                l[j-1]=l[j]
            else:
                l[j+1]=l[j]
                check[j+1]=1
    print(check.count(1))
    for i in l:
        print(i,end=' ')
    print()
    ",['greedy']
4922,"Recently, Mike was very busy with studying for exams and contests. Now he is going to chill a bit by doing some sight seeing in the city.City consists of n intersections numbered from 1 to n. Mike starts walking from his house located at the intersection number 1 and goes along some sequence of intersections. Walking from intersection number i to intersection j requires |i - j| units of energy. The total energy spent by Mike to visit a sequence of intersections p1 = 1, p2, ..., pk is equal to  units of energy.Of course, walking would be boring if there were no shortcuts. A shortcut is a special path that allows Mike walking from one intersection to another requiring only 1 unit of energy. There are exactly n shortcuts in Mike's city, the ith of them allows walking from intersection i to intersection ai (i ≤ ai ≤ ai + 1) (but not in the opposite direction), thus there is exactly one shortcut starting at each intersection. Formally, if Mike chooses a sequence p1 = 1, p2, ..., pk then for each 1 ≤ i &lt; k satisfying pi + 1 = api and api ≠ pi Mike will spend only 1 unit of energy instead of |pi - pi + 1| walking from the intersection pi to intersection pi + 1. For example, if Mike chooses a sequence p1 = 1, p2 = ap1, p3 = ap2, ..., pk = apk - 1, he spends exactly k - 1 units of total energy walking around them.Before going on his adventure, Mike asks you to find the minimum amount of energy required to reach each of the intersections from his home. Formally, for each 1 ≤ i ≤ n Mike is interested in finding minimum possible total energy of some sequence p1 = 1, p2, ..., pk = i. NoteIn the first sample case desired sequences are:1: 1; m1 = 0;2: 1, 2; m2 = 1;3: 1, 3; m3 = |3 - 1| = 2.In the second sample case the sequence for any intersection 1 &lt; i is always 1, i and mi = |1 - i|.In the third sample case — consider the following intersection sequences:1: 1; m1 = 0;2: 1, 2; m2 = |2 - 1| = 1;3: 1, 4, 3; m3 = 1 + |4 - 3| = 2;4: 1, 4; m4 = 1;5: 1, 4, 5; m5 = 1 + |4 - 5| = 2;6: 1, 4, 6; m6 = 1 + |4 - 6| = 3;7: 1, 4, 5, 7; m7 = 1 + |4 - 5| + 1 = 3. from Queue import Queue

n = int(raw_input())
list = map(int, raw_input().split())

adj = []
dist = []

for i in xrange(n): 
	adj.append([])
	dist.append(10**9)
	
for i in xrange(n-1):
	adj[i].append(i+1)
	adj[i+1].append(i)
	
for i in xrange(n):
	element = list[i]
	if (element-1 != i and element != 0 and element-2 != i) :
		adj[i].append(list[i]-1)

def bfs(ind) :
	q = Queue()
	q.put(ind)
	dist[ind] = 0
	while not q.empty():
		v = q.get()	
		for vizinho in adj[v] :
			if (dist[vizinho] > dist[v] +1) :
				dist[vizinho] = dist[v] +1
				#print v
				#print str(vizinho) + "" "" + str(dist[v] +1)
				q.put(vizinho)
bfs(0)
result = """"
for x in xrange(n):
	if (x == n-1) :
		result += str(dist[x])
	else :
		result += str(dist[x]) + "" ""
print result
","['dfs and similar', 'graphs', 'greedy', 'shortest paths']"
2505,"You are given $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$. Is it possible to arrange them on a circle so that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors?In other words, check if there exists a rearrangement $$$b_1, b_2, \ldots, b_n$$$ of the integers $$$a_1, a_2, \ldots, a_n$$$ such that for each $$$i$$$ from $$$1$$$ to $$$n$$$ at least one of the following conditions holds: $$$b_{i-1} &lt; b_i &gt; b_{i+1}$$$ $$$b_{i-1} &gt; b_i &lt; b_{i+1}$$$To make sense of the previous formulas for $$$i=1$$$ and $$$i=n$$$, one shall define $$$b_0=b_n$$$ and $$$b_{n+1}=b_1$$$. NoteIt can be shown that there are no valid arrangements for the first and the third test cases.In the second test case, the arrangement $$$[1, 8, 4, 9]$$$ works. In this arrangement, $$$1$$$ and $$$4$$$ are both smaller than their neighbors, and $$$8, 9$$$ are larger.In the fourth test case, the arrangement $$$[1, 11, 1, 111, 1, 1111]$$$ works. In this arrangement, the three elements equal to $$$1$$$ are smaller than their neighbors, while all other elements are larger than their neighbors. #import io, os
#input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

t = int(input())

for _ in range(t):

  n = int(input())

  arr = list(map(int,input().split()))

  arr.sort()

  lp = 0
  rp = n - 1

  new = []
  new1 = []
  new2= []
  
  parity = 0
  while lp <= rp:

    if parity % 2 == 0:

      parity = 1
      new1.append(arr[rp])
      rp -= 1

    else:

      parity = 0
      new2.append(arr[lp])
      lp +=1

  new1.reverse()
  for i in range(n):
    if i % 2 == 0:
      new.append(new1[-1])
      new1.pop()
    else:
      new.append(new2[-1])
      new2.pop()


  flag = False

  tempnew = new.copy()
  new.insert(0,new[-1])
  new.append(new[1])
  for i in range(1,len(new)-1):

    if new[i] > new[i-1] and new[i] > new[i+1]:
      pass
    elif new[i] < new[i-1] and new[i] < new[i+1]:
      pass
    else:
      flag=True
  
  if not flag:
    print(""YES"")
    print(*tempnew)

  else:
    print(""NO"")","['constructive algorithms', 'greedy', 'sortings']"
2986,"Petya loves lucky numbers very much. Everybody knows that lucky numbers are positive integers whose decimal record contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.Petya has sequence a consisting of n integers.The subsequence of the sequence a is such subsequence that can be obtained from a by removing zero or more of its elements.Two sequences are considered different if index sets of numbers included in them are different. That is, the values ​of the elements ​do not matter in the comparison of subsequences. In particular, any sequence of length n has exactly 2n different subsequences (including an empty subsequence).A subsequence is considered lucky if it has a length exactly k and does not contain two identical lucky numbers (unlucky numbers can be repeated any number of times).Help Petya find the number of different lucky subsequences of the sequence a. As Petya's parents don't let him play with large numbers, you should print the result modulo prime number 1000000007 (109 + 7). NoteIn the first sample all 3 subsequences of the needed length are considered lucky.In the second sample there are 4 lucky subsequences. For them the sets of indexes equal (the indexation starts from 1): {1, 3}, {1, 4}, {2, 3} and {2, 4}. #!/usr/bin/env python

MOD = 1000000007

def gcd(a, b):
    if a == 0:
        return b, 0, 1
    d, x, y = gcd(b % a, a)
    return d, y - b / a * x, x

def div(a):
    d, x, y = gcd(a, MOD)
    return x

def c(n, k):
    if k > n or k < 0:
        return 0
    res = 1
    for i in xrange(max(k + 1, n - k + 1), n + 1):
        res = res * i % MOD
        res = res * div(n - i + 1) % MOD
    return res

def is_lucky(num):
    return num.replace('4', '').replace('7', '') == """"

if __name__ == ""__main__"":
    n, k = map(int, raw_input().strip().split())
    luckies = filter(is_lucky, raw_input().strip().split())
    others = n - len(luckies)
    lucky_dict = {}
    for lucky in luckies:
        if lucky not in lucky_dict:
            lucky_dict[lucky] = 0
        lucky_dict[lucky] += 1
    
    dp_count = []
    for lucky, count in lucky_dict.iteritems():
        dp_count.append(0)
        for i in range(len(dp_count)-1, -1, -1):
            if i !=0:
                dp_count[i] += dp_count[i - 1] * count
            else:
                dp_count[i] += count
            dp_count[i] %= MOD

    res = 0
    max_count = len(dp_count) if len(dp_count) < k else k
    cur_binom = c(others, k - max_count)
    for i in range(max_count-1, -1, -1):
        res += cur_binom * dp_count[i]
        res %= MOD
        if k - i > others:
            cur_binom = 0
            break
        cur_binom = cur_binom * div(k - i) * (others - k + i + 1) % MOD
    res += cur_binom
    res %= MOD
    print res
","['combinatorics', 'dp', 'math']"
4393,"User ainta has a permutation p1, p2, ..., pn. As the New Year is coming, he wants to make his permutation as pretty as possible.Permutation a1, a2, ..., an is prettier than permutation b1, b2, ..., bn, if and only if there exists an integer k (1 ≤ k ≤ n) where a1 = b1, a2 = b2, ..., ak - 1 = bk - 1 and ak &lt; bk all holds.As known, permutation p is so sensitive that it could be only modified by swapping two distinct elements. But swapping two elements is harder than you think. Given an n × n binary matrix A, user ainta can swap the values of pi and pj (1 ≤ i, j ≤ n, i ≠ j) if and only if Ai, j = 1.Given the permutation p and the matrix A, user ainta wants to know the prettiest permutation that he can obtain. NoteIn the first sample, the swap needed to obtain the prettiest permutation is: (p1, p7).In the second sample, the swaps needed to obtain the prettiest permutation is (p1, p3), (p4, p5), (p3, p4).   A permutation p is a sequence of integers p1, p2, ..., pn, consisting of n distinct positive integers, each of them doesn't exceed n. The i-th element of the permutation p is denoted as pi. The size of the permutation p is denoted as n. n = input()
A = map(int, raw_input().split())
M = [raw_input() for ii in range(n)]

seen = [False for ii in range(n)]

vi = []
def dfs(id):
	seen[id] = True
	vi.append(id)
	for ii in range(n):
		if M[id][ii] == '1' and seen[ii] == False:
			dfs(ii)

for ii in range(0,n):
	if seen[ii] == False:
		vi = []
		dfs(ii)
		k = [A[x] for x in vi]
		k.sort()
		vi.sort()
		# print vi, k
		for jj in range(len(vi)):
			A[vi[jj]] = k[jj]

for ii in A:
	print ii,","['dfs and similar', 'dsu', 'graphs', 'greedy', 'math', 'sortings']"
3532,"A subarray of array $$$a$$$ from index $$$l$$$ to the index $$$r$$$ is the array $$$[a_l, a_{l+1}, \dots, a_{r}]$$$. The number of occurrences of the array $$$b$$$ in the array $$$a$$$ is the number of subarrays of $$$a$$$ such that they are equal to $$$b$$$.You are given $$$n$$$ arrays $$$A_1, A_2, \dots, A_n$$$; the elements of these arrays are integers from $$$1$$$ to $$$k$$$. You have to build an array $$$a$$$ consisting of $$$m$$$ integers from $$$1$$$ to $$$k$$$ in such a way that, for every given subarray $$$A_i$$$, the number of occurrences of $$$A_i$$$ in the array $$$a$$$ is not less than the number of occurrences of each non-empty subarray of $$$A_i$$$ in $$$a$$$. Note that if $$$A_i$$$ doesn't occur in $$$a$$$, and no subarray of $$$A_i$$$ occurs in $$$a$$$, this condition is still met for $$$A_i$$$.Your task is to calculate the number of different arrays $$$a$$$ you can build, and print it modulo $$$998244353$$$. nan import sys
input = sys.stdin.readline

n,m,k = map(int, input().split())
nex = [-1] * k
prev = [-1] * k
bad = [0] * k

for _ in range(n):
    l = list(map(int, input().split()))
    nn = l.pop(0)
    tg = True
    for i in range(nn - 1):
        u, v = l[i] - 1, l[i+1] - 1
        tg = tg and (prev[v] == -1 or prev[v] == u)
        prev[v] = u
        tg = tg and (nex[u] == -1 or nex[u] == v)
        nex[u] = v
    if not tg:
        for v in l:
            bad[v - 1] = 1

MOD = 998244353
b = 500
ct = [0] * b
ot = []
dp = [1]

for i in range(k):
    ib = False
    curr = i
    val = 0
    if prev[i] == -1:
        while curr != -1:
            ib = ib or bad[curr]
            if ib:
                break
            curr = nex[curr]
            val += 1
        if not ib:
            if val < b:
                ct[val] += 1
            else:
                    ot.append(val)
            
for i in range(1, m + 1):
    curr = 0
    for j in range(1, b):
        if j <= i:
            curr += (ct[j] * dp[i - j])
            curr %= MOD
    for j in ot:
        if j <= i:
            curr += dp[i - j]
    curr %= MOD
    dp.append(curr)
    
print(dp[m])","['combinatorics', 'dfs and similar', 'dp', 'dsu', 'graphs', 'other']"
4277,"DZY loves planting, and he enjoys solving tree problems.DZY has a weighted tree (connected undirected graph without cycles) containing n nodes (they are numbered from 1 to n). He defines the function g(x, y) (1 ≤ x, y ≤ n) as the longest edge in the shortest path between nodes x and y. Specially g(z, z) = 0 for every z.For every integer sequence p1, p2, ..., pn (1 ≤ pi ≤ n), DZY defines f(p) as . DZY wants to find such a sequence p that f(p) has maximum possible value. But there is one more restriction: the element j can appear in p at most xj times.Please, find the maximum possible f(p) under the described restrictions. NoteIn the first sample, one of the optimal p is [4, 3, 2, 1]. n = int(input())
edges = [[int(x) for x in input().split()] for i in range(n-1)]
edges = sorted(edges)
use_count = [0]+[int(input()) for i in range(n)]
lo,hi = 0,10000
def getpar(par,u):
    if par[par[u]] == par[u]:
        return par[u]
    par[u] = getpar(par,par[u])
    return par[u]
def unite(par,sz,use,u,v):
    u = getpar(par,u)
    v = getpar(par,v)
    par[u] = v
    sz[v] += sz[u]
    use[v] += use[u]
def solve(fp):
    par = [i for i in range(n+1)]
    sz = [1 for i in range(n+1)]
    use = [use_count[i] for i in range(n+1)]
    for edge in edges:
        if edge[2] < fp:
            unite(par,sz,use,edge[0],edge[1])
    total_use = sum(use_count)
    for i in range(n+1):
        p = getpar(par,i)
        if(p == i):
            if(total_use - use[p] < sz[p]):
                return False
    return True
while lo < hi:
    mid = (lo+hi+1)//2
    if solve(mid):
        lo = mid
    else:
        hi = mid-1
print(lo)
","['binary search', 'dsu', 'trees']"
4353,"It is the hard version of the problem. The only difference is that in this version $$$a_i \le 10^9$$$.You are given an array of $$$n$$$ integers $$$a_0, a_1, a_2, \ldots a_{n - 1}$$$. Bryap wants to find the longest beautiful subsequence in the array.An array $$$b = [b_0, b_1, \ldots, b_{m-1}]$$$, where $$$0 \le b_0 &lt; b_1 &lt; \ldots &lt; b_{m - 1} &lt; n$$$, is a subsequence of length $$$m$$$ of the array $$$a$$$.Subsequence $$$b = [b_0, b_1, \ldots, b_{m-1}]$$$ of length $$$m$$$ is called beautiful, if the following condition holds:   For any $$$p$$$ ($$$0 \le p &lt; m - 1$$$) holds: $$$a_{b_p} \oplus b_{p+1} &lt; a_{b_{p+1}} \oplus b_p$$$. Here $$$a \oplus b$$$ denotes the bitwise XOR of $$$a$$$ and $$$b$$$. For example, $$$2 \oplus 4 = 6$$$ and $$$3 \oplus 1=2$$$.Bryap is a simple person so he only wants to know the length of the longest such subsequence. Help Bryap and find the answer to his question. NoteIn the first test case, we can pick the whole array as a beautiful subsequence because $$$1 \oplus 1 &lt; 2 \oplus 0$$$.In the second test case, we can pick elements with indexes $$$1$$$, $$$2$$$ and $$$4$$$ (in $$$0$$$ indexation). For this elements holds: $$$2 \oplus 2 &lt; 4 \oplus 1$$$ and $$$4 \oplus 4 &lt; 1 \oplus 2$$$. 
twopow = []
for i in range(30):
    twopow.append(2 ** i)
twopow.reverse()

maxN = int(60e6)
trie = [0] * maxN  # in segments of 6. [l, r, 00, 01, 10, 11]
for i in range(0, maxN, 6):
    trie[i] = trie[i + 1] = -1  # -1 if not linked to any node

idx_of_trie = 6
def get_next_idx_of_trie():
    global idx_of_trie
    idx_of_trie += 6
    return idx_of_trie - 6

def clear_trie():
    global idx_of_trie
    temp = idx_of_trie
    
    while idx_of_trie >= 1:
        idx_of_trie -= 1
        trie[idx_of_trie] = 0
    
    for i in range(0, temp, 6):
        trie[i] = trie[i + 1] = -1
    
    idx_of_trie = 6
        

bitmap = [(1, 0), (0, 0), (1, 1), (0, 1)]
# bitmap[ibit * 2 + aibit] = (jbit, ajbit) where j < i and (aibit ^ jbit) > (ajbit ^ ibit)

def main():
    
    def add(i, ai):
        value = i ^ ai
        node = 0
        currmax = 1
        for tp in twopow:
            
            if (i & tp) > 0: ibit = 1
            else: ibit = 0
            if (ai & tp) > 0: aibit = 1
            else: aibit = 0
            
            if (value & tp) > 0:
                if trie[node + 1] == -1:
                    trie[node + 1] = get_next_idx_of_trie()
                neighbour = trie[node]
                node = trie[node + 1]
            else:
                if trie[node] == -1:
                    trie[node] = get_next_idx_of_trie()
                neighbour = trie[node + 1]
                node = trie[node]
            
            if neighbour != -1:
                # ai ^ j == aj ^ i right up to before this node.
                # Need to find max dp for ai ^ j > aj ^ i,
                # where i is current index and j is a previous index.
                # for jbit in range(2):
                #     for ajbit in range(2):
                #         if (aibit ^ jbit) > (ajbit ^ ibit):
                #             currmax = max(currmax, 1 + neighbour.dp[jbit][ajbit])
                    
                # Casework. (aibit ^ jbit) > (ajbit ^ ibit)
                jbit, ajbit = bitmap[ibit * 2 + aibit]
                currmax = max(currmax, 1 + trie[neighbour + 2 + jbit * 2 + ajbit])
        
        # update trie
        node = 0
        for tp in twopow:
            
            if (i & tp) > 0: ibit = 1
            else: ibit = 0
            if (ai & tp) > 0: aibit = 1
            else: aibit = 0
            
            if (value & tp) > 0:
                node = trie[node + 1]
            else:
                node = trie[node]
            
            # node.dp[ibit][aibit] = max(node.dp[ibit][aibit], currmax)
            trie[node + 2 + ibit * 2 + aibit] = max(currmax,
                                                    trie[node + 2 + ibit * 2 + aibit])
        
        return currmax
    
    t = int(input())
    allans = []
    for _ in range(t):
        n = int(input())
        a = readIntArr()
        
        # testdp = [1] * n
        ans = 0
        for i, ai in enumerate(a):
            res = add(i, ai)
            # testdp[i] = res
            ans = max(ans, res)
        
        # print(testdp)  # TEST
        
        allans.append(ans)
        clear_trie()
    multiLineArrayPrint(allans)
    
    return

import sys
input=sys.stdin.buffer.readline #FOR READING PURE INTEGER INPUTS (space separation ok)
# input=lambda: sys.stdin.readline().rstrip(""\r\n"") #FOR READING STRING/TEXT INPUTS.
 
def oneLineArrayPrint(arr):
    print(' '.join([str(x) for x in arr]))
def multiLineArrayPrint(arr):
    print('\n'.join([str(x) for x in arr]))
def multiLineArrayOfArraysPrint(arr):
    print('\n'.join([' '.join([str(x) for x in y]) for y in arr]))
 
def readIntArr():
    return [int(x) for x in input().split()]
# def readFloatArr():
#     return [float(x) for x in input().split()]
 
def makeArr(defaultValFactory,dimensionArr): # eg. makeArr(lambda:0,[n,m])
    dv=defaultValFactory;da=dimensionArr
    if len(da)==1:return [dv() for _ in range(da[0])]
    else:return [makeArr(dv,da[1:]) for _ in range(da[0])]
 
def queryInteractive(a, b, c):
    print('? {} {} {}'.format(a, b, c))
    sys.stdout.flush()
    return int(input())
 
def answerInteractive(x1, x2):
    print('! {} {}'.format(x1, x2))
    sys.stdout.flush()
 
inf=float('inf')
# MOD=10**9+7
# MOD=998244353
 
from math import gcd,floor,ceil
import math
# from math import floor,ceil # for Python2
 
for _abc in range(1):
    main()","['bitmasks', 'data structures', 'dp', 'strings', 'trees']"
120,"A lot of students spend their winter holidays productively. Vlad has advanced very well in doing so! For three days already, fueled by salads and tangerines — the leftovers from New Year celebration — he has been calibrating his rating in his favorite MOBA game, playing as a hero named Perun.Perun has an ultimate ability called ""Thunderwrath"". At the instant of its activation, each enemy on the map (n of them in total) loses  health points as a single-time effect. It also has a restriction: it can only activated when the moment of time is an integer. The initial bounty for killing an enemy is . Additionally, it increases by  each second. Formally, if at some second t the ability is activated and the i-th enemy is killed as a result (i.e. his health drops to zero or lower), Vlad earns  units of gold.Every enemy can receive damage, as well as be healed. There are multiple ways of doing so, but Vlad is not interested in details. For each of n enemies he knows:    — maximum number of health points for the i-th enemy;   — initial health of the enemy (on the 0-th second);   — the amount of health the i-th enemy can regenerate per second. There also m health updates Vlad knows about:    — time when the health was updated;   — the enemy whose health was updated;   — updated health points for enemyj. Obviously, Vlad wants to maximize his profit. If it's necessary, he could even wait for years to activate his ability at the right second. Help him determine the exact second (note that it must be an integer) from 0 (inclusively) to  + ∞ so that a single activation of the ability would yield Vlad the maximum possible amount of gold, and print this amount. NoteOn the pictures you can see health points of each enemy versus time in sample cases.Periods when Vlad can kill one enemy are marked with yellow color.Periods when Vlad can kill two enemies are marked with purple color.  In the first sample case, Vlad can activate the ability at the 50-th second: the enemies 2 and 3 will die since they would have 40 and 50 health points correspondingly. Vlad will earn 2·(1000 + 50·10) = 3000 gold.  In the second sample case, the maximum amount of health for the enemy 1 is less than the damage dealt by the ability. Hence, the enemy could be killed anytime. As the bounty increases by 50 over the time, the maximum possible amount of gold is infinite. from sys import stdin
from collections import defaultdict
from itertools import repeat
def main():
    n, m = map(int, stdin.readline().split())
    b, inc, d = map(int, stdin.readline().split())
    dat = map(int, stdin.read().split(), repeat(10, 3 * (n + m)))
    j = n * 3
    ev = [[] for _ in xrange(n)]
    a = defaultdict(int)
    for _ in xrange(m):
        t, i, h = dat[j:j+3]
        ev[i-1].append((t, h))
        j += 3
    j = 0
    c = 0
    for i in xrange(n):
        mh = dat[j]
        reg = dat[j+2]
        ev[i].sort()
        h = dat[j+1]
        p = 0
        on = 0
        if h <= d:
            c += 1
            on = 1
        if reg:
            if mh <= d and inc:
                print -1
                return
            for t, nh in ev[i]:
                if on:
                    x = p + (d - h) / reg + 1
                    if x < t:
                        a[x] -= 1
                        on = 0
                non = nh <= d
                if on != non:
                    a[t] += (-1,1)[non]
                on = non
                p = t
                h = nh
            if on:
                x = p + (d - h) / reg + 1
                a[x] -= 1
        else:
            for t, nh in ev[i]:
                non = nh <= d
                if on != non:
                    a[t] += (-1,1)[non]
                on = non
                p = t
            if on and inc:
                print -1
                return
        j += 3
    ans = c * b
    for t in sorted(a.keys()):
        y = c * (b + (t - 1) * inc)
        if ans < y:
            ans = y
        c += a[t]
    print ans
main()
","['brute force', 'greedy', 'sortings']"
1786,"Once upon a time Petya and Gena gathered after another programming competition and decided to play some game. As they consider most modern games to be boring, they always try to invent their own games. They have only stickers and markers, but that won't stop them.The game they came up with has the following rules. Initially, there are n stickers on the wall arranged in a row. Each sticker has some number written on it. Now they alternate turn, Petya moves first.One move happens as follows. Lets say there are m ≥ 2 stickers on the wall. The player, who makes the current move, picks some integer k from 2 to m and takes k leftmost stickers (removes them from the wall). After that he makes the new sticker, puts it to the left end of the row, and writes on it the new integer, equal to the sum of all stickers he took on this move. Game ends when there is only one sticker left on the wall. The score of the player is equal to the sum of integers written on all stickers he took during all his moves. The goal of each player is to maximize the difference between his score and the score of his opponent.Given the integer n and the initial sequence of stickers on the wall, define the result of the game, i.e. the difference between the Petya's and Gena's score if both players play optimally.  NoteIn the first sample, the optimal move for Petya is to take all the stickers. As a result, his score will be equal to 14 and Gena's score will be equal to 0.In the second sample, the optimal sequence of moves is the following. On the first move Petya will take first three sticker and will put the new sticker with value  - 8. On the second move Gena will take the remaining two stickers. The Petya's score is 1 + ( - 7) + ( - 2) =  - 8, Gena's score is ( - 8) + 3 =  - 5, i.e. the score difference will be  - 3. n = int(input())
raw = input().split()
d = []
prev = 0
for i in range(n):
    di = int(raw[i])
    di += prev
    d.append(di)
    prev = di
i = n - 2
cur = d[n - 1]
while i > 0:
    cur = max(cur, d[i] - cur)
    i -= 1

print(cur)","['dp', 'games']"
1162,"One day in the IT lesson Anna and Maria learned about the lexicographic order.String x is lexicographically less than string y, if either x is a prefix of y (and x ≠ y), or there exists such i (1 ≤ i ≤ min(|x|, |y|)), that xi &lt; yi, and for any j (1 ≤ j &lt; i) xj = yj. Here |a| denotes the length of the string a. The lexicographic comparison of strings is implemented by operator &lt; in modern programming languages​​.The teacher gave Anna and Maria homework. She gave them a string of length n. They should write out all substrings of the given string, including the whole initial string, and the equal substrings (for example, one should write out the following substrings from the string ""aab"": ""a"", ""a"", ""aa"", ""ab"", ""aab"", ""b""). The resulting strings should be sorted in the lexicographical order. The cunning teacher doesn't want to check all these strings. That's why she said to find only the k-th string from the list. Help Anna and Maria do the homework. NoteIn the second sample before string ""bc"" follow strings ""a"", ""ab"", ""abc"", ""b"". # -*- coding: utf-8 -*-
""""""
Created on Sat May  7 16:53:11 2016

@author: Alex
""""""
from heapq import heappush,heappop,heapify
string = input()
l = len(string)
k = int(input())
A = l*(l+1)/2
if A<k:
    print(""No such line."")
else:
    heap = [(string[i],i+1) for i in range(l)]
    heapify(heap)
    cnt = 0
    while cnt<k:
        now,nextp = heappop(heap)
        cnt+=1
        if nextp<l:
            heappush(heap,(now+string[nextp],nextp+1))
    print(now)","['brute force', 'constructive algorithms', 'hashing', 'implementation', 'other', 'strings']"
4832,"Peter decided to wish happy birthday to his friend from Australia and send him a card. To make his present more mysterious, he decided to make a chain. Chain here is such a sequence of envelopes A = {a1,  a2,  ...,  an}, where the width and the height of the i-th envelope is strictly higher than the width and the height of the (i  -  1)-th envelope respectively. Chain size is the number of envelopes in the chain. Peter wants to make the chain of the maximum size from the envelopes he has, the chain should be such, that he'll be able to put a card into it. The card fits into the chain if its width and height is lower than the width and the height of the smallest envelope in the chain respectively. It's forbidden to turn the card and the envelopes. Peter has very many envelopes and very little time, this hard task is entrusted to you. nan from bisect import *
 
n, w, h = map(int, raw_input().split())
a = []
for i in range(n):
	x, y = map(int, raw_input().split())
	if w < x and h < y:
		a += [(x, y, i + 1)]
a.sort(cmp = lambda x, y : x[0] - y[0] if x[0] != y[0] else y[1] - x[1])
n = len(a)
r = []
d = [0] * n
for i, e in enumerate(a):
	j = bisect_left(r, e[1])
	d[i] = j
	if j < len(r):
		r[j] = e[1]
	else:
		r.append(e[1])
p = []
s = len(r)
print s
for i in range(n - 1, -1, -1):
	if d[i] == s - 1:
		p += [a[i][2]]
		s -= 1
print ' '.join(map(str, p[ : : -1]))
","['dp', 'sortings']"
3856,"There are $$$n$$$ children, who study at the school №41. It is well-known that they are good mathematicians. Once at a break, they arranged a challenge for themselves. All children arranged in a row and turned heads either to the left or to the right.Children can do the following: in one second several pairs of neighboring children who are looking at each other can simultaneously turn the head in the opposite direction. For instance, the one who was looking at the right neighbor turns left and vice versa for the second child. Moreover, every second at least one pair of neighboring children performs such action. They are going to finish when there is no pair of neighboring children who are looking at each other. You are given the number $$$n$$$, the initial arrangement of children and the number $$$k$$$. You have to find a way for the children to act if they want to finish the process in exactly $$$k$$$ seconds. More formally, for each of the $$$k$$$ moves, you need to output the numbers of the children who turn left during this move.For instance, for the configuration shown below and $$$k = 2$$$ children can do the following steps:    At the beginning, two pairs make move: $$$(1, 2)$$$ and $$$(3, 4)$$$. After that, we receive the following configuration:    At the second move pair $$$(2, 3)$$$ makes the move. The final configuration is reached. Good job.   It is guaranteed that if the solution exists, it takes not more than $$$n^2$$$ ""headturns"". NoteThe first sample contains a pair of children who look at each other. After one move, they can finish the process.In the second sample, children can't make any move. As a result, they can't end in $$$k&gt;0$$$ moves.The third configuration is described in the statement. from __future__ import division, print_function
def main():
    n, k = map(int, input().split())
    l1 = list(input())
    stages = []
    while 1:
        l2 = []
        temp = []
        i = 0
        while i < n - 1:
            if l1[i] == ""R"" and l1[i+1] == ""L"":
                temp.append(i + 1)
                l2.append(""L"")
                l2.append(""R"")
                i += 2
            else:
                l2.append(l1[i])
                i += 1
        while i < n:
            l2.append(l1[i])
            i += 1
        l1 = l2
        if len(temp) == 0:
            break
        stages.append(temp)
    total_moves = 0
    min_moves = len(stages)
    #print(*stages, sep = ""\n"")
    for x in stages:
        total_moves += len(x)
    if total_moves < k or k < min_moves:
        print(-1)
    else:
        x = len(stages)
        if x == k:
            for i in range(x):
                print(len(stages[i]), end = "" "")
                print(*stages[i])
        else:
            flag = 0
            for i in range(len(stages)):
                for j in range(len(stages[i])):
                    print(1, stages[i][j])
                    k -= 1
                    rows_left = len(stages) - i
                    if j == len(stages[i]) - 1:
                        rows_left -= 1
                    if k  == rows_left:
                        
                        flag = 1
                        row_number = i
                        column_number = j + 1
                        break
                if flag == 1:
                    break
            if flag == 1:
                if column_number != len(stages[row_number]):
                    print(len(stages[row_number][column_number:]), end = "" "")
                    print(*stages[row_number][column_number:])
                row_number += 1
                for i in range(row_number, len(stages)):
                    print(len(stages[i]), end ="" "")
                    print(*stages[i])

            
######## Python 2 and 3 footer by Pajenegod and c1729

# Note because cf runs old PyPy3 version which doesn't have the sped up
# unicode strings, PyPy3 strings will many times be slower than pypy2.
# There is a way to get around this by using binary strings in PyPy3
# but its syntax is different which makes it kind of a mess to use.

# So on cf, use PyPy2 for best string performance.

py2 = round(0.5)
if py2:
    from future_builtins import ascii, filter, hex, map, oct, zip
    range = xrange

import os, sys
from io import IOBase, BytesIO

BUFSIZE = 8192
class FastIO(BytesIO):
    newlines = 0

    def __init__(self, file):
        self._file = file
        self._fd = file.fileno()
        self.writable = ""x"" in file.mode or ""w"" in file.mode
        self.write = super(FastIO, self).write if self.writable else None

    def _fill(self):
        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
        self.seek((self.tell(), self.seek(0,2), super(FastIO, self).write(s))[0])
        return s

    def read(self):
        while self._fill(): pass
        return super(FastIO,self).read()

    def readline(self):
        while self.newlines == 0:
            s = self._fill(); self.newlines = s.count(b""\n"") + (not s)
        self.newlines -= 1
        return super(FastIO, self).readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.getvalue())
            self.truncate(0), self.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        if py2:
            self.write = self.buffer.write
            self.read = self.buffer.read
            self.readline = self.buffer.readline
        else:
            self.write = lambda s:self.buffer.write(s.encode('ascii'))
            self.read = lambda:self.buffer.read().decode('ascii')
            self.readline = lambda:self.buffer.readline().decode('ascii')


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip('\r\n')

# Cout implemented in Python
import sys
class ostream:
    def __lshift__(self,a):
        sys.stdout.write(str(a))
        return self
cout = ostream()
endl = '\n'

# Read all remaining integers in stdin, type is given by optional argument, this is fast
def readnumbers(zero = 0):
    conv = ord if py2 else lambda x:x
    A = []; numb = zero; sign = 1; i = 0; s = sys.stdin.buffer.read()
    try:
        while True:
            if s[i] >= b'0' [0]:
                numb = 10 * numb + conv(s[i]) - 48
            elif s[i] == b'-' [0]: sign = -1
            elif s[i] != b'\r' [0]:
                A.append(sign*numb)
                numb = zero; sign = 1
            i += 1
    except:pass
    if s and s[-1] >= b'0' [0]:
        A.append(sign*numb)
    return A

if __name__== ""__main__"":
  main()","['brute force', 'constructive algorithms', 'games', 'graphs', 'greedy', 'implementation', 'sortings']"
1872,"You are given an undirected unweighted graph consisting of $$$n$$$ vertices and $$$m$$$ edges.You have to write a number on each vertex of the graph. Each number should be $$$1$$$, $$$2$$$ or $$$3$$$. The graph becomes beautiful if for each edge the sum of numbers on vertices connected by this edge is odd.Calculate the number of possible ways to write numbers $$$1$$$, $$$2$$$ and $$$3$$$ on vertices so the graph becomes beautiful. Since this number may be large, print it modulo $$$998244353$$$.Note that you have to write exactly one number on each vertex.The graph does not have any self-loops or multiple edges. NotePossible ways to distribute numbers in the first test:   the vertex $$$1$$$ should contain $$$1$$$, and $$$2$$$ should contain $$$2$$$;  the vertex $$$1$$$ should contain $$$3$$$, and $$$2$$$ should contain $$$2$$$;  the vertex $$$1$$$ should contain $$$2$$$, and $$$2$$$ should contain $$$1$$$;  the vertex $$$1$$$ should contain $$$2$$$, and $$$2$$$ should contain $$$3$$$. In the second test there is no way to distribute numbers. from collections import deque
from sys import stdin, stdout
input = stdin.readline
print = stdout.write
 
anss = []
t = int(input())
 
for test_count in range(t):
	ans = 1
	part = 0
	factor = 0
	queue = deque([])
	n, m = map(int, input().split())
	if m > (n // 2) * ( n // 2 + 1):
		anss.append(0)
		for edge_count in range(m):
			input()
		continue
	edge = [[] for i in range(n + 1)]
	flag = [-1] * (n + 1)
	assure = 1
 
	for edge_count in range(m):
		u, v = map(int, input().split())
		edge[u].append(v)
		edge[v].append(u)
	flag[1] = 0
	queue.append(1)
 
	break_all = False
	while not break_all:
		even, odd = 1, 0
		while queue and not break_all:
			search = queue.popleft()
			# print('searching vertex {0}, {1}'.format(search, edge[search]))
			current = flag[search]
			for to in edge[search]:
				if flag[to] == -1:
					flag[to] = current ^ 1
					if flag[to] & 1:
						odd += 1
					else:
						even += 1
					queue.append(to)
				elif flag[to] == current:
					break_all = True
				else:
					assert flag[to] == current ^ 1
		# print(flag)
		if break_all:
			# print('break_all')
			ans = 0
		else:
			if (even, odd) == (1, 0):
				factor += 1
			else:
				ans *= pow(2, even, 998244353) + pow(2, odd, 998244353)
				ans %= 998244353
		while assure <= n:
			if flag[assure] == -1:
				part += 1
				flag[assure] = 2 * part
 
				queue.append(assure)
				break
			assure += 1
		if assure == n + 1:
			break
	ans *= pow(3, factor, 998244353)
	ans %= 998244353
	anss.append(ans)
print('\n'.join(map(str, anss)))
# print(time.time() - start)","['dfs and similar', 'graphs']"
134,"You are given a string s consisting of lowercase Latin letters. Character c is called k-dominant iff each substring of s with length at least k contains this character c.You have to find minimum k such that there exists at least one k-dominant character. nan #888C
#given a string s consisting of lowercase Latin letters.
#Character c is called k-dominant iff each substring of s with length at least k contains c
#find minimum k such that there exists at least one k-dominant character
#Easy Medium
#compute max distance per letter, tricky part: need to compute distance to beginning and end too
#find the minimum among all letters
def dominant(s):
    ALPHA_LEN=26
    pos=[-1]*ALPHA_LEN  # store position of 26 letter
    MAX_=10000
    ans=len(s)//2+len(s)%2
    dist=[MAX_]*ALPHA_LEN # store max distance of same letter
    for i in range(len(s)):
        idx = ord(s[i])-ord('a')
        #always measure distance from start
        d=i-pos[idx]
        if dist[idx]==MAX_ or d>dist[idx]:  #update if it is first time or larger
            dist[idx]=d
            #print(""{0} at {1} from {2} to {3}"".format(s[i], i, dist[i], d))
        pos[idx]=i
    for i in range(ALPHA_LEN):  #update distance to end
        d=len(s)-pos[i]
        if d>dist[i]:
            #print(""change at {0} from {1} to {2}"".format(i, dist[i], d))
            dist[i]=d
    #print(dist)
    print(min(dist))

def test():
    dominant(""abacaba"")  #2
    dominant(""zzzzz"")    #1
    dominant(""abcde"")    #3
    dominant(""abcd"")     #3
    dominant(""abcded"")   #4

def nia():
    s=input()   #1 ≤ |s| ≤ 100000
    while len(s)==0:
        s=input()
    s=s.split()
    iVal=[];
    for i in range (len(s)):
        iVal.append(int(s[i]))
    return iVal

def solve():
    dominant(input())

solve()
","['binary search', 'implementation', 'two pointers']"
3393,"It is the easy version of the problem. The only difference is that in this version $$$k = 3$$$.You are given a positive integer $$$n$$$. Find $$$k$$$ positive integers $$$a_1, a_2, \ldots, a_k$$$, such that:  $$$a_1 + a_2 + \ldots + a_k = n$$$  $$$LCM(a_1, a_2, \ldots, a_k) \le \frac{n}{2}$$$ Here $$$LCM$$$ is the least common multiple of numbers $$$a_1, a_2, \ldots, a_k$$$.We can show that for given constraints the answer always exists. nan #begin of codeforces template
# (don't delete):
#  
# from collections import *
# from heapq import *
# import bisect
#
#t = int(input()) #input number of test cases
#for _ in range(t): #iter for test cases
#    n = int(input()) #input int
#    n,m = map(int,input().split()) #input tuple
#    L = list(map(int,input().split())) #input list
#    s = input() #input string
#    ans = solve(s,L) #solve
#    print(ans)
#
#end of codeforces template

from collections import *

inf = float(""inf"")

def solve(A):
    print("" "".join(map(str,A)))
    
t = int(input()) #input number of test cases
for _ in range(t): #iter for test cases
    n,k = map(int,input().split()) #input tuple
    s = 1
    m = n
    if n%4 == 0:
        print(n//2,n//4,n//4)
    else:
        while m%2 == 0:
            s *= 2
            m //= 2
        print(s,(n-s)//2,(n-s)//2)","['constructive algorithms', 'math']"
3247,"There are $$$n$$$ participants in a competition, participant $$$i$$$ having a strength of $$$s_i$$$. Every participant wonders how much of an advantage they have over the other best participant. In other words, each participant $$$i$$$ wants to know the difference between $$$s_i$$$ and $$$s_j$$$, where $$$j$$$ is the strongest participant in the competition, not counting $$$i$$$ (a difference can be negative).So, they ask you for your help! For each $$$i$$$ ($$$1 \leq i \leq n$$$) output the difference between $$$s_i$$$ and the maximum strength of any participant other than participant $$$i$$$. NoteFor the first test case: The first participant has a strength of $$$4$$$ and the largest strength of a participant different from the first one is $$$7$$$, so the answer for the first participant is $$$4 - 7 = -3$$$.  The second participant has a strength of $$$7$$$ and the largest strength of a participant different from the second one is $$$5$$$, so the answer for the second participant is $$$7 - 5 = 2$$$. The third participant has a strength of $$$3$$$ and the largest strength of a participant different from the third one is $$$7$$$, so the answer for the third participant is $$$3 - 7 = -4$$$. The fourth participant has a strength of $$$5$$$ and the largest strength of a participant different from the fourth one is $$$7$$$, so the answer for the fourth participant is $$$5 - 7 = -2$$$.  t = int(input())

for i in range(t):
    q = 0
    it = []
    n = int(input())
    s = input().split()
    for j in range(n):
        s[j] = int(s[j])
    maxi = max(s)
    m = s.index(maxi)
    for j in range(n):
        a = []
        stre = s[j]
        if j == m:
            a.extend(s)
            a.remove(stre)
            mai = max(a)
            x = stre - mai
            it.append(str(x))
            continue
        x = stre - maxi
        it.append(str(x))
    w = ' '.join(it)
    print(w)
","['data structures', 'implementation', 'sortings']"
3617,"One of the most important products of the R1 company is a popular @r1.com mail service. The R1 mailboxes receive and send millions of emails every day.Today, the online news thundered with terrible information. The R1 database crashed and almost no data could be saved except for one big string. The developers assume that the string contains the letters of some users of the R1 mail. Recovering letters is a tedious mostly manual work. So before you start this process, it was decided to estimate the difficulty of recovering. Namely, we need to calculate the number of different substrings of the saved string that form correct e-mail addresses.We assume that valid addresses are only the e-mail addresses which meet the following criteria:  the address should begin with a non-empty sequence of letters, numbers, characters '_', starting with a letter;  then must go character '@';  then must go a non-empty sequence of letters or numbers;  then must go character '.';  the address must end with a non-empty sequence of letters. You got lucky again and the job was entrusted to you! Please note that the substring is several consecutive characters in a string. Two substrings, one consisting of the characters of the string with numbers l1, l1 + 1, l1 + 2, ..., r1 and the other one consisting of the characters of the string with numbers l2, l2 + 1, l2 + 2, ..., r2, are considered distinct if l1 ≠ l2 or r1 ≠ r2. NoteIn the first test case all the substrings that are correct e-mail addresses begin from one of the letters of the word agapov and end in one of the letters of the word com.In the second test case note that the e-mail x@x.x is considered twice in the answer. Note that in this example the e-mail entries overlap inside the string. from sys import stdin
def main():
    s = stdin.readline().strip()
    dp = [0] * 4
    ans = 0
    for c in s:
        if c.isalpha():
            dp[0] += 1
            dp[2] += dp[1]
            dp[1] = 0
            ans += dp[3]
        elif c.isdigit():
            dp[2] += dp[1]
            dp[1] = 0
            dp[3] = 0
        elif c == '.':
            dp[0] = 0
            dp[1] = 0
            dp[3] = dp[2]
            dp[2] = 0
        elif c == '@':
            dp[1] = dp[0]
            dp[0] = 0
            dp[2] = 0
            dp[3] = 0
        elif c == '_':
            dp[1] = 0
            dp[2] = 0
            dp[3] = 0
    print ans
main()
",['implementation']
184,"You are given a bracket sequence $$$s$$$ of length $$$n$$$, where $$$n$$$ is even (divisible by two). The string $$$s$$$ consists of $$$\frac{n}{2}$$$ opening brackets '(' and $$$\frac{n}{2}$$$ closing brackets ')'.In one move, you can choose exactly one bracket and move it to the beginning of the string or to the end of the string (i.e. you choose some index $$$i$$$, remove the $$$i$$$-th character of $$$s$$$ and insert it before or after all remaining characters of $$$s$$$).Your task is to find the minimum number of moves required to obtain regular bracket sequence from $$$s$$$. It can be proved that the answer always exists under the given constraints.Recall what the regular bracket sequence is:  ""()"" is regular bracket sequence;  if $$$s$$$ is regular bracket sequence then ""("" + $$$s$$$ + "")"" is regular bracket sequence;  if $$$s$$$ and $$$t$$$ are regular bracket sequences then $$$s$$$ + $$$t$$$ is regular bracket sequence. For example, ""()()"", ""(())()"", ""(())"" and ""()"" are regular bracket sequences, but "")("", ""()("" and "")))"" are not.You have to answer $$$t$$$ independent test cases. NoteIn the first test case of the example, it is sufficient to move the first bracket to the end of the string.In the third test case of the example, it is sufficient to move the last bracket to the beginning of the string.In the fourth test case of the example, we can choose last three openning brackets, move them to the beginning of the string and obtain ""((()))(())"". 
t=int(input())
for i in range(t):
	n=int(input())
	s=input()
	while '()' in s:
		s=s.replace('()','')
	m=s.count(')')
	print(m)","['greedy', 'strings']"
2575,"One must train much to do well on wizardry contests. So, there are numerous wizardry schools and magic fees.One of such magic schools consists of n tours. A winner of each tour gets a huge prize. The school is organised quite far away, so one will have to take all the prizes home in one go. And the bags that you've brought with you have space for no more than k huge prizes.Besides the fact that you want to take all the prizes home, you also want to perform well. You will consider your performance good if you win at least l tours.In fact, years of organizing contests proved to the organizers that transporting huge prizes is an issue for the participants. Alas, no one has ever invented a spell that would shrink the prizes... So, here's the solution: for some tours the winner gets a bag instead of a huge prize. Each bag is characterized by number ai — the number of huge prizes that will fit into it.You already know the subject of all tours, so you can estimate the probability pi of winning the i-th tour. You cannot skip the tour under any circumstances.Find the probability that you will perform well on the contest and will be able to take all won prizes home (that is, that you will be able to fit all the huge prizes that you won into the bags that you either won or brought from home). NoteIn the first sample we need either win no tour or win the third one. If we win nothing we wouldn't perform well. So, we must to win the third tour. Other conditions will be satisfied in this case. Probability of wining the third tour is 0.3.In the second sample we win the only tour with probability 1.0, and go back home with bag for it. from collections import *

f = lambda: list(map(int, input().split()))
n, l, a = f()
p, s = f(), f()
m = s.count(-1)
x = {(0, min(a, m)): 1}
d = [1]

for p, s in zip(p, s):
    p /= 100
    if s > 0:
        y = defaultdict(int)
        for (k, a), q in x.items():
            y[(k, a)] += q - q * p
            y[(min(l, k + 1), min(m, a + s))] += q * p
        x = y
    else:
        d = [(a - b) * p + b for a, b in zip([0] + d, d + [0])]

y = [[0] * (m + 2) for i in range(n - m + 2)]
for k, a in x:
    if k + a >= l: y[k][a] = x[(k, a)]

for k in range(n - m, -1, -1):
    for a in range(m, -1, -1):
        y[k][a - 1] += y[k][a]
        y[k][a] += y[k + 1][a]

print(sum(y[max(0, l - k)][k] * p for k, p in enumerate(d) if l - k <= n - m))","['dp', 'math', 'probabilities']"
511,"We call an array $$$a$$$ of length $$$n$$$ fancy if for each $$$1 &lt; i \le n$$$ it holds that $$$a_i = a_{i-1} + 1$$$.Let's call $$$f(p)$$$ applied to a permutation$$$^\dagger$$$ of length $$$n$$$ as the minimum number of subarrays it can be partitioned such that each one of them is fancy. For example $$$f([1,2,3]) = 1$$$, while $$$f([3,1,2]) = 2$$$ and $$$f([3,2,1]) = 3$$$.Given $$$n$$$ and a permutation $$$p$$$ of length $$$n$$$, we define a permutation $$$p'$$$ of length $$$n$$$ to be $$$k$$$-special if and only if:  $$$p'$$$ is lexicographically smaller$$$^\ddagger$$$ than $$$p$$$, and  $$$f(p') = k$$$. Your task is to count for each $$$1 \le k \le n$$$ the number of $$$k$$$-special permutations modulo $$$m$$$.$$$^\dagger$$$ A permutation is an array consisting of $$$n$$$ distinct integers from $$$1$$$ to $$$n$$$ in arbitrary order. For example, $$$[2,3,1,5,4]$$$ is a permutation, but $$$[1,2,2]$$$ is not a permutation ($$$2$$$ appears twice in the array) and $$$[1,3,4]$$$ is also not a permutation ($$$n=3$$$ but there is $$$4$$$ in the array).$$$^\ddagger$$$ A permutation $$$a$$$ of length $$$n$$$ is lexicographically smaller than a permutation $$$b$$$ of length $$$n$$$ if and only if the following holds: in the first position where $$$a$$$ and $$$b$$$ differ, the permutation $$$a$$$ has a smaller element than the corresponding element in $$$b$$$. NoteIn the first example, the permutations that are lexicographically smaller than $$$[1,3,4,2]$$$ are:  $$$[1,2,3,4]$$$, $$$f([1,2,3,4])=1$$$;  $$$[1,2,4,3]$$$, $$$f([1,2,4,3])=3$$$;  $$$[1,3,2,4]$$$, $$$f([1,3,2,4])=4$$$. Thus our answer is $$$[1,0,1,1]$$$.In the second example, the permutations that are lexicographically smaller than $$$[3,2,1]$$$ are:  $$$[1,2,3]$$$, $$$f([1,2,3])=1$$$;  $$$[1,3,2]$$$, $$$f([1,3,2])=3$$$;  $$$[2,1,3]$$$, $$$f([2,1,3])=3$$$;  $$$[2,3,1]$$$, $$$f([2,3,1])=2$$$;  $$$[3,1,2]$$$, $$$f([3,1,2])=2$$$. Thus our answer is $$$[1,2,2]$$$. n, m = map(int, input().split())

def modmul(a, b, c = 0):
    return (a * b + c) % m


comb = [[1]]
for i in range(2010):
    prev = comb[-1]
    nex = [1]
    for i in range(i):
        nex.append((prev[i] + prev[i + 1]) % m)
    nex.append(1)
    comb.append(nex)

fact = [1]
for i in range(1, 3000):
    fact.append((i * fact[i - 1]) % m)

p = list(map(lambda x: int(x) - 1, input().split()))
rem = [1] * n
pairs = n - 1

base = 0

out = [[0] * (n + 1) for _ in range(n + 1)]
for i in range(n):
    diff = [0] * 3
    spec = [0] * 3

    for j in range(p[i]):
        d = 0

        if rem[j] == 0:
            continue
        
        if j and rem[j - 1]:
            d += 1

        #if j < n - 1 and rem[j + 1]:
        #    d += 1

        if i and j == p[i - 1] + 1:
            spec[d] += 1
        else:
            diff[d] += 1

    for d in range(3):
        pp = pairs - d
        if pp < 0:
            continue
        if diff[d] == 0 and spec[d] == 0:
            continue

        remain = n - i - 1

        for sq in range(pp + 1):
            ways = comb[pp][sq]
            order = remain - sq
            assert order >= 0

            ct = modmul(ways, fact[order])
            
            out[base][sq] += modmul(ct, diff[d] + spec[d])
            if spec[d]:
                out[base][sq + 1] += ct

    j = p[i]
    rem[j] = 0
    if j and rem[j - 1]:
        pairs -= 1
    if j < n - 1 and rem[j + 1]:
        pairs -= 1

    if i and p[i] == p[i - 1] + 1:
        base += 1

while len(out) > 1:
    prev = out.pop()
    for i in range(n):
        out[-1][i] += prev[i]
        if i > 0:
            out[-1][i] += prev[i - 1]

out = out[0]

res = []
for i in range(n):
    basee = out[n - 1 - i]
    for j in range(i):
        basee -= modmul(res[j], comb[n - j - 1][n - i - 1])
        #print(i, j, basee)
    res.append(basee % m)
print(' '.join(map(str, res)))
","['combinatorics', 'dp', 'math']"
3978,"The Little Elephant has found a ragged old black-and-white string s on the attic.The characters of string s are numbered from the left to the right from 1 to |s|, where |s| is the length of the string. Let's denote the i-th character of string s as si. As the string is black-and-white, each character of the string is either letter ""B"", or letter ""W"". Unfortunately, the string is very old and some characters are damaged. The damaged positions are denoted as ""X"".The Little Elephant in determined to restore the string and hang it on the wall. For that he needs to replace each character ""X"" by a ""B"" or a ""W"". The string must look good on the wall, so it must be beautiful. The Little Elephant considers a string beautiful if it has two non-intersecting substrings of a given length k, such that the left one fully consists of characters ""B"", and the right one fully consists of characters ""W"". More formally, there are four integers a, b, c, d (1 ≤ a ≤ b &lt; c ≤ d ≤ |s|; b - a + 1 = d - c + 1 = k) such that si = ""B"" (a ≤ i ≤ b) and sj = ""W"" (c ≤ j ≤ d). Help the Little Elephant find the number of different beautiful strings he can obtain from string s. Two strings are considered different if there is such position, where the character in the first string differs from the corresponding character in the second string. If this string doesn't contain characters «X» and it is already beautiful — the answer is 1.As the answer can be rather large, print it modulo 1000000007 (109 + 7). nan Mod=1000000007
n,k=map(int,input().split(' '))
s=' '+input()
f,fs,g,gs,w=[0]*1000005,[0]*1000005,[0]*1000005,[0]*1000005,[0]*1000005
qx,qw,qb=[0]*1000005,[0]*1000005,[0]*1000005
q=0
f[0]=fs[0]=1
for i in range(1,n+1):
	lg=(i-k if i-k>=q else q)
	if s[i]!='B':
		f[i]=fs[i-1]-fs[lg-1]+Mod
		f[i]-=(Mod if f[i]>=Mod else 0)
	else:
		f[i]=0
	fs[i]=fs[i-1]+f[i]
	fs[i]-=(Mod if fs[i]>=Mod else 0)
	if s[i]=='W':
		q=i;
g[n+1]=gs[n+1]=1
q=n+1
for i in range(n,0,-1):
	rg=(i+k if i+k<=q else q)
	if s[i]!='W':
		g[i]=gs[i+1]-gs[rg+1]+Mod
		g[i]-=(Mod if g[i]>=Mod else 0)
	else:
		g[i]=0
	gs[i]=gs[i+1]+g[i]
	gs[i]-=(Mod if gs[i]>=Mod else 0)
	if s[i]=='B':
		q=i;
for i in range(1,n+1):
	qx[i],qb[i],qw[i]=qx[i-1]+(s[i]=='X'),qb[i-1]+(s[i]=='B'),qw[i-1]+(s[i]=='W')
for i in range(n,0,-1):
	w[i]=w[i+1]
	if s[i]=='X':
		w[i]*=2
		w[i]-=(Mod if w[i]>=Mod else 0)
	if i+k-1<=n:
		if qb[i+k-1]-qb[i-1]==0:
			w[i]+=g[i+k]
			w[i]-=(Mod if w[i]>=Mod else 0)
ans=0
for i in range(k,n+1):
	if qw[i]-qw[i-k]==0:
		ans=(ans+f[i-k]*w[i+1])%Mod
print(ans)",['dp']
3075,"Ashish and Vivek play a game on a matrix consisting of $$$n$$$ rows and $$$m$$$ columns, where they take turns claiming cells. Unclaimed cells are represented by $$$0$$$, while claimed cells are represented by $$$1$$$. The initial state of the matrix is given. There can be some claimed cells in the initial state.In each turn, a player must claim a cell. A cell may be claimed if it is unclaimed and does not share a row or column with any other already claimed cells. When a player is unable to make a move, he loses and the game ends.If Ashish and Vivek take turns to move and Ashish goes first, determine the winner of the game if both of them are playing optimally.Optimal play between two players means that both players choose the best possible strategy to achieve the best possible outcome for themselves. NoteFor the first case: One possible scenario could be: Ashish claims cell $$$(1, 1)$$$, Vivek then claims cell $$$(2, 2)$$$. Ashish can neither claim cell $$$(1, 2)$$$, nor cell $$$(2, 1)$$$ as cells $$$(1, 1)$$$ and $$$(2, 2)$$$ are already claimed. Thus Ashish loses. It can be shown that no matter what Ashish plays in this case, Vivek will win. For the second case: Ashish claims cell $$$(1, 1)$$$, the only cell that can be claimed in the first move. After that Vivek has no moves left.For the third case: Ashish cannot make a move, so Vivek wins.For the fourth case: If Ashish claims cell $$$(2, 3)$$$, Vivek will have no moves left. for _ in range(int(input())):
    n,m=map(int,input().split())
    mat=[]
    r=[0]*n
    for i in range(n):
        a=list(map(int,input().split()))
        if 1 in a:
            r[i]=1
        mat.append(a)
    #print(mat[0][1])
    c=[0]*m
    for i in range(m):
        for j in range(n):
            if mat[j][i]==1:
                c[i]=1
                break
    #print(r,c)
    count=0
    rd=0
    cd=0
    for i in r:
        if i==1:
            #print(r[i])
            rd+=1
    for i in c:
        if i==1:
            cd+=1
    #print(rd,cd)
    rd=n-rd
    cd=m-cd
    ma=min(rd,cd)
    if(ma%2):
        print('Ashish')
    else:
        print('Vivek')
    '''if(rd>cd):
        ma=n-rd
        if(ma%2):
            print('Ashish')
        else:
            print('Vivek')
    else:
        ma=m-cd
        if(ma%2):
            print('Ashish')
        else:
            print('Vivek')'''
","['games', 'greedy', 'implementation']"
4895,"You are given an array a consisting of n positive integers. You pick two integer numbers l and r from 1 to n, inclusive (numbers are picked randomly, equiprobably and independently). If l &gt; r, then you swap values of l and r. You have to calculate the expected value of the number of unique elements in segment of the array from index l to index r, inclusive (1-indexed). nan n=int(input())
a=list(map(int,input().split()))

lastocc=[0]*1000006
ans=[0]*n
ans[0]=1
lastocc[a[0]]=1

for i in range(1,n):
    ans[i]=ans[i-1]+(i+1-lastocc[a[i]])
    lastocc[a[i]]=i+1

print((2*sum(ans)-n)/(n*n))
","['data structures', 'math', 'probabilities', 'two pointers']"
4152,"$$$n$$$ students are taking an exam. The highest possible score at this exam is $$$m$$$. Let $$$a_{i}$$$ be the score of the $$$i$$$-th student. You have access to the school database which stores the results of all students.You can change each student's score as long as the following conditions are satisfied:   All scores are integers  $$$0 \leq a_{i} \leq m$$$  The average score of the class doesn't change. You are student $$$1$$$ and you would like to maximize your own score.Find the highest possible score you can assign to yourself such that all conditions are satisfied. NoteIn the first case, $$$a = [1,2,3,4] $$$, with average of $$$2.5$$$. You can change array $$$a$$$ to $$$[10,0,0,0]$$$. Average remains $$$2.5$$$, and all conditions are satisfied.In the second case, $$$0 \leq a_{i} \leq 5$$$. You can change $$$a$$$ to $$$[5,1,1,3]$$$. You cannot increase $$$a_{1}$$$ further as it will violate condition $$$0\le a_i\le m$$$. for _ in range(int(input())):
    n,m=map(int,input().split())
    l=list(map(int,input().split()))
    s=sum(l)
    print(min(m,s))
    ",['implementation']
2347,"Iahub recently has learned Bubble Sort, an algorithm that is used to sort a permutation with n elements a1, a2, ..., an in ascending order. He is bored of this so simple algorithm, so he invents his own graph. The graph (let's call it G) initially has n vertices and 0 edges. During Bubble Sort execution, edges appear as described in the following algorithm (pseudocode). procedure bubbleSortGraph()    build a graph G with n vertices and 0 edges    repeat        swapped = false        for i = 1 to n - 1 inclusive do:            if a[i] &gt; a[i + 1] then                add an undirected edge in G between a[i] and a[i + 1]                swap( a[i], a[i + 1] )                swapped = true            end if        end for    until not swapped     /* repeat the algorithm as long as swapped value is true. */ end procedureFor a graph, an independent set is a set of vertices in a graph, no two of which are adjacent (so there are no edges between vertices of an independent set). A maximum independent set is an independent set which has maximum cardinality. Given the permutation, find the size of the maximum independent set of graph G, if we use such permutation as the premutation a in procedure bubbleSortGraph. NoteConsider the first example. Bubble sort swaps elements 3 and 1. We add edge (1, 3). Permutation is now [1, 3, 2]. Then bubble sort swaps elements 3 and 2. We add edge (2, 3). Permutation is now sorted. We have a graph with 3 vertices and 2 edges (1, 3) and (2, 3). Its maximal independent set is [1, 2]. def lis(a):

    b = []

    for c in a:

        # if len(b) == 0 or c > b[-1]

        if len(b) == 0 or c > b[-1]:

            b.append(c)

        else:

            l = 0

            r = len(b)

            while l < r-1:

                m = l+r>>1

                # if b[m] <= c: l = m

                if b[m] < c: l = m

                else: r = m

            # if b[l] <= c: l += 1

            if b[l] < c: l += 1

            b[l] = c

        

    return len(b)

                    



n = int(input())



a = list(map(int, input().split()))



print(lis(a))





# Made By Mostafa_Khaled","['binary search', 'data structures', 'dp']"
3684,"Alice and Bob play ping-pong with simplified rules.During the game, the player serving the ball commences a play. The server strikes the ball then the receiver makes a return by hitting the ball back. Thereafter, the server and receiver must alternately make a return until one of them doesn't make a return.The one who doesn't make a return loses this play. The winner of the play commences the next play. Alice starts the first play.Alice has $$$x$$$ stamina and Bob has $$$y$$$. To hit the ball (while serving or returning) each player spends $$$1$$$ stamina, so if they don't have any stamina, they can't return the ball (and lose the play) or can't serve the ball (in this case, the other player serves the ball instead). If both players run out of stamina, the game is over.Sometimes, it's strategically optimal not to return the ball, lose the current play, but save the stamina. On the contrary, when the server commences a play, they have to hit the ball, if they have some stamina left.Both Alice and Bob play optimally and want to, firstly, maximize their number of wins and, secondly, minimize the number of wins of their opponent.Calculate the resulting number of Alice's and Bob's wins. NoteIn the first test case, Alice serves the ball and spends $$$1$$$ stamina. Then Bob returns the ball and also spends $$$1$$$ stamina. Alice can't return the ball since she has no stamina left and loses the play. Both of them ran out of stamina, so the game is over with $$$0$$$ Alice's wins and $$$1$$$ Bob's wins.In the second test case, Alice serves the ball and spends $$$1$$$ stamina. Bob decides not to return the ball — he loses the play but saves stamina. Alice, as the winner of the last play, serves the ball in the next play and spends $$$1$$$ more stamina. This time, Bob returns the ball and spends $$$1$$$ stamina. Alice doesn't have any stamina left, so she can't return the ball and loses the play. Both of them ran out of stamina, so the game is over with $$$1$$$ Alice's and $$$1$$$ Bob's win.In the third test case, Alice serves the ball and spends $$$1$$$ stamina. Bob returns the ball and spends $$$1$$$ stamina. Alice ran out of stamina, so she can't return the ball and loses the play. Bob, as a winner, serves the ball in the next $$$6$$$ plays. Each time Alice can't return the ball and loses each play. The game is over with $$$0$$$ Alice's and $$$7$$$ Bob's wins. from collections import Counter, defaultdict, deque
import bisect
from sys import stdin, stdout
from itertools import repeat
import math


def inp(force_list=False):
    re = map(int, raw_input().split())
    if len(re) == 1 and not force_list:
        return re[0]
    return re

def inst():
    return raw_input().strip()

def gcd(x, y):
   while(y):
       x, y = y, x % y
   return x

mod = 1000000007

def my_main():
    kase = inp()
    ans = []
    for i in range(kase):
        x, y = inp()
        if x==y:
            ans.append(""%s %s"" % (x-1, x))
        elif x>y:
            ans.append(""%s %s"" % (x-1, y))
        else:
            ans.append(""%s %s"" % (x-1, y))
    print '\n'.join(ans)
my_main()
","['constructive algorithms', 'games', 'math']"
251,"Dora loves adventures quite a lot. During some journey she encountered an amazing city, which is formed by $$$n$$$ streets along the Eastern direction and $$$m$$$ streets across the Southern direction. Naturally, this city has $$$nm$$$ intersections. At any intersection of $$$i$$$-th Eastern street and $$$j$$$-th Southern street there is a monumental skyscraper. Dora instantly became curious and decided to explore the heights of the city buildings.When Dora passes through the intersection of the $$$i$$$-th Eastern and $$$j$$$-th Southern street she examines those two streets. After Dora learns the heights of all the skyscrapers on those two streets she wonders: how one should reassign heights to the skyscrapers on those two streets, so that the maximum height would be as small as possible and the result of comparing the heights of any two skyscrapers on one street wouldn't change.Formally, on every of $$$nm$$$ intersections Dora solves an independent problem. She sees $$$n + m - 1$$$ skyscrapers and for each of them she knows its real height. Moreover, any two heights can be compared to get a result ""greater"", ""smaller"" or ""equal"". Now Dora wants to select some integer $$$x$$$ and assign every skyscraper a height from $$$1$$$ to $$$x$$$. When assigning heights, Dora wants to preserve the relative order of the skyscrapers in both streets. That is, the result of any comparison of heights of two skyscrapers in the current Eastern street shouldn't change and the result of any comparison of heights of two skyscrapers in current Southern street shouldn't change as well. Note that skyscrapers located on the Southern street are not compared with skyscrapers located on the Eastern street only. However, the skyscraper located at the streets intersection can be compared with both Southern and Eastern skyscrapers. For every intersection Dora wants to independently calculate the minimum possible $$$x$$$.For example, if the intersection and the two streets corresponding to it look as follows:  Then it is optimal to replace the heights of the skyscrapers as follows (note that all comparisons ""less"", ""equal"", ""greater"" inside the Eastern street and inside the Southern street are preserved)  The largest used number is $$$5$$$, hence the answer for this intersection would be $$$5$$$.Help Dora to compute the answers for each intersection. NoteIn the first example, it's not possible to decrease the maximum used height for the problem at any intersection, hence we don't have to change any heights.In the second example, the answers are as follows:   For the intersection of the first line and the first column  For the intersection of the first line and the second column  For the intersection of the second line and the first column  For the intersection of the second line and the second column   from sys import stdin, stdout
n,m = map(int, raw_input().split(' '))
lines = stdin.readlines()
rows = [None]*n
for i in xrange(n):
	rows[i] = map(int, lines[i].split(' '))

def equivalently_sorted_list(xs):
	'example: [10,20,14,10] -> ([1,3,2,1], 3). returns list of positive integers with equivalent pairwise comparisons (<,=,>) to list.'

	xs = sorted([xs[i]*1000+i for i in xrange(len(xs))])
	ys = [0]*len(xs)
	last_x = None
	j = 0
	for w in xs:
		x = w/1000
		i = w%1000
		if x == last_x:
			ys[i] = j
		else:
			j += 1
			ys[i] = j
		last_x = x
	return ys, j

columns = [[rows[i][j] for i in xrange(n)] for j in xrange(m)]

rows_ordered = [equivalently_sorted_list(row) for row in rows]
columns_ordered = [equivalently_sorted_list(column) for column in columns]

def answer(i,j):
	if rows_ordered[i][0][j] > columns_ordered[j][0][i]:
		difference = rows_ordered[i][0][j] - columns_ordered[j][0][i]
		return max(rows_ordered[i][1], columns_ordered[j][1] + difference)
	else:
		difference = columns_ordered[j][0][i] - rows_ordered[i][0][j]
		return max(columns_ordered[j][1], rows_ordered[i][1] + difference)

answer_matrix = [[answer(i,j) for i in xrange(n)] for j in xrange(m)]

stdout.write('\n'.join([' '.join([str(answer_matrix[j][i]) for j in xrange(m)]) for i in xrange(n)]))","['implementation', 'sortings']"
2499,"We call two numbers $$$x$$$ and $$$y$$$ similar if they have the same parity (the same remainder when divided by $$$2$$$), or if $$$|x-y|=1$$$. For example, in each of the pairs $$$(2, 6)$$$, $$$(4, 3)$$$, $$$(11, 7)$$$, the numbers are similar to each other, and in the pairs $$$(1, 4)$$$, $$$(3, 12)$$$, they are not.You are given an array $$$a$$$ of $$$n$$$ ($$$n$$$ is even) positive integers. Check if there is such a partition of the array into pairs that each element of the array belongs to exactly one pair and the numbers in each pair are similar to each other.For example, for the array $$$a = [11, 14, 16, 12]$$$, there is a partition into pairs $$$(11, 12)$$$ and $$$(14, 16)$$$. The numbers in the first pair are similar because they differ by one, and in the second pair because they are both even. NoteThe first test case was explained in the statement.In the second test case, the two given numbers are not similar.In the third test case, any partition is suitable. for _ in range(input()):
    n=input()
    l=map(int,raw_input().split())
    even=0
    for i in range(n):
        if l[i]%2==0:
            even+=1
    if even%2==0:
        print 'YES'
    else:
        l.sort()
        for i in range(len(l)-1):
            if l[i+1]-l[i]==1:
                print 'YES'
                break

        else:
            print 'NO'","['constructive algorithms', 'greedy', 'other', 'sortings']"
733,"You are given a set Y of n distinct positive integers y1, y2, ..., yn.Set X of n distinct positive integers x1, x2, ..., xn is said to generate set Y if one can transform X to Y by applying some number of the following two operation to integers in X:  Take any integer xi and multiply it by two, i.e. replace xi with 2·xi.  Take any integer xi, multiply it by two and add one, i.e. replace xi with 2·xi + 1. Note that integers in X are not required to be distinct after each operation.Two sets of distinct integers X and Y are equal if they are equal as sets. In other words, if we write elements of the sets in the array in the increasing order, these arrays would be equal.Note, that any set of integers (or its permutation) generates itself.You are given a set Y and have to find a set X that generates Y and the maximum element of X is mininum possible. nan def main():
    from heapq import heapify, heapreplace
    input()
    s = set(map(int, input().split()))
    xx = [-x for x in s]
    heapify(xx)
    while True:
        x = -xx[0]
        while x != 1:
            x //= 2
            if x not in s:
                s.add(x)
                heapreplace(xx, -x)
                break
        else:
            break
    print(' '.join(str(-x) for x in xx))

if __name__ == '__main__':
    main()
","['binary search', 'data structures', 'dfs and similar', 'greedy', 'strings', 'trees']"
2547,"There are $$$n$$$ computers in the company network. They are numbered from $$$1$$$ to $$$n$$$.For each pair of two computers $$$1 \leq i &lt; j \leq n$$$ you know the value $$$a_{i,j}$$$: the difficulty of sending data between computers $$$i$$$ and $$$j$$$. All values $$$a_{i,j}$$$ for $$$i&lt;j$$$ are different.You want to separate all computers into $$$k$$$ sets $$$A_1, A_2, \ldots, A_k$$$, such that the following conditions are satisfied:   for each computer $$$1 \leq i \leq n$$$ there is exactly one set $$$A_j$$$, such that $$$i \in A_j$$$;  for each two pairs of computers $$$(s, f)$$$ and $$$(x, y)$$$ ($$$s \neq f$$$, $$$x \neq y$$$), such that $$$s$$$, $$$f$$$, $$$x$$$ are from the same set but $$$x$$$ and $$$y$$$ are from different sets, $$$a_{s,f} &lt; a_{x,y}$$$. For each $$$1 \leq k \leq n$$$ find the number of ways to divide computers into $$$k$$$ groups, such that all required conditions are satisfied. These values can be large, so you need to find them by modulo $$$998\,244\,353$$$. NoteHere are all possible ways to separate all computers into $$$4$$$ groups in the second example:  $$$\{1, 2\}, \{3, 4\}, \{5\}, \{6, 7\}$$$;  $$$\{1\}, \{2\}, \{3, 4\}, \{5, 6, 7\}$$$;  $$$\{1, 2\}, \{3\}, \{4\}, \{5, 6, 7\}$$$.  # import itertools as it
# import functools as ft
import math

teststring = """"""4
0 3 4 6
3 0 2 1
4 2 0 5
6 1 5 0

""""""
online = __file__ != ""/home/jhli/py/Grakn/Problem_G2.py""
true, false = True, False
if True:

    def spitout():
        for c in teststring.splitlines():
            yield c


    _ito = spitout()

    if not online:
        def input():
            return next(_ito)


    def build_enum(*a):
        built = dict()
        for i, c in enumerate(a):
            built[c] = i
        return lambda x: built[x]
# T = 1
# T = int(input())
##-----------------start coding-----------------
n = int(input())
E = [(0, 0)] * (int(n*(n-1)/2))

P = 998244353

for i in range(n):
    L = list(map(int, input().split("" "")))
    for j in range(i+1, n):
        E[L[j]-1] = (i, j)

R = list(range(n))
C = [[0, 1] for _ in range(n)]
Nv = [1] * n
Ne = [0] * n

def root(x):
    if x == R[x]:
        return x
    else:
        R[x] = y = root(R[x])
        return y

def prod(A, B, da, db):
    C = [0] * (min(da+db, n) + 1)
    for i in range(da+1):
        for j in range(db+1):
            if i + j <= n:
                C[i+j] += A[i] * B[j]
                C[i+j] %= P
    return C
    
# print(E)    
# print("""")

for (x, y) in E:
    r = rx = root(x)
    ry = root(y)
    # print((x, y, w), (rx, ry))
    if rx != ry:
        if r > ry: r = ry
        R[rx] = R[ry] = r
        C[r] = prod(C[rx], C[ry], Nv[rx], Nv[ry])
        Nv[r] = Nv[rx] + Nv[ry]
        Ne[r] = Ne[rx] + Ne[ry] + 1
    else:
        Ne[r] += 1
    if Ne[r]*2 == Nv[r] * (Nv[r] - 1):
        C[r][1] = 1
    # print(""R"", R)
    # print(""Nv"", Nv)
    # print(""Ne"", Ne)
    # print(""C"", C)
    # print("""")
        
print("" "".join(map(str, C[0][1:n+1])))

# print('Case #{}: {}'.format(ti, '...'))

","['combinatorics', 'dp', 'dsu', 'graphs', 'other', 'trees']"
122,"Nastya owns too many arrays now, so she wants to delete the least important of them. However, she discovered that this array is magic! Nastya now knows that the array has the following properties:  In one second we can add an arbitrary (possibly negative) integer to all elements of the array that are not equal to zero.  When all elements of the array become equal to zero, the array explodes. Nastya is always busy, so she wants to explode the array as fast as possible. Compute the minimum time in which the array can be exploded. NoteIn the first example you can add  - 1 to all non-zero elements in one second and make them equal to zero.In the second example you can add  - 2 on the first second, then the array becomes equal to [0, 0,  - 3]. On the second second you can add 3 to the third (the only non-zero) element. n = int(input())
arr = list(map(int,input().split(' ')))


c = 0
arr = sorted(arr);
for i in range(0,n):
    if arr[i]==0:
        continue
    if i!=0 and arr[i]==arr[i-1]:
        continue
    c = c+1
    
print(c)
","['implementation', 'sortings']"
2460,"Boboniu gives you  $$$r$$$ red balls,  $$$g$$$ green balls,  $$$b$$$ blue balls,  $$$w$$$ white balls. He allows you to do the following operation as many times as you want:   Pick a red ball, a green ball, and a blue ball and then change their color to white. You should answer if it's possible to arrange all the balls into a palindrome after several (possibly zero) number of described operations.  NoteIn the first test case, you're not able to do any operation and you can never arrange three balls of distinct colors into a palindrome.In the second test case, after doing one operation, changing $$$(8,1,9,3)$$$ to $$$(7,0,8,6)$$$, one of those possible palindromes may be ""rrrwwwbbbbrbbbbwwwrrr"".A palindrome is a word, phrase, or sequence that reads the same backwards as forwards. For example, ""rggbwbggr"", ""b"", ""gg"" are palindromes while ""rgbb"", ""gbbgr"" are not. Notice that an empty word, phrase, or sequence is palindrome. Nombre = int(input()) ; 
for m in range(Nombre) : 
    Tab = list(map(int,input().split())) ; 
    odd = 0 ;
    null = 0 ; 
    for n in Tab : 
        if (n % 2) == 1 : 
            odd += 1 ;
    if (odd ==1) or (odd== 4) or (odd ==0) : 
        print(""Yes"") ; 
    elif (odd == 3) : 
        for n in range(3) : 
            if Tab[n] == 0 : 
                null += 1 ; 
        if null > 0 : 
            print(""No"") ;
        else : 
            print(""Yes"") ; 
    else : 
        print(""No"") ;","['brute force', 'math']"
811,"Last summer, Feluda gifted Lalmohan-Babu a balanced bracket sequence $$$s$$$ of length $$$2 n$$$.Topshe was bored during his summer vacations, and hence he decided to draw an undirected graph of $$$2 n$$$ vertices using the balanced bracket sequence $$$s$$$. For any two distinct vertices $$$i$$$ and $$$j$$$ ($$$1 \le i &lt; j \le 2 n$$$), Topshe draws an edge (undirected and unweighted) between these two nodes if and only if the subsegment $$$s[i \ldots j]$$$ forms a balanced bracket sequence.Determine the number of connected components in Topshe's graph.See the Notes section for definitions of the underlined terms. NoteSample explanation:In the first test case, the graph constructed from the bracket sequence (), is just a graph containing nodes $$$1$$$ and $$$2$$$ connected by a single edge. In the second test case, the graph constructed from the bracket sequence ()(()) would be the following (containing two connected components):  Definition of Underlined Terms: A sequence of brackets is called balanced if one can turn it into a valid math expression by adding characters $$$+$$$ and $$$1$$$. For example, sequences (())(), (), and (()(())) are balanced, while )(, ((), and (()))( are not. The subsegment $$$s[l \ldots r]$$$ denotes the sequence $$$[s_l, s_{l + 1}, \ldots, s_r]$$$. A connected component is a set of vertices $$$X$$$ such that for every two vertices from this set there exists at least one path in the graph connecting these vertices, but adding any other vertex to $$$X$$$ violates this rule. 

n = int(input())
for i in range(n):
    trash = int(input())
    miew = input()
    balance = 0
    groups = 0
    recently_closed = False
    for j in range(len(miew)):
        char = miew[j]
        if char == '(':
            balance += 1
            recently_closed = False
        else:
            if balance > 0 and recently_closed:
                groups += 1
            if balance > 0:
                balance -= 1
                recently_closed = True
            else:
                groups += 1
        # print(groups, j)
    groups += balance + 1
    print(groups)



","['data structures', 'dsu', 'graphs', 'greedy']"
2837,"You are given three sequences: $$$a_1, a_2, \ldots, a_n$$$; $$$b_1, b_2, \ldots, b_n$$$; $$$c_1, c_2, \ldots, c_n$$$.For each $$$i$$$, $$$a_i \neq b_i$$$, $$$a_i \neq c_i$$$, $$$b_i \neq c_i$$$.Find a sequence $$$p_1, p_2, \ldots, p_n$$$, that satisfy the following conditions: $$$p_i \in \{a_i, b_i, c_i\}$$$ $$$p_i \neq p_{(i \mod n) + 1}$$$.In other words, for each element, you need to choose one of the three possible values, such that no two adjacent elements (where we consider elements $$$i,i+1$$$ adjacent for $$$i&lt;n$$$ and also elements $$$1$$$ and $$$n$$$) will have equal value.It can be proved that in the given constraints solution always exists. You don't need to minimize/maximize anything, you need to find any proper sequence. NoteIn the first test case $$$p = [1, 2, 3]$$$.It is a correct answer, because:  $$$p_1 = 1 = a_1$$$, $$$p_2 = 2 = b_2$$$, $$$p_3 = 3 = c_3$$$  $$$p_1 \neq p_2 $$$, $$$p_2 \neq p_3 $$$, $$$p_3 \neq p_1$$$ All possible correct answers to this test case are: $$$[1, 2, 3]$$$, $$$[1, 3, 2]$$$, $$$[2, 1, 3]$$$, $$$[2, 3, 1]$$$, $$$[3, 1, 2]$$$, $$$[3, 2, 1]$$$.In the second test case $$$p = [1, 2, 1, 2]$$$.In this sequence $$$p_1 = a_1$$$, $$$p_2 = a_2$$$, $$$p_3 = a_3$$$, $$$p_4 = a_4$$$. Also we can see, that no two adjacent elements of the sequence are equal.In the third test case $$$p = [1, 3, 4, 3, 2, 4, 2]$$$.In this sequence $$$p_1 = a_1$$$, $$$p_2 = a_2$$$, $$$p_3 = b_3$$$, $$$p_4 = b_4$$$, $$$p_5 = b_5$$$, $$$p_6 = c_6$$$, $$$p_7 = c_7$$$. Also we can see, that no two adjacent elements of the sequence are equal. #!/usr/bin/env python
from __future__ import division, print_function

import os
import sys
from io import BytesIO, IOBase

def main():
    for _ in range(int(input())):
        n = int(input())
        a = list(map(int,input().split()))
        b = list(map(int,input().split()))
        c = list(map(int,input().split()))
        ans = [a[0]]
        for i in range(1,n-1):
            if a[i] != ans[-1]:
                ans.append(a[i])
            elif b[i] != ans[-1]:
                ans.append(b[i])
            elif c[i] != ans[-1]:
                ans.append(c[i])
        if a[-1] != ans[-1] and a[-1] != ans[0]:
            ans.append(a[-1])
        elif b[-1] != ans[-1] and b[-1] != ans[0]:
            ans.append(b[-1])
        elif c[-1] != ans[-1] and c[-1] != ans[0]:
            ans.append(c[-1])
        print("" "".join(map(str,ans)))


# region fastio

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


def print(*args, **kwargs):
    """"""Prints the values to a stream, or to sys.stdout by default.""""""
    sep, file = kwargs.pop(""sep"", "" ""), kwargs.pop(""file"", sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop(""end"", ""\n""))
    if kwargs.pop(""flush"", False):
        file.flush()


if sys.version_info[0] < 3:
    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# endregion

if __name__ == ""__main__"":
    main()
",['constructive algorithms']
1135,"One day mum asked Petya to sort his toys and get rid of some of them. Petya found a whole box of toy spiders. They were quite dear to him and the boy didn't want to throw them away. Petya conjured a cunning plan: he will glue all the spiders together and attach them to the ceiling. Besides, Petya knows that the lower the spiders will hang, the more mum is going to like it and then she won't throw his favourite toys away. Help Petya carry out the plan.A spider consists of k beads tied together by k - 1 threads. Each thread connects two different beads, at that any pair of beads that make up a spider is either directly connected by a thread, or is connected via some chain of threads and beads.Petya may glue spiders together directly gluing their beads. The length of each thread equals 1. The sizes of the beads can be neglected. That's why we can consider that gluing spiders happens by identifying some of the beads (see the picture). Besides, the construction resulting from the gluing process should also represent a spider, that is, it should have the given features. After Petya glues all spiders together, he measures the length of the resulting toy. The distance between a pair of beads is identified as the total length of the threads that connect these two beads. The length of the resulting construction is the largest distance between all pairs of beads. Petya wants to make the spider whose length is as much as possible.    The picture two shows two spiders from the second sample. We can glue to the bead number 2 of the first spider the bead number 1 of the second spider. The threads in the spiders that form the sequence of threads of maximum lengths are highlighted on the picture. nan import sys
sys.stdin = open(""input.txt"",""r"")
sys.stdout = open(""output.txt"",""w"")
from collections import defaultdict

t = int(input())

def DFS(x,d,t,visited):

	global ans
	visited[x] = 1
	l = [0]
	for i in d[x]:
		if visited[i] == 1:
			continue
		l.append(abs(DFS(i,d,t+1,visited)))
	l.sort()
	
	if len(l) >= 2:
		ans = max(ans,l[-1]+l[-2])
	return max(l)+1
ans1 = 0
for i in range(t):

	l = list(map(int,input().split()))
	l = list(l[1:])

	d = defaultdict(list)
	for j in range(0,len(l),2):

	
		d[l[j]].append(l[j+1])
		d[l[j+1]].append(l[j])

		if len(d[l[j]]) == 1:
			x = l[j]
		if len(d[l[j+1]]) == 1:
			x = l[j+1]

	visited = [0 for j in range(max(l)+1)]
	ans = 0
	
	t1 = 0
	DFS(x,d,t1,visited)
	ans1 = ans1 + ans
print(ans1)
","['dp', 'greedy', 'trees']"
567,"Dima and Inna love spending time together. The problem is, Seryozha isn't too enthusiastic to leave his room for some reason. But Dima and Inna love each other so much that they decided to get criminal...Dima constructed a trap graph. He shouted: ""Hey Seryozha, have a look at my cool graph!"" to get his roommate interested and kicked him into the first node.A trap graph is an undirected graph consisting of n nodes and m edges. For edge number k, Dima denoted a range of integers from lk to rk (lk ≤ rk). In order to get out of the trap graph, Seryozha initially (before starting his movements) should pick some integer (let's call it x), then Seryozha must go some way from the starting node with number 1 to the final node with number n. At that, Seryozha can go along edge k only if lk ≤ x ≤ rk.Seryozha is a mathematician. He defined the loyalty of some path from the 1-st node to the n-th one as the number of integers x, such that if he initially chooses one of them, he passes the whole path. Help Seryozha find the path of maximum loyalty and return to his room as quickly as possible! NoteExplanation of the first example.Overall, we have 2 ways to get from node 1 to node 4: first you must go along the edge 1-2 with range [1-10], then along one of the two edges 2-4. One of them contains range [3-5], that is, we can pass through with numbers 3, 4, 5. So the loyalty of such path is 3.If we go along edge 2-4 with range [2-7], then we can pass through with numbers 2, 3, 4, 5, 6, 7. The loyalty is 6. That is the answer.The edge 1-2 have no influence on the answer because its range includes both ranges of the following edges. import sys
sys.setrecursionlimit(100000)

def dfs(v, l, r, mark):
    if v == n - 1:
        return True
    mark[v] = True
    for u, e in graph[v]:
        if not mark[u] and edges[e][0] <= l <= r <= edges[e][1]:
            if dfs(u, l, r, mark):
                return True
    return False


def pred(k):
    for l, _ in edges:
        if dfs(0, l, l + k - 1, [False] * n):
            return True
    return False


n, m = map(int, raw_input().split())
graph = [[] for _ in range(n)]
edges = []

maxd = 0
for i in range(m):
    ak, bk, lk, rk = map(int, raw_input().split())
    edges.append((lk, rk))
    graph[ak - 1].append((bk - 1, i))
    graph[bk - 1].append((ak - 1, i))
    maxd = max(maxd, rk - lk + 1)


l = 0
r = maxd + 1
while r - l > 1:
    mid = (l + r) / 2
    if pred(mid):
        l = mid
    else:
        r = mid
if l > 0:
    print(l)
else:
    print('Nice work, Dima!')
","['binary search', 'data structures', 'dfs and similar', 'dsu', 'shortest paths', 'two pointers']"
2373,"Monocarp has got an array $$$a$$$ consisting of $$$n$$$ integers. Let's denote $$$k$$$ as the mathematic mean of these elements (note that it's possible that $$$k$$$ is not an integer). The mathematic mean of an array of $$$n$$$ elements is the sum of elements divided by the number of these elements (i. e. sum divided by $$$n$$$).Monocarp wants to delete exactly two elements from $$$a$$$ so that the mathematic mean of the remaining $$$(n - 2)$$$ elements is still equal to $$$k$$$.Your task is to calculate the number of pairs of positions $$$[i, j]$$$ ($$$i &lt; j$$$) such that if the elements on these positions are deleted, the mathematic mean of $$$(n - 2)$$$ remaining elements is equal to $$$k$$$ (that is, it is equal to the mathematic mean of $$$n$$$ elements of the original array $$$a$$$). NoteIn the first example, any pair of elements can be removed since all of them are equal.In the second example, there is no way to delete two elements so the mathematic mean doesn't change.In the third example, it is possible to delete the elements on positions $$$1$$$ and $$$3$$$, or the elements on positions $$$4$$$ and $$$5$$$. def sayinin_adedi(x):
    dizi9 = [0] * len(x)
    o_sayi = x[0]
    o_sayinin_adedi = 1
    i = 1
    while i < len(x):
        if x[i] == o_sayi:
            o_sayinin_adedi+=1
        else:
            j = i-1
            while dizi9[j] == 0:
                dizi9[j] = o_sayinin_adedi
                j-=1
                if j < 0:
                    break
            o_sayi = x[i]
            o_sayinin_adedi = 1
        i+=1
    i = 0
    while  i < o_sayinin_adedi:
        dizi9[len(x)-1-i] = o_sayinin_adedi
        i+=1
    return dizi9
kac_kere = int(input())
while kac_kere > 0:
    kac_sayi = input()
    dizi = input().split()
    toplam = 0
    for x in range(0, len(dizi)):
        dizi[x] = int(dizi[x])
        toplam = toplam + dizi[x]
    dizi.sort()
    dizi2 = sayinin_adedi(dizi)
    ortalama = float(toplam) / len(dizi)
    i = 0
    j = 1
    ikili_sayisi = 0
    while dizi[i] < ortalama:
        if dizi[i] + dizi[-j] > 2 * ortalama:
            j+=dizi2[-j]
        elif dizi[i] + dizi[-j] == 2 * ortalama:
            ikili_sayisi+= dizi2[i] * dizi2[-j]
            i+=dizi2[i]
            j+=dizi2[-j]
        else:
            i+=dizi2[i]
    if dizi[i] == ortalama:
        ikili_sayisi+= int(dizi2[i] * (dizi2[i] - 1) / 2)
    print(ikili_sayisi)
    kac_kere-=1","['data structures', 'dp', 'implementation', 'math', 'two pointers']"
3123,"Although Inzane successfully found his beloved bone, Zane, his owner, has yet to return. To search for Zane, he would need a lot of money, of which he sadly has none. To deal with the problem, he has decided to hack the banks.  There are n banks, numbered from 1 to n. There are also n - 1 wires connecting the banks. All banks are initially online. Each bank also has its initial strength: bank i has initial strength ai.Let us define some keywords before we proceed. Bank i and bank j are neighboring if and only if there exists a wire directly connecting them. Bank i and bank j are semi-neighboring if and only if there exists an online bank k such that bank i and bank k are neighboring and bank k and bank j are neighboring.When a bank is hacked, it becomes offline (and no longer online), and other banks that are neighboring or semi-neighboring to it have their strengths increased by 1.To start his plan, Inzane will choose a bank to hack first. Indeed, the strength of such bank must not exceed the strength of his computer. After this, he will repeatedly choose some bank to hack next until all the banks are hacked, but he can continue to hack bank x if and only if all these conditions are met:  Bank x is online. That is, bank x is not hacked yet.  Bank x is neighboring to some offline bank.  The strength of bank x is less than or equal to the strength of Inzane's computer. Determine the minimum strength of the computer Inzane needs to hack all the banks. NoteIn the first sample, Inzane can hack all banks using a computer with strength 5. Here is how:  Initially, strengths of the banks are [1, 2, 3, 4, 5].  He hacks bank 5, then strengths of the banks become [1, 2, 4, 5,  - ].  He hacks bank 4, then strengths of the banks become [1, 3, 5,  - ,  - ].  He hacks bank 3, then strengths of the banks become [2, 4,  - ,  - ,  - ].  He hacks bank 2, then strengths of the banks become [3,  - ,  - ,  - ,  - ].  He completes his goal by hacking bank 1. In the second sample, Inzane can hack banks 4, 2, 3, 1, 5, 7, and 6, in this order. This way, he can hack all banks using a computer with strength 93. n = int(input())

strengths = list(map(int, input().split()))
max_strength = max(strengths)

count_max = strengths.count(max_strength)
count_second_place = strengths.count(max_strength - 1)

maxes = [0 for i in range(n)]
second_places = [0 for i in range(n)]

for i in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    if strengths[a] == max_strength:
        maxes[b] += 1
    elif strengths[a] == max_strength - 1:
        second_places[b] += 1

    if strengths[b] == max_strength:
        maxes[a] += 1
    elif strengths[b] == max_strength - 1:
        second_places[a] += 1

total_max = 1000000009
for i in range(n):
    here = 0
    if strengths[i] < max_strength:
        if maxes[i] == count_max:
            here = max_strength + 1
        else:
            here = max_strength + 2
    else:
        if count_max == 1:
            if second_places[i] == count_second_place:
                here = max_strength
            else:
                here = max_strength + 1
        else:
            if maxes[i] == count_max - 1:
                here = max_strength + 1
            else:
                here = max_strength + 2
    total_max = min(total_max, here)

print(total_max)
","['constructive algorithms', 'data structures', 'dp', 'trees']"
4837,"Alex doesn't like boredom. That's why whenever he gets bored, he comes up with games. One long winter evening he came up with a game and decided to play it.Given a sequence a consisting of n integers. The player can make several steps. In a single step he can choose an element of the sequence (let's denote it ak) and delete it, at that all elements equal to ak + 1 and ak - 1 also must be deleted from the sequence. That step brings ak points to the player. Alex is a perfectionist, so he decided to get as many points as possible. Help him. NoteConsider the third test example. At first step we need to choose any element equal to 2. After that step our sequence looks like this [2, 2, 2, 2]. Then we do 4 steps, on each step we choose any element equals to 2. In total we earn 10 points. def main():
    L = [0 for i in range(100001)]
    c = [0 for i in range(100001)]
    n = int(input())
    Max = 0
    inp = [int(x) for x in input().split()]
    for i in range(n):
        c[inp[i]]+=1
        Max = max(inp[i],Max)
    L[1] = inp.count(1) 
    for i in range(2,Max+1):
        L[i] = max(L[i-1],L[i-2]+c[i]*i)
    print(L[Max])
if __name__ == ""__main__"" : main()",['dp']
3752,"You are given a string s, consisting of lowercase English letters, and the integer m.One should choose some symbols from the given string so that any contiguous subsegment of length m has at least one selected symbol. Note that here we choose positions of symbols, not the symbols themselves.Then one uses the chosen symbols to form a new string. All symbols from the chosen position should be used, but we are allowed to rearrange them in any order.Formally, we choose a subsequence of indices 1 ≤ i1 &lt; i2 &lt; ... &lt; it ≤ |s|. The selected sequence must meet the following condition: for every j such that 1 ≤ j ≤ |s| - m + 1, there must be at least one selected index that belongs to the segment [j,  j + m - 1], i.e. there should exist a k from 1 to t, such that j ≤ ik ≤ j + m - 1.Then we take any permutation p of the selected indices and form a new string sip1sip2... sipt.Find the lexicographically smallest string, that can be obtained using this procedure. NoteIn the first sample, one can choose the subsequence {3} and form a string ""a"".In the second sample, one can choose the subsequence {1, 2, 4} (symbols on this positions are 'a', 'b' and 'a') and rearrange the chosen symbols to form a string ""aab"". m = int(input())
s = input()
ans = []
mark = [True for _ in range(len(s))]
z = 'a'
i = 0
while i <= len(s) - m:
    k = i
    for j in range(i, i + m):
        if s[j] <= s[k]:
            k = j
    ans.append(s[k])
    z = max(z, s[k])
    mark[k] = False
    i = k
    i += 1
for i in range(len(s)):
    if s[i] < z and mark[i]:
        ans.append(s[i])
print(''.join(str(i) for i in sorted(ans)))","['data structures', 'greedy', 'strings']"
4609,"You are given a Young diagram. Given diagram is a histogram with $$$n$$$ columns of lengths $$$a_1, a_2, \ldots, a_n$$$ ($$$a_1 \geq a_2 \geq \ldots \geq a_n \geq 1$$$).    Young diagram for $$$a=[3,2,2,2,1]$$$. Your goal is to find the largest number of non-overlapping dominos that you can draw inside of this histogram, a domino is a $$$1 \times 2$$$ or $$$2 \times 1$$$ rectangle. NoteSome of the possible solutions for the example:  from sys import stdin,stdout

n = int(stdin.readline().strip())
alist = list(map(int,stdin.readline().split()))
k = max(alist)
total,odd,even = 0,0,0
for i,a in enumerate(alist):
    total += a//2
    if a%2:
        if i%2:
            odd+=1
        else:
            even+=1
total+=min(odd,even)
print(total)
","['dp', 'greedy', 'math']"
3697,"A new entertainment has appeared in Buryatia — a mathematical circus! The magician shows two numbers to the audience — $$$n$$$ and $$$k$$$, where $$$n$$$ is even. Next, he takes all the integers from $$$1$$$ to $$$n$$$, and splits them all into pairs $$$(a, b)$$$ (each integer must be in exactly one pair) so that for each pair the integer $$$(a + k) \cdot b$$$ is divisible by $$$4$$$ (note that the order of the numbers in the pair matters), or reports that, unfortunately for viewers, such a split is impossible.Burenka really likes such performances, so she asked her friend Tonya to be a magician, and also gave him the numbers $$$n$$$ and $$$k$$$.Tonya is a wolf, and as you know, wolves do not perform in the circus, even in a mathematical one. Therefore, he asks you to help him. Let him know if a suitable splitting into pairs is possible, and if possible, then tell it. NoteIn the first test case, splitting into pairs $$$(1, 2)$$$ and $$$(3, 4)$$$ is suitable, same as splitting into $$$(1, 4)$$$ and $$$(3, 2)$$$.In the second test case, $$$(1 + 0) \cdot 2 = 1 \cdot (2 + 0) = 2$$$ is not divisible by $$$4$$$, so there is no partition. tests = int(input())

def solve(n, k):
	if(k&1):
		print(""YES"")
		for i in range(1, n+1, 2):
			print(str(i) + "" "" + str(i+1))
	else:
		if(k % 4 == 0):
			print(""NO"")
		else:
			print(""YES"")
			for i in range(1, n+1, 4):
				print(str(i+1) + "" "" + str(i))
				if(i+3 <= n):
					print(str(i+2) + "" "" + str(i+3))
				 
	
	

for _ in range(tests):
	n, k = [int(i) for i in input().split("" "")]
	solve(n, k)

","['constructive algorithms', 'math']"
2463,"Wabbit is trying to move a box containing food for the rest of the zoo in the coordinate plane from the point $$$(x_1,y_1)$$$ to the point $$$(x_2,y_2)$$$.He has a rope, which he can use to pull the box. He can only pull the box if he stands exactly $$$1$$$ unit away from the box in the direction of one of two coordinate axes. He will pull the box to where he is standing before moving out of the way in the same direction by $$$1$$$ unit.   For example, if the box is at the point $$$(1,2)$$$ and Wabbit is standing at the point $$$(2,2)$$$, he can pull the box right by $$$1$$$ unit, with the box ending up at the point $$$(2,2)$$$ and Wabbit ending at the point $$$(3,2)$$$.Also, Wabbit can move $$$1$$$ unit to the right, left, up, or down without pulling the box. In this case, it is not necessary for him to be in exactly $$$1$$$ unit away from the box. If he wants to pull the box again, he must return to a point next to the box. Also, Wabbit can't move to the point where the box is located.Wabbit can start at any point. It takes $$$1$$$ second to travel $$$1$$$ unit right, left, up, or down, regardless of whether he pulls the box while moving.Determine the minimum amount of time he needs to move the box from $$$(x_1,y_1)$$$ to $$$(x_2,y_2)$$$. Note that the point where Wabbit ends up at does not matter. NoteIn the first test case, the starting and the ending points of the box are $$$(1,2)$$$ and $$$(2,2)$$$ respectively. This is the same as the picture in the statement. Wabbit needs only $$$1$$$ second to move as shown in the picture in the statement.In the second test case, Wabbit can start at the point $$$(2,1)$$$. He pulls the box to $$$(2,1)$$$ while moving to $$$(3,1)$$$. He then moves to $$$(3,2)$$$ and then to $$$(2,2)$$$ without pulling the box. Then, he pulls the box to $$$(2,2)$$$ while moving to $$$(2,3)$$$. It takes $$$4$$$ seconds. import math
o=int(input())
for i in range(o):
    s=input()
    l=s.split()
    f1=math.fabs(int(l[0])-int(l[2]))
    f2=math.fabs(int(l[1])-int(l[3]))
    if int(l[0])!=int(l[2]) and int(l[1])!=int(l[3]):
        print(int(2+f1+f2))
    else:
        print(int(f1+f2))
        ",['math']
4080,"There are $$$n$$$ weighted points on the $$$OX$$$-axis. The coordinate and the weight of the $$$i$$$-th point is $$$x_i$$$ and $$$w_i$$$, respectively. All points have distinct coordinates and positive weights. Also, $$$x_i &lt; x_{i + 1}$$$ holds for any $$$1 \leq i &lt; n$$$. The weighted distance between $$$i$$$-th point and $$$j$$$-th point is defined as $$$|x_i - x_j| \cdot (w_i + w_j)$$$, where $$$|val|$$$ denotes the absolute value of $$$val$$$.You should answer $$$q$$$ queries, where the $$$i$$$-th query asks the following: Find the minimum weighted distance among all pairs of distinct points among the points in subarray $$$[l_i,r_i]$$$. NoteFor the first query, the minimum weighted distance is between points $$$1$$$ and $$$3$$$, which is equal to $$$|x_1 - x_3| \cdot (w_1 + w_3) = |-2 - 1| \cdot (2 + 1) = 9$$$.For the second query, the minimum weighted distance is between points $$$2$$$ and $$$3$$$, which is equal to $$$|x_2 - x_3| \cdot (w_2 + w_3) = |0 - 1| \cdot (10 + 1) = 11$$$.For the fourth query, the minimum weighted distance is between points $$$3$$$ and $$$4$$$, which is equal to $$$|x_3 - x_4| \cdot (w_3 + w_4) = |1 - 9| \cdot (1 + 2) = 24$$$. ''' F. Closest Pair
https://codeforces.com/contest/1635/problem/F
'''

import io, os, sys
input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline  # decode().strip() if str
output = sys.stdout.write

DEBUG = os.environ.get('debug') not in [None, '0']

if DEBUG:
    from inspect import currentframe, getframeinfo
    from re import search

def debug(*args):
    if not DEBUG: return
    frame = currentframe().f_back
    s = getframeinfo(frame).code_context[0]
    r = search(r""\((.*)\)"", s).group(1)
    vnames = r.split(', ')
    var_and_vals = [f'{var}={val}' for var, val in zip(vnames, args)]
    prefix = f'{currentframe().f_back.f_lineno:02d}: '
    print(f'{prefix}{"", "".join(var_and_vals)}')


INF = float('inf')

# -----------------------------------------

class FenwickTreeMin:
    def __init__(self, data):
        '''transform list into BIT'''
        self.bit = data
        for i in range(len(data)):
            j = i | (i + 1)
            if j < len(data):
                data[j] = min(data[j], data[i])

    def query(self, end):
        '''calc min(bit[:end])'''
        x = INF
        while end:
            x = min(x, self.bit[end - 1])
            end &= end - 1  # 110 -> 100
        return x

    def update(self, idx, x):
        '''updates bit[idx] += x'''
        while idx < len(self.bit):
            self.bit[idx] = min(self.bit[idx], x)
            idx |= idx + 1   # 101 -> 110


# let L[i] = max j < i s.t. wj <= wi, R[i] = min j > i s.t. wj <= wi
# then closest pair for i..N-1 must be one of 2N intervals (L[i], i), (R[i], i)
# given q = (l, r), find min-dist interval fully covered by (l, r)

def solve(N, Q, points, queries):
    # find all cand intervals (L[i], i), (R[i], i)
    # ends[l] = right ends of all cand intervals starting at l
    ends = [[] for _ in range(N)]

    stack = []
    for i, (_, w) in enumerate(points):
        while stack and points[stack[-1]][1] > w: stack.pop()
        if stack: ends[stack[-1]].append(i)
        stack.append(i)
    
    stack = []
    for i in range(N-1, -1, -1):
        _, w = points[i]
        while stack and points[stack[-1]][1] > w: stack.pop()
        if stack: ends[i].append(stack[-1])
        stack.append(i)
    
    # query_ends[l] = [](r, i) for all queries starting at l
    query_ends = [[] for _ in range(N)]
    for i, (l, r) in enumerate(queries):
        query_ends[l-1].append((r-1, i))
    
    # move l right to left
    # add dist(l, ends[l]) and process query (l, query_ends[l])
    # all intervals added so far will have left end >= l
    # so fenwick.query(r) returns min dist inside (l, r)
    fenwick = FenwickTreeMin([INF] * N)
    res = [INF] * Q
    for l in range(N-1, -1, -1):
        for r in ends[l]:
            fenwick.update(r, (points[r][0] - points[l][0]) * (points[r][1] + points[l][1]))
        for r, i in query_ends[l]:
            res[i] = fenwick.query(r + 1)

    return res


def main():
    N, Q = list(map(int, input().split()))
    points = [list(map(int, input().split())) for _ in range(N)]
    queries = [list(map(int, input().split())) for _ in range(Q)]
    out = solve(N, Q, points, queries)
    print('\n'.join(map(str, out)))


if __name__ == '__main__':
    main()

","['data structures', 'greedy']"
2653,"Once upon a time Mike and Mike decided to come up with an outstanding problem for some stage of ROI (rare olympiad in informatics). One of them came up with a problem prototype but another stole the idea and proposed that problem for another stage of the same olympiad. Since then the first Mike has been waiting for an opportunity to propose the original idea for some other contest... Mike waited until this moment!You are given an array $$$a$$$ of $$$n$$$ integers. You are also given $$$q$$$ queries of two types:  Replace $$$i$$$-th element in the array with integer $$$x$$$.  Replace each element in the array with integer $$$x$$$. After performing each query you have to calculate the sum of all elements in the array. NoteConsider array from the example and the result of performing each query:  Initial array is $$$[1, 2, 3, 4, 5]$$$.  After performing the first query, array equals to $$$[5, 2, 3, 4, 5]$$$. The sum of all elements is $$$19$$$.  After performing the second query, array equals to $$$[10, 10, 10, 10, 10]$$$. The sum of all elements is $$$50$$$.  After performing the third query, array equals to $$$[10, 10, 10, 10, 11$$$]. The sum of all elements is $$$51$$$.  After performing the fourth query, array equals to $$$[10, 10, 10, 1, 11]$$$. The sum of all elements is $$$42$$$.  After performing the fifth query, array equals to $$$[1, 1, 1, 1, 1]$$$. The sum of all elements is $$$5$$$.  import sys
input=sys.stdin.readline
n,q=map(int,input().split())
a=list(map(int,input().split()))
s=sum(a)
rep={}
same='x'
for i in range(q):
    command=list(map(int,input().split()))
    if command[0]==1:
        if same!='x':
            s=s-rep.get(command[1],same)+command[2]
            rep[command[1]]=command[2]
        else:
            s=s-rep.get(command[1],a[command[1]-1])+command[2]
            rep[command[1]]=command[2]
    else:
        s=n*command[1]
        same=command[1]
        rep={}
    print(s)","['data structures', 'implementation']"
2697,"Magnus decided to play a classic chess game. Though what he saw in his locker shocked him! His favourite chessboard got broken into 4 pieces, each of size n by n, n is always odd. And what's even worse, some squares were of wrong color. j-th square of the i-th row of k-th piece of the board has color ak, i, j; 1 being black and 0 being white. Now Magnus wants to change color of some squares in such a way that he recolors minimum number of squares and obtained pieces form a valid chessboard. Every square has its color different to each of the neightbouring by side squares in a valid board. Its size should be 2n by 2n. You are allowed to move pieces but not allowed to rotate or flip them. nan n = input()
a = [[], [], [], []]
for k in range(4):
    for j in range(n):
        a[k].append(raw_input())
    if k < 3: raw_input()

c = [0, 0, 0, 0]
for k in range(4):
    for i in range(n):
        for j in range(n):
            if (i * n + j) % 2 == 0:
                c[k] += int(a[k][i][j])
            else:
                c[k] += 1 - int(a[k][i][j])

c.sort()
c[2] = n * n - c[2]
c[3] = n * n - c[3]
print sum(c)
","['bitmasks', 'brute force', 'implementation']"
602,"Monocarp is playing Minecraft and wants to build a wall of cacti. He wants to build it on a field of sand of the size of $$$n \times m$$$ cells. Initially, there are cacti in some cells of the field. Note that, in Minecraft, cacti cannot grow on cells adjacent to each other by side — and the initial field meets this restriction. Monocarp can plant new cacti (they must also fulfil the aforementioned condition). He can't chop down any of the cacti that are already growing on the field — he doesn't have an axe, and the cacti are too prickly for his hands.Monocarp believes that the wall is complete if there is no path from the top row of the field to the bottom row, such that:   each two consecutive cells in the path are adjacent by side;  no cell belonging to the path contains a cactus. Your task is to plant the minimum number of cacti to build a wall (or to report that this is impossible). nan import sys, os, io
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

def f(u, v):
    return u * m + v

def g(u):
    return u // m, u % m

def bfs():
    dist = [inf] * l
    q, q0 = [], []
    k, k0 = 0, 0
    for i in range(0, l, m):
        if not ng[i]:
            dist[i] = s[i]
            if not dist[i]:
                q.append(i)
            else:
                q0.append(i)
    parent = [-1] * l
    for d in range(l + 1):
        while len(q) ^ k:
            u = q[k]
            i, j = g(u)
            for di, dj in v2:
                ni, nj = i + di, j + dj
                if not 0 <= ni < n or not 0 <= nj < m:
                    continue
                v = f(ni, nj)
                if ng[v] or dist[v] ^ inf:
                    continue
                dist[v] = d + s[v]
                parent[v] = u
                if not s[v]:
                    q.append(v)
                else:
                    q0.append(v)
            k += 1
        q, q0 = q0, q
        k, k0 = k0, k
    return dist, parent

t = int(input())
ans = []
v = [(1, 0), (0, 1), (-1, 0), (0, -1)]
v2 = [(1, 1), (1, -1), (-1, 1), (-1, -1)]
inf = pow(10, 9) + 1
for _ in range(t):
    n, m = map(int, input().split())
    l = n * m
    s = []
    ng = [0] * l
    for i in range(n):
        s0 = list(input().rstrip())
        for j in range(m):
            if s0[j] & 1:
                for di, dj in v:
                    ni, nj = i + di, j + dj
                    if not 0 <= ni < n or not 0 <= nj < m:
                        continue
                    ng[f(ni, nj)] = 1
        for j in s0:
            s.append((j & 1) ^ 1)
    dist, parent = bfs()
    mi = inf
    for i in range(m - 1, l, m):
        if mi > dist[i]:
            mi, u = dist[i], i
    if mi == inf:
        ans0 = ""NO""
        ans.append(ans0)
        continue
    s[u] = 0
    while not parent[u] == -1:
        u = parent[u]
        s[u] = 0
    ans0 = ""YES""
    ans.append(ans0)
    for i in range(n):
        ans0 = [""."" if s[j] else ""#"" for j in range(i * m, (i + 1) * m)]
        ans.append("""".join(ans0))
sys.stdout.write(""\n"".join(ans))","['constructive algorithms', 'dfs and similar', 'graphs', 'shortest paths']"
2984,"Given an array $$$a$$$ of $$$n$$$ integers, find a range of values $$$[x, y]$$$ ($$$x \le y$$$), and split $$$a$$$ into exactly $$$k$$$ ($$$1 \le k \le n$$$) subarrays in such a way that:  Each subarray is formed by several continuous elements of $$$a$$$, that is, it is equal to $$$a_l, a_{l+1}, \ldots, a_r$$$ for some $$$l$$$ and $$$r$$$ ($$$1 \leq l \leq r \leq n$$$).  Each element from $$$a$$$ belongs to exactly one subarray.  In each subarray the number of elements inside the range $$$[x, y]$$$ (inclusive) is strictly greater than the number of elements outside the range. An element with index $$$i$$$ is inside the range $$$[x, y]$$$ if and only if $$$x \le a_i \le y$$$.  Print any solution that minimizes $$$y - x$$$. NoteIn the first test, there should be only one subarray, which must be equal to the whole array. There are $$$2$$$ elements inside the range $$$[1, 2]$$$ and $$$0$$$ elements outside, if the chosen range is $$$[1, 1]$$$, there will be $$$1$$$ element inside ($$$a_1$$$) and $$$1$$$ element outside ($$$a_2$$$), and the answer will be invalid.In the second test, it is possible to choose the range $$$[2, 2]$$$, and split the array in subarrays $$$(1, 3)$$$ and $$$(4, 4)$$$, in subarray $$$(1, 3)$$$ there are $$$2$$$ elements inside the range ($$$a_2$$$ and $$$a_3$$$) and $$$1$$$ element outside ($$$a_1$$$), in subarray $$$(4, 4)$$$ there is only $$$1$$$ element ($$$a_4$$$), and it is inside the range.In the third test, it is possible to choose the range $$$[5, 5]$$$, and split the array in subarrays $$$(1, 4)$$$, $$$(5, 7)$$$ and $$$(8, 11)$$$, in the subarray $$$(1, 4)$$$ there are $$$3$$$ elements inside the range and $$$1$$$ element outside, in the subarray $$$(5, 7)$$$ there are $$$2$$$ elements inside and $$$1$$$ element outside and in the subarray $$$(8, 11)$$$ there are $$$3$$$ elements inside and $$$1$$$ element outside. import sys
import os
from io import BytesIO, IOBase

# region fastio
BUFSIZE = 8192
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

if sys.version_info[0] < 3:
    sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

f = sys.stdin
if os.environ.get('USER') == ""loic"":
    f = open(""data.in"")
    
line = lambda: f.readline().split()
ui = lambda: int(line()[0])
ti = lambda: map(int,line())
li = lambda: list(ti())

#######################################################################

def bs_pred_r(predicate, start_l, start_r):
    l = start_l
    r = start_r
    while l <= r:
        mid = (l&r+1) + ((l^r+1)>>1)
        if predicate(mid):
            r = mid-1
        else:
            l = mid+1
    return l

def build_ranges(x,y,k):
    res = []
    
    c = 0
    prev = 0
    rem = k
    for i,val in enumerate(A):
        if x <= val <= y:
            c += 1
        if rem > 1:
            sz = i - prev + 1
            if c > sz//2:
                c = 0
                rem -= 1
                res.append((prev,i))
                prev = i+1
    
    res.append((prev,N-1))
    
    return res

def solve():
    
    c = [0] * (N+1)
    for val in A:
        c[val] += 1
        
    pref = [0] * (N+1)
    for i in range(1,N+1):
        pref[i] += pref[i-1] + c[i]
    
    x = -10**9
    y = 10**9
    for i,val in enumerate(pref):
        q = K-1 + (N-K+1)//2 + 1
        if val < q:
            continue
        d = val - q + 1
        pred = lambda x: pref[x] >= d
        l = bs_pred_r(pred, 0, N)
        if i-l < y-x:
            x = l
            y = i
    
    res = build_ranges(x, y, K)
    
    return str(x) + "" "" + str(y) + ""\n"" + ""\n"".join(str(a+1) + "" "" + str(b+1) for a,b in res)

for test in range(1,ui()+1):
    N,K = ti()
    A = li()

    print(solve())
    
f.close()","['binary search', 'constructive algorithms', 'greedy', 'two pointers']"
1448,"Malek has recently found a treasure map. While he was looking for a treasure he found a locked door. There was a string s written on the door consisting of characters '(', ')' and '#'. Below there was a manual on how to open the door. After spending a long time Malek managed to decode the manual and found out that the goal is to replace each '#' with one or more ')' characters so that the final string becomes beautiful. Below there was also written that a string is called beautiful if for each i (1 ≤ i ≤ |s|) there are no more ')' characters than '(' characters among the first i characters of s and also the total number of '(' characters is equal to the total number of ')' characters. Help Malek open the door by telling him for each '#' character how many ')' characters he must replace it with. Note|s| denotes the length of the string s. '''import sys
st = input()
a = 0
b = 0
last = 0
v = []
for s in st:
	if s == ""("":
		a += 1
	elif s == "")"":
		a -= 1
	elif s == ""#"":
		a -= 1
		v.append(1)
	if a < 0:
		print(-1)
		sys.exit()

v[-1] += a
i=0
a = 0
for s in st:
	if s == ""("":
		a += 1
	elif s == "")"":
		a -= 1
	elif s == ""#"":
		a -= v[i]
		i += 1
	if a < 0:
		print(-1)
		sys.exit()
if a != 0:
	print(-1)
else:
	for vs in v:
		print(vs)'''


import sys
a=0
s=input()
l=[]
for i in s:
	if(i=='('):
		a=a+1
	elif(i==')'):
		a=a-1
	else:
		a=a-1
		l.append(1)
	if(a<0):
		print(-1)
		sys.exit()
l[-1]+=a
a=0
k=0
for j in s:
	if(j=='('):
		a=a+1
	elif(j==')'):
		a=a-1
	else:
		a=a-l[k]
		k=k+1
	if(a<0):
		print(-1)
		sys.exit()

if(a!=0):
	print(-1)
else:
	for j in l:
		print(j)","['greedy', 'implementation']"
3388,"This is the easy version of the problem. The difference between the versions is in the constraints on the array elements. You can make hacks only if all versions of the problem are solved.You are given an array $$$[a_1, a_2, \dots, a_n]$$$. Your goal is to find the length of the longest subarray of this array such that the most frequent value in it is not unique. In other words, you are looking for a subarray such that if the most frequent value occurs $$$f$$$ times in this subarray, then at least $$$2$$$ different values should occur exactly $$$f$$$ times.An array $$$c$$$ is a subarray of an array $$$d$$$ if $$$c$$$ can be obtained from $$$d$$$ by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end. NoteIn the first sample, the subarray $$$[1, 1, 2, 2, 3, 3]$$$ is good, but $$$[1, 1, 2, 2, 3, 3, 3]$$$ isn't: in the latter there are $$$3$$$ occurrences of number $$$3$$$, and no other element appears $$$3$$$ times. n = int(input())
a = [int(x) for x in input().split()]

cnt = [0]*101

for x in a:
    cnt[x] += 1

maxFreq = max(cnt)
v = []
for i in range(101):
    if cnt[i] == maxFreq:
        v.append(i)

if len(v) > 1:
    print(n)

else:
    ans = 0

    for i in range(101):

        if i == v[0] or cnt[i] == 0:
            continue

        table = {0:-1}
        sum = 0

        for j in range(n):

            if a[j] == i:
                sum += 1

            if a[j] == v[0]:
                sum -= 1

            if sum in table:
                ind = table[sum]
                ans = max(ans , j-ind)
            else:
                table[sum] = j

    print(ans)









","['data structures', 'greedy']"
318,"Joseph really likes the culture of Japan. Last year he learned Japanese traditional clothes and visual arts and now he is trying to find out the secret of the Japanese game called Nonogram.In the one-dimensional version of the game, there is a row of $$$n$$$ empty cells, some of which are to be filled with a pen. There is a description of a solution called a profile — a sequence of positive integers denoting the lengths of consecutive sets of filled cells. For example, the profile of $$$[4, 3, 1]$$$ means that there are sets of four, three, and one filled cell, in that order, with at least one empty cell between successive sets. A suitable solution for $$$n = 12$$$ and $$$p = [4, 3, 1]$$$.  A wrong solution: the first four filled cells should be consecutive.  A wrong solution: there should be at least one empty cell before the last filled cell. Joseph found out that for some numbers $$$n$$$ and profiles $$$p$$$ there are lots of ways to fill the cells to satisfy the profile. Now he is in the process of solving a nonogram consisting of $$$n$$$ cells and a profile $$$p$$$. He has already created a mask of $$$p$$$ — he has filled all the cells that must be filled in every solution of the nonogram. The mask for $$$n = 12$$$ and $$$p = [4, 3, 1]$$$: all the filled cells above are filled in every solution. After a break, he lost the source profile $$$p$$$. He only has $$$n$$$ and the mask $$$m$$$. Help Joseph find any profile $$$p'$$$ with the mask $$$m$$$ or say that there is no such profile and Joseph has made a mistake. nan import copy
from collections import defaultdict as dd
from collections import deque
import math
import sys
import os

# sys.setrecursionlimit(10**5)  # This uses something like 128 MB RAM. I guess only play with this if I expect recursion depth problems.

#region  set up dbg commands
# set up debug stuff.
# remember .bashrc should contain `export PYTHON_CONTEST_HELPER=""dummy""`
if os.environ.get(""PYTHON_CONTEST_HELPER""):
    OUT_RED_BOLD = ""\033[31;1m""
    OUT_GREEN = ""\033[32m""
    OUT_RESET = ""\033[0m""
    OUT_BOLD = ""\033[;1m""
    OUT_CYAN = ""\033[36;1m""
    OUT_PURPLE = ""\033[35;1m""
    OUT_YELLOW = ""\033[33;1m""
    OUT_BACKGROUND = ""\033[41;30;1m""

    def dbgBase(*args, **kwargs):
        color_helper = kwargs.pop('color', OUT_CYAN)
        print(f""{OUT_RED_BOLD}{sys._getframe().f_back.f_back.f_lineno: >20} {OUT_BOLD}: {color_helper}"", end='', file=sys.stderr)
        end_maybe = kwargs.get('end', '\n')
        kwargs['end']=f""{OUT_RESET}{end_maybe}""
        print(*args, file=sys.stderr, **kwargs)

    def dbg(*args, **kwargs): dbgBase(color=OUT_CYAN, *args, **kwargs)
    dbgB = dbg
    def dbgG(*args, **kwargs): dbgBase(color=OUT_GREEN, *args, **kwargs)
    def dbgP(*args, **kwargs): dbgBase(color=OUT_PURPLE, *args, **kwargs)
    def dbgY(*args, **kwargs): dbgBase(color=OUT_YELLOW, *args, **kwargs)
    def dbgBackground(*args, **kwargs): dbgBase(color=OUT_BACKGROUND, *args, **kwargs)
    def el(n=1): print('\n'*n, file=sys.stderr, end='')
else:
    def dbg(*args, **kwargs): pass
    def dbgB(*args, **kwargs): pass
    def dbgG(*args, **kwargs): pass
    def dbgP(*args, **kwargs): pass
    def dbgY(*args, **kwargs): pass
    def dbgBackground(*args, **kwargs): pass
    def el(n=1): pass
#endregion
#region  FastIO
from io import BytesIO, IOBase

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
#endregion

def nn():
    return int(input())

def li():
    return list(input())

def lm():
    return list(map(int, input().split()))


# To print while flushing output for interactive problems:
# print(x, flush=True)


#########################################################################
# Problem specific code usually goes below this line.
#########################################################################

# ! Read the sample cases before writing code!








def solve(testID):
    dat = input()
    dbg(dat)
    min_space = -1
    if dat[0] == ""#"" or dat[-1] == ""#"":
        min_space = 0
    curr_cell = 0
    total_blocks = []
    while curr_cell < len(dat):
        curr_spaces = 0
        while curr_cell < len(dat) and dat[curr_cell] == ""_"":
            curr_spaces += 1
            curr_cell += 1
        if curr_spaces != 0 and (min_space == -1 or curr_spaces < min_space):
            min_space = curr_spaces
        curr_block_size = 0
        start_cell = curr_cell
        while curr_cell < len(dat) and dat[curr_cell] == ""#"":
            curr_block_size += 1
            curr_cell += 1
        if curr_block_size > 0:
            total_blocks.append((start_cell, curr_block_size))
    dbgB(min_space)
    dbgB(total_blocks)
    if len(total_blocks) == 0:
        print(0)
        print()
        return
    for slack in range(min_space + 1):
        last_allowed_spot = 0
        success = True
        for pos, block_size in total_blocks:
            dbgP(slack, pos, block_size, last_allowed_spot)
            prior_empty_space = pos - last_allowed_spot
            space_to_fill = prior_empty_space - slack
            dbgY(space_to_fill)
            if space_to_fill < 0:
                success = False
                break
            if space_to_fill > 0 and slack == 0:
                success = False
                break
            if space_to_fill == 1:
                success = False
                break
            if space_to_fill % 2 == 1 and slack == 1:
                success = False
                break
            last_allowed_spot = pos + block_size + 1
            dbgP(last_allowed_spot)
        if not success:
            continue
        remaining_space = len(dat) - last_allowed_spot + 1 - slack
        dbgG(remaining_space)
        if (remaining_space > 0 and slack == 0) or remaining_space < 0 or remaining_space == 1 or (remaining_space % 2 == 1 and slack == 1):
            success = False
            continue
        break
    if not success:
        print(-1)
        return
    dbgY(slack)

    profile_ints = []
    last_allowed_spot = 0
    for pos, block_size in total_blocks:
        space_to_fill = pos - last_allowed_spot - slack
        dbgB(space_to_fill)
        if space_to_fill % 2 == 1:
            profile_ints.append(2)
            space_to_fill -= 3
        while space_to_fill > 0:
            profile_ints.append(1)
            space_to_fill -= 2
        profile_ints.append(block_size + slack)
        last_allowed_spot = pos + block_size + 1
    remaining_space = len(dat) - last_allowed_spot + 1 - slack
    dbgP(remaining_space)
    if remaining_space > 0:
        if remaining_space % 2 == 1:
            profile_ints.append(2)
            remaining_space -= 3
        while remaining_space > 0:
            profile_ints.append(1)
            remaining_space -= 2

    dbgG(profile_ints)

    print(len(profile_ints))
    print("" "".join([str(x) for x in profile_ints]))

    return


T = 1
# dbgBackground(""Loading num cases!!!!!""); T = nn()  # ! Comment this out for single-case problems!
for testID in range(1, T+1):
    el()
    dbgBackground(f""Case {testID}"")
    solve(testID)
","['constructive algorithms', 'math']"
3564,"You are given an array $$$a$$$ consisting of $$$n$$$ integers. We denote the subarray $$$a[l..r]$$$ as the array $$$[a_l, a_{l + 1}, \dots, a_r]$$$ ($$$1 \le l \le r \le n$$$).A subarray is considered good if every integer that occurs in this subarray occurs there exactly thrice. For example, the array $$$[1, 2, 2, 2, 1, 1, 2, 2, 2]$$$ has three good subarrays:  $$$a[1..6] = [1, 2, 2, 2, 1, 1]$$$;  $$$a[2..4] = [2, 2, 2]$$$;  $$$a[7..9] = [2, 2, 2]$$$. Calculate the number of good subarrays of the given array $$$a$$$. nan from collections import Counter
from random import randint
import sys
input = sys.stdin.buffer.readline
 
def prog():
    n = int(input())
    a = list(map(int,input().split()))
    curr_occurences = [0]*(n + 1)
    mult = [randint(1,10**20) for i in range(n + 1)]
    hash_at_idx = [0]*(n + 1)
    hashes = Counter([0])
    curr_hash = 0
    last_3 = [[] for i in range(n + 1)]
    ans = 0
    least_start = -1
    
    for i in range(n):
        x = a[i]
        if len(last_3[x]) == 3:
            new_start = last_3[x][0]
            while least_start < new_start:
                hashes[hash_at_idx[least_start]] -= 1
                least_start += 1
            del last_3[x][0]
            
        curr_hash -= curr_occurences[x]*mult[x]
        curr_occurences[x] = (curr_occurences[x] + 1) % 3
        curr_hash += curr_occurences[x]*mult[x]
        ans += hashes[curr_hash]
        hashes[curr_hash] += 1
        hash_at_idx[i] = curr_hash
        last_3[x].append(i)
 
    print(ans)
    
prog()","['data structures', 'divide and conquer', 'hashing', 'two pointers']"
1507,"You have given tree consist of $$$n$$$ vertices. Select a vertex as root vertex that satisfies the condition below.  For all vertices $$$v_{1}$$$ and $$$v_{2}$$$, if $$$distance$$$($$$root$$$, $$$v_{1}$$$) $$$= distance$$$($$$root$$$, $$$v_{2})$$$ then $$$degree$$$($$$v_{1}$$$) $$$= degree$$$($$$v_{2}$$$), where $$$degree$$$ means the number of vertices connected to that vertex, and $$$distance$$$ means the number of edges between two vertices. Determine and find if there is such root vertex in the tree. If there are multiple answers, find any of them. NoteThis is the picture for the first example. $$$1$$$, $$$5$$$, $$$7$$$ also can be a valid answer.  This is the picture for the second example. You can see that it's impossible to find such root vertex.   #!/usr/bin/env python
def longest_path():
    try:
        d = [-1 for _ in range(n)]
        d[0] = 0; q = [0]
        for i in range(n):
            f = q[i]
            for t in g[f]:
                if d[t] == -1:
                    q.append(t)
                    d[t] = d[f] + 1
        u = q[-1]
        d = [-1 for _ in range(n)]
        p = [-1 for _ in range(n)]
        d[u] = 0; q = [u]
        for i in range(n):
            f = q[i]
            for t in g[f]:
                if d[t] == -1:
                    q.append(t)
                    d[t] = d[f] + 1
                    p[t] = f
        v = q[-1]
        ld = d[v]
        w = v
        if ld & 1:
            return u, v, None
        while d[w] != (ld >> 1):
            w = p[w]
        return u, v, w
    except:
        print(f'Error raised in longest_path()')


def top(u):
    try:
        if u is None:
            return False
        dist = [-1 for _ in range(n)]
        deg = [-1 for _ in range(n)]
        dist[u] = 0; q = [u]
        for i in range(n):
            f = q[i]
            if deg[dist[f]] == -1:
                deg[dist[f]] = len(g[f])
            elif len(g[f]) != deg[dist[f]]:
                return False
            for t in g[f]:
                if dist[t] == -1:
                    q.append(t)
                    dist[t] = dist[f] + 1
        return True
    except:
        print(f'Error raised in top({u})')


def semitop(w):
    try:
        if w is None:
            return False, None
        d = [-1 for _ in range(n)]
        d[w] = 0; q = [w]; i = 0
        while i < len(q):
            f = q[i]
            for t in g[f]:
                if d[t] == -1:
                    if len(g[t]) != 2:
                        d[t] = 100_500
                        if top(t):
                            return True, t
                    else:
                        d[t] = d[f] + 1
                        q.append(t)
            i += 1
        return False, None
    except:
        print(f'Error raised in semitop({w})')


try:
    n = int(input())
    g = [[] for _ in range(n)]
    for _ in range(n - 1):
        u, v = map(lambda _: int(_) - 1, input().split())
        g[u].append(v); g[v].append(u)
    u, v, w = longest_path()

    if top(u):
        print(u + 1)
    elif top(v):
        print(v + 1)
    elif top(w):
        print(w + 1)
    else:
        k, t = semitop(w)
        if k:
            print(t + 1)
        else:
            print(-1)
except:
    print(f'Error raised in main')","['constructive algorithms', 'dfs and similar', 'dp', 'hashing', 'implementation', 'trees']"
274,"Alice received a set of Toy Train™ from Bob. It consists of one train and a connected railway network of $$$n$$$ stations, enumerated from $$$1$$$ through $$$n$$$. The train occupies one station at a time and travels around the network of stations in a circular manner. More precisely, the immediate station that the train will visit after station $$$i$$$ is station $$$i+1$$$ if $$$1 \leq i &lt; n$$$ or station $$$1$$$ if $$$i = n$$$. It takes the train $$$1$$$ second to travel to its next station as described.Bob gave Alice a fun task before he left: to deliver $$$m$$$ candies that are initially at some stations to their independent destinations using the train. The candies are enumerated from $$$1$$$ through $$$m$$$. Candy $$$i$$$ ($$$1 \leq i \leq m$$$), now at station $$$a_i$$$, should be delivered to station $$$b_i$$$ ($$$a_i \neq b_i$$$).    The blue numbers on the candies correspond to $$$b_i$$$ values. The image corresponds to the $$$1$$$-st example. The train has infinite capacity, and it is possible to load off any number of candies at a station. However, only at most one candy can be loaded from a station onto the train before it leaves the station. You can choose any candy at this station. The time it takes to move the candies is negligible.Now, Alice wonders how much time is needed for the train to deliver all candies. Your task is to find, for each station, the minimum time the train would need to deliver all the candies were it to start from there. NoteConsider the second sample.If the train started at station $$$1$$$, the optimal strategy is as follows.  Load the first candy onto the train.  Proceed to station $$$2$$$. This step takes $$$1$$$ second.  Deliver the first candy.  Proceed to station $$$1$$$. This step takes $$$1$$$ second.  Load the second candy onto the train.  Proceed to station $$$2$$$. This step takes $$$1$$$ second.  Deliver the second candy.  Proceed to station $$$1$$$. This step takes $$$1$$$ second.  Load the third candy onto the train.  Proceed to station $$$2$$$. This step takes $$$1$$$ second.  Deliver the third candy. Hence, the train needs $$$5$$$ seconds to complete the tasks.If the train were to start at station $$$2$$$, however, it would need to move to station $$$1$$$ before it could load the first candy, which would take one additional second. Thus, the answer in this scenario is $$$5+1 = 6$$$ seconds. from collections import defaultdict as dd
n,m=[int(i) for i in input().split(' ')]
a=[]
b=[]

def fnx(i,j):
    if i<j:
        return(j-i)
    else:
        return(n-i+j)

def fnr(r):
    if r%n==0:
        return(n)
    else:
        return(r%n)

for i in range(m):
    x,y=[int(i) for i in input().split(' ')]
    a.append(x)
    b.append(y)
    
ANS=[]

ii=1
s=[[] for i in range(n+1)]
d=dd(list)

r=[ -1 for i in range(n+1)]
y=[-1]

for i in range(m):
    x,yy=a[i],b[i]
    s[x].append([fnx(x,yy),x,yy])    
    d[yy].append(x)
    
for i in range(1,n+1):
    rt=s[i].copy()
    rt.sort()
    r[i]=rt
    y.append(len(s[i]))
#print(r)


p=max(y)
A=(p-2)*n
ans1=[]
ans2=[]
for i in range(1,n+1):
    if y[i]==p:
        if p==1:
            ans2.append(r[i][0])
            continue
        ans1.append(r[i][1])
        ans2.append(r[i][0])
    if y[i]==p-1:
        if p-1==0:
            continue
        ans1.append(r[i][0])



for ij in range(1,n+1):
    tr=0
    for i in range(len(ans1)):
        re=ans1[i][0]+fnr(ans1[i][1]-ij+1)-1
        tr=max(tr,re)
        
    trf=0
    for i in range(len(ans2)):
        re=ans2[i][0]+fnr(ans2[i][1]-ij+1)-1
        trf=max(trf,re)

    er=max(A+tr,A+trf+n)
    #print(er)
    ANS.append(er)
print(*ANS)
","['brute force', 'greedy', 'implementation']"
3566,"Polycarpus got an internship in one well-known social network. His test task is to count the number of unique users who have visited a social network during the day. Polycarpus was provided with information on all user requests for this time period. For each query, we know its time... and nothing else, because Polycarpus has already accidentally removed the user IDs corresponding to the requests from the database. Thus, it is now impossible to determine whether any two requests are made by the same person or by different people.But wait, something is still known, because that day a record was achieved — M simultaneous users online! In addition, Polycarpus believes that if a user made a request at second s, then he was online for T seconds after that, that is, at seconds s, s + 1, s + 2, ..., s + T - 1. So, the user's time online can be calculated as the union of time intervals of the form [s, s + T - 1] over all times s of requests from him.Guided by these thoughts, Polycarpus wants to assign a user ID to each request so that:  the number of different users online did not exceed M at any moment,  at some second the number of distinct users online reached value M,  the total number of users (the number of distinct identifiers) was as much as possible. Help Polycarpus cope with the test. NoteConsider the first sample. The user who sent the first request was online from 17:05:53 to 17:06:02, the user who sent the second request was online from 17:05:58 to 17:06:07, the user who sent the third request, was online from 17:06:01 to 17:06:10. Thus, these IDs cannot belong to three distinct users, because in that case all these users would be online, for example, at 17:06:01. That is impossible, because M = 2. That means that some two of these queries belonged to the same user. One of the correct variants is given in the answer to the sample. For it user 1 was online from 17:05:53 to 17:06:02, user 2 — from 17:05:58 to 17:06:10 (he sent the second and third queries), user 3 — from 22:39:47 to 22:39:56.In the second sample there is only one query. So, only one user visited the network within the 24-hour period and there couldn't be two users online on the network simultaneously. (The time the user spent online is the union of time intervals for requests, so users who didn't send requests could not be online in the network.)  def main():
    mode=""filee""
    if mode==""file"":f=open(""test.txt"",""r"")
    get = lambda :[int(x) for x in (f.readline() if mode==""file"" else input()).split()]
    gets = lambda :[str(x) for x in (f.readline()[:-1] if mode==""file"" else input()).split("":"")]
    [n,m,t]=get()
    [a,b]=[[0]*20002,[0]*20002]
    if n<m:
        print(""No solution"")
        return
    for i in range(1,n+1):
        g = gets()
        a[i] = int(g[-1]) + int(g[1])*60 + int(g[0])*3600
    [p,count,sim,ist] = [1,0,0,False]
    for i in range(1,n+1):
        while p<i and a[i] - t + 1>a[p]:
            p+=1
            if b[p]!=b[p-1]:
                sim = max(sim-1,0)
        if a[i]<a[p]+t and sim<m:
            [count,sim] = [count+1,sim+1]
        if sim==m:
            ist=True
        b[i] = count
    if ist==False:
        print(""No solution"")
        return
    print(count)
    for i in range(1,n+1):
        print(b[i],end=' ')

    if mode==""file"":f.close()


if __name__==""__main__"":
    main()

","['greedy', 'two pointers']"
3479,"You have given an array $$$a$$$ of length $$$n$$$ and an integer $$$x$$$ to a brand new robot. What the robot does is the following: it iterates over the elements of the array, let the current element be $$$q$$$. If $$$q$$$ is divisible by $$$x$$$, the robot adds $$$x$$$ copies of the integer $$$\frac{q}{x}$$$ to the end of the array, and moves on to the next element. Note that the newly added elements could be processed by the robot later. Otherwise, if $$$q$$$ is not divisible by $$$x$$$, the robot shuts down.Please determine the sum of all values of the array at the end of the process. NoteIn the first test case the array initially consists of a single element $$$[12]$$$, and $$$x=2$$$. After the robot processes the first element, the array becomes $$$[12, 6, 6]$$$. Then the robot processes the second element, and the array becomes $$$[12, 6, 6, 3, 3]$$$. After the robot processes the next element, the array becomes $$$[12, 6, 6, 3, 3, 3, 3]$$$, and then the robot shuts down, since it encounters an element that is not divisible by $$$x = 2$$$. The sum of the elements in the resulting array is equal to $$$36$$$.In the second test case the array initially contains integers $$$[4, 6, 8, 2]$$$, and $$$x=2$$$. The resulting array in this case looks like $$$ [4, 6, 8, 2, 2, 2, 3, 3, 4, 4, 1, 1, 1, 1, 1, 1]$$$. #######puzzleVerma#######
 
 
import sys
import math
LI=lambda:[int(k) for k in input().split()]
input = lambda: sys.stdin.readline().rstrip()
IN=lambda:int(input())
S=lambda:input()
 
 
for i in range(IN()):
    n,x=LI()
    a=LI()
    sm=sum(a)
    ans=0
    ndi=0
    co=10**9
    for i in range(n):
        ele=a[i]
        tco=1
        while ele%x==0:
            tco+=1
            ele/=x
        if tco<co:
            co=tco
            ndi=i
    ans+=sum(a[:ndi])
    ans+=(sm*co)
    print(ans)","['brute force', 'greedy', 'implementation', 'math']"
1103,"You are given an array $$$a$$$ of $$$n$$$ integers and an integer $$$s$$$. It is guaranteed that $$$n$$$ is odd.In one operation you can either increase or decrease any single element by one. Calculate the minimum number of operations required to make the median of the array being equal to $$$s$$$.The median of the array with odd length is the value of the element which is located on the middle position after the array is sorted. For example, the median of the array $$$6, 5, 8$$$ is equal to $$$6$$$, since if we sort this array we will get $$$5, 6, 8$$$, and $$$6$$$ is located on the middle position. NoteIn the first sample, $$$6$$$ can be increased twice. The array will transform to $$$8, 5, 8$$$, which becomes $$$5, 8, 8$$$ after sorting, hence the median is equal to $$$8$$$.In the second sample, $$$19$$$ can be increased once and $$$15$$$ can be increased five times. The array will become equal to $$$21, 20, 12, 11, 20, 20, 12$$$. If we sort this array we get $$$11, 12, 12, 20, 20, 20, 21$$$, this way the median is $$$20$$$. n, s = [int(x) for x in input().split()]
a = [int(x) for x in input().split()]
a.sort()
m = n // 2
me = a[m]
ct = m
if me == s:
    print(0)
    exit(0)
elif me < s:
    while ct < n and a[ct] < s:
        ct += 1
    ds = sum([(x-s) for x in a[m:ct:1]])
elif me > s:
    while ct >= 0 and a[ct] > s:
        ct -= 1
    ds = sum([(x-s) for x in a[ct+1:m+1:1]])
print(abs(ds))
",['greedy']
734,"First-rate specialists graduate from Berland State Institute of Peace and Friendship. You are one of the most talented students in this university. The education is not easy because you need to have fundamental knowledge in different areas, which sometimes are not related to each other. For example, you should know linguistics very well. You learn a structure of Reberland language as foreign language. In this language words are constructed according to the following rules. First you need to choose the ""root"" of the word — some string which has more than 4 letters. Then several strings with the length 2 or 3 symbols are appended to this word. The only restriction —  it is not allowed to append the same string twice in a row. All these strings are considered to be suffixes of the word (this time we use word ""suffix"" to describe a morpheme but not the few last characters of the string as you may used to). Here is one exercise that you have found in your task list. You are given the word s. Find all distinct strings with the length 2 or 3, which can be suffixes of this word according to the word constructing rules in Reberland language. Two strings are considered distinct if they have different length or there is a position in which corresponding characters do not match. Let's look at the example: the word abacabaca is given. This word can be obtained in the following ways: , where the root of the word is overlined, and suffixes are marked by ""corners"". Thus, the set of possible suffixes for this word is {aca, ba, ca}.  NoteThe first test was analysed in the problem statement. In the second example the length of the string equals 5. The length of the root equals 5, so no string can be used as a suffix. s = input()
n = len(s)
res = set()

from collections import defaultdict

two = [""$"", """", ""$""]
thr = [""$"", """", ""$""]

works = lambda w, i : (two[i] != ""$"" and w != two[i]) or (thr[i] != ""$"" and w != thr[i])

i = n - 2
while i > 4:
    ntwo = s[i: i + 2]
    if works(ntwo, 1):
        res.add(ntwo)
    else:
        ntwo = ""$""    

    if (i <= n - 3):
        nthr = s[i: i + 3]
        if works(nthr, 2):
            res.add(nthr)
        else:
            nthr = ""$""
    else:
        nthr = ""$""

    two = [ntwo] + two[0:2]
    thr = [nthr] + thr[0:2]
    i -= 1

res = list(res)
res.sort()

print(len(res))
for word in res:
    print(word)","['dp', 'strings']"
4836,"Happy PMP is freshman and he is learning about algorithmic problems. He enjoys playing algorithmic games a lot.One of the seniors gave Happy PMP a nice game. He is given two permutations of numbers 1 through n and is asked to convert the first one to the second. In one move he can remove the last number from the permutation of numbers and inserts it back in an arbitrary position. He can either insert last number between any two consecutive numbers, or he can place it at the beginning of the permutation.Happy PMP has an algorithm that solves the problem. But it is not fast enough. He wants to know the minimum number of moves to convert the first permutation to the second.  NoteIn the first sample, he removes number 1 from end of the list and places it at the beginning. After that he takes number 2 and places it between 1 and 3.In the second sample, he removes number 5 and inserts it after 1.In the third sample, the sequence of changes are like this:  1 5 2 3 4 1 4 5 2 3 1 3 4 5 2 1 2 3 4 5  So he needs three moves. n = int(raw_input())
a = map(int,raw_input().split())
b = map(int,raw_input().split())
j = 0
for i in range(0,n):
        if a[j] == b[i]:
                j += 1
print n-j
                                               ",['greedy']
4147,"Vasya and Kolya play a game with a string, using the following rules. Initially, Kolya creates a string s, consisting of small English letters, and uniformly at random chooses an integer k from a segment [0, len(s) - 1]. He tells Vasya this string s, and then shifts it k letters to the left, i. e. creates a new string t = sk + 1sk + 2... sns1s2... sk. Vasya does not know the integer k nor the string t, but he wants to guess the integer k. To do this, he asks Kolya to tell him the first letter of the new string, and then, after he sees it, open one more letter on some position, which Vasya can choose.Vasya understands, that he can't guarantee that he will win, but he wants to know the probability of winning, if he plays optimally. He wants you to compute this probability. Note that Vasya wants to know the value of k uniquely, it means, that if there are at least two cyclic shifts of s that fit the information Vasya knowns, Vasya loses. Of course, at any moment of the game Vasya wants to maximize the probability of his win. NoteIn the first example Vasya can always open the second letter after opening the first letter, and the cyclic shift is always determined uniquely.In the second example if the first opened letter of t is ""t"" or ""c"", then Vasya can't guess the shift by opening only one other letter. On the other hand, if the first letter is ""i"" or ""a"", then he can open the fourth letter and determine the shift uniquely. from __future__ import print_function, division
from sys import stdin, stdout
from collections import *

chrs = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789:;?!""#&\'()*+,-./ '
rstr = lambda: stdin.readline().strip()
s, ans = rstr(), 0
le = len(s)
mem = [[[0 for _ in range(le)] for _ in range(26)] for _ in range(26)]
get = lambda x: ord(x) - ord('a')

for i in range(le):
    for j in range(le):
        mem[get(s[i])][get(s[(j + i) % le])][j] += 1

for i in range(26):
    t1 = 0
    for j in range(le):
        t2 = 0
        for k in range(26):
            t2 += (mem[get(chrs[i])][get(chrs[k])][j] == 1)
        t1 = max(t1, t2)

    ans += t1

print(ans / le)
","['implementation', 'math', 'probabilities']"
605,"Everyone knows that hobbits love to organize all sorts of parties and celebrations. There are n hobbits living in the Shire. They decided to organize the Greatest Party (GP) that would last for several days. Next day the hobbits wrote a guest list, some non-empty set containing all the inhabitants of the Shire. To ensure that everybody enjoy themselves and nobody gets bored, for any two days (say, days A and B) of the GP there existed at least one hobbit, invited to come on day A and on day B. However, to ensure that nobody has a row, for any three different days A, B, C there shouldn't be a hobbit invited on days A, B and C. The Shire inhabitants are keen on keeping the GP going for as long as possible. Your task is given number n, to indicate the GP's maximum duration and the guest lists for each day. nan n = int(input())
k = 3
while k * (k + 1) // 2 <= n:
    k += 1
en = 1
graph = [ [] for i in range(k) ]
for i in range(k):
    for j in range(i):
        graph[i].append(en)
        graph[j].append(en)
        en += 1
print k
for i in range(k):
    print "" "".join(map(str, graph[i]))","['constructive algorithms', 'greedy']"
3423,"This problem is different with hard version only by constraints on total answers lengthIt is an interactive problemVenya joined a tour to the madhouse, in which orderlies play with patients the following game. Orderlies pick a string $$$s$$$ of length $$$n$$$, consisting only of lowercase English letters. The player can ask two types of queries:   ? l r – ask to list all substrings of $$$s[l..r]$$$. Substrings will be returned in random order, and in every substring, all characters will be randomly shuffled.  ! s – guess the string picked by the orderlies. This query can be asked exactly once, after that the game will finish. If the string is guessed correctly, the player wins, otherwise he loses. The player can ask no more than $$$3$$$ queries of the first type.To make it easier for the orderlies, there is an additional limitation: the total number of returned substrings in all queries of the first type must not exceed $$$(n+1)^2$$$.Venya asked you to write a program, which will guess the string by interacting with the orderlies' program and acting by the game's rules.Your program should immediately terminate after guessing the string using a query of the second type. In case your program guessed the string incorrectly, or it violated the game rules, it will receive verdict Wrong answer.Note that in every test case the string is fixed beforehand and will not change during the game, which means that the interactor is not adaptive. nan import sys
import copy
import string
from collections import defaultdict, Counter

def sortString(s):
    return ''.join(sorted(s))

def solve(p1, p2):
    p1 = Counter([sortString(s) for s in p1])
    p2 = Counter([sortString(s) for s in p2])

    for key in p2.keys():
        p1[key] -= p2[key]

    pp = []
    for key, value in p1.items():
        pp += [key] * value
    pp.sort(key=len)

    res = ''
    d = defaultdict(int)
    for bag in pp:
        counter = Counter(bag)
        cur = '#'
        for c in string.ascii_lowercase:
            if d[c] < counter[c]:
                assert cur == '#'
                cur = c
        res += cur
        d = counter
    return res

n = int(raw_input())

print '? 1 %d' % n
print ''
sys.stdout.flush()

p1 = []
m = (1 + n) * n / 2
for i in xrange(m):
    p1.append(raw_input().strip())

if n == 1:
    res = p1[0]
    print '! %s' % res
    print ''
    sys.stdout.flush()
else:
    print '? 2 %d' % n
    print ''
    sys.stdout.flush()

    p2 = []
    m = (1 + n - 1) * (n - 1) / 2
    for i in xrange(m):
        p2.append(raw_input().strip())

    res = solve(p1, p2)
    print '! %s' % res
    print ''
    sys.stdout.flush()
","['constructive algorithms', 'interactive']"
1018,"Bob has a simple undirected connected graph (without self-loops and multiple edges). He wants to learn whether his graph is bipartite (that is, you can paint all vertices of the graph into two colors so that there is no edge connecting two vertices of the same color) or not. As he is not very good at programming, he asked Alice for help. He does not want to disclose his graph to Alice, but he agreed that Alice can ask him some questions about the graph.The only question that Alice can ask is the following: she sends $$$s$$$ — a subset of vertices of the original graph. Bob answers with the number of edges that have both endpoints in $$$s$$$. Since he doesn't want Alice to learn too much about the graph, he allows her to ask no more than $$$20000$$$ questions. Furthermore, he suspects that Alice might introduce false messages to their communication channel, so when Alice finally tells him whether the graph is bipartite or not, she also needs to provide a proof — either the partitions themselves or a cycle of odd length.Your task is to help Alice to construct the queries, find whether the graph is bipartite.  NoteIn the first case, Alice learns that there are $$$4$$$ edges in the whole graph. Over the course of the next three queries, she learns that vertex $$$1$$$ has two neighbors: $$$3$$$ and $$$4$$$. She then learns that while vertex $$$2$$$ is adjacent to $$$4$$$, the vertex $$$3$$$ isn't adjacent to $$$4$$$. There is only one option for the remaining edge, and that is $$$(2, 3)$$$. This means that the graph is a cycle on four vertices, with $$$(1, 2)$$$ being one partition and $$$(3, 4)$$$ being the second. Here, it would be also valid to output ""3 4"" on the second line.In the second case, we also have a graph on four vertices and four edges. In the second query, Alice learns that there are three edges among vertices $$$(1, 2, 4)$$$. The only way this could possibly happen is that those form a triangle. As the triangle is not bipartite, Alice can report it as a proof. Notice that she does not learn where the fourth edge is, but she is able to answer Bob correctly anyway. from sys import stdout


def Ask(S1, S2, L, R):
    size = 0 if S2 is None else len(S2)

    if size == 0 and R - L < 2:
        return 0

    question = []

    for i in range(L, R):
        question.append(str(S1[i] + 1))

    for i in range(size):
        question.append(str(S2[i] + 1))

    stdout.write(""? "" + str(size + R - L) + ""\n"" + "" "".join(question) + ""\n"")
    stdout.flush()

    answer = int(input())

    if answer == -1:
        exit()

    return answer


def Binary_Search(S, check):
    L = 0
    R = len(S)

    while R - L > 1:
        middle = L + (R - L) // 2

        if check(S, L, middle):
            R = middle

        else:
            L = middle

    return S[L]


def Spanning_Build(v, S, father, set, sets):
    sets[v] = set
    S.remove(v)
    D = [v]

    while len(S) > 0 and Ask(S, D, 0, len(S)) != Ask(S, None, 0, len(S)):
        w = Binary_Search(S, lambda S_i, i, j: Ask(S_i, D, i, j) != Ask(S_i, None, i, j))
        father[w] = v
        Spanning_Build(w, S, father, not set, sets)


def Found_Edge(B):
    L = 0
    R = len(B)

    while R - L > 2:
        middle = L + (R - L) // 2

        if Ask(B, None, L, middle):
            R = middle

        elif Ask(B, None, middle, R):
                L = middle

        else:
            B_1 = B[L: middle]
            B_2 = B[middle: R]

            v = Binary_Search(B_1, lambda B_1i, i, j: Ask(B_1i, B_2, i, j) != 0)

            D = [v]

            w = Binary_Search(B_2, lambda B_2i, i, j: Ask(B_2i, D, i, j) != 0)

            return v, w

    return B[L], B[L + 1]


def Odd_Cycle(v, w, father):
    mark = [False for _ in range(len(father))]

    x = v

    while x != -1:
        mark[x] = True
        x = father[x]

    x = w

    while not mark[x]:
        x = father[x]

    first_middle = []
    second_middle = []

    while w != x:
        first_middle.append(str(w + 1))
        w = father[w]

    first_middle.append(str(x + 1))

    while v != x:
        second_middle.append(str(v + 1))
        v = father[v]

    stdout.write(""N "" + str(len(first_middle) + len(second_middle)) + ""\n"" + "" "".join(first_middle)
                     + "" "" + "" "".join(reversed(second_middle)) + ""\n"")
    stdout.flush()


n = int(input())

father = [-1 for _ in range(n)]
sets = [False for _ in range(n)]
S = [i for i in range(n)]

Spanning_Build(0, S, father, True, sets)

B = []
N = []

for i in range(n):
    if sets[i]:
        B.append(i)

    else:
        N.append(i)

if Ask(B, None, 0, len(B)) != 0:
    v, w = Found_Edge(B)
    Odd_Cycle(v, w, father)

elif Ask(N, None, 0, len(N)) != 0:
    v, w = Found_Edge(N)
    Odd_Cycle(v, w, father)

else:
    B = [str(v + 1) for v in B]
    stdout.write(""Y "" + str(len(B)) + ""\n"" + "" "".join(B) + ""\n"")
    stdout.flush()
","['binary search', 'constructive algorithms', 'dfs and similar', 'graphs', 'interactive']"
1044,"Katya studies in a fifth grade. Recently her class studied right triangles and the Pythagorean theorem. It appeared, that there are triples of positive integers such that you can construct a right triangle with segments of lengths corresponding to triple. Such triples are called Pythagorean triples.For example, triples (3, 4, 5), (5, 12, 13) and (6, 8, 10) are Pythagorean triples.Here Katya wondered if she can specify the length of some side of right triangle and find any Pythagorean triple corresponding to such length? Note that the side which length is specified can be a cathetus as well as hypotenuse.Katya had no problems with completing this task. Will you do the same? NoteIllustration for the first sample. import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,copy,functools
# import time,random,resource

# sys.setrecursionlimit(10**6)
inf = 10**20
eps = 1.0 / 10**10
mod = 10**9+7
mod2 = 998244353
dd = [(-1,0),(0,1),(1,0),(0,-1)]
ddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]

def LI(): return list(map(int, sys.stdin.readline().split()))
def LLI(): return [list(map(int, l.split())) for l in sys.stdin.readlines()]
def LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]
def LF(): return [float(x) for x in sys.stdin.readline().split()]
def LS(): return sys.stdin.readline().split()
def I(): return int(sys.stdin.readline())
def F(): return float(sys.stdin.readline())
def S(): return input()
def pf(s): return print(s, flush=True)
def pe(s): return print(str(s), file=sys.stderr)
def JA(a, sep): return sep.join(map(str, a))
def JAA(a, s, t): return s.join(t.join(map(str, b)) for b in a)
def IF(c, t, f): return t if c else f
def YES(c): return IF(c, ""YES"", ""NO"")
def Yes(c): return IF(c, ""Yes"", ""No"")


def main():
    t = 1

    rr = []
    for _ in range(t):
        n = I()

        k = 1
        while n % 2 == 0 and n != 4:
            k *= 2
            n //= 2

        if n == 1:
            rr.append(-1)
        elif n == 4:
            rr.append(JA([3*k,5*k], "" ""))
        else:
            t = n**2 // 2
            rr.append(JA([t*k,(t+1)*k], "" ""))

    return JA(rr, ""\n"")


print(main())


","['math', 'number theory']"
2297,"Ivan is a student at Berland State University (BSU). There are n days in Berland week, and each of these days Ivan might have some classes at the university.There are m working hours during each Berland day, and each lesson at the university lasts exactly one hour. If at some day Ivan's first lesson is during i-th hour, and last lesson is during j-th hour, then he spends j - i + 1 hours in the university during this day. If there are no lessons during some day, then Ivan stays at home and therefore spends 0 hours in the university.Ivan doesn't like to spend a lot of time in the university, so he has decided to skip some lessons. He cannot skip more than k lessons during the week. After deciding which lessons he should skip and which he should attend, every day Ivan will enter the university right before the start of the first lesson he does not skip, and leave it after the end of the last lesson he decides to attend. If Ivan skips all lessons during some day, he doesn't go to the university that day at all.Given n, m, k and Ivan's timetable, can you determine the minimum number of hours he has to spend in the university during one week, if he cannot skip more than k lessons? NoteIn the first example Ivan can skip any of two lessons during the first day, so he spends 1 hour during the first day and 4 hours during the second day.In the second example Ivan can't skip any lessons, so he spends 4 hours every day. n, m, k = map(int, raw_input().split())

a = [[] for i in xrange(n)]
for i in xrange(n):
    s = raw_input()
    for j in xrange(m):
        if s[j] == '1': a[i].append(j)

w = [([0] * (k + 1)) for i in xrange(n)]
for i in xrange(n):
    if len(a[i]) == 0: continue
    for j in xrange(k + 1):
        if len(a[i]) > j:
            w[i][j] = a[i][-1] - a[i][0] + 1
        else:
            w[i][j] = 0
            continue
        for x in xrange(j + 1):
            y = len(a[i]) - 1 - (j - x)
            if y >= x:
                t = a[i][y] - a[i][x] + 1
                w[i][j] = min(w[i][j], t)

dp = [[n * m for j in xrange(k + 1)] for i in xrange(n)]
for j in xrange(k + 1):
    dp[0][j] = w[0][j]

for i in xrange(1, n):
    for j in xrange(k + 1):
        for l in xrange(j + 1):
            dp[i][j] = min(dp[i][j], w[i][l] + dp[i - 1][j - l])

print dp[-1][-1]
",['dp']
4226,"There are n cities in the country where the Old Peykan lives. These cities are located on a straight line, we'll denote them from left to right as c1, c2, ..., cn. The Old Peykan wants to travel from city c1 to cn using roads. There are (n - 1) one way roads, the i-th road goes from city ci to city ci + 1 and is di kilometers long.The Old Peykan travels 1 kilometer in 1 hour and consumes 1 liter of fuel during this time.Each city ci (except for the last city cn) has a supply of si liters of fuel which immediately transfers to the Old Peykan if it passes the city or stays in it. This supply refreshes instantly k hours after it transfers. The Old Peykan can stay in a city for a while and fill its fuel tank many times. Initially (at time zero) the Old Peykan is at city c1 and s1 liters of fuel is transferred to it's empty tank from c1's supply. The Old Peykan's fuel tank capacity is unlimited. Old Peykan can not continue its travel if its tank is emptied strictly between two cities.Find the minimum time the Old Peykan needs to reach city cn. NoteIn the second sample above, the Old Peykan stays in c1 for 3 hours. import sys 
import math
#4
#1 3 2 0
m,k = [int(i) for i in sys.stdin.readline().split()]
d = [int(i) for i in sys.stdin.readline().split()]
s = [int(i) for i in sys.stdin.readline().split()]
 
### 0 closed closed 1 gym 2 contest 3 both
 
time = 0
oil = 0
max_val = 0
for i,val in enumerate(d):
    oil += s[i]
    if s[i] > max_val:
        max_val = s[i]
    if val <=  oil: ## you can move
        time += val
        oil -= val
    else:
        left = val - oil  ## the required gas
        ## if the required gas is less than
        times = math.ceil(left/max_val) ## time 
        oil += times * max_val
        time += val + times * k
        oil -= val
print(time)",['greedy']
3776,"Bob decided to take a break from calculus homework and designed a game for himself. The game is played on a sequence of piles of stones, which can be described with a sequence of integers $$$s_1, \ldots, s_k$$$, where $$$s_i$$$ is the number of stones in the $$$i$$$-th pile. On each turn, Bob picks a pair of non-empty adjacent piles $$$i$$$ and $$$i+1$$$ and takes one stone from each. If a pile becomes empty, its adjacent piles do not become adjacent. The game ends when Bob can't make turns anymore. Bob considers himself a winner if at the end all piles are empty.We consider a sequence of piles winning if Bob can start with it and win with some sequence of moves.You are given a sequence $$$a_1, \ldots, a_n$$$, count the number of subsegments of $$$a$$$ that describe a winning sequence of piles. In other words find the number of segments $$$[l, r]$$$ ($$$1 \leq l \leq r \leq n$$$), such that the sequence $$$a_l, a_{l+1}, \ldots, a_r$$$ is winning. NoteIn the first test case, Bob can't win on subsegments of length $$$1$$$, as there is no pair of adjacent piles in an array of length $$$1$$$.In the second test case, every subsegment is not winning.In the fourth test case, the subsegment $$$[1, 4]$$$ is winning, because Bob can make moves with pairs of adjacent piles: $$$(2, 3)$$$, $$$(1, 2)$$$, $$$(3, 4)$$$. Another winning subsegment is $$$[2, 3]$$$. ''' E. Game with Stones
https://codeforces.com/contest/1589/problem/E
'''

import io, os, sys
from math import e
input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline  # decode().strip() if str
output = sys.stdout.write


from types import GeneratorType
def bootstrap(f, stack=[]):
    def wrappedfunc(*args, **kwargs):
        if stack:
            return f(*args, **kwargs)
        else:
            to = f(*args, **kwargs)
            while True:
                if type(to) is GeneratorType:
                    stack.append(to)
                    to = next(to)
                else:
                    stack.pop()
                    if not stack:
                        break
                    to = stack[-1].send(to)
            return to
    return wrappedfunc


import random
random.seed(123)

class Node:
    def __init__(self, val, priority):
        self.val = val
        self.priority = priority
        self.count = 1
        self.left = None
        self.right = None
    
    def __repr__(self):
        return f'Node(val={self.val}, count={self.count})'


class Treap:
    '''Multiset treap, all nodes hold unique values'''
    def __init__(self):
        self.root = None
        self.size = 0
    
    def _rand(self):
        return random.randint(1,2**32)
    
    def find(self, val):
        '''find node holding val'''
        node = self.root
        while node:
            if node.val == val: break
            node = node.left if node.val > val else node.right
        return node

    @bootstrap
    def split(self, root, val):
        '''split subtree rooted here into 2 treaps: one < val, one >= val'''
        if not root: yield (None, None)
        if root.val < val:
            x, y = yield self.split(root.right, val)
            root.right = x
            yield (root, y)
        else:
            x, y = yield self.split(root.left, val)
            root.left = y
            yield (x, root)

    @bootstrap
    def merge(self, x, y):
        '''merge 2 treaps into new treap, assuming x vals <= y vals'''
        if not x or not y: yield x or y
        if x.priority > y.priority:  # make x root
            x.right = yield self.merge(x.right, y)
            yield x
        else:
            y.left = yield self.merge(x, y.left)
            yield y
 
    def insert(self, val):
        '''split current tree, then merge 2 trees with new node'''
        node = self.find(val)
        if node is not None:
            node.count += 1
        else:
            y = Node(val, self._rand())
            x, z = self.split(self.root, val)
            self.root = self.merge(self.merge(x, y), z)
        self.size += 1
    
    def delete(self, val, del_all=False):
        '''delete node with val, assuming int val'''
        node = self.find(val)
        if not node: return
        if not del_all and node.count > 1:
            node.count -= 1
            self.size -= 1
        else:  # remove entire node
            x, y = self.split(self.root, val)
            y, z = self.split(y, val+1)
            self.root = self.merge(x, z)
            self.size -= node.count
    
    def get_min(self):
        '''get min value'''
        node = self.root
        while node.left:
            node = node.left
        return node.val
 
    def get_max(self):
        '''get max value'''
        node = self.root
        while node.right:
            node = node.right
        return node.val
    
    def get_count(self, val):
        '''get num nodes with val'''
        node = self.find(val)
        return 0 if not node else node.count


# let S(l, r) = a[r] - a[r-1] + a[r-2] - ... + (-1)^(r-l) * a[l]
# then a[l..r] is winning if S(l, m) >= 0 and S(l, r) == 0 for m=l..r
 
# iterate i=1..N and track set of valid prefixes / potential segment starts
# * add S(1, i) to prefix set
# * remove all prefixes S(1, l) s.t. S(l, r) < 0; note S(l, r) = S(r, 1) - (-1)^(r-l) * S(l-1, 1)
# -> if S(1, l) remains, then S(i, l) >= 0 for i=l+1..r
# * num winning segments ending at r is num l s.t. S(l, r) == 0
 
def solve_treap(N, nums):
    # set of valid prefixes with even/odd length
    pref = [Treap(), Treap()]
    pref[0].insert(0)
 
    # running prefix
    res = p = 0
    for i, num in enumerate(nums):
        p = num - p
        sign, rsign = (i+1) % 2, i % 2
 
        # remove invalid prefixes
        while pref[sign].size > 0:
            mx = pref[sign].get_max()
            if p - mx >= 0: break
            pref[sign].delete(mx, del_all=True)
        while pref[rsign].size > 0:
            mn = pref[rsign].get_min()
            if p + mn >= 0: break
            pref[rsign].delete(mn, del_all=True)
 
        # num winning segs ending at i
        res += pref[sign].get_count(p)
        res += pref[rsign].get_count(-p)
 
        # add current sum
        pref[sign].insert(p)
 
    return res


from collections import deque

def solve_deque(N, nums):
    dq1, dq2 = deque([[0, 1]]), deque()  # (pref, count)
    res = p = 0
    for num in nums:
        p = num - p

        # remove invalid prefixes
        while dq1 and p - dq1[-1][0] < 0:
            dq1.pop()
        while dq2 and p + dq2[0][0] < 0:
            dq2.popleft()

        # num winning segs ending at i
        if dq1 and p - dq1[-1][0] == 0:
            res += dq1[-1][1]
        if dq2 and p + dq2[0][0] == 0:
            res += dq2[0][1]

        # add current sum
        # note p >= all remaining vals in dq1
        # so dq1 and dq2 are both increasing deque
        if dq1 and dq1[-1][0] == p:
            dq1[-1][1] += 1
        else:
            dq1.append([p, 1])

        dq1, dq2 = dq2, dq1

    return res


solve = solve_deque

def main():
    T = int(input())
    for _ in range(T):
        N = int(input())
        nums = list(map(int, input().split()))
        out = solve(N, nums)
        output(f'{out}\n')

if __name__ == '__main__':
    main()

","['binary search', 'data structures', 'games', 'greedy']"
4770,"When Masha came to math classes today, she saw two integer sequences of length $$$n - 1$$$ on the blackboard. Let's denote the elements of the first sequence as $$$a_i$$$ ($$$0 \le a_i \le 3$$$), and the elements of the second sequence as $$$b_i$$$ ($$$0 \le b_i \le 3$$$).Masha became interested if or not there is an integer sequence of length $$$n$$$, which elements we will denote as $$$t_i$$$ ($$$0 \le t_i \le 3$$$), so that for every $$$i$$$ ($$$1 \le i \le n - 1$$$) the following is true:   $$$a_i = t_i | t_{i + 1}$$$ (where $$$|$$$ denotes the bitwise OR operation) and  $$$b_i = t_i \&amp; t_{i + 1}$$$ (where $$$\&amp;$$$ denotes the bitwise AND operation). The question appeared to be too difficult for Masha, so now she asked you to check whether such a sequence $$$t_i$$$ of length $$$n$$$ exists. If it exists, find such a sequence. If there are multiple such sequences, find any of them. NoteIn the first example it's easy to see that the sequence from output satisfies the given conditions:   $$$t_1 | t_2 = (01_2) | (11_2) = (11_2) = 3 = a_1$$$ and $$$t_1 \&amp; t_2 = (01_2) \&amp; (11_2) = (01_2) = 1 = b_1$$$;  $$$t_2 | t_3 = (11_2) | (10_2) = (11_2) = 3 = a_2$$$ and $$$t_2 \&amp; t_3 = (11_2) \&amp; (10_2) = (10_2) = 2 = b_2$$$;  $$$t_3 | t_4 = (10_2) | (00_2) = (10_2) = 2 = a_3$$$ and $$$t_3 \&amp; t_4 = (10_2) \&amp; (00_2) = (00_2) = 0 = b_3$$$. In the second example there is no such sequence. from sys import stdin, stdout
n=0
A=[]
B=[]
res=[]
fA=[]
fB=[]
t=[]
for i in range(4):
    nA=[]
    nB=[]
    for j in range(4):
        nA.append((i | j))
        nB.append((i & j))
    fA.append(nA)
    fB.append(nB)

f=[]
for x in range(4):
    fx=[]
    for a in range(4):
        fxa=[]
        for b in range(4):
            fxab=[]
            for k in range(4):
                if ((a==x|k) and (b==x&k)):
                    fxab.append(k)
            fxa.append(set(fxab))
        fx.append(fxa)
    f.append(fx)

def trace():
    global t,res,n
    t=n*[0]
    t[n-1]=-1
    for x in range(4):
        if (len(res[n-2][x])>0):
            for y in res[n-2][x]:
                t[n-1]=y
                t[n-2]=x
                i=n-3
                while(i>=0):
                    for z in range(4):
                        if (t[i+1] in res[i][z]):
                            t[i]=z
                            break
                    i=i-1
            return True    
    return (t[n-1]>=0)
def main():
    global n,A,B,res,t
    n=int(stdin.readline())
    A=[int(x) for x in stdin.readline().split()]
    B=[int(x) for x in stdin.readline().split()]
    res=[]
    for i in range(n):
        res.append([set(),set(),set(),set()])
    s=set()
    for i in range(n-1):
        if (i==0):
            for x in range(4):
                res[0][x]=f[x][A[0]][B[0]]
                s=s.union(res[0][x])
        else:
            nSet=set({})
            for x in s:
                res[i][x]=f[x][A[i]][B[i]]
                nSet=nSet.union(res[i][x])
            if (len(nSet)==0):
                stdout.write(""NO"")
                return 0
            s=nSet
    
    if (trace()==False):
        stdout.write(""NO"")
        return 0
    else:
        sp="" ""
        stdout.write(""YES\n""+(sp.join(str(x) for x in t)))
    return 0

if __name__ == ""__main__"":
    main()",['dp']
4745,"Rats have bred to hundreds and hundreds in the basement of the store, owned by Vasily Petrovich. Vasily Petrovich may have not noticed their presence, but they got into the habit of sneaking into the warehouse and stealing food from there. Vasily Petrovich cannot put up with it anymore, he has to destroy the rats in the basement. Since mousetraps are outdated and do not help, and rat poison can poison inattentive people as well as rats, he chose a radical way: to blow up two grenades in the basement (he does not have more).In this problem, we will present the shop basement as a rectangular table of n × m cells. Some of the cells are occupied by walls, and the rest of them are empty. Vasily has been watching the rats and he found out that at a certain time they go to sleep, and all the time they sleep in the same places. He wants to blow up a grenade when this convenient time comes. On the plan of his basement, he marked cells with sleeping rats in them. Naturally, these cells are not occupied by walls.Grenades can only blow up in a cell that is not occupied by a wall. The blast wave from a grenade distributes as follows. We assume that the grenade blast occurs at time 0. During this initial time only the cell where the grenade blew up gets 'clear'. If at time t some cell is clear, then at time t + 1 those side-neighbouring cells which are not occupied by the walls get clear too (some of them could have been cleared before). The blast wave distributes for exactly d seconds, then it dies immediately.    An example of a distributing blast wave: Picture 1 shows the situation before the blast, and the following pictures show ""clear"" cells by time 0,1,2,3 and 4. Thus, the blast wave on the picture distributes for d = 4 seconds. Vasily Petrovich wonders, whether he can choose two cells to blast the grenades so as to clear all cells with sleeping rats. Write the program that finds it out. nan #! /usr/bin/env python2
 
import Queue
 
inFile = open(""input.txt"", 'r')
outFile = open(""output.txt"", 'w')
 
n, m, d = map(int, inFile.readline().strip().split(' '))
mat = map(lambda x: x.strip(), inFile.readlines())
mv = [(0, 1), (0, -1), (1, 0), (-1, 0)]
 
def findRats():
    ret = []
    for i in xrange(n):
        for j in xrange(m):
            if mat[i][j] == 'R':
                ret.append((i, j))
    return ret
 
def bfs(bgn, mat, d):
    q = Queue.Queue()
    q.put(bgn)
    c = {bgn:0}
    ret = set()
    while not q.empty():
        now = q.get()
        ret.add(now)
        if c[now] < d:
            for mi in mv:
                then = (now[0] + mi[0], now[1] + mi[1])
                if then[0] < n and then[0] >= 0 and \
                        then[1] < m and then[1] >= 0:
                    if mat[then[0]][then[1]] != 'X':
                        if then not in c:
                            q.put(then)
                            c[then] = c[now] + 1
    return ret
 
def find(firsts, locs):
    for first in firsts:
        others = []
        for loc in locs:
            if first not in loc:
                others.append(loc)
        if len(others) == 0:
            ans = [first]
            for i in xrange(n):
                for j in xrange(m):
                    if (i, j) != first:
                        if mat[i][j] != 'X':
                            ans.append((i, j))
                            return ans
            return -1
        seconds = reduce(lambda x, y: x & y, others)
        for second in seconds:
            if second != first:
                return (first, second)
    return -1
 
rats = findRats()
if len(rats) > ((d + 1) * 2) ** 2:
    outFile.write('-1\n')
else:
    locs = []
    for r in rats:
        locs.append(bfs(r, mat, d))
    ans = find(locs[0], locs[1:])
    if ans == -1:
        outFile.write('-1\n')
    else:
        outFile.write(""{:d} {:d} {:d} {:d}"". \
                          format(ans[0][0] + 1,
                                 ans[0][1] + 1,
                                 ans[1][0] + 1, 
                                 ans[1][1] + 1))
","['brute force', 'dfs and similar', 'graphs', 'implementation', 'shortest paths']"
298,"You and your friend are participating in a TV show ""Run For Your Prize"".At the start of the show n prizes are located on a straight line. i-th prize is located at position ai. Positions of all prizes are distinct. You start at position 1, your friend — at position 106 (and there is no prize in any of these two positions). You have to work as a team and collect all prizes in minimum possible time, in any order.You know that it takes exactly 1 second to move from position x to position x + 1 or x - 1, both for you and your friend. You also have trained enough to instantly pick up any prize, if its position is equal to your current position (and the same is true for your friend). Carrying prizes does not affect your speed (or your friend's speed) at all.Now you may discuss your strategy with your friend and decide who will pick up each prize. Remember that every prize must be picked up, either by you or by your friend.What is the minimum number of seconds it will take to pick up all the prizes? NoteIn the first example you take all the prizes: take the first at 1, the second at 2 and the third at 8.In the second example you take the first prize in 1 second and your friend takes the other in 5 seconds, you do this simultaneously, so the total time is 5. # stdin.readline()
# int(stdin.readline())
# stdout.write()
# raw_input()
# map(int,raw_input().split())
# map(int,stdin.readline().split())
def main():
    an = """"
    n=input()
    a=map(int,stdin.readline().split())
    z=1000000000000000000000
    for i in xrange(n-1):
        z=min(z,max(a[i]-1,(10**6)-a[i+1]))
    z=min(z,a[n-1]-1)
    z=min(z,10**6-a[0])
    print z
    stdout.write(an)
if __name__ == ""__main__"":
    from sys import stdin, stdout
    main()","['brute force', 'greedy']"
4345,"The popular improv website Interpretation Impetus hosts regular improv contests and maintains a rating of the best performers. However, since improv can often go horribly wrong, the website is notorious for declaring improv contests unrated. It now holds a wager before each improv contest where the participants try to predict whether it will be rated or unrated, and they are now more popular than the improv itself.Izzy and $$$n$$$ other participants take part in each wager. First, they each make their prediction, expressed as 1 (""rated"") or 0 (""unrated""). Izzy always goes last, so she knows the predictions of the other participants when making her own. Then, the actual competition takes place and it is declared either rated or unrated.You need to write a program that will interactively play as Izzy. There will be $$$m$$$ wagers held in 2021, and Izzy's goal is to have at most $$$1.3\cdot b + 100$$$ wrong predictions after all those wagers, where $$$b$$$ is the smallest number of wrong predictions that any other wager participant will have after all those wagers. The number $$$b$$$ is not known in advance. Izzy also knows nothing about the other participants — they might somehow always guess correctly, or their predictions might be correlated. Izzy's predictions, though, do not affect the predictions of the other participants and the decision on the contest being rated or not — in other words, in each test case, your program always receives the same inputs, no matter what it outputs. NoteIn the example, the participants made 1, 2, and 3 mistakes respectively, therefore $$$b=1$$$ (the smallest of these numbers). Izzy made 3 mistakes, which were not more than $$$1.3\cdot b + 100=101.3$$$, so these outputs are good enough to pass this test case (as are any other valid outputs). import math
from sys import stdout
from typing import List


def get_guesses() -> List[int]:
    inp = input()
    return [-1 if x == '0' else 1 for x in inp]


def guess(answer: int) -> None:
    print(answer)
    stdout.flush()


def get_ans() -> int:
    true_ans = int(input())
    return true_ans


def solve():
    n, m = list(map(int, (input().split("" ""))))
    lr = .01
    weights = [.0] * n
    weights.append(0.0)  # bias
    for i in range(m):
        g = get_guesses()
        g.append(1)
        weighted_sum = sum([weights[j] * g[j] for j in range(len(g))])
        guess(1 if weighted_sum > 0 else 0)
        sig_out = 1 / (1.0 + math.exp(-weighted_sum))
        error = sig_out - get_ans()
        # Square error
        gradient = [g[i] * sig_out * (1 - sig_out) *
                    error for i in range(len(g))]
        weights = [weights[i] - gradient[i] * lr for i in range(len(weights))]

solve()
","['greedy', 'interactive', 'math', 'probabilities']"
2483,"There are $$$n$$$ cities in Berland. The city numbered $$$1$$$ is the capital. Some pairs of cities are connected by a one-way road of length 1.Before the trip, Polycarp for each city found out the value of $$$d_i$$$ — the shortest distance from the capital (the $$$1$$$-st city) to the $$$i$$$-th city.Polycarp begins his journey in the city with number $$$s$$$ and, being in the $$$i$$$-th city, chooses one of the following actions:   Travel from the $$$i$$$-th city to the $$$j$$$-th city if there is a road from the $$$i$$$-th city to the $$$j$$$-th and $$$d_i &lt; d_j$$$;  Travel from the $$$i$$$-th city to the $$$j$$$-th city if there is a road from the $$$i$$$-th city to the $$$j$$$-th and $$$d_i \geq d_j$$$;  Stop traveling. Since the government of Berland does not want all people to come to the capital, so Polycarp no more than once can take the second action from the list. in other words, he can perform the second action $$$0$$$ or $$$1$$$ time during his journey. Polycarp, on the other hand, wants to be as close to the capital as possible.  For example, if $$$n = 6$$$ and the cities are connected, as in the picture above, then Polycarp could have made the following travels (not all possible options):   $$$2 \rightarrow 5 \rightarrow 1 \rightarrow 2 \rightarrow 5$$$;  $$$3 \rightarrow 6 \rightarrow 2$$$;  $$$1 \rightarrow 3 \rightarrow 6 \rightarrow 2 \rightarrow 5$$$. Polycarp wants for each starting city $$$i$$$ to find out how close he can get to the capital. More formally: he wants to find the minimal value of $$$d_j$$$ that Polycarp can get from the city $$$i$$$ to the city $$$j$$$ according to the rules described above. nan import sys, math
#sys.setrecursionlimit(10**6)
INF = float('inf')
mod = 10**9 + 7
#mod = 998244353
input = lambda: sys.stdin.readline().rstrip()
li = lambda: list(map(int, input().split()))
from collections import deque

def bfs(start):
    queue = deque([start])
    seen = [INF] * N
    seen[start] = 0
    while queue:
        x = queue.popleft()
        for y in G[x]:
            if seen[y] < INF:
                continue
            seen[y] = seen[x] + 1
            queue.append(y)
    return seen


t = int(input())
output = []
for _ in range(t):
    input()
    N, M = li()
    AB = [li() for _ in range(M)]
    G = [[] for _ in range(N)]
    for i in range(M):
        a, b = AB[i]
        a -= 1; b -= 1
        G[a].append(b)
    dist = bfs(0)
    ans = bfs(0)
    for i in range(N):
        for j in G[i]:
            ans[i] = min(ans[i], dist[j])

    G2 = [[] for _ in range(N)]
    rG2 = [[] for _ in range(N)]
    for i in range(M):
        a, b = AB[i]
        a -= 1; b -= 1
        if dist[a] < dist[b]:
            G2[a].append(b)
            rG2[b].append(a)
    
    dq = deque()
    deg = [0] * N
    for i in range(N):
        if len(G2[i]) == 0:
            dq.append(i)
        deg[i] = len(G2[i])
    seen = [0] * N

    while dq:
        x = dq.popleft()
        for y in G2[x]:
            ans[x] = min(ans[x], ans[y])
        for y in rG2[x]:
            deg[y] -= 1
            if not deg[y]:
                dq.append(y)
    output.append(ans)



    



    
    

for o in output:
    print(*o)
    ","['dfs and similar', 'dp', 'graphs', 'shortest paths']"
4434,"Sakuzyo - ImprintingA.R.C. Markland-N is a tall building with $$$n$$$ floors numbered from $$$1$$$ to $$$n$$$. Between each two adjacent floors in the building, there is a staircase connecting them.It's lunchtime for our sensei Colin ""ConneR"" Neumann Jr, and he's planning for a location to enjoy his meal.ConneR's office is at floor $$$s$$$ of the building. On each floor (including floor $$$s$$$, of course), there is a restaurant offering meals. However, due to renovations being in progress, $$$k$$$ of the restaurants are currently closed, and as a result, ConneR can't enjoy his lunch there.CooneR wants to reach a restaurant as quickly as possible to save time. What is the minimum number of staircases he needs to walk to reach a closest currently open restaurant.Please answer him quickly, and you might earn his praise and even enjoy the lunch with him in the elegant Neumanns' way! NoteIn the first example test case, the nearest floor with an open restaurant would be the floor $$$4$$$.In the second example test case, the floor with ConneR's office still has an open restaurant, so Sensei won't have to go anywhere.In the third example test case, the closest open restaurant is on the $$$6$$$-th floor. a=int(input())
r=0
d=list()
while r<a:
    k=0
    b=[int(b) for b in input().split()]
    #print('b = ',b)
    c=[int(c) for c in input().split()]
    #print('c = ',c)
    if b[1] not in c:
        k=0
    else:
        t=1
        while t<=min(max(b[1],b[0]-b[1]),1005):
            #print(t)
            if (b[1]+t) not in c and b[1]+t<b[0]+1:
                #print('fffffffffffffffff')
                k=k+1
                break
            elif (b[1]-t) not in c and b[1]-t>0:
                k=k+1
                break
            else:
                #print('3333333333333333333333333')
                k=k+1
            #print(b[1]+t)
            t=t+1
    d.append(k)
    #print(k)
    r=r+1
r=0
while r<a:
    print(d[r])
    r=r+1
","['binary search', 'brute force', 'implementation']"
1534,"Methodius received an email from his friend Polycarp. However, Polycarp's keyboard is broken, so pressing a key on it once may cause the corresponding symbol to appear more than once (if you press a key on a regular keyboard, it prints exactly one symbol).For example, as a result of typing the word ""hello"", the following words could be printed: ""hello"", ""hhhhello"", ""hheeeellllooo"", but the following could not be printed: ""hell"", ""helo"", ""hhllllooo"".Note, that when you press a key, the corresponding symbol must appear (possibly, more than once). The keyboard is broken in a random manner, it means that pressing the same key you can get the different number of letters in the result.For each word in the letter, Methodius has guessed what word Polycarp actually wanted to write, but he is not sure about it, so he asks you to help him.You are given a list of pairs of words. For each pair, determine if the second word could be printed by typing the first one on Polycarp's keyboard. nan for _ in range(int(input())):
    a = input()
    b = input()
    l1,l2 = len(a),len(b)
    f = 1
    i,j = 0,0
    while i < l1:
        last = a[i]
        c = 0
        while i < l1 and a[i] == last:
            c += 1
            i += 1
        p = 0
        while j < l2 and b[j] == last:
            p += 1
            j += 1
        if p < c:
            f = 0
            break
    #print(i,j)
    if f and j == l2: print(""YES"")
    else: print(""NO"")","['implementation', 'strings']"
1726,"Mocha is a young girl from high school. She has learned so much interesting knowledge from her teachers, especially her math teacher. Recently, Mocha is learning about binary system and very interested in bitwise operation.This day, Mocha got a sequence $$$a$$$ of length $$$n$$$. In each operation, she can select an arbitrary interval $$$[l, r]$$$ and for all values $$$i$$$ ($$$0\leq i \leq r-l$$$), replace $$$a_{l+i}$$$ with $$$a_{l+i} \,\&amp;\, a_{r-i}$$$ at the same time, where $$$\&amp;$$$ denotes the bitwise AND operation. This operation can be performed any number of times.For example, if $$$n=5$$$, the array is $$$[a_1,a_2,a_3,a_4,a_5]$$$, and Mocha selects the interval $$$[2,5]$$$, then the new array is $$$[a_1,a_2\,\&amp;\, a_5, a_3\,\&amp;\, a_4, a_4\,\&amp;\, a_3, a_5\,\&amp;\, a_2]$$$.Now Mocha wants to minimize the maximum value in the sequence. As her best friend, can you help her to get the answer? NoteIn the first test case, Mocha can choose the interval $$$[1,2]$$$, then the sequence becomes $$$[ 0, 0]$$$, where the first element is $$$1\,\&amp;\,2$$$, and the second element is $$$2\,\&amp;\,1$$$.In the second test case, Mocha can choose the interval $$$[1,3]$$$, then the sequence becomes $$$[ 1,1,1]$$$, where the first element is $$$1\,\&amp;\,3$$$, the second element is $$$1\,\&amp;\,1$$$, and the third element is $$$3\,\&amp;\,1$$$. for _ in range(int(input())):
    n=int(input())
    a=list(map(int,input().split()))
    x=a[0]
    for i in range(1,n):
        x=a[i]&x
        if x==0:
            break
    print(x)","['bitmasks', 'constructive algorithms', 'math']"
4327,"You are given a forest — an undirected graph with $$$n$$$ vertices such that each its connected component is a tree.The diameter (aka ""longest shortest path"") of a connected undirected graph is the maximum number of edges in the shortest path between any pair of its vertices.You task is to add some edges (possibly zero) to the graph so that it becomes a tree and the diameter of the tree is minimal possible.If there are multiple correct answers, print any of them. NoteIn the first example adding edges (1, 4) or (3, 4) will lead to a total diameter of 3. Adding edge (2, 4), however, will make it 2.Edge (1, 2) is the only option you have for the second example. The diameter is 1.You can't add any edges in the third example. The diameter is already 2. import sys,math
from collections import defaultdict
from io import BytesIO

sys.stdin = BytesIO(sys.stdin.read())
input = lambda: sys.stdin.readline().rstrip('\r\n')
#n = int(input())
n,k = [int(x) for x in input().split(' ')]
#arr = [int(x) for x in input().split(' ')]

def makesv(v):
    s = {v}
    sviaz[v] = nsv
    while len(s):
        cur = s.pop()
        for el in ds[cur]:
            if sviaz[el] == 0:
                sviaz[el] = nsv
                s.add(el)
                

sviaz = [0] * n
ds = defaultdict(set)
dcop = defaultdict(set)
for _ in range(k):
    s,f = [int(x)-1 for x in input().split(' ')]
    ds[s].add(f)
    ds[f].add(s)
    dcop[s].add(f)
    dcop[f].add(s)
nsv = 0
for i in range(n):
    if sviaz[i] > 0:
        continue
    else:
        nsv += 1
        makesv(i)
#print(ds,sviaz)

def countmain(ind):
    sc = set()
    for i in range(len(sviaz)):
        if sviaz[i] == ind:
            sc.add(i)
    curl = 0
    while len(sc) > 2:
        leaves = set()
        for el in sc:
            if len(ds[el]) < 2:
                leaves.add(el)
        while len(sc) > 2:
            curl += 1
            newleaves = set()
            for v in leaves:
                sc.remove(v)
                for el in ds[v]:
                    ds[el].remove(v)
                    if len(ds[el]) < 2:
                        newleaves.add(el)
            leaves = newleaves
    if len(sc) == 2:
        return (curl+1,curl,sc.pop())
    elif len(sc) == 1:
        return (curl,curl,sc.pop())
re = list()
for ind in range(1,nsv+1):
    fdist,sdist,curv = countmain(ind)
    re.append((fdist,sdist,curv))


re.sort(reverse = True)
#print(re)
md = re[0][0]
sd = re[0][1]
newv = list()
for i in range(1,len(re)):
    newv.append((str(re[0][2]+1),str(re[i][2]+1)))
    newmd = re[i][0]
    newsd = re[i][1]
    if newmd+1 > md:
        sd = md
        md = newmd + 1
    elif newmd + 1 > sd:
        sd = newmd + 1
print(md + sd)
for el in newv:
    print(' '.join(el))

","['constructive algorithms', 'dfs and similar', 'greedy', 'trees']"
1175,"On a beach there are $$$n$$$ huts in a perfect line, hut $$$1$$$ being at the left and hut $$$i+1$$$ being $$$100$$$ meters to the right of hut $$$i$$$, for all $$$1 \le i \le n - 1$$$. In hut $$$i$$$ there are $$$p_i$$$ people.There are $$$m$$$ ice cream sellers, also aligned in a perfect line with all the huts. The $$$i$$$-th ice cream seller has their shop $$$x_i$$$ meters to the right of the first hut. All ice cream shops are at distinct locations, but they may be at the same location as a hut.You want to open a new ice cream shop and you wonder what the best location for your shop is. You can place your ice cream shop anywhere on the beach (not necessarily at an integer distance from the first hut) as long as it is aligned with the huts and the other ice cream shops, even if there is already another ice cream shop or a hut at that location. You know that people would come to your shop only if it is strictly closer to their hut than any other ice cream shop.If every person living in the huts wants to buy exactly one ice cream, what is the maximum number of ice creams that you can sell if you place the shop optimally? NoteIn the first sample, you can place the shop (coloured orange in the picture below) $$$150$$$ meters to the right of the first hut (for example) so that it is the closest shop to the first two huts, which have $$$2$$$ and $$$5$$$ people, for a total of $$$7$$$ sold ice creams.  In the second sample, you can place the shop $$$170$$$ meters to the right of the first hut (for example) so that it is the closest shop to the last two huts, which have $$$7$$$ and $$$8$$$ people, for a total of $$$15$$$ sold ice creams.   import bisect
import functools
import heapq
import itertools
import math
import operator
import re
import sys
import typing
from collections import Counter, defaultdict, deque
from functools import reduce
import sys
input=sys.stdin.readline
'''
INF = 1 << 31
r,g,b=map(int,input().split())
dp = [[INF] * 901 for _ in range(1000)]
for i in range(900):
    dp[i][0] = 0
for i in range(1000):
    pos = i - 500
    for j in range(1,r+g+b+1):
        if j <= r:
            dp[i][j] = min(dp[i][j],dp[i-1][j-1]+abs(pos+100))
        elif j <= r + g:
            dp[i][j] = min(dp[i][j],dp[i-1])
'''
import sys
import os
from io import BytesIO, IOBase
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
n,m=map(int,input().split())
p=list(map(int,input().split()))
cumsum = list(itertools.accumulate(p))
x=list(map(int,input().split()))
x.sort()
ans = 0
for i in range(m+1):
    if i == 0:
        pos = (x[0] - 1) // 100
        ans = max(ans,sum(p[:min(pos+1,n)]))
        #print(ans)
    elif i == m:
        pos = x[-1] // 100
        ans = max(ans,cumsum[-1]-cumsum[min(pos,n-1)])
    else:
        dis = x[i] - x[i-1]
        f = (dis - 1) // 2
        ff = f // 100
        pre = x[i-1] // 100
        suf = (x[i] - 1) // 100
        for j in range(pre,suf):
            ans = max(ans,cumsum[min(n-1,suf,j+ff+1)]-cumsum[min(n-1,j)])

print(ans)
","['brute force', 'implementation', 'sortings']"
3179,"Polycarpus has n friends in Tarasov city. Polycarpus knows phone numbers of all his friends: they are strings s1, s2, ..., sn. All these strings consist only of digits and have the same length. Once Polycarpus needed to figure out Tarasov city phone code. He assumed that the phone code of the city is the longest common prefix of all phone numbers of his friends. In other words, it is the longest string c which is a prefix (the beginning) of each si for all i (1 ≤ i ≤ n). Help Polycarpus determine the length of the city phone code.  NoteA prefix of string t is a string that is obtained by deleting zero or more digits from the end of string t. For example, string ""00209"" has 6 prefixes: """" (an empty prefix), ""0"", ""00"", ""002"", ""0020"", ""00209"".In the first sample the city phone code is string ""00"".In the second sample the city phone code is an empty string.In the third sample the city phone code is string ""770123456789"". n=int(input())
a=[]
for i in range(n):
    a.append(input())
s=''
k=a[0]
j=0
r=0
for i in k:
    for ii in a:
        if ii[j]==k[j]:
            pass
        else:
            r=1
            break
    else:
        s=s+k[j]
    if r==1:
        break
    j=j+1
print(len(s))
        
    ","['brute force', 'implementation', 'other']"
927,"Of course our child likes walking in a zoo. The zoo has n areas, that are numbered from 1 to n. The i-th area contains ai animals in it. Also there are m roads in the zoo, and each road connects two distinct areas. Naturally the zoo is connected, so you can reach any area of the zoo from any other area using the roads.Our child is very smart. Imagine the child want to go from area p to area q. Firstly he considers all the simple routes from p to q. For each route the child writes down the number, that is equal to the minimum number of animals among the route areas. Let's denote the largest of the written numbers as f(p, q). Finally, the child chooses one of the routes for which he writes down the value f(p, q).After the child has visited the zoo, he thinks about the question: what is the average value of f(p, q) for all pairs p, q (p ≠ q)? Can you answer his question? NoteConsider the first sample. There are 12 possible situations:  p = 1, q = 3, f(p, q) = 10.  p = 2, q = 3, f(p, q) = 20.  p = 4, q = 3, f(p, q) = 30.  p = 1, q = 2, f(p, q) = 10.  p = 2, q = 4, f(p, q) = 20.  p = 4, q = 1, f(p, q) = 10. Another 6 cases are symmetrical to the above. The average is .Consider the second sample. There are 6 possible situations:  p = 1, q = 2, f(p, q) = 10.  p = 2, q = 3, f(p, q) = 20.  p = 1, q = 3, f(p, q) = 10. Another 3 cases are symmetrical to the above. The average is . n, m = map(int, input().split())
p, c = list(range(n + 1)), [1] * (n + 1)
v = [0] + list(map(int, input().split()))
s, e = 0, [()] * m
for i in range(m):
    x, y = map(int, input().split())
    e[i] = (x, y, min(v[x], v[y]))
e.sort(key = lambda x: x[2], reverse = True)
q = [[i] for i in range(n + 1)]
for l, r, v in e:
    l, r = p[l], p[r]
    if l == r: continue
    if len(q[l]) > len(q[r]): l, r = r, l
    q[r].extend(q[l])
    for t in q[l]: p[t] = r
    s += c[l] * c[r] * v
    c[r] += c[l]
print(s * 2 / (n * (n - 1)))
","['dsu', 'sortings']"
2422,"One day, after a difficult lecture a diligent student Sasha saw a graffitied desk in the classroom. She came closer and read: ""Find such positive integer n, that among numbers n + 1, n + 2, ..., 2·n there are exactly m numbers which binary representation contains exactly k digits one"".The girl got interested in the task and she asked you to help her solve it. Sasha knows that you are afraid of large numbers, so she guaranteed that there is an answer that doesn't exceed 1018. nan import functools as f
m,k=map(int,raw_input().split())
j=1
k-=1
for i in xrange(69,-1,-1):
    n=f.reduce(lambda x,y:x*(i-y)/(y+1),range(k),1)
    if n<m:
        j+=1<<i
        m-=n
        k-=1
print j

","['binary search', 'bitmasks', 'combinatorics', 'dp', 'math']"
1747,"Dima worked all day and wrote down on a long paper strip his favorite number $$$n$$$ consisting of $$$l$$$ digits. Unfortunately, the strip turned out to be so long that it didn't fit in the Dima's bookshelf.To solve the issue, Dima decided to split the strip into two non-empty parts so that each of them contains a positive integer without leading zeros. After that he will compute the sum of the two integers and write it down on a new strip.Dima wants the resulting integer to be as small as possible, because it increases the chances that the sum will fit it in the bookshelf. Help Dima decide what is the minimum sum he can obtain. NoteIn the first example Dima can split the number $$$1234567$$$ into integers $$$1234$$$ and $$$567$$$. Their sum is $$$1801$$$.In the second example Dima can split the number $$$101$$$ into integers $$$10$$$ and $$$1$$$. Their sum is $$$11$$$. Note that it is impossible to split the strip into ""1"" and ""01"" since the numbers can't start with zeros. n=int(input())
s=input()
mid=len(s)//2
l=mid
r=mid+1
while l>=0 and s[l]=='0':
    l-=1
while r<n and s[r]=='0':
    r+=1
if l==0:
    print(int(s[:r])+int(s[r:]))
elif r==n:
    print(int(s[:l])+int(s[l:]))
else:
    print(min(int(s[:r])+int(s[r:]),int(s[:l])+int(s[l:])))
    ","['greedy', 'implementation', 'strings']"
3475,"Gleb ordered pizza home. When the courier delivered the pizza, he was very upset, because several pieces of sausage lay on the crust, and he does not really like the crust.The pizza is a circle of radius r and center at the origin. Pizza consists of the main part — circle of radius r - d with center at the origin, and crust around the main part of the width d. Pieces of sausage are also circles. The radius of the i -th piece of the sausage is ri, and the center is given as a pair (xi, yi).Gleb asks you to help determine the number of pieces of sausage caught on the crust. A piece of sausage got on the crust, if it completely lies on the crust. NoteBelow is a picture explaining the first example. Circles of green color denote pieces of sausage lying on the crust.   #RAVENS
#TEAM_2
#ESSI-DAYI_MOHSEN-LORENZO

from math import sqrt
r,d=map(int,input().split())
c=0
for i in range(int(input())):
    x,y,rr=map(int,input().split())
    b=sqrt(x**2+y**2)
    if(b<=abs(r-rr) and b>=(r-d+rr)):
        c+=1
print(c)",['geometry']
1831,"Основой любой социальной сети является отношение дружбы между двумя пользователями в том или ином смысле. В одной известной социальной сети дружба симметрична, то есть если a является другом b, то b также является другом a. В этой же сети есть функция, которая демонстрирует множество людей, имеющих высокую вероятность быть знакомыми для пользователя. Эта функция работает следующим образом. Зафиксируем пользователя x. Пусть некоторый другой человек y, не являющийся другом x на текущий момент, является другом не менее, чем для k% друзей x. Тогда он является предполагаемым другом для x.У каждого человека в социальной сети есть свой уникальный идентификатор — это целое число от 1 до 109. Вам дан список пар пользователей, являющихся друзьями. Определите для каждого упомянутого пользователя множество его предполагаемых друзей. nan # import sys

# sys.stdin = open('a.in')

m, k = (int(x) for x in raw_input().split())

f = {}
ff = {}
all_users = set()

for i in range(m):
    a, b = (int(x) for x in raw_input().split())

    f.setdefault(a, set()).add(b)
    f.setdefault(b, set()).add(a)
    all_users.add(a)
    all_users.add(b)

for x in f:
    ff.setdefault(x, {})
    for y in f[x]:
        for z in f[y]:
            if z not in f[x]:
                ff[x].setdefault(z, 0) 
                ff[x][z] += 1

#print(f, ff)

for x in sorted(f):
    fl = []
    l = len(f[x])
    for y in all_users:
        if y == x or y in f[x]:
            continue
        v = ff[x].get(y, 0)
        #print(x, y, v, l, 100*v/l, k)
        if 100 * v >= l * k:
            fl.append(y)
    print(""{}: {} {}"".format(x, len(fl), "" "".join(str(t) for t in sorted(fl))))",['implementation']
1126,"Unfortunately, Vasya can only sum pairs of integers (a, b), such that for any decimal place at least one number has digit 0 in this place. For example, Vasya can sum numbers 505 and 50, but he cannot sum 1 and 4.Vasya has a set of k distinct non-negative integers d1, d2, ..., dk.Vasya wants to choose some integers from this set so that he could sum any two chosen numbers. What maximal number of integers can he choose in the required manner? nan input()
A = map(int, raw_input().split())
ans = []
for i in A:
  if i in range(1, 10):
    ans += [i]
    break
for i in A:
  if i in range(10, 100, 10):
    ans += [i]
    break
if len(ans) == 0:
  for i in A:
    if i not in (0, 100):
      ans += [i]
      break
if 100 in A:
  ans += [100]
if 0 in A:
  ans += [0]
print(len(ans))
print("" "".join(map(str,ans)))","['brute force', 'constructive algorithms', 'implementation']"
4786,"You have a list of numbers from $$$1$$$ to $$$n$$$ written from left to right on the blackboard.You perform an algorithm consisting of several steps (steps are $$$1$$$-indexed). On the $$$i$$$-th step you wipe the $$$i$$$-th number (considering only remaining numbers). You wipe the whole number (not one digit).  When there are less than $$$i$$$ numbers remaining, you stop your algorithm. Now you wonder: what is the value of the $$$x$$$-th remaining number after the algorithm is stopped? nan import sys
import math
from collections import defaultdict,deque

input = sys.stdin.readline
def inar():
    return [int(el) for el in input().split()]
def main():
    t=int(input())
    for _ in range(t):
        n,x=inar()
        print(x*2)




if __name__ == '__main__':
    main()



",['math']
376,"Bob watches TV every day. He always sets the volume of his TV to $$$b$$$. However, today he is angry to find out someone has changed the volume to $$$a$$$. Of course, Bob has a remote control that can change the volume.There are six buttons ($$$-5, -2, -1, +1, +2, +5$$$) on the control, which in one press can either increase or decrease the current volume by $$$1$$$, $$$2$$$, or $$$5$$$. The volume can be arbitrarily large, but can never be negative. In other words, Bob cannot press the button if it causes the volume to be lower than $$$0$$$.As Bob is so angry, he wants to change the volume to $$$b$$$ using as few button presses as possible. However, he forgets how to do such simple calculations, so he asks you for help. Write a program that given $$$a$$$ and $$$b$$$, finds the minimum number of presses to change the TV volume from $$$a$$$ to $$$b$$$. NoteIn the first example, Bob can press the $$$-2$$$ button twice to reach $$$0$$$. Note that Bob can not press $$$-5$$$ when the volume is $$$4$$$ since it will make the volume negative. In the second example, one of the optimal ways for Bob is to press the $$$+5$$$ twice, then press $$$-1$$$ once.In the last example, Bob can press the $$$+5$$$ once, then press $$$+1$$$.  for _ in range(int(input())):
    s = list(map(int, input().split()))
    t = 0
    k = abs(s[1] - s[0])
    a = k / 5
    b = k % 5
    if a == 0:
        if b == 0:
            print(int(t))
            continue
        elif 3 > b > 0:
            t += 1
        elif 5 > b >= 3:
            t += 2
    else:
        t += a
        if b == 0:
            print(int(t))
            continue
        elif 3 > b > 0:
            t += 1
        elif 5 > b >= 3:
            t += 2
    print(int(t))",['math']
2131,"Given a tree with $$$n$$$ nodes numbered from $$$1$$$ to $$$n$$$. Each node $$$i$$$ has an associated value $$$V_i$$$.If the simple path from $$$u_1$$$ to $$$u_m$$$ consists of $$$m$$$ nodes namely $$$u_1 \rightarrow u_2 \rightarrow u_3 \rightarrow \dots u_{m-1} \rightarrow u_{m}$$$, then its alternating function $$$A(u_{1},u_{m})$$$ is defined as $$$A(u_{1},u_{m}) = \sum\limits_{i=1}^{m} (-1)^{i+1} \cdot V_{u_{i}}$$$. A path can also have $$$0$$$ edges, i.e. $$$u_{1}=u_{m}$$$.Compute the sum of alternating functions of all unique simple paths. Note that the paths are directed: two paths are considered different if the starting vertices differ or the ending vertices differ. The answer may be large so compute it modulo $$$10^{9}+7$$$.  NoteConsider the first example.A simple path from node $$$1$$$ to node $$$2$$$: $$$1 \rightarrow 2$$$ has alternating function equal to $$$A(1,2) = 1 \cdot (-4)+(-1) \cdot 1 = -5$$$.A simple path from node $$$1$$$ to node $$$3$$$: $$$1 \rightarrow 3$$$ has alternating function equal to $$$A(1,3) = 1 \cdot (-4)+(-1) \cdot 5 = -9$$$.A simple path from node $$$2$$$ to node $$$4$$$: $$$2 \rightarrow 1 \rightarrow 4$$$ has alternating function $$$A(2,4) = 1 \cdot (1)+(-1) \cdot (-4)+1 \cdot (-2) = 3$$$.A simple path from node $$$1$$$ to node $$$1$$$ has a single node $$$1$$$, so $$$A(1,1) = 1 \cdot (-4) = -4$$$.Similarly, $$$A(2, 1) = 5$$$, $$$A(3, 1) = 9$$$, $$$A(4, 2) = 3$$$, $$$A(1, 4) = -2$$$, $$$A(4, 1) = 2$$$, $$$A(2, 2) = 1$$$, $$$A(3, 3) = 5$$$, $$$A(4, 4) = -2$$$, $$$A(3, 4) = 7$$$, $$$A(4, 3) = 7$$$, $$$A(2, 3) = 10$$$, $$$A(3, 2) = 10$$$. So the answer is $$$(-5) + (-9) + 3 + (-4) + 5 + 9 + 3 + (-2) + 2 + 1 + 5 + (-2) + 7 + 7 + 10 + 10 = 40$$$.Similarly $$$A(1,4)=-2, A(2,2)=1, A(2,1)=5, A(2,3)=10, A(3,3)=5, A(3,1)=9, A(3,2)=10, A(3,4)=7, A(4,4)=-2, A(4,1)=2, A(4,2)=3 , A(4,3)=7$$$ which sums upto 40.  import sys
range = xrange
input = raw_input

inp = [int(x) for x in sys.stdin.read().split()]
ii = 0

n = inp[ii]
ii += 1

V = inp[ii:ii + n]
ii += n

coupl = [[] for _ in range(n)]

for _ in range(n - 1):
    u = inp[ii] - 1
    ii += 1
    v = inp[ii] - 1
    ii += 1
    
    coupl[u].append(v)
    coupl[v].append(u)

found = [0]*n
children = [[] for _ in range(n)]
P = [-1]*n

bfs = [0]
P[0] = 0
for node in bfs:
    for nei in coupl[node]:
        if P[nei] == -1:
            bfs.append(nei)
            P[nei] = node
            children[node].append(nei)


E = [0]*n
O = [0]*n

for node in reversed(bfs):
    O[node] += 1
    p = P[node]
    if p != node:
        E[p] += O[node]
        O[p] += E[node]

UE = list(E)
UO = list(O)

for node in bfs:
    for child in children[node]:
        UO[child] += UE[node] - O[child]
        UE[child] += UO[node] - E[child]

out = []
for node in range(n):

    ue = UE[node]
    count = uo = UO[node]
    p = P[node]
    if p != node:
        e = UE[p] - O[node]
        o = UO[p] - E[node]

        count += - E[node] * o + O[node] * e
    for child in children[node]:
        e = ue - O[child]
        o = uo - E[child]

        count += E[child] * o - O[child] * e
    out.append(count)
print sum(out[i] * V[i] for i in range(n)) % (10**9 + 7)
","['combinatorics', 'dfs and similar', 'divide and conquer', 'dp', 'probabilities', 'trees']"
746,"$$$n$$$ fishermen have just returned from a fishing vacation. The $$$i$$$-th fisherman has caught a fish of weight $$$a_i$$$.Fishermen are going to show off the fish they caught to each other. To do so, they firstly choose an order in which they show their fish (each fisherman shows his fish exactly once, so, formally, the order of showing fish is a permutation of integers from $$$1$$$ to $$$n$$$). Then they show the fish they caught according to the chosen order. When a fisherman shows his fish, he might either become happy, become sad, or stay content.Suppose a fisherman shows a fish of weight $$$x$$$, and the maximum weight of a previously shown fish is $$$y$$$ ($$$y = 0$$$ if that fisherman is the first to show his fish). Then:  if $$$x \ge 2y$$$, the fisherman becomes happy;  if $$$2x \le y$$$, the fisherman becomes sad;  if none of these two conditions is met, the fisherman stays content. Let's call an order in which the fishermen show their fish emotional if, after all fishermen show their fish according to this order, each fisherman becomes either happy or sad. Calculate the number of emotional orders modulo $$$998244353$$$. nan n = int(raw_input())
a = map(int, raw_input().split())
a.sort()
if a[-2] * 2 > a[-1]:
    print 0
    quit()
mod = 998244353
f = [1] * (n + 1)
for i in xrange(1, n + 1):
    f[i] = f[i-1] * i % mod
invf = [1] * (n + 1)
invf[n] = pow(f[n], mod - 2, mod)
for i in xrange(n - 1, 0, -1):
    invf[i] = invf[i+1] * (i + 1) % mod
a.pop()
dp = [0] * n
dp[0] = 1
h = 0
for i, x in enumerate(a, 1):
    while a[h] * 2 <= x:
        h += 1
    dp[i] = (dp[i-1] * (n - i) + dp[h] * f[n-h-2] * invf[n-i-1]) % mod
print dp[-1]
","['combinatorics', 'dp', 'math', 'two pointers']"
3275,"Alice gave Bob two integers $$$a$$$ and $$$b$$$ ($$$a &gt; 0$$$ and $$$b \ge 0$$$). Being a curious boy, Bob wrote down an array of non-negative integers with $$$\operatorname{MEX}$$$ value of all elements equal to $$$a$$$ and $$$\operatorname{XOR}$$$ value of all elements equal to $$$b$$$.What is the shortest possible length of the array Bob wrote?Recall that the $$$\operatorname{MEX}$$$ (Minimum EXcluded) of an array is the minimum non-negative integer that does not belong to the array and the $$$\operatorname{XOR}$$$ of an array is the bitwise XOR of all the elements of the array. NoteIn the first test case, one of the shortest arrays with $$$\operatorname{MEX}$$$ $$$1$$$ and $$$\operatorname{XOR}$$$ $$$1$$$ is $$$[0, 2020, 2021]$$$.In the second test case, one of the shortest arrays with $$$\operatorname{MEX}$$$ $$$2$$$ and $$$\operatorname{XOR}$$$ $$$1$$$ is $$$[0, 1]$$$.It can be shown that these arrays are the shortest arrays possible. #lista=list(map(int,input().split()))
#x=lista[0]
#n=lista[0]
import math
import sys
from collections import deque
#from sys import stdin, stdout
from decimal import *

#lista=list(map(int,input().split()))
#x=lista[0]
#n=lista[0]
 
rasp_final=""""
#my_set=set()
#for x in range(1, 100000):
 #my_set.add(2*x*x)
 #my_set.add(4*x*x)
 
#vector_prime=[-1]*21000
#vector_rasp=[0]*21000

#vector_prime[1]=1

#vector_rasp[1]=1

contor=2
#primes sieve
#for i in range(2,21000):
 #if vector_prime[i]==-1:
  #vector_prime[i]=1
  #vector_rasp[contor]=i
  #contor=contor+1
  #for j in range(i+i,21000,i):
  # vector_prime[j]=0
   #print(i,j)


  
#suma=0
#vector=list(map(int,input().split()))
#for i in vector:
 #suma=suma+i
#luni = {'January':1, 'February':2, 'March':3, 'April':4, 'May':5, 'June':6, 'July':7, 'August':8, 'September':9, 'October':10, 'November':11, 'December':0}
#luni_reverse = {1:'January', 2:'February', 3:'March', 4:'April', 5:'May', 6:'June', 7:'July', 8:'August', 9:'September', 10:'October', 11:'November', 0:'December'} 
#alfabet = {'a': 1, 'b': 2,'c': 3,'d': 4,'e': 5,'f': 6,'g': 7,'h': 8,'i': 9,'j': 10,'k': 11,'l': 12,'m': 13,'n': 14,'o': 15,'p': 16,'q': 17,'r': 18,'s': 19,'t': 20,'u': 21,'v': 22,'w': 23,'x': 24,'y': 25,'z': 26}
#alfabet_2={'1':""a"", '2':""b"", '3':""c"", '4':""d"", '5':""e"", '6':""f"", '7':""g"", '8':""h"", '9':""i"", '10':""j"", '11':""k"", '12':""l"", '13':""m"", '14':""n"", '15':""o"", '16':""p"", '17':""q"", '18':""r"", '19':""s"", '20':""t"", '21':""u"", '22':""v"", '23':""w"", '24':""x"", '25':""y"", '26':""z""}
 
k=int(input()) 
#k=1
 
contor=0 
while k>0:

 contor+=1
 waiting=deque()

 #n=int(input())
 
 lista=list(map(int,input().split()))
 a=lista[0]
 b=lista[1]
 
 if a==1 and b==0:
  print(1)
 elif a==1 and b==1:
   print (3)
 elif b==0 and a==2:
   print (3)  
 elif a==2 and b==1:
   print (2)  
 elif a==1 and b>1:
   print(2)
 elif a%2==0:
  if (a//2)%2==0:
   
   if b==a:
    print(a+2)
   elif b==0:
    print(a)
   else:
    print(a+1)
  else:
   
   if b==a+1:
    print(a+2)
   elif b==1:
    print(a)
   else:
    print(a+1)
   
 else:
  if ((a-1)//2)%2==0:
   if b==1:
    print(a+2)
   elif a-1==b:
    print(a)
   else:
    print(a+1)
  else:
   if b==a:
    print(a)
   elif b==0:
    print(a+2)
   else:
    print(a+1)
    
   
   
   
 
   
  
  
  
 k=k-1
#print(rasp_final)","['bitmasks', 'greedy']"
1483,"You are organizing a boxing tournament, where $$$n$$$ boxers will participate ($$$n$$$ is a power of $$$2$$$), and your friend is one of them. All boxers have different strength from $$$1$$$ to $$$n$$$, and boxer $$$i$$$ wins in the match against boxer $$$j$$$ if and only if $$$i$$$ is stronger than $$$j$$$.The tournament will be organized as follows: $$$n$$$ boxers will be divided into pairs; the loser in each pair leaves the tournament, and $$$\frac{n}{2}$$$ winners advance to the next stage, where they are divided into pairs again, and the winners in all pairs advance to the next stage, and so on, until only one boxer remains (who is declared the winner).Your friend really wants to win the tournament, but he may be not the strongest boxer. To help your friend win the tournament, you may bribe his opponents: if your friend is fighting with a boxer you have bribed, your friend wins even if his strength is lower.Furthermore, during each stage you distribute the boxers into pairs as you wish.The boxer with strength $$$i$$$ can be bribed if you pay him $$$a_i$$$ dollars. What is the minimum number of dollars you have to spend to make your friend win the tournament, provided that you arrange the boxers into pairs during each stage as you wish? NoteIn the first test case no matter how you will distribute boxers into pairs, your friend is the strongest boxer and anyway wins the tournament.In the second test case you can distribute boxers as follows (your friend is number $$$2$$$):$$$1 : 2, 8 : 5, 7 : 3, 6 : 4$$$ (boxers $$$2, 8, 7$$$ and $$$6$$$ advance to the next stage);$$$2 : 6, 8 : 7$$$ (boxers $$$2$$$ and $$$8$$$ advance to the next stage, you have to bribe the boxer with strength $$$6$$$);$$$2 : 8$$$ (you have to bribe the boxer with strength $$$8$$$); import heapq
 
pop=heapq.heappop
push=heapq.heappush
 
n=int(input())
a=list(map(int, input().split()))
 
ans=0
pos=-1
 
for i, x in enumerate(a):
    if x==-1:
        pos=i
        break
        
if pos==n-1:
    print(0)
else:
    ans += a[n-1]
    cur  = n-2
    
    used      = [0] * n 
    used[pos] = 1
    used[n-1] = 1
    
    Q=[]
    i=n//2
    
    
    while i>=2:
        for _ in range(i):
            while used[cur]==1:
                cur-=1
            
            val=0 if cur < pos else a[cur]
            push(Q, (val, cur))
            cur-=1
            
        while True:
            x, p = pop(Q)
            
            if used[p]==0:
                break
                
        used[p]=1
        #print(p, a[p])    
        if p > pos:
            ans+=a[p]
        i//=2        
        
    print(ans)       ","['brute force', 'dp', 'greedy']"
2715,"You have a set of dominoes. Each domino is a rectangular tile with a line dividing its face into two square ends. Can you put all dominoes in a line one by one from left to right so that any two dominoes touched with the sides that had the same number of points? You can rotate the dominoes, changing the left and the right side (domino ""1-4"" turns into ""4-1""). nan def F(x):
	for y in range(7):
		while t[x][y]:
			t[x][y] -= 1
			t[y][x] -= 1
			F(y)
	r.append(x)

e = {}
t = [[0] * 7 for i in range(7)]
c = [0] * 7
n = input()
for i in range(n):
	x, y = map(int, raw_input().split())
	c[x] += 1
	c[y] += 1
	t[x][y] += 1
	t[y][x] += 1
	if (x, y) not in e:
		e[(x, y)] = []
	e[(x, y)].append(i + 1)
v = [i for i in range(7) if c[i] & 1]
r = []
if len(v) > 2:
	print 'No solution'
else:
	v.extend(i for i in range(7) if c[i])
	F(v[0])
	if len(r) - 1 != n:
		print 'No solution'
	else:
		x = r[0]
		for y in r[1 : ]:
			if len(e.get((x, y), [])):
				print e[(x, y)].pop(), '+'
			else:
				print e[(y, x)].pop(), '-'
			x = y
","['dfs and similar', 'graphs']"
4558,"In Berland, $$$n$$$ different types of banknotes are used. Banknotes of the $$$i$$$-th type have denomination $$$10^{a_i}$$$ burles (burles are the currency used in Berland); the denomination of banknotes of the first type is exactly $$$1$$$.Let's denote $$$f(s)$$$ as the minimum number of banknotes required to represent exactly $$$s$$$ burles. For example, if the denominations of banknotes used in Berland are $$$1$$$, $$$10$$$ and $$$100$$$, then $$$f(59) = 14$$$: $$$9$$$ banknotes with denomination of $$$1$$$ burle and $$$5$$$ banknotes with denomination of $$$10$$$ burles can be used to represent exactly $$$9 \cdot 1 + 5 \cdot 10 = 59$$$ burles, and there's no way to do it with fewer banknotes.For a given integer $$$k$$$, find the minimum positive number of burles $$$s$$$ that cannot be represented with $$$k$$$ or fewer banknotes (that is, $$$f(s) &gt; k$$$). nan import sys
import math
import bisect
from sys import stdin, stdout
from math import gcd, floor, sqrt, log
from collections import defaultdict as dd
from bisect import bisect_left as bl, bisect_right as br
from collections import Counter
from collections import defaultdict as dd

# sys.setrecursionlimit(100000000)

flush = lambda: stdout.flush()
stdstr = lambda: stdin.readline()
stdint = lambda: int(stdin.readline())
stdpr = lambda x: stdout.write(str(x))
stdmap = lambda: map(int, stdstr().split())
stdarr = lambda: list(map(int, stdstr().split()))

mod = 1000000007


for _ in range(stdint()):
    n,k = stdmap()
    k += 1
    arr = stdarr()

    if(n == 1):
        print(k)
        continue


    res = 0

    for i in range(n):
        if(i == n-1):
            use = k
        else:
            use = min(k, int(""9"" * (arr[i+1]-arr[i])))

        add = use * (10**arr[i])

        res += add
        k -= use

    print(res)
","['greedy', 'number theory']"
4822,"Vasya has a graph containing both directed (oriented) and undirected (non-oriented) edges. There can be multiple edges between a pair of vertices.Vasya has picked a vertex s from the graph. Now Vasya wants to create two separate plans:  to orient each undirected edge in one of two possible directions to maximize number of vertices reachable from vertex s;  to orient each undirected edge in one of two possible directions to minimize number of vertices reachable from vertex s. In each of two plans each undirected edge must become directed. For an edge chosen directions can differ in two plans.Help Vasya find the plans. nan I = lambda:map(int, raw_input().split())
n, m, s = I()
E = [I() for i in range(m)]
w = ['+'] * sum(a[0] == 2 for a in E)
e = [[] for i in range(n)]
v, s, p = [0] * n, s - 1, 0
for i in range(m):
	E[i][1] -= 1
	E[i][2] -= 1
	if E[i][0] == 2:
		e[E[i][1]].append([E[i][2], p * 2 + 1])
		e[E[i][2]].append([E[i][1], p * 2])
		p += 1
	else:
		e[E[i][1]].append([E[i][2], -1])
q, v[s] = [s], 1
while q:
	x = q.pop()
	for y in e[x]:
		if not v[y[0]]:
			v[y[0]] = 1
			q.append(y[0])
			if y[1] != -1:
				w[y[1] / 2] = ['-', '+'][y[1] % 2]
print sum(v)
print ''.join(w)
v = [0] * n
q, v[s] = [s], 1
while q:
	x = q.pop()
	for y in e[x]:
		if y[1] != -1:
			w[y[1] / 2] = ['+', '-'][y[1] % 2]
		elif not v[y[0]]:
			v[y[0]] = 1
			q.append(y[0])
			
print sum(v)
print ''.join(w)","['dfs and similar', 'graphs']"
4320,"You have a statistic of price changes for one product represented as an array of $$$n$$$ positive integers $$$p_0, p_1, \dots, p_{n - 1}$$$, where $$$p_0$$$ is the initial price of the product and $$$p_i$$$ is how the price was increased during the $$$i$$$-th month.Using these price changes you are asked to calculate the inflation coefficients for each month as the ratio of current price increase $$$p_i$$$ to the price at the start of this month $$$(p_0 + p_1 + \dots + p_{i - 1})$$$.Your boss said you clearly that the inflation coefficients must not exceed $$$k$$$ %, so you decided to increase some values $$$p_i$$$ in such a way, that all $$$p_i$$$ remain integers and the inflation coefficients for each month don't exceed $$$k$$$ %.You know, that the bigger changes — the more obvious cheating. That's why you need to minimize the total sum of changes.What's the minimum total sum of changes you need to make all inflation coefficients not more than $$$k$$$ %? NoteIn the first test case, you can, for example, increase $$$p_0$$$ by $$$50$$$ and $$$p_1$$$ by $$$49$$$ and get array $$$[20150, 50, 202, 202]$$$. Then you get the next inflation coefficients:   $$$\frac{50}{20150} \le \frac{1}{100}$$$;  $$$\frac{202}{20150 + 50} \le \frac{1}{100}$$$;  $$$\frac{202}{20200 + 202} \le \frac{1}{100}$$$; In the second test case, you don't need to modify array $$$p$$$, since the inflation coefficients are already good:   $$$\frac{1}{1} \le \frac{100}{100}$$$;  $$$\frac{1}{1 + 1} \le \frac{100}{100}$$$;  #import io, os
#input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

import math
t = int(input())
for _ in range(t):
  
  n, k = map(int,input().split())
  k = k
  arr = list(map(int,input().split()))

  running_total = arr[0]
  ans = 0
  
  for i in range(1,len(arr)):

    if (arr[i] / running_total) > k/100:

      ans += math.ceil(100 * arr[i] / k ) - running_total
      running_total += math.ceil(100 * arr[i] / k ) - running_total

    

    running_total +=  arr[i]
    
  print(ans)","['binary search', 'brute force', 'greedy', 'math']"
1270,"This is the hard version of the problem. The difference between versions is the constraints on $$$n$$$ and $$$a_i$$$. You can make hacks only if all versions of the problem are solved.First, Aoi came up with the following idea for the competitive programming problem:Yuzu is a girl who collecting candies. Originally, she has $$$x$$$ candies. There are also $$$n$$$ enemies numbered with integers from $$$1$$$ to $$$n$$$. Enemy $$$i$$$ has $$$a_i$$$ candies.Yuzu is going to determine a permutation $$$P$$$. A permutation is an array consisting of $$$n$$$ distinct integers from $$$1$$$ to $$$n$$$ in arbitrary order. For example, $$$\{2,3,1,5,4\}$$$ is a permutation, but $$$\{1,2,2\}$$$ is not a permutation ($$$2$$$ appears twice in the array) and $$$\{1,3,4\}$$$ is also not a permutation (because $$$n=3$$$ but there is the number $$$4$$$ in the array).After that, she will do $$$n$$$ duels with the enemies with the following rules:  If Yuzu has equal or more number of candies than enemy $$$P_i$$$, she wins the duel and gets $$$1$$$ candy. Otherwise, she loses the duel and gets nothing.  The candy which Yuzu gets will be used in the next duels. Yuzu wants to win all duels. How many valid permutations $$$P$$$ exist?This problem was easy and wasn't interesting for Akari, who is a friend of Aoi. And Akari made the following problem from the above idea:Let's define $$$f(x)$$$ as the number of valid permutations for the integer $$$x$$$.You are given $$$n$$$, $$$a$$$ and a prime number $$$p \le n$$$. Let's call a positive integer $$$x$$$ good, if the value $$$f(x)$$$ is not divisible by $$$p$$$. Find all good integers $$$x$$$.Your task is to solve this problem made by Akari. NoteIn the first test, $$$p=2$$$.  If $$$x \le 2$$$, there are no valid permutations for Yuzu. So $$$f(x)=0$$$ for all $$$x \le 2$$$. The number $$$0$$$ is divisible by $$$2$$$, so all integers $$$x \leq 2$$$ are not good.  If $$$x = 3$$$, $$$\{1,2,3\}$$$ is the only valid permutation for Yuzu. So $$$f(3)=1$$$, so the number $$$3$$$ is good.  If $$$x = 4$$$, $$$\{1,2,3\} , \{1,3,2\} , \{2,1,3\} , \{2,3,1\}$$$ are all valid permutations for Yuzu. So $$$f(4)=4$$$, so the number $$$4$$$ is not good.  If $$$x \ge 5$$$, all $$$6$$$ permutations are valid for Yuzu. So $$$f(x)=6$$$ for all $$$x \ge 5$$$, so all integers $$$x \ge 5$$$ are not good. So, the only good number is $$$3$$$.In the third test, for all positive integers $$$x$$$ the value $$$f(x)$$$ is divisible by $$$p = 3$$$. import sys
import collections  
def input():
	return sys.stdin.readline().rstrip()
 
def split_input():
	return [int(i) for i in input().split()]

n,p = split_input()
a = split_input()

start = max(a) - n + 1
x = [0 for i in range(n)]
for i in a:
	ind = i - start
	if ind <= 0:
		x[0] += 1
	else:
		x[ind] += 1
for i in range(1,n):
	x[i] += x[i-1]
zero_ind = -1
for i in range(n):
	zero_ind = max(i - x[i], zero_ind)
s = set()
for i in range(zero_ind+1, n):
	if x[i] >= p:
	# 	t = p
	# 	while (x[i] >= t):
	# 		s.add(i - (x[i] - t))
	# 		t += p
		s.add((i + start - x[i])%p)
ans = []
for i in range(zero_ind + 1, p):
	if (i+start)%p not in s:
		ans.append(i + start)
print(len(ans))
print(*ans, sep = "" "")","['binary search', 'combinatorics', 'dp', 'math', 'number theory', 'sortings']"
1808,"In Berland a bus travels along the main street of the capital. The street begins from the main square and looks like a very long segment. There are n bus stops located along the street, the i-th of them is located at the distance ai from the central square, all distances are distinct, the stops are numbered in the order of increasing distance from the square, that is, ai &lt; ai + 1 for all i from 1 to n - 1. The bus starts its journey from the first stop, it passes stops 2, 3 and so on. It reaches the stop number n, turns around and goes in the opposite direction to stop 1, passing all the intermediate stops in the reverse order. After that, it again starts to move towards stop n. During the day, the bus runs non-stop on this route.The bus is equipped with the Berland local positioning system. When the bus passes a stop, the system notes down its number.One of the key features of the system is that it can respond to the queries about the distance covered by the bus for the parts of its path between some pair of stops. A special module of the system takes the input with the information about a set of stops on a segment of the path, a stop number occurs in the set as many times as the bus drove past it. This module returns the length of the traveled segment of the path (or -1 if it is impossible to determine the length uniquely). The operation of the module is complicated by the fact that stop numbers occur in the request not in the order they were visited but in the non-decreasing order.For example, if the number of stops is 6, and the part of the bus path starts at the bus stop number 5, ends at the stop number 3 and passes the stops as follows: , then the request about this segment of the path will have form: 3, 4, 5, 5, 6. If the bus on the segment of the path from stop 5 to stop 3 has time to drive past the 1-th stop (i.e., if we consider a segment that ends with the second visit to stop 3 on the way from 5), then the request will have form: 1, 2, 2, 3, 3, 4, 5, 5, 6.You will have to repeat the Berland programmers achievement and implement this function. NoteThe first test from the statement demonstrates the first example shown in the statement of the problem.The second test from the statement demonstrates the second example shown in the statement of the problem.In the third sample there are two possible paths that have distinct lengths, consequently, the sought length of the segment isn't defined uniquely.In the fourth sample, even though two distinct paths correspond to the query, they have the same lengths, so the sought length of the segment is defined uniquely. r = lambda: list(map(int, input().split()))
ri = lambda: int(input())
n, a, m, b = ri(), r(), ri(), r()
c = [0] * n
for e in b: c[e - 1] += 1
c[0] *= 2; c[-1] *= 2
d = 0
df= 0
r = max(e // 2 for e in c)
c = [e - r * 2 for e in c]
if any(c):
    for i in range(n - 1):
        de = a[i+1] - a[i]
        d += min(c[i], c[i+1]) * de
        df += de    
    print(d + r * 2 * df)
else:
    de = a[1] - a[0]
    for i in range(1, n - 1):
        if a[i + 1] - a[i] != de: print(-1); break
    else: print(r * de * 2 * (n - 1) - de)","['constructive algorithms', 'greedy', 'hashing', 'implementation']"
3269,"Lee tried so hard to make a good div.2 D problem to balance his recent contest, but it still doesn't feel good at all. Lee invented it so tediously slow that he managed to develop a phobia about div.2 D problem setting instead. And now he is hiding behind the bushes...Let's define a Rooted Dead Bush (RDB) of level $$$n$$$ as a rooted tree constructed as described below.A rooted dead bush of level $$$1$$$ is a single vertex. To construct an RDB of level $$$i$$$ we, at first, construct an RDB of level $$$i-1$$$, then for each vertex $$$u$$$:   if $$$u$$$ has no children then we will add a single child to it;  if $$$u$$$ has one child then we will add two children to it;  if $$$u$$$ has more than one child, then we will skip it.   Rooted Dead Bushes of level $$$1$$$, $$$2$$$ and $$$3$$$. Let's define a claw as a rooted tree with four vertices: one root vertex (called also as center) with three children. It looks like a claw:  The center of the claw is the vertex with label $$$1$$$. Lee has a Rooted Dead Bush of level $$$n$$$. Initially, all vertices of his RDB are green.In one move, he can choose a claw in his RDB, if all vertices in the claw are green and all vertices of the claw are children of its center, then he colors the claw's vertices in yellow.He'd like to know the maximum number of yellow vertices he can achieve. Since the answer might be very large, print it modulo $$$10^9+7$$$. NoteIt's easy to see that the answer for RDB of level $$$1$$$ or $$$2$$$ is $$$0$$$.The answer for RDB of level $$$3$$$ is $$$4$$$ since there is only one claw we can choose: $$$\{1, 2, 3, 4\}$$$.The answer for RDB of level $$$4$$$ is $$$4$$$ since we can choose either single claw $$$\{1, 3, 2, 4\}$$$ or single claw $$$\{2, 7, 5, 6\}$$$. There are no other claws in the RDB of level $$$4$$$ (for example, we can't choose $$$\{2, 1, 7, 6\}$$$, since $$$1$$$ is not a child of center vertex $$$2$$$).  Rooted Dead Bush of level 4.  #!/usr/bin/env python
import os
import sys
from io import BytesIO, IOBase
import threading 
from math import floor
from bisect import bisect_right
from collections import Counter
from math import gcd


mod=10**9+7



def main():
    size=2*10**6+1
    ans=[0]*(size)
    a=0
    b=0
    for i in range(1,2*10**6+1):
        # if i<10:
            # print(i,a,b)
        a,b=b,b+2*a
        if i%3==0:
            b+=1
        a%=mod
        b%=mod
        ans[i]=b

    for _ in range(int(input())):
        # print(ans[:10])
        n=int(input())
        print(ans[n]*4%mod)






        



        



BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# endregion

if __name__ == ""__main__"":
    main()","['dp', 'graphs', 'greedy', 'math', 'trees']"
1209,"It is Borya's eleventh birthday, and he has got a great present: n cards with numbers. The i-th card has the number ai written on it. Borya wants to put his cards in a row to get one greater number. For example, if Borya has cards with numbers 1, 31, and 12, and he puts them in a row in this order, he would get a number 13112.He is only 11, but he already knows that there are n! ways to put his cards in a row. But today is a special day, so he is only interested in such ways that the resulting big number is divisible by eleven. So, the way from the previous paragraph is good, because 13112 = 1192 × 11, but if he puts the cards in the following order: 31, 1, 12, he would get a number 31112, it is not divisible by 11, so this way is not good for Borya. Help Borya to find out how many good ways to put the cards are there.Borya considers all cards different, even if some of them contain the same number. For example, if Borya has two cards with 1 on it, there are two good ways.Help Borya, find the number of good ways to put the cards. This number can be large, so output it modulo 998244353. nan mod = 998244353
f0 = [ [0 for i in range(11)] for j in range(2010) ]
f1 = [ [0 for i in range(11)] for j in range(2010) ]
fac = [0 for i in range(2010)]
tab = [0 for i in range(11)]
C = [ [0 for i in range(2010)] for j in range(2010) ]

def Init() :
    fac[0] = 1
    for i in range(2010) :
        if i > 0 : fac[i] = fac[i - 1] * i % mod
        C[i][0] = 1
        for j in range(1, 2010) :
            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod

def len(x) :
    res = 0
    while x > 0 :
        res += 1
        x = x // 10
    return res
            
def solve() :
    n = int(input())
    f0[0][0] = f1[0][0] = 1
    a = list(map(int, input().split()))
    c0, c1 = 0, 0
    s0, s1 = 0, 0
    for nu in a :
        m = nu % 11
        if len(nu) & 1 :
            c1 += 1
            s1 += m
            for i in range(11) :
                f1[c1][i] = 0
            for i in range(c1 - 1, -1, -1) :
                for j in range(11) :
                    if f1[i][j] == 0 : continue
                    f1[i + 1][(j + m) % 11] += f1[i][j]
                    f1[i + 1][(j + m) % 11] %= mod
        else :
            c0 += 1
            s0 += m
            for i in range(11) :
                f0[c0][i] = 0
            for i in range(c0 - 1, -1, -1) :
                for j in range(11) :
                    if f0[i][j] == 0 : continue
                    f0[i + 1][(j + m) % 11] += f0[i][j]
                    f0[i + 1][(j + m) % 11] %= mod
    s1 %= 11
    s0 %= 11
    part = c1 // 2
    for i in range(11) :
        tab[i] = 0
    for i in range(11) :
        tab[(i + i + 11 - s1) % 11] = f1[c1 - part][i]
    for i in range(11) :
        tab[i] = tab[i] * fac[part] % mod * fac[c1 - part] % mod

    ans = 0
    if c1 == 0 :
        ans = f0[c0][0] * fac[c0]
    elif c0 == 0 :
        ans = tab[0]
    else :
        for i in range(c0 + 1) :
            for j in range(11) :
                if f0[i][j] == 0 : continue
                # print(f0[i][j], tab[(j + j + 11 - s0) % 11] \
                # , fac[i] % mod * fac[c0 - i] % mod, C[j + (c1 - part) - 1][(c1 - part) - 1] % mod * C[part + c0 - i][part] % mod )
                ans = ( ans \
                        + fac[i] % mod * fac[c0 - i] % mod \
                        * f0[i][j] * tab[(j + j + 11 - s0) % 11] % mod \
                        * C[i + (c1 - part) - 1][(c1 - part) - 1] % mod \
                        * C[part + c0 - i][part]
 ) % mod
    print(ans)

Init()
T = int(input())
for ttt in range(T) : solve()","['combinatorics', 'dp', 'math']"
1497,"Cat Noku has obtained a map of the night sky. On this map, he found a constellation with n stars numbered from 1 to n. For each i, the i-th star is located at coordinates (xi, yi). No two stars are located at the same position.In the evening Noku is going to take a look at the night sky. He would like to find three distinct stars and form a triangle. The triangle must have positive area. In addition, all other stars must lie strictly outside of this triangle. He is having trouble finding the answer and would like your help. Your job is to find the indices of three stars that would form a triangle that satisfies all the conditions. It is guaranteed that there is no line such that all stars lie on that line. It can be proven that if the previous condition is satisfied, there exists a solution to this problem. NoteIn the first sample, we can print the three indices in any order.In the second sample, we have the following picture.   Note that the triangle formed by starts 1, 4 and 3 doesn't satisfy the conditions stated in the problem, as point 5 is not strictly outside of this triangle (it lies on it's border). def dis(x,y):
    return x**2+y**2

def check(a,b,c):
    if (c[1]-b[1])*(b[0]-a[0])==(b[1]-a[1])*(c[0]-b[0]):
        return True
    return False

def solve():
    n=input()
    points=[]
    dist=[]
    for x in xrange(n):
        points.append(map(int,raw_input().split()))
        dist.append(dis(points[-1][0],points[-1][1]))
    indices = sorted(range(n), key = dist.__getitem__)
    for y in xrange(2,n):
        if check(points[indices[0]],points[indices[1]],points[indices[y]]):
            continue
        else:
            print indices[0]+1,indices[1]+1,indices[y]+1
            break

solve() 
","['geometry', 'implementation']"
2225,"A car number in Berland consists of exactly n digits. A number is called beautiful if it has at least k equal digits. Vasya wants to change the digits in his car's number so that the number became beautiful. To replace one of n digits Vasya has to pay the sum of money, equal to the absolute difference between the old digit and the new one.Help Vasya: find the minimum sum of money he should pay to make the number of his car beautiful. You should also find the resulting beautiful number. If there are several such numbers, then print the lexicographically minimum one. NoteIn the first sample replacing the second digit with an ""8"" costs |9 - 8| = 1. Replacing the fifth digit with an ""8"" costs the same. Replacing the sixth digit costs |6 - 8| = 2. As a result, Vasya will pay 1 + 1 + 2 = 4 for a beautiful number ""888188"".The lexicographical comparison of strings is performed by the &lt; operator in modern programming languages. The string x is lexicographically smaller than the string y, if there exists such i (1 ≤ i ≤ n), that xi &lt; yi, and for any j (1 ≤ j &lt; i) xj = yj. The strings compared in this problem will always have the length n. n,k = map(int,input().split())

s = list(map(int, input()))
e = list(enumerate(s))
min_cost = 9*n
a=[9]*n
for j in range(10):
    r = s[:]
    cost = 0
    for x, y in sorted(e, key=lambda t : (abs(t[1] - j), -t[1], t[0]*(-1)**(j > t[1]) ))[:k]:
        r[x]=j
        cost += abs(y-j)
    if  cost < min_cost :
        min_cost = cost
        a = r
    if min_cost == cost:
        a = min(a,r)
print(min_cost)
print (''.join(map(str,a)))






























		















	
















		


















		













","['brute force', 'greedy', 'sortings', 'strings']"
1456,"During the last Sereja's Codesecrof round the server crashed many times, so the round was decided to be made unrated for some participants. Let's assume that n people took part in the contest. Let's assume that the participant who got the first place has rating a1, the second place participant has rating a2, ..., the n-th place participant has rating an. Then changing the rating on the Codesecrof site is calculated by the formula .After the round was over, the Codesecrof management published the participants' results table. They decided that if for a participant di &lt; k, then the round can be considered unrated for him. But imagine the management's surprise when they found out that the participants' rating table is dynamic. In other words, when some participant is removed from the rating, he is removed from the results' table and the rating is recalculated according to the new table. And of course, all applications for exclusion from the rating are considered in view of the current table.We know that among all the applications for exclusion from the rating the first application to consider is from the participant with the best rank (the rank with the minimum number), for who di &lt; k. We also know that the applications for exclusion from rating were submitted by all participants.Now Sereja wonders, what is the number of participants to be excluded from the contest rating, and the numbers of the participants in the original table in the order of their exclusion from the rating. Pay attention to the analysis of the first test case for a better understanding of the statement. NoteConsider the first test sample.  Initially the sequence of the contest participants' ratings equals [5, 3, 4, 1, 2]. You can use this sequence to calculate the sequence of rating changes: [0, -9, -13, 8, 14]. According to the problem statement, the application of the participant who won the second place will be considered first. As soon as the second place winner is out from the ratings, the participants' rating sequence will equal [5, 4, 1, 2]. By this sequence you can count the new sequence of rating changes: [0, -8, 2, 6]. According to the problem statement, the application of the participant who won the second place will be considered. Initially this participant won third place. The new rating sequence equals [5, 1, 2], the new sequence of rating changes equals [0, -1, 1]. The second place participant's application is taken into consideration, initially this participant won the fourth place. The new rating sequence equals [5, 2], the new sequence of rating changes equals [0, 0]. No more applications will be considered. Thus, you should print 2, 3, 4. n, k = map(int, input().split())
c, v = 0, []
for i, a in enumerate(map(int, input().split())):
    j = i + 1 - len(v)
    d = c - (j - 1) * (n - j) * a
    if d < k:
        v.append(i + 1)
        n -= 1
    else:
        c += a * (j - 1)
print('\n'.join(map(str, v)))",['implementation']
4845,"Alice is visiting New York City. To make the trip fun, Alice will take photos of the city skyline and give the set of photos as a present to Bob. However, she wants to find the set of photos with maximum beauty and she needs your help. There are $$$n$$$ buildings in the city, the $$$i$$$-th of them has positive height $$$h_i$$$. All $$$n$$$ building heights in the city are different. In addition, each building has a beauty value $$$b_i$$$. Note that beauty can be positive or negative, as there are ugly buildings in the city too. A set of photos consists of one or more photos of the buildings in the skyline. Each photo includes one or more buildings in the skyline that form a contiguous segment of indices. Each building needs to be in exactly one photo. This means that if a building does not appear in any photo, or if a building appears in more than one photo, the set of pictures is not valid. The beauty of a photo is equivalent to the beauty $$$b_i$$$ of the shortest building in it. The total beauty of a set of photos is the sum of the beauty of all photos in it. Help Alice to find the maximum beauty a valid set of photos can have.  NoteIn the first example, Alice can achieve maximum beauty by taking five photos, each one containing one building. In the second example, Alice can achieve a maximum beauty of $$$10$$$ by taking four pictures: three just containing one building, on buildings $$$1$$$, $$$2$$$ and $$$5$$$, each photo with beauty $$$-3$$$, $$$4$$$ and $$$7$$$ respectively, and another photo containing building $$$3$$$ and $$$4$$$, with beauty $$$2$$$. In the third example, Alice will just take one picture of the whole city.In the fourth example, Alice can take the following pictures to achieve maximum beauty: photos with just one building on buildings $$$1$$$, $$$2$$$, $$$8$$$, $$$9$$$, and $$$10$$$, and a single photo of buildings $$$3$$$, $$$4$$$, $$$5$$$, $$$6$$$, and $$$7$$$.  import io,os
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
from collections import deque 


class segment_tree(object):

    # self.flag True means get minimum,  False means get maximum 

    def merge(self,num,curr):
        if self.flag:
            return min(curr,num)
        else:
            return max(curr,num)



    def __init__(self,n,initial,flag):
        self.flag = flag
        self.n = n
        self.arr = [0]*(2*n)
        for i in range(2*n-1,0,-1):
            if i>=n:  self.arr[i] = initial[i-n]
            else:     self.arr[i] = self.merge(self.arr[2*i],self.arr[2*i+1])




    def update(self,index,target):

        self.arr[index] = target
        if index & 1:
            nexttarget = self.merge( self.arr[index], self.arr[index-1])
        else:
            nexttarget = self.merge( self.arr[index], self.arr[index+1])
        if index>0:  self.update(index>>1,nexttarget )


    def addnum(self,index,diff):
        self.update(index+self.n, self.arr[index+self.n] + diff)


    def query(self,left,right):
        i,j = self.n+left,  self.n+right+1
        if self.flag:
            output = float('inf')  # initial output should be changed if you want to change the merge function
        else:
            output = -float('inf')

        while i<j:
            if i&1:
                output = self.merge(self.arr[i],output)
                i += 1
            if j&1:
                j -= 1
                output = self.merge(self.arr[j],output)
            i = i >> 1
            j = j >> 1
        return output



def getranking(arr):
    temp = []
    n = len(arr)
    output = [0]*n
    for i in range(len(arr)):
        temp.append((arr[i],i))
    temp.sort(key=lambda x:(x[0],x[1]))
    for i in range(n):
        output[temp[i][1]] = i
    return output 

    


def main(t):

    n = int(input())
    height = list(map(int,input().split()))
    ranking = getranking(height)
    seg = segment_tree(n,ranking,True)
    dic = {}
    for i in range(n):  dic[ranking[i]] = i
  
    beauty = list(map(int,input().split()))
    leftnode = [-1]*n
    rightnode = [-1]*n


    

    parity = [-1]*n


    # get the left and right son node
  
    queue = deque()

    root = dic[0]
    queue.append((0,n-1,root))    

    childnum = [1]*n



    seq = []
    while queue:
        left,right,index = queue.popleft()
        seq.append(index)
        if left <= index-1:
            leftnode[index] = dic[seg.query(left,index-1)]
            queue.append((left,index-1,leftnode[index])) 
            parity[leftnode[index]] = 0   # 0 for leftnode and 1 for rightnode

        if index+1 <= right:
            rightnode[index] = dic[seg.query(index+1,right)]
            queue.append((index+1,right,rightnode[index])) 
            parity[rightnode[index]] = 1

    seq = seq[::-1]


#    print(leftnode,rightnode,dic,seq)
    dp = [0]*n

    for index in seq:
        num1,num2,num3 = -float('inf'), beauty[index], -float('inf')
        if leftnode[index] >= 0:  
            num1 = dp[leftnode[index]]
            childnum[index] += childnum[leftnode[index]]
        if rightnode[index] >= 0: 
            num3 = dp[rightnode[index]]
            childnum[index] += childnum[rightnode[index]]

        dp[index] = num2 + max(num1,0) + max(num3,0)
        leftnum,rightnum = 0,0
        if leftnode[index] >= 0:  leftnum = childnum[leftnode[index]]
        if rightnode[index] >= 0:  rightnum = childnum[rightnode[index]]
        if index > leftnum and rightnode[index] >= 0:   dp[index] = max(dp[index], dp[rightnode[index]]) 
        if index + rightnum < n - 1 and leftnode[index] >= 0:   dp[index] = max(dp[index], dp[leftnode[index]])
         
      
#    print(dp)
            
    print(dp[seq[-1]])
            
 
















T = 1 #int(input())
t = 1
while t<=T:
    main(t)
    t += 1

","['data structures', 'dp']"
3817,"Vasya has written some permutation $$$p_1, p_2, \ldots, p_n$$$ of integers from $$$1$$$ to $$$n$$$, so for all $$$1 \leq i \leq n$$$ it is true that $$$1 \leq p_i \leq n$$$ and all $$$p_1, p_2, \ldots, p_n$$$ are different. After that he wrote $$$n$$$ numbers $$$next_1, next_2, \ldots, next_n$$$. The number $$$next_i$$$ is equal to the minimal index $$$i &lt; j \leq n$$$, such that $$$p_j &gt; p_i$$$. If there is no such $$$j$$$ let's let's define as $$$next_i = n + 1$$$.In the evening Vasya went home from school and due to rain, his notebook got wet. Now it is impossible to read some written numbers. Permutation and some values $$$next_i$$$ are completely lost! If for some $$$i$$$ the value $$$next_i$$$ is lost, let's say that $$$next_i = -1$$$.You are given numbers $$$next_1, next_2, \ldots, next_n$$$ (maybe some of them are equal to $$$-1$$$). Help Vasya to find such permutation $$$p_1, p_2, \ldots, p_n$$$ of integers from $$$1$$$ to $$$n$$$, that he can write it to the notebook and all numbers $$$next_i$$$, which are not equal to $$$-1$$$, will be correct.  NoteIn the first test case for permutation $$$p = [1, 2, 3]$$$ Vasya should write $$$next = [2, 3, 4]$$$, because each number in permutation is less than next. It's easy to see, that it is the only satisfying permutation.In the third test case, any permutation can be the answer because all numbers $$$next_i$$$ are lost.In the fourth test case, there is no satisfying permutation, so the answer is $$$-1$$$. import os
import sys
from atexit import register
from io import BytesIO

sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))
sys.stdout = BytesIO()
register(lambda: os.write(1, sys.stdout.getvalue()))

input = lambda: sys.stdin.readline().rstrip('\r\n')
t=int(input())

for u in xrange(t):
    n=int(input())
    a=list(map(int,input().split()))
    long=[]
    lens=0
    fucked=False
    for i in xrange(n):
        if a[i]==-1:
            if lens==0:
                a[i]=i+2
            else:
                a[i]=long[-1]
        else:
            if lens==0 or a[i]<long[-1]:
                long.append(a[i])
                lens+=1
            elif lens>0 and a[i]>long[-1]:
                fucked=True
        if lens>0:
            if i>=long[-1]-2:
                long.pop()
                lens-=1
    if fucked:
        print(-1)
    else:
        back={}
        for i in xrange(n+1):
            back[i+1]=[]
        for i in xrange(n):
            back[a[i]].append(i+1)
        perm=[0]*n
        q=[n+1]
        big=n
        while q!=[]:
            newq=[]
            for guy in q:
                for boi in back[guy]:
                    perm[boi-1]=big
                    big-=1
                newq+=back[guy]
            q=newq
        perm=[str(guy) for guy in perm]
        print("" "".join(perm))","['constructive algorithms', 'data structures', 'dfs and similar', 'graphs', 'greedy', 'math', 'sortings']"
3616,"One day n friends met at a party, they hadn't seen each other for a long time and so they decided to make a group photo together. Simply speaking, the process of taking photos can be described as follows. On the photo, each photographed friend occupies a rectangle of pixels: the i-th of them occupies the rectangle of width wi pixels and height hi pixels. On the group photo everybody stands in a line, thus the minimum pixel size of the photo including all the photographed friends, is W × H, where W is the total sum of all widths and H is the maximum height of all the photographed friends.As is usually the case, the friends made n photos — the j-th (1 ≤ j ≤ n) photo had everybody except for the j-th friend as he was the photographer.Print the minimum size of each made photo in pixels.  nan n = int(input())

friends = []

Wob = 0
Hob = [0, 0]

for i in range(n):
    w, h = [int(j) for j in input().split()]
    friends.append([w, h])
    Wob += w
    if h > Hob[0]:
        Hob[1] = Hob[0]
        Hob[0] = h
    elif h > Hob[1]:
        Hob[1] = h

for f in friends:
    w = Wob - f[0]
    h = Hob[0]
    if f[1] == Hob[0]:
        h = Hob[1]
    print(w*h, end="" "")






","['data structures', 'dp', 'implementation', 'other']"
175,"Student Valera is an undergraduate student at the University. His end of term exams are approaching and he is to pass exactly n exams. Valera is a smart guy, so he will be able to pass any exam he takes on his first try. Besides, he can take several exams on one day, and in any order.According to the schedule, a student can take the exam for the i-th subject on the day number ai. However, Valera has made an arrangement with each teacher and the teacher of the i-th subject allowed him to take an exam before the schedule time on day bi (bi &lt; ai). Thus, Valera can take an exam for the i-th subject either on day ai, or on day bi. All the teachers put the record of the exam in the student's record book on the day of the actual exam and write down the date of the mark as number ai.Valera believes that it would be rather strange if the entries in the record book did not go in the order of non-decreasing date. Therefore Valera asks you to help him. Find the minimum possible value of the day when Valera can take the final exam if he takes exams so that all the records in his record book go in the order of non-decreasing date. NoteIn the first sample Valera first takes an exam in the second subject on the first day (the teacher writes down the schedule date that is 3). On the next day he takes an exam in the third subject (the teacher writes down the schedule date, 4), then he takes an exam in the first subject (the teacher writes down the mark with date 5). Thus, Valera takes the last exam on the second day and the dates will go in the non-decreasing order: 3, 4, 5.In the second sample Valera first takes an exam in the third subject on the fourth day. Then he takes an exam in the second subject on the fifth day. After that on the sixth day Valera takes an exam in the first subject. n = int(input())
exams = []
for i in range(n):
	exams.append([int(x) for x in input().split(' ')])
dayX = -1
for nextExam in sorted(exams, key=lambda item: (item[0], item[1])):
	if dayX <= nextExam[1]:
		dayX = nextExam[1]
	else:
		dayX = nextExam[0]
print(dayX)","['greedy', 'sortings']"
2988,"You have a board represented as a grid with $$$2 \times n$$$ cells.The first $$$k_1$$$ cells on the first row and first $$$k_2$$$ cells on the second row are colored in white. All other cells are colored in black.You have $$$w$$$ white dominoes ($$$2 \times 1$$$ tiles, both cells are colored in white) and $$$b$$$ black dominoes ($$$2 \times 1$$$ tiles, both cells are colored in black).You can place a white domino on the board if both board's cells are white and not occupied by any other domino. In the same way, you can place a black domino if both cells are black and not occupied by any other domino.Can you place all $$$w + b$$$ dominoes on the board if you can place dominoes both horizontally and vertically? NoteIn the first test case, $$$n = 1$$$, $$$k_1 = 0$$$ and $$$k_2 = 1$$$. It means that $$$2 \times 1$$$ board has black cell $$$(1, 1)$$$ and white cell $$$(2, 1)$$$. So, you can't place any white domino, since there is only one white cell.In the second test case, the board of the same size $$$2 \times 1$$$, but both cell are white. Since $$$w = 0$$$ and $$$b = 0$$$, so you can place $$$0 + 0 = 0$$$ dominoes on the board.In the third test case, board $$$2 \times 3$$$, but fully colored in black (since $$$k_1 = k_2 = 0$$$), so you can't place any white domino.In the fourth test case, cells $$$(1, 1)$$$, $$$(1, 2)$$$, $$$(1, 3)$$$, and $$$(2, 1)$$$ are white and other cells are black. You can place $$$2$$$ white dominoes at positions $$$((1, 1), (2, 1))$$$ and $$$((1, 2), (1, 3))$$$ and $$$2$$$ black dominoes at positions $$$((1, 4), (2, 4))$$$ $$$((2, 2), (2, 3))$$$. t=int(input())
for y  in range(t):
    n,k1,k2=map(int,input().split())
    w,b=map(int,input().split())
    kw=k1+k2
    to=kw//2
    tob=(n*2-kw)//2
    # print(to)
    if w<=to:
        # print(""this w"")
        w=0
        avil=to-w
    else:
        # print(""w n"")
        print(""NO"")
        continue
    # avil=avil+(n-to)
    if b<=tob :
        # print(""this b"")
        b=0
    else:
        # print(""b n"")
        print(""NO"")
        continue
    # print(""above"")
    if w==0 and b==0:
        print(""YES"")
","['combinatorics', 'constructive algorithms', 'math']"
1832,"Musicians of a popular band ""Flayer"" have announced that they are going to ""make their exit"" with a world tour. Of course, they will visit Berland as well.There are n cities in Berland. People can travel between cities using two-directional train routes; there are exactly m routes, i-th route can be used to go from city vi to city ui (and from ui to vi), and it costs wi coins to use this route.Each city will be visited by ""Flayer"", and the cost of the concert ticket in i-th city is ai coins.You have friends in every city of Berland, and they, knowing about your programming skills, asked you to calculate the minimum possible number of coins they have to pay to visit the concert. For every city i you have to compute the minimum number of coins a person from city i has to spend to travel to some city j (or possibly stay in city i), attend a concert there, and return to city i (if j ≠ i).Formally, for every  you have to calculate , where d(i, j) is the minimum number of coins you have to spend to travel from city i to city j. If there is no way to reach city j from city i, then we consider d(i, j) to be infinitely large. nan from __future__ import division, print_function
py2 = round(0.5)

if py2:
    from future_builtins import ascii, filter, hex, map, oct, zip
    range = xrange

import os, sys
from io import BytesIO, IOBase

# FastIO for PyPy2 and PyPy3 by Pajenegod,
class FastI(object):
    def __init__(self, fd=0, buffersize=2**14):
        self.stream = stream = BytesIO(); self.bufendl = 0
        def read2buffer():
            curpos = stream.tell(); s = os.read(fd, buffersize + os.fstat(fd).st_size)
            stream.seek(0,2); stream.write(s); stream.seek(curpos); return s
        self.read2buffer = read2buffer
    def read(self):
        while self.read2buffer(): pass
        return self.stream.read() if self.stream.tell() else self.stream.getvalue()
    def readline(self):
        while self.bufendl == 0: s = self.read2buffer(); self.bufendl += s.count(b'\n') + (not s)
        self.bufendl -= 1; return self.stream.readline()
    def input(self): return self.readline().rstrip(b'\r\n')
    def readnumbers(self, n,zero=0):
        conv = ord if py2 else lambda x:x
        
        A = []; numb = zero; sign = 1
        
        curpos = self.stream.tell()
        self.stream.seek(0,2)
        buffsize = self.stream.tell()
        self.stream.seek(curpos)
        
        while len(A)<n:
            if curpos>=buffsize:
                buffsize += len(self.read2buffer())
                if curpos==buffsize: break
            small_buff = min(32,buffsize-curpos)
            s = self.stream.read(small_buff)
            i = 0
            while i<small_buff and len(A)<n:
                if s[i] >= b'0'[0]: numb = 10 * numb + (conv(s[i]) - 48)
                elif s[i] != b'\r'[0]: A.append(sign*numb); numb = zero; sign = 1
                elif s[i] == b'-'[0]: sign = -1
                i += 1
            curpos += i
        if curpos == buffsize and len(A)<n: A.append(sign*numb)
        assert(len(A)==n)
        if self.stream.tell()!=curpos: self.stream.seek(curpos)
        return A

class FastO(IOBase):
    def __init__(self, fd=1):
        stream = BytesIO()
        self.flush = lambda: os.write(1, stream.getvalue()) and not stream.truncate(0) and stream.seek(0)
        self.write = stream.write if py2 else lambda s: stream.write(s.encode())

sys.stdin, sys.stdout = FastI(), FastO()
input = sys.stdin.readline

big = 3E12

class segheap:
    def __init__(self,data):
        n = len(data)
        m = 1
        while m<n:m*=2
        self.n = n
        self.m = m

        self.data = [big]*(2*m)
        for i in range(n):
            self.data[i+m] = data[i]
        for i in reversed(range(m)):
            self.data[i] = min(self.data[2*i],self.data[2*i+1])

    def mini(self):
        i = 1
        while i<self.m:
            if self.data[i]==self.data[2*i]:
                i = 2*i
            else:
                i = 2*i+1
        i -= self.m
        self.setter(i,big)
        return i
    def setter(self,ind,val):
        ind += self.m
        if val<self.data[ind]:
            while ind>0 and self.data[ind]>val:
                self.data[ind] = val
                ind //= 2
        elif val>self.data[ind]:
            old_val = self.data[ind]
            self.data[ind] = val
            ind //= 2
            while ind>0 and self.data[ind]==old_val:
                self.data[ind] = min(self.data[2*ind],self.data[2*ind+1])
                ind //= 2

n, m = [int(x) for x in sys.stdin.readline().split()]

inp = sys.stdin.readnumbers(3*m, 0.0)

coupl = [[] for _ in range(n)]
cost = [[] for _ in range(n)]
for _ in range(m):
    v = int(inp[_*3+0]-1)
    u = int(inp[_*3+1]-1)
    w = inp[_*3+2]
    coupl[v].append(u)
    coupl[u].append(v)
    cost[u].append(w)
    cost[v].append(w)

inp = sys.stdin.readnumbers(n, 0.0)

best = [inp[i] for i in range(n)]

Q = segheap(best)

while Q.data[1]!=big:
    c = Q.data[1]
    node = Q.mini()
    if best[node]!=c:
        continue
    for j in range(len(coupl[node])):
        nei = coupl[node][j]
        C = c+2*cost[node][j]
        if C<best[nei]:
            best[nei] = C
            Q.setter(nei,C)

for x in best:
    sys.stdout.write(str(int(x)))
    sys.stdout.write(' ')","['data structures', 'graphs', 'shortest paths']"
45,"An array $$$b$$$ of length $$$k$$$ is called good if its arithmetic mean is equal to $$$1$$$. More formally, if $$$$$$\frac{b_1 + \cdots + b_k}{k}=1.$$$$$$Note that the value $$$\frac{b_1+\cdots+b_k}{k}$$$ is not rounded up or down. For example, the array $$$[1,1,1,2]$$$ has an arithmetic mean of $$$1.25$$$, which is not equal to $$$1$$$.You are given an integer array $$$a$$$ of length $$$n$$$. In an operation, you can append a non-negative integer to the end of the array. What's the minimum number of operations required to make the array good?We have a proof that it is always possible with finitely many operations. NoteIn the first test case, we don't need to add any element because the arithmetic mean of the array is already $$$1$$$, so the answer is $$$0$$$.In the second test case, the arithmetic mean is not $$$1$$$ initially so we need to add at least one more number. If we add $$$0$$$ then the arithmetic mean of the whole array becomes $$$1$$$, so the answer is $$$1$$$.In the third test case, the minimum number of elements that need to be added is $$$16$$$ since only non-negative integers can be added.In the fourth test case, we can add a single integer $$$4$$$. The arithmetic mean becomes $$$\frac{-2+4}{2}$$$ which is equal to $$$1$$$. from functools import reduce
import sys
from os import path
if(path.exists('input.txt')):
    sys.stdin = open(""input.txt"", 'r')
    sys.stdout = open(""output.txt"", 'w')


input = iter(sys.stdin.readlines())

n = int(next(input))

for _ in range(n):
    l = int(next(input))
    a = (int(i) for i in next(input).split())
    sum1 = sum(a)
    ar = sum1 / l

    if ar == 1:
        sys.stdout.write('0\n')
    elif ar < 1:
        sys.stdout.write('1\n')
    else:
        sys.stdout.write(str(sum1-l)+'\n')


sys.stdout.flush()
","['greedy', 'math']"
4230,"A tuple of positive integers {x1, x2, ..., xk} is called simple if for all pairs of positive integers (i,  j) (1  ≤ i  &lt;  j ≤ k), xi  +  xj is a prime.You are given an array a with n positive integers a1,  a2,  ...,  an (not necessary distinct). You want to find a simple subset of the array a with the maximum size.A prime number (or a prime) is a natural number greater than 1 that has no positive divisors other than 1 and itself.Let's define a subset of the array a as a tuple that can be obtained from a by removing some (possibly all) elements of it. nan def f(N):
    p=[1]*N
    k=4
    for i in range(2,N):
        if p[i]:
            for j in range(k,N,i):
                p[j]=0
        k+=i<<1|1
    return p
p=f(2000001)
n=input()
a=map(int,raw_input().split())
one=a.count(1)
if one>1:
    for x in a:
        if not x&1:
            if p[x+1]:
                print one+1
                print x, '1 '*one
                exit()
    print one
    print '1 '*one
else:
    for x in a:
        for y in a:
            if p[x+y] and x+y>2:
                print 2
                print x,y
                exit()
    print 1
    print a[0]
","['constructive algorithms', 'greedy', 'number theory']"
4063,"You are given an array $$$a_1, a_2, \dots, a_n$$$ and an integer $$$k$$$.You are asked to divide this array into $$$k$$$ non-empty consecutive subarrays. Every element in the array should be included in exactly one subarray. Let $$$f(i)$$$ be the index of subarray the $$$i$$$-th element belongs to. Subarrays are numbered from left to right and from $$$1$$$ to $$$k$$$.Let the cost of division be equal to $$$\sum\limits_{i=1}^{n} (a_i \cdot f(i))$$$. For example, if $$$a = [1, -2, -3, 4, -5, 6, -7]$$$ and we divide it into $$$3$$$ subbarays in the following way: $$$[1, -2, -3], [4, -5], [6, -7]$$$, then the cost of division is equal to $$$1 \cdot 1 - 2 \cdot 1 - 3 \cdot 1 + 4 \cdot 2 - 5 \cdot 2 + 6 \cdot 3 - 7 \cdot 3 = -9$$$.Calculate the maximum cost you can obtain by dividing the array $$$a$$$ into $$$k$$$ non-empty consecutive subarrays.  nan n, k = map(int, raw_input().strip().split())
a = map(int, raw_input().strip().split())

pre = [0] * n
pre[0] = a[0]
for i in xrange(1, n):
    pre[i] = pre[i - 1] + a[i]

ans = k * pre[-1]
pre.pop()

pre.sort()

z = 0
for i in xrange(k - 1): z += pre[i]

print ans - z
","['greedy', 'sortings']"
3849,"Let's call two numbers similar if their binary representations contain the same number of digits equal to $$$1$$$. For example:  $$$2$$$ and $$$4$$$ are similar (binary representations are $$$10$$$ and $$$100$$$);  $$$1337$$$ and $$$4213$$$ are similar (binary representations are $$$10100111001$$$ and $$$1000001110101$$$);  $$$3$$$ and $$$2$$$ are not similar (binary representations are $$$11$$$ and $$$10$$$);  $$$42$$$ and $$$13$$$ are similar (binary representations are $$$101010$$$ and $$$1101$$$). You are given an array of $$$n$$$ integers $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$. You may choose a non-negative integer $$$x$$$, and then get another array of $$$n$$$ integers $$$b_1$$$, $$$b_2$$$, ..., $$$b_n$$$, where $$$b_i = a_i \oplus x$$$ ($$$\oplus$$$ denotes bitwise XOR).Is it possible to obtain an array $$$b$$$ where all numbers are similar to each other? nan import sys

readline = sys.stdin.readline
readlines = sys.stdin.readlines
ns = lambda: readline().rstrip()
ni = lambda: int(readline().rstrip())
nm = lambda: map(int, readline().split())
nl = lambda: list(map(int, readline().split()))
prn = lambda x: print(*x, sep='\n')


def solve():
    n = ni()
    a = nl()
    mask = (1 << 15) - 1
    ab = [x & mask for x in a]
    at = [x >> 15 for x in a]
    d = dict()
    for bit in range(mask, -1, -1):
        b = [bin(bit^x).count('1') for x in ab]
        g = tuple([x - b[0] for x in b[1:]])
        d[g] = bit
    for bit in range(mask + 1):
        b = [bin(bit^x).count('1') for x in at]
        g = tuple([b[0] - x for x in b[1:]])
        if g in d:
            print((bit << 15) | d[g])
            return
    print(-1)
    return

solve()

# T = ni()
# for _ in range(T):
#     solve()
","['bitmasks', 'brute force', 'hashing', 'other']"
2770,"Ashish has $$$n$$$ elements arranged in a line. These elements are represented by two integers $$$a_i$$$ — the value of the element and $$$b_i$$$ — the type of the element (there are only two possible types: $$$0$$$ and $$$1$$$). He wants to sort the elements in non-decreasing values of $$$a_i$$$.He can perform the following operation any number of times:  Select any two elements $$$i$$$ and $$$j$$$ such that $$$b_i \ne b_j$$$ and swap them. That is, he can only swap two elements of different types in one move. Tell him if he can sort the elements in non-decreasing values of $$$a_i$$$ after performing any number of operations. NoteFor the first case: The elements are already in sorted order.For the second case: Ashish may first swap elements at positions $$$1$$$ and $$$2$$$, then swap elements at positions $$$2$$$ and $$$3$$$.For the third case: The elements are already in sorted order.For the fourth case: No swap operations may be performed as there is no pair of elements $$$i$$$ and $$$j$$$ such that $$$b_i \ne b_j$$$. The elements cannot be sorted.For the fifth case: Ashish may swap elements at positions $$$3$$$ and $$$4$$$, then elements at positions $$$1$$$ and $$$2$$$. import math,sys,bisect
from collections import defaultdict,Counter,deque
from itertools import groupby,accumulate
#sys.setrecursionlimit(1000000)
input = iter(sys.stdin.buffer.read().decode().splitlines()).__next__
ilele = lambda: map(int,input().split())
alele = lambda: list(map(int, input().split()))
#def list2d(a, b, c): return [[c] * b for i in range(a)]
#def list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]
#MOD = 1000000000 + 7
def Y(c):  print([""NO"",""YES""][c])
def y(c):  print([""no"",""yes""][c])
def Yy(c):  print([""No"",""Yes""][c])
    
for _ in range(int(input())):
    N = int(input())
    A = alele()
    B = alele()
    C = sorted(A)
    Yy(A==C or len(set(B)) !=  1)","['constructive algorithms', 'implementation']"
2834,"Polycarp is wondering about buying a new computer, which costs $$$c$$$ tugriks. To do this, he wants to get a job as a programmer in a big company.There are $$$n$$$ positions in Polycarp's company, numbered starting from one. An employee in position $$$i$$$ earns $$$a[i]$$$ tugriks every day. The higher the position number, the more tugriks the employee receives. Initially, Polycarp gets a position with the number $$$1$$$ and has $$$0$$$ tugriks.Each day Polycarp can do one of two things:   If Polycarp is in the position of $$$x$$$, then he can earn $$$a[x]$$$ tugriks.  If Polycarp is in the position of $$$x$$$ ($$$x &lt; n$$$) and has at least $$$b[x]$$$ tugriks, then he can spend $$$b[x]$$$ tugriks on an online course and move to the position $$$x+1$$$. For example, if $$$n=4$$$, $$$c=15$$$, $$$a=[1, 3, 10, 11]$$$, $$$b=[1, 2, 7]$$$, then Polycarp can act like this:   On the first day, Polycarp is in the $$$1$$$-st position and earns $$$1$$$ tugrik. Now he has $$$1$$$ tugrik;  On the second day, Polycarp is in the $$$1$$$-st position and move to the $$$2$$$-nd position. Now he has $$$0$$$ tugriks;  On the third day, Polycarp is in the $$$2$$$-nd position and earns $$$3$$$ tugriks. Now he has $$$3$$$ tugriks;  On the fourth day, Polycarp is in the $$$2$$$-nd position and is transferred to the $$$3$$$-rd position. Now he has $$$1$$$ tugriks;  On the fifth day, Polycarp is in the $$$3$$$-rd position and earns $$$10$$$ tugriks. Now he has $$$11$$$ tugriks;  On the sixth day, Polycarp is in the $$$3$$$-rd position and earns $$$10$$$ tugriks. Now he has $$$21$$$ tugriks;  Six days later, Polycarp can buy himself a new computer. Find the minimum number of days after which Polycarp will be able to buy himself a new computer. nan from sys import stdin
input = stdin.readline
II = lambda :int(input())
MI = lambda :map(int,input().split())
LI = lambda :list(map(int,input().split()))
ANS = []
#文字列出力はListでつくってから''.join(ANS),文字列結合は遅い
T = II()
def solve(n,A,B,c):
    ans = float('inf')
    x = 0
    memo = 0
    for i in range(n):
        if i == 0:
            co = (c + A[i]-1)//A[i]
            tmp = (B[i]-x + A[i]-1)//A[i]
            x = A[i] * tmp -B[i]
            memo += tmp + 1
            ans = min(co,ans)
        else:
            co = max((c-x + A[i]-1)//A[i],0) + memo
            ans = min(co,ans)
            if i <n-1:
                if B[i] >= x:
                    tmp = (B[i]-x + A[i]-1)//A[i]
                else:
                    tmp = 0
                memo += tmp + 1
                x += A[i] * tmp - B[i]

    return ans

for _ in range(T):
    n,c = MI()
    A = LI()
    B = LI()
    ANS.append(solve(n,A,B,c))
for ans in ANS:
    print(ans)","['brute force', 'dp', 'greedy', 'implementation']"
1558,"Ari the monster is not an ordinary monster. She is the hidden identity of Super M, the Byteforces’ superhero. Byteforces is a country that consists of n cities, connected by n - 1 bidirectional roads. Every road connects exactly two distinct cities, and the whole road system is designed in a way that one is able to go from any city to any other city using only the given roads. There are m cities being attacked by humans. So Ari... we meant Super M have to immediately go to each of the cities being attacked to scare those bad humans. Super M can pass from one city to another only using the given roads. Moreover, passing through one road takes her exactly one kron - the time unit used in Byteforces.   However, Super M is not on Byteforces now - she is attending a training camp located in a nearby country Codeforces. Fortunately, there is a special device in Codeforces that allows her to instantly teleport from Codeforces to any city of Byteforces. The way back is too long, so for the purpose of this problem teleportation is used exactly once.You are to help Super M, by calculating the city in which she should teleport at the beginning in order to end her job in the minimum time (measured in krons). Also, provide her with this time so she can plan her way back to Codeforces. NoteIn the first sample, there are two possibilities to finish the Super M's job in 3 krons. They are: and .However, you should choose the first one as it starts in the city with the lower number. from heapq import *
INF = float('inf')
n, m = map(int, input().split())
adj = [[] for _ in range(n+1)]
wg= ng = [0 for _ in range(n+1)]

for _ in range(n-1):
    a, b = map(int, input().split())
    adj[a].append(b)
    adj[b].append(a)

aaa = set(map(int, input().split()))
if len(aaa) == 1:print(min(aaa));print(0);exit()
rm = []
for i in range(n+1):
    ng[i] = len(adj[i])
    if i not in aaa and ng[i] == 1: rm.append(i)

for a in aaa: ng[a] = 0

def remove_node(index):
    while adj[index]:
        nx = adj[index].pop()
        adj[nx].remove(index)
        ng[nx] -= 1
        if ng[nx] == 1: rm.append(nx)

    ng[index] = 0

while rm: remove_node(rm.pop())

state = [0 for _ in range(n+1)]
que = [(min(aaa), None)]
res = 0
for _ in range(2):
    deep = [0 for _ in range(n + 1)]
    while que:
        res += 1
        root, proot = que.pop()
        for nx in adj[root]:
            if proot == nx:
                continue
            if _: state[nx] = root
            deep[nx] = deep[root] + 1
            que.append((nx, root))
    if _: break

    start = max(1,deep.index(max(deep)))
    que = [(start, None)]

end = max(1, deep.index(max(deep)))
i = end
path = 1
while i != start:
    path += 1
    i = state[i]

print(min(start,end))
print(res -1 -path)
","['dfs and similar', 'dp', 'graphs', 'trees']"
3162,"There is a country with $$$n$$$ citizens. The $$$i$$$-th of them initially has $$$a_{i}$$$ money. The government strictly controls the wealth of its citizens. Whenever a citizen makes a purchase or earns some money, they must send a receipt to the social services mentioning the amount of money they currently have.Sometimes the government makes payouts to the poor: all citizens who have strictly less money than $$$x$$$ are paid accordingly so that after the payout they have exactly $$$x$$$ money. In this case the citizens don't send a receipt.You know the initial wealth of every citizen and the log of all events: receipts and payouts. Restore the amount of money each citizen has after all events. NoteIn the first example the balances change as follows: 1 2 3 4 $$$\rightarrow$$$ 3 3 3 4 $$$\rightarrow$$$ 3 2 3 4 $$$\rightarrow$$$ 3 2 3 4In the second example the balances change as follows: 3 50 2 1 10 $$$\rightarrow$$$ 3 0 2 1 10 $$$\rightarrow$$$ 8 8 8 8 10 $$$\rightarrow$$$ 8 8 20 8 10 n = int(raw_input())
a = map(int, raw_input().split())
q = int(raw_input())
Q = []
b = [-1 for i in xrange(n)]
c = -1

while q:
    q -= 1
    Q.append(map(int, raw_input().split()))

for q in Q[::-1]:
    if q[0] == 1:
        if b[q[1]-1] == -1:
            b[q[1]-1] = max(q[2],c)
    else:
        c = max(c, q[1])

for i in xrange(n):
    if b[i] == -1:
        b[i] = max(c, a[i])

print ' '.join(map(str, b))
","['binary search', 'brute force', 'data structures', 'sortings']"
3377,"Mishka got an integer array $$$a$$$ of length $$$n$$$ as a birthday present (what a surprise!).Mishka doesn't like this present and wants to change it somehow. He has invented an algorithm and called it ""Mishka's Adjacent Replacements Algorithm"". This algorithm can be represented as a sequence of steps:  Replace each occurrence of $$$1$$$ in the array $$$a$$$ with $$$2$$$;  Replace each occurrence of $$$2$$$ in the array $$$a$$$ with $$$1$$$;  Replace each occurrence of $$$3$$$ in the array $$$a$$$ with $$$4$$$;  Replace each occurrence of $$$4$$$ in the array $$$a$$$ with $$$3$$$;  Replace each occurrence of $$$5$$$ in the array $$$a$$$ with $$$6$$$;  Replace each occurrence of $$$6$$$ in the array $$$a$$$ with $$$5$$$;  $$$\dots$$$  Replace each occurrence of $$$10^9 - 1$$$ in the array $$$a$$$ with $$$10^9$$$;  Replace each occurrence of $$$10^9$$$ in the array $$$a$$$ with $$$10^9 - 1$$$. Note that the dots in the middle of this algorithm mean that Mishka applies these replacements for each pair of adjacent integers ($$$2i - 1, 2i$$$) for each $$$i \in\{1, 2, \ldots, 5 \cdot 10^8\}$$$ as described above.For example, for the array $$$a = [1, 2, 4, 5, 10]$$$, the following sequence of arrays represents the algorithm: $$$[1, 2, 4, 5, 10]$$$ $$$\rightarrow$$$ (replace all occurrences of $$$1$$$ with $$$2$$$) $$$\rightarrow$$$ $$$[2, 2, 4, 5, 10]$$$ $$$\rightarrow$$$ (replace all occurrences of $$$2$$$ with $$$1$$$) $$$\rightarrow$$$ $$$[1, 1, 4, 5, 10]$$$ $$$\rightarrow$$$ (replace all occurrences of $$$3$$$ with $$$4$$$) $$$\rightarrow$$$ $$$[1, 1, 4, 5, 10]$$$ $$$\rightarrow$$$ (replace all occurrences of $$$4$$$ with $$$3$$$) $$$\rightarrow$$$ $$$[1, 1, 3, 5, 10]$$$ $$$\rightarrow$$$ (replace all occurrences of $$$5$$$ with $$$6$$$) $$$\rightarrow$$$ $$$[1, 1, 3, 6, 10]$$$ $$$\rightarrow$$$ (replace all occurrences of $$$6$$$ with $$$5$$$) $$$\rightarrow$$$ $$$[1, 1, 3, 5, 10]$$$ $$$\rightarrow$$$ $$$\dots$$$ $$$\rightarrow$$$ $$$[1, 1, 3, 5, 10]$$$ $$$\rightarrow$$$ (replace all occurrences of $$$10$$$ with $$$9$$$) $$$\rightarrow$$$ $$$[1, 1, 3, 5, 9]$$$. The later steps of the algorithm do not change the array.Mishka is very lazy and he doesn't want to apply these changes by himself. But he is very interested in their result. Help him find it. NoteThe first example is described in the problem statement. """"""
CONTESTENT: ngtien2
CONTEST: Codeforces Round #498 (Div. 3)
LANGUAGE: Python 2.7
PROBLEM: A. Adjacent Replacements
""""""

n = int(raw_input())
a = map(int, raw_input().split())

for i in xrange(n):
    if a[i] % 2 == 0:
        a[i] -= 1
    print a[i],",['implementation']
1610,"Note that the memory limit is unusual.You are given a multiset consisting of $$$n$$$ integers. You have to process queries of two types:  add integer $$$k$$$ into the multiset;  find the $$$k$$$-th order statistics in the multiset and remove it. $$$k$$$-th order statistics in the multiset is the $$$k$$$-th element in the sorted list of all elements of the multiset. For example, if the multiset contains elements $$$1$$$, $$$4$$$, $$$2$$$, $$$1$$$, $$$4$$$, $$$5$$$, $$$7$$$, and $$$k = 3$$$, then you have to find the $$$3$$$-rd element in $$$[1, 1, 2, 4, 4, 5, 7]$$$, which is $$$2$$$. If you try to delete an element which occurs multiple times in the multiset, only one occurence is removed. After processing all queries, print any number belonging to the multiset, or say that it is empty. NoteIn the first example, all elements of the multiset are deleted.In the second example, the elements $$$5$$$, $$$1$$$, $$$4$$$, $$$2$$$ are deleted (they are listed in chronological order of their removal).In the third example, $$$6$$$ is not the only answer. import sys, os, gc
 
class FenwickTree:
    def __init__(self, x):
        """"""transform list into BIT""""""
        self.bit = x
        for i in range(len(x)):
            j = i | (i + 1)
            if j < len(x):
                x[j] += x[i]
 
    def update(self, idx, x):
        """"""updates bit[idx] += x""""""
        while idx < len(self.bit):
            self.bit[idx] += x
            idx |= idx + 1
 
    def query(self, end):
        """"""calc sum(bit[:end])""""""
        x = 0
        while end:
            x += self.bit[end - 1]
            end &= end - 1
        return x
 
    def findkth(self, k):
        """"""Find largest idx such that sum(bit[:idx]) <= k""""""
        idx = -1
        for d in reversed(range(len(self.bit).bit_length())):
            right_idx = idx + (1 << d)
            if right_idx < len(self.bit) and k >= self.bit[right_idx]:
                idx = right_idx
                k -= self.bit[idx]
        return idx + 1
 
ii = 0
_inp = b''
def getchar():
    global ii, _inp
    if ii >= len(_inp):
        _inp = os.read(0, 100000)
        gc.collect()
        ii = 0
    if not _inp:
        return b' '[0]
    ii += 1
    return _inp[ii - 1]
 
def input():
    c = getchar()
    if c == b'-'[0]:
        x = 0
        sign = 1
    else:
        x = c - b'0'[0]
        sign = 0
    c = getchar()
    while c >= b'0'[0]:
        x = 10 * x + c - b'0'[0]
        c = getchar()
    if c == b'\r'[0]:
        getchar()
    return -x if sign else x
 
def main():
    n = input()
    q = input()
    A = [0]*n
    for _ in range(n):
        A[input() - 1] += 1
     
    fen = FenwickTree(A)
    for _ in range(q):
        x = input()
        if x < 0:
            fen.update(fen.findkth(-x - 1), -1)
        else:
            fen.update(x - 1, 1)
    i = 0
    while i < n and not A[i]:
        i += 1
    if i == n:
        os.write(1, b'0')
    else:
        os.write(1, str(i + 1).encode('ascii'))
main()","['binary search', 'data structures']"
3036,"Chef Monocarp has just put $$$n$$$ dishes into an oven. He knows that the $$$i$$$-th dish has its optimal cooking time equal to $$$t_i$$$ minutes.At any positive integer minute $$$T$$$ Monocarp can put no more than one dish out of the oven. If the $$$i$$$-th dish is put out at some minute $$$T$$$, then its unpleasant value is $$$|T - t_i|$$$ — the absolute difference between $$$T$$$ and $$$t_i$$$. Once the dish is out of the oven, it can't go back in.Monocarp should put all the dishes out of the oven. What is the minimum total unpleasant value Monocarp can obtain? NoteIn the first example Monocarp can put out the dishes at minutes $$$3, 1, 5, 4, 6, 2$$$. That way the total unpleasant value will be $$$|4 - 3| + |2 - 1| + |4 - 5| + |4 - 4| + |6 - 5| + |2 - 2| = 4$$$.In the second example Monocarp can put out the dishes at minutes $$$4, 5, 6, 7, 8, 9, 10$$$.In the third example Monocarp can put out the dish at minute $$$1$$$.In the fourth example Monocarp can put out the dishes at minutes $$$5, 1, 2, 4, 3$$$.In the fifth example Monocarp can put out the dishes at minutes $$$1, 3, 4, 5$$$. import sys

original_stdout = sys.stdout

var_for_sublime = False 


if var_for_sublime:
	fin = open('input.txt' , 'r')
	fout = open('output.txt' , 'w')
	sys.stdout = fout
	def give_string():
		return fin.readline()
else:
	fin = sys.stdin 
	fout = sys.stdout
	def give_string():
		return fin.buffer.readline()

def give_list():
	return list(map(int, give_string().split()))
def give_int():
	return int(give_string())


MOD = 1e9+ 7
def modpow( a , p) :
	ans = 1 
	while p :
		if p&1 :
			ans *= a 
			ans %= MOD 
		p >>= 1
		a *= a
		a %= MOD
	return ans 		



def fac_cal(n):
	ans = 1
	for i in range(1 , n+1):
		ans *= i 
		ans %= MOD 
	return ans 





def solve():
	n = give_int() 
	t=  give_list() 
	t.sort()
	# print(t)
	dp = [ [1e9]*(2*n) for i in range(n)]
	for i in range(n):
		for j in range(i+1 , 2*n):
			if(i == 0):
				dp[i][j] = min(dp[i][j-1] , abs(t[0] - j))
			else:
				dp[i][j] = min(dp[i][j-1] , dp[i-1][j-1]+abs(t[i]-j))
			# print(i , j )
	ans = 1e9
	# for li in dp:
	# 	print(li)
	for i in range(2*n):
		ans = min(ans , dp[n-1][i])
	print(ans)


def main():
	try :
		t = 1 
		t = give_int()
		for i in range(t):
			solve()
	finally:
		fin.close()
		fout.close()
		sys.stdout = original_stdout





if __name__ == '__main__' :
	main()","['dp', 'greedy', 'math', 'other', 'sortings']"
2377,"Jzzhu have n non-negative integers a1, a2, ..., an. We will call a sequence of indexes i1, i2, ..., ik (1 ≤ i1 &lt; i2 &lt; ... &lt; ik ≤ n) a group of size k. Jzzhu wonders, how many groups exists such that ai1 &amp; ai2 &amp; ... &amp; aik = 0 (1 ≤ k ≤ n)? Help him and print this number modulo 1000000007 (109 + 7). Operation x &amp; y denotes bitwise AND operation of two numbers. nan import sys
#!/usr/bin/env python3

mod=1000000007;

cnt=[0]*(1<<21)
p2=[0]*(1<<21)


n=int(sys.stdin.readline())	
a=[int(x) for x in sys.stdin.readline().split()]

for i in a:
	cnt[i]+=1

for i in range(20):
	for j in range(1<<20):
		if (j&(1<<i))==0:
			cnt[j]+=cnt[j|(1<<i)]

ans=0
p2[0]=1
for i in range(1,1<<20):
	p2[i]=(p2[i-1]*2)%mod

for i in range(1<<20):
	if bin(i).count(""1"")&1:
		ans=(ans-p2[cnt[i]]+mod)%mod
	else:
		ans=(ans+p2[cnt[i]]+mod)%mod


sys.stdout.write(str(ans))
sys.stdout.write('\n')
","['bitmasks', 'combinatorics', 'dp']"
2222,"Mishka received a gift of multicolored pencils for his birthday! Unfortunately he lives in a monochrome world, where everything is of the same color and only saturation differs. This pack can be represented as a sequence a1, a2, ..., an of n integer numbers — saturation of the color of each pencil. Now Mishka wants to put all the mess in the pack in order. He has an infinite number of empty boxes to do this. He would like to fill some boxes in such a way that:  Each pencil belongs to exactly one box;  Each non-empty box has at least k pencils in it;  If pencils i and j belong to the same box, then |ai - aj| ≤ d, where |x| means absolute value of x. Note that the opposite is optional, there can be pencils i and j such that |ai - aj| ≤ d and they belong to different boxes. Help Mishka to determine if it's possible to distribute all the pencils into boxes. Print ""YES"" if there exists such a distribution. Otherwise print ""NO"". NoteIn the first example it is possible to distribute pencils into 2 boxes with 3 pencils in each with any distribution. And you also can put all the pencils into the same box, difference of any pair in it won't exceed 10.In the second example you can split pencils of saturations [4, 5, 3, 4] into 2 boxes of size 2 and put the remaining ones into another box. import heapq

def run():
    n, k, d = map(int, input().split())
    a = sorted(map(int, input().split()))

    max_size = [None] * n  # how many pencils can be in box starting with this one
    start = 0
    end = 0
    while start < n:
        while end < n-1 and a[end+1] - a[start] <= d:
            end += 1
        max_size[start] = end - start + 1
        start += 1

    possilbe_starts = []
    # heap with starts and stops of intervals where new box can start
    # - all pencils before that are successfully boxed
    heapq.heappush(possilbe_starts, (0, ""start""))
    heapq.heappush(possilbe_starts, (1, ""stop""))

    number_of_opened = 0  # number of opened intervals

    for pencil in range(n):
        while possilbe_starts and possilbe_starts[0][0] <= pencil:
            top = heapq.heappop(possilbe_starts)
            number_of_opened += (1 if top[1] == ""start"" else -1)
        if number_of_opened <= 0:
            continue
        if max_size[pencil] < k:
            continue
        if pencil + max_size[pencil] + 1 > n:
            print(""YES"")
            break
        heapq.heappush(possilbe_starts, (pencil + k, ""start""))
        heapq.heappush(possilbe_starts, (pencil + max_size[pencil] + 1, ""stop""))
    else:
        print(""NO"")

run()
","['binary search', 'data structures', 'dp', 'greedy', 'two pointers']"
4575,"Let's define the following recurrence: $$$$$$a_{n+1} = a_{n} + minDigit(a_{n}) \cdot maxDigit(a_{n}).$$$$$$Here $$$minDigit(x)$$$ and $$$maxDigit(x)$$$ are the minimal and maximal digits in the decimal representation of $$$x$$$ without leading zeroes. For examples refer to notes.Your task is calculate $$$a_{K}$$$ for given $$$a_{1}$$$ and $$$K$$$. Note$$$a_{1} = 487$$$  $$$a_{2} = a_{1} + minDigit(a_{1}) \cdot maxDigit(a_{1}) = 487 + \min (4, 8, 7) \cdot \max (4, 8, 7) = 487 + 4 \cdot 8 = 519$$$  $$$a_{3} = a_{2} + minDigit(a_{2}) \cdot maxDigit(a_{2}) = 519 + \min (5, 1, 9) \cdot \max (5, 1, 9) = 519 + 1 \cdot 9 = 528$$$  $$$a_{4} = a_{3} + minDigit(a_{3}) \cdot maxDigit(a_{3}) = 528 + \min (5, 2, 8) \cdot \max (5, 2, 8) = 528 + 2 \cdot 8 = 544$$$  $$$a_{5} = a_{4} + minDigit(a_{4}) \cdot maxDigit(a_{4}) = 544 + \min (5, 4, 4) \cdot \max (5, 4, 4) = 544 + 4 \cdot 5 = 564$$$  $$$a_{6} = a_{5} + minDigit(a_{5}) \cdot maxDigit(a_{5}) = 564 + \min (5, 6, 4) \cdot \max (5, 6, 4) = 564 + 4 \cdot 6 = 588$$$  $$$a_{7} = a_{6} + minDigit(a_{6}) \cdot maxDigit(a_{6}) = 588 + \min (5, 8, 8) \cdot \max (5, 8, 8) = 588 + 5 \cdot 8 = 628$$$ t=int(input())
for _ in range(t):
    a1,k=map(int,input().split())
    for i in range(k-1):
        mi=9
        ma=0
        for d in str(a1):
          if int(d)>ma:
            ma=int(d)
          if int(d)<mi:
            mi=int(d)
        if mi==0:
            break
        a1=a1+(ma*mi)
        
    print(a1)   ","['brute force', 'implementation', 'math']"
4254,"Galya is playing one-dimensional Sea Battle on a 1 × n grid. In this game a ships are placed on the grid. Each of the ships consists of b consecutive cells. No cell can be part of two ships, however, the ships can touch each other.Galya doesn't know the ships location. She can shoot to some cells and after each shot she is told if that cell was a part of some ship (this case is called ""hit"") or not (this case is called ""miss"").Galya has already made k shots, all of them were misses.Your task is to calculate the minimum number of cells such that if Galya shoot at all of them, she would hit at least one ship.It is guaranteed that there is at least one valid ships placement. NoteThere is one ship in the first sample. It can be either to the left or to the right from the shot Galya has already made (the ""1"" character). So, it is necessary to make two shots: one at the left part, and one at the right part. n,a,b,k=map(int,input().split())
A=input()
B=A.split('1')
C=[]
l=1

for i in B:
    if len(i)>=b:
        for j in range(b-1,len(i),b):
            C.append(j+l)
    l+=len(i)+1
C=C[:len(C)-a+1]
print(len(C))
print(' '.join(list(map(str,C))))





# Made By Mostafa_Khaled","['constructive algorithms', 'greedy', 'implementation', 'math']"
4597,"Today at the lesson Vitya learned a very interesting function — mex. Mex of a sequence of numbers is the minimum non-negative number that is not present in the sequence as element. For example, mex([4, 33, 0, 1, 1, 5]) = 2 and mex([1, 2, 3]) = 0.Vitya quickly understood all tasks of the teacher, but can you do the same?You are given an array consisting of n non-negative integers, and m queries. Each query is characterized by one number x and consists of the following consecutive steps:  Perform the bitwise addition operation modulo 2 (xor) of each array element with the number x.  Find mex of the resulting array. Note that after each query the array changes. nan from sys import stdin, stdout
from itertools import repeat
def main(bi=bin):
    n, m = map(int, stdin.readline().split())
    a = map(int, stdin.read().split(), repeat(10, n + m))
    N = 1 << 19
    t = [0] * (N + N)
    for x in set(a[:n]):
        t[x+N] = 1
    for x in xrange(N - 1, 0, -1):
        t[x] = t[x+x] & t[x+x+1]
    s = 0
    ans = []
    aa = ans.append
    for x in a[n:]:
        s ^= x
        r = 1
        for c in bi(s)[2:].zfill(19):
            r += r
            if c == ""1"":
                r += t[r^1] ^ 1
            else:
                r += t[r]
        aa((r ^ s) - N)
    stdout.write('\n'.join(map(str, ans)))
main()
","['binary search', 'data structures']"
2796,"Sherlock has a new girlfriend (so unlike him!). Valentine's day is coming and he wants to gift her some jewelry.He bought n pieces of jewelry. The i-th piece has price equal to i + 1, that is, the prices of the jewelry are 2, 3, 4, ... n + 1.Watson gave Sherlock a challenge to color these jewelry pieces such that two pieces don't have the same color if the price of one piece is a prime divisor of the price of the other piece. Also, Watson asked him to minimize the number of different colors used.Help Sherlock complete this trivial task. NoteIn the first input, the colors for first, second and third pieces of jewelry having respective prices 2, 3 and 4 are 1, 1 and 2 respectively.In this case, as 2 is a prime divisor of 4, colors of jewelry having prices 2 and 4 must be distinct. def f(n):
    if n==2:
        return True
    for i in range(2,int(n**0.5)+1):
        if n%i==0:
            return False
    return True
s=int(input())
if s>2:
    print(2)
    q=[1]*(s)
    for i in range(2,s+2):
        if f(i):
            q[i-2]=2
    print(' '.join([str(w)for w in q]))
elif s==1:
    print(1)
    print(1)
else:
    print(1)
    print('1 1')
","['constructive algorithms', 'number theory']"
764,"It is well known that Berland has n cities, which form the Silver ring — cities i and i + 1 (1 ≤ i &lt; n) are connected by a road, as well as the cities n and 1. The goverment have decided to build m new roads. The list of the roads to build was prepared. Each road will connect two cities. Each road should be a curve which lies inside or outside the ring. New roads will have no common points with the ring (except the endpoints of the road).Now the designers of the constructing plan wonder if it is possible to build the roads in such a way that no two roads intersect (note that the roads may intersect at their endpoints). If it is possible to do, which roads should be inside the ring, and which should be outside? nan n, m = map(int, input().split())
road = [[] for i in range(m)]
for i in range(m):
    road[i] = [i] + list(map(int, input().split())) + ['NONE']
for i in road:
    if i[2] < i[1]:
        i[1], i[2] = i[2], i[1]
    i[1], i[2] = i[1] - 1, i[2] - 1

participation = [[] for i in range(m)]
for i in range(len(road)):
    for j in range(i + 1, len(road)):
        if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):
            if road[j][1] != road[i][1] and road[j][2] != road[i][1] and road[j][1] != road[i][2] and road[j][2] != road[i][2]:
                participation[i].append(j)
                participation[j].append(i)
result = """"
mark = [0] * m
stack = []
while sum(mark) != m:
    if len(stack) == 0:
        for i in range(len(mark)):
            if mark[i] == 0:
                stack.append(i)
                break
    index = stack.pop()
    mark[index] = 1
    if road[index][3] == ""NONE"":
        road[index][3] = ""i""
    for i in participation[index]:
        if road[i][3] == road[index][3]:
            result = ""Impossible""
            print(result)
            break
        elif road[index][3] != ""i"" and road[i][3] == ""NONE"":
            road[i][3] = ""i""
            stack.append(i)
        elif road[index][3] == ""i"" and road[i][3] == ""NONE"":
            road[i][3] = ""o""
            stack.append(i)
    if result == ""Impossible"":
        break


if result != ""Impossible"":
    for i in road:
        result += i[3]
    print(result)","['dfs and similar', 'dsu', 'graphs', 'other']"
3980,"Wherever the destination is, whoever we meet, let's render this song together.On a Cartesian coordinate plane lies a rectangular stage of size w × h, represented by a rectangle with corners (0, 0), (w, 0), (w, h) and (0, h). It can be seen that no collisions will happen before one enters the stage.On the sides of the stage stand n dancers. The i-th of them falls into one of the following groups:   Vertical: stands at (xi, 0), moves in positive y direction (upwards);  Horizontal: stands at (0, yi), moves in positive x direction (rightwards).   According to choreography, the i-th dancer should stand still for the first ti milliseconds, and then start moving in the specified direction at 1 unit per millisecond, until another border is reached. It is guaranteed that no two dancers have the same group, position and waiting time at the same time.When two dancers collide (i.e. are on the same point at some time when both of them are moving), they immediately exchange their moving directions and go on.  Dancers stop when a border of the stage is reached. Find out every dancer's stopping position. NoteThe first example corresponds to the initial setup in the legend, and the tracks of dancers are marked with different colours in the following figure.  In the second example, no dancers collide. from collections import namedtuple

Dancer = namedtuple('Dancer', ['category', 'x', 'y', 'idx', 'group'])

def read_dancer(idx):
	group, pos, time = [int(x) for x in input().split(' ')]
	x, y = None, None
	if group == 1:
		x, y = pos, 0
	else:
		x, y = 0, pos
	return Dancer(time-pos, x, y, idx, group)

n, w, h = [int(x) for x in input().split(' ')]

dancers = [read_dancer(idx) for idx in range(n)]

dancers_in = sorted(dancers, key = lambda d: (d.category, -d.group, d.x, -d.y))
dancers_out = sorted(dancers, key = lambda d: (d.category, d.group, d.x, -d.y))


end_pos = [None for _ in range(n)]

def get_end_pos(dancer):
	x, y = None, None
	if dancer.x == 0:
		x, y = w, dancer.y
	else:
		x, y = dancer.x, h
	return (x, y)

for i in range(n):
	end_pos[dancers_in[i].idx] = get_end_pos(dancers_out[i])

for i in range(n):
	print(*end_pos[i])","['constructive algorithms', 'data structures', 'geometry', 'implementation', 'sortings', 'two pointers']"
4315,"This is an interactive problem.After completing the last level of the enchanted temple, you received a powerful artifact of the 255th level. Do not rush to celebrate, because this artifact has a powerful rune that can be destroyed with a single spell $$$s$$$, which you are going to find. We define the spell as some non-empty string consisting only of the letters a and b.At any time, you can cast an arbitrary non-empty spell $$$t$$$, and the rune on the artifact will begin to resist. Resistance of the rune is the edit distance between the strings that specify the casted spell $$$t$$$ and the rune-destroying spell $$$s$$$.Edit distance of two strings $$$s$$$ and $$$t$$$ is a value equal to the minimum number of one-character operations of replacing, inserting and deleting characters in $$$s$$$ to get $$$t$$$. For example, the distance between ababa and aaa is $$$2$$$, the distance between aaa and aba is $$$1$$$, the distance between bbaba and abb is $$$3$$$. The edit distance is $$$0$$$ if and only if the strings are equal.It is also worth considering that the artifact has a resistance limit  — if you cast more than $$$n + 2$$$ spells, where $$$n$$$ is the length of spell $$$s$$$, the rune will be blocked.Thus, it takes $$$n + 2$$$ or fewer spells to destroy the rune that is on your artifact. Keep in mind that the required destructive spell $$$s$$$ must also be counted among these $$$n + 2$$$ spells.Note that the length $$$n$$$ of the rune-destroying spell $$$s$$$ is not known to you in advance. It is only known that its length $$$n$$$ does not exceed $$$300$$$. nan from sys import stdout


def f(x):
    if x == 0:
        exit(0)
    stdout.flush()


print('a')
x1 = int(input())
f(x1)
if x1 == 300:
    print('b' * 300)
    exit(0)
lenz = x1 + 1
print('a' * lenz)
x = int(input())
f(x)
ca = lenz - x
patt = ''
c1 = 1
c2 = ca
if ca == 0:
    print('b' * (lenz - 1))
    x = int(input())
    f(x)
else:
    while c2:
        print(patt + 'b' * c1 + 'a' * c2)
        x = int(input())
        f(x)
        if x == lenz - c2 - len(patt) - c1:
            c1 += 1
        else:
            c1 -= 1
            patt += 'b' * c1
            patt += 'a'
            c1 = 1
            c2 -= 1
    print(patt + 'b' * (lenz - len(patt)))
    x = int(input())
    f(x)","['constructive algorithms', 'interactive', 'strings']"
2498,"You are given a functional graph. It is a directed graph, in which from each vertex goes exactly one arc. The vertices are numerated from 0 to n - 1.Graph is given as the array f0, f1, ..., fn - 1, where fi — the number of vertex to which goes the only arc from the vertex i. Besides you are given array with weights of the arcs w0, w1, ..., wn - 1, where wi — the arc weight from i to fi.    The graph from the first sample test. Also you are given the integer k (the length of the path) and you need to find for each vertex two numbers si and mi, where:  si — the sum of the weights of all arcs of the path with length equals to k which starts from the vertex i;  mi — the minimal weight from all arcs on the path with length k which starts from the vertex i. The length of the path is the number of arcs on this path. nan import sys
n, k = map(int, sys.stdin.buffer.readline().decode('utf-8').split())
a = list(map(int, sys.stdin.buffer.readline().decode('utf-8').split()))
b = list(map(int, sys.stdin.buffer.readline().decode('utf-8').split()))

logk = len(bin(k)) - 2
sum_w, sum_w_p = b[:], b[:]
min_w, min_w_p = b[:], b[:]
dest, dest_p = a[:], a[:]

ans_sum, ans_min, pos = [0]*n, b[:], list(range(n))
if k & 1:
    ans_sum = b[:]
    pos = [a[i] for i in range(n)]
k >>= 1

for j in range(1, logk):
    for i in range(n):
        d = dest[i]
        p = 0 if d > i else 1
        dest_p[i] = d
        dest[i] = (dest_p if p else dest)[d]
        sum_w_p[i] = sum_w[i]
        sum_w[i] += (sum_w_p if p else sum_w)[d]
        min_w_p[i] = min_w[i]
        if min_w[i] > (min_w_p if p else min_w)[d]:
            min_w[i] = (min_w_p if p else min_w)[d]

    if k & 1:
        for i in range(n):
            ans_sum[i] += sum_w[pos[i]]
            if ans_min[i] > min_w[pos[i]]:
                ans_min[i] = min_w[pos[i]]
            pos[i] = dest[pos[i]]
    k >>= 1


sys.stdout.buffer.write('\n'.join(
    (str(ans_sum[i]) + ' ' + str(ans_min[i]) for i in range(n))).encode('utf-8'))
","['data structures', 'graphs']"
2873,"Suppose you are performing the following algorithm. There is an array $$$v_1, v_2, \dots, v_n$$$ filled with zeroes at start. The following operation is applied to the array several times — at $$$i$$$-th step ($$$0$$$-indexed) you can:   either choose position $$$pos$$$ ($$$1 \le pos \le n$$$) and increase $$$v_{pos}$$$ by $$$k^i$$$;  or not choose any position and skip this step. You can choose how the algorithm would behave on each step and when to stop it. The question is: can you make array $$$v$$$ equal to the given array $$$a$$$ ($$$v_j = a_j$$$ for each $$$j$$$) after some step? NoteIn the first test case, you can stop the algorithm before the $$$0$$$-th step, or don't choose any position several times and stop the algorithm.In the second test case, you can add $$$k^0$$$ to $$$v_1$$$ and stop the algorithm.In the third test case, you can't make two $$$1$$$ in the array $$$v$$$.In the fifth test case, you can skip $$$9^0$$$ and $$$9^1$$$, then add $$$9^2$$$ and $$$9^3$$$ to $$$v_3$$$, skip $$$9^4$$$ and finally, add $$$9^5$$$ to $$$v_2$$$. def giveb(num, k):
    l = []
    while num > 0:
        if num%k not in [0,1]:
            return 'notvalid'
        else:
            l.append(str(num%k))
            num = num//k
    return ''.join(l[::-1])


for _ in range(int(input())):
    n, k = map(int, input().split())
    l = list(map(int, input().split()))
    ans = []
    used = set()
    valid = True
    for i in l:
        ans.append(giveb(i, k))
    for i in ans:
        for idx, j in enumerate(i[::-1]):
            if j == '0': continue
            if j != '1' or idx in used:
                valid = False
                break
            else:
                used.add(idx)
    #print(ans,used)
    if valid: print(""YES"")
    else: print('NO')","['bitmasks', 'greedy', 'implementation', 'math', 'number theory', 'other']"
787,"There are $$$n$$$ workers and $$$m$$$ tasks. The workers are numbered from $$$1$$$ to $$$n$$$. Each task $$$i$$$ has a value $$$a_i$$$ — the index of worker who is proficient in this task.Every task should have a worker assigned to it. If a worker is proficient in the task, they complete it in $$$1$$$ hour. Otherwise, it takes them $$$2$$$ hours.The workers work in parallel, independently of each other. Each worker can only work on one task at once.Assign the workers to all tasks in such a way that the tasks are completed as early as possible. The work starts at time $$$0$$$. What's the minimum time all tasks can be completed by? NoteIn the first testcase, the first worker works on tasks $$$1$$$ and $$$3$$$, and the second worker works on tasks $$$2$$$ and $$$4$$$. Since they both are proficient in the corresponding tasks, they take $$$1$$$ hour on each. Both of them complete $$$2$$$ tasks in $$$2$$$ hours. Thus, all tasks are completed by $$$2$$$ hours.In the second testcase, it's optimal to assign the first worker to tasks $$$1, 2$$$ and $$$3$$$ and the second worker to task $$$4$$$. The first worker spends $$$3$$$ hours, the second worker spends $$$2$$$ hours (since they are not proficient in the taken task).In the third example, each worker can be assigned to the task they are proficient at. Thus, each of them complete their task in $$$1$$$ hour. t=int(input())

for i in range(t):
    n,m=map(int,input().split())
    a=list(map(int,input().split()))
    dela=[0]*n
    for x in a:
        dela[x-1]+=1
    dela.sort()
    skol=[0]*(dela[-1]+1)
    s=0
    kol = n
    for x in range(len(dela)):
        if dela[x]!=s:
            skol[s] = kol

            kol=n-x
            for y in range(s+1,dela[x]+1):
                skol[y]=kol
            s=dela[x]
    skol[-1]=kol
    S=m
    ph=[None]*len(skol)
    ph[0]=0
    for x in range(1,len(skol)):
        ph[x]=n-ph[x-1]-skol[x]
    #print(ph)
    for x in range(len(skol)-1,-1,-1):
        S+=skol[x]
        if n*(x-1)-ph[x-1]<S:
            print(x)
            break","['binary search', 'greedy', 'implementation', 'two pointers']"
2314,"You are organizing a cycling race on the streets of the city. The city contains n junctions, some pairs of them are connected by roads; on each road you can move in any direction. No two roads connect the same pair of intersections, and no road connects the intersection with itself.You want the race to be open to both professional athletes and beginner cyclists, and that's why you will organize the race in three nominations: easy, moderate and difficult; each participant will choose the more suitable nomination. For each nomination you must choose the route — the chain of junctions, consecutively connected by roads. Routes must meet the following conditions: all three routes should start at the same intersection, and finish at the same intersection (place of start and finish can't be the same); to avoid collisions, no two routes can have common junctions (except for the common start and finish), and can not go along the same road (irrespective of the driving direction on the road for those two routes); no route must pass twice through the same intersection or visit the same road twice (irrespective of the driving direction on the road for the first and second time of visit).Preparing for the competition is about to begin, and you need to determine the routes of the race as quickly as possible. The length of the routes is not important, it is only important that all the given requirements were met. nan from typing import List
import sys

n, m = [int(a) for a in input().split(' ')]

adj: List[List[int]] = [[]] + [[] for _ in range(n)]

visited: List[bool] = [False] * (n + 1)
parent: List[int] = [0] * (n + 1)
depth: List[int] = [0] * (n + 1)
low: List[int] = [0] * (n + 1)
cx: List[int] = [0] * (n + 1)
cy: List[int] = [0] * (n + 1)
qi: List[int] = [0] * (n + 1)

for i in range(m):
    u, v = [int(a) for a in input().split(' ')]
    adj[u].append(v)
    adj[v].append(u)


def solve():

    for i in range(1, n + 1):
        if not visited[i]:
            # dfs(i)
            dfs2(i)
    print('NO')


def lca(a, b):
    while depth[a] > depth[b]:
        a = parent[a]
    while depth[b] > depth[a]:
        b = parent[b]
    while a != b:
        a = parent[a]
        b = parent[b]
    return a


def parent_path(a, b):
    p = []
    while a != b:
        p.append(str(a))
        a = parent[a]
    p.append(str(b))
    return p


def gett(a, b, u, v):
    if depth[b] > depth[v]:
        a, b, u, v = u, v, a, b
    e = lca(a, u)
    print('YES')
    c1 = parent_path(e, v)
    print(' '.join([str(len(c1))] + c1))
    c2 = list(reversed(parent_path(a, e))) + list(reversed(parent_path(v, b)))
    print(' '.join([str(len(c2))] + c2))
    c3 = list(reversed(parent_path(u, e))) + [str(v)]
    print(' '.join([str(len(c3))] + c3))
    exit(0)


def dfs(i):
    visited[i] = True
    depth[i] = depth[parent[i]] + 1
    for ni in adj[i]:
        if parent[i] != ni:
            if not visited[ni]:
                parent[ni] = i
                dfs(ni)
            elif depth[ni] < depth[i]:
                x = i
                while x != ni:
                    if cx[x] and cy[x]:
                        gett(cx[x], cy[x], i, ni)
                    else:
                        cx[x] = i
                        cy[x] = ni
                    x = parent[x]


def dfs2(i):
    visited[i] = True
    q: List[int] = []
    q.append(i)
    while len(q) > 0:
        u = q[-1]
        if qi[u] >= len(adj[u]):
            q.pop()
            continue
        v = adj[u][qi[u]]
        qi[u] += 1
        if parent[u] != v:
            if not visited[v]:
                parent[v] = u
                depth[v] = depth[u] + 1
                visited[v] = True
                q.append(v)
            elif depth[v] < depth[u]:
                x = u
                while x != v:
                    if cx[x] and cy[x]:
                        gett(cx[x], cy[x], u, v)
                    else:
                        cx[x] = u
                        cy[x] = v
                    x = parent[x]

solve()","['dfs and similar', 'graphs']"
1612,"Petya and Vasya are tossing a coin. Their friend Valera is appointed as a judge. The game is very simple. First Vasya tosses a coin x times, then Petya tosses a coin y times. If the tossing player gets head, he scores one point. If he gets tail, nobody gets any points. The winner is the player with most points by the end of the game. If boys have the same number of points, the game finishes with a draw.At some point, Valera lost his count, and so he can not say exactly what the score is at the end of the game. But there are things he remembers for sure. He remembers that the entire game Vasya got heads at least a times, and Petya got heads at least b times. Moreover, he knows that the winner of the game was Vasya. Valera wants to use this information to know every possible outcome of the game, which do not contradict his memories. nan x, y, a, b = map(int, input().split())
ans = []
for vasya in range(max(b + 1, a), x + 1):
  for petya in range(b, min(vasya, y + 1)):
    ans.append((petya, vasya))
print(len(ans))
print(""\n"".join([""%d %d"" % (b, a) for a, b in ans]))","['brute force', 'implementation']"
841,"The king of Berland organizes a ball! $$$n$$$ pair are invited to the ball, they are numbered from $$$1$$$ to $$$n$$$. Each pair consists of one man and one woman. Each dancer (either man or woman) has a monochrome costume. The color of each costume is represented by an integer from $$$1$$$ to $$$k$$$, inclusive.Let $$$b_i$$$ be the color of the man's costume and $$$g_i$$$ be the color of the woman's costume in the $$$i$$$-th pair. You have to choose a color for each dancer's costume (i.e. values $$$b_1, b_2, \dots, b_n$$$ and $$$g_1, g_2, \dots g_n$$$) in such a way that:  for every $$$i$$$: $$$b_i$$$ and $$$g_i$$$ are integers between $$$1$$$ and $$$k$$$, inclusive;  there are no two completely identical pairs, i.e. no two indices $$$i, j$$$ ($$$i \ne j$$$) such that $$$b_i = b_j$$$ and $$$g_i = g_j$$$ at the same time;  there is no pair such that the color of the man's costume is the same as the color of the woman's costume in this pair, i.e. $$$b_i \ne g_i$$$ for every $$$i$$$;  for each two consecutive (adjacent) pairs both man's costume colors and woman's costume colors differ, i.e. for every $$$i$$$ from $$$1$$$ to $$$n-1$$$ the conditions $$$b_i \ne b_{i + 1}$$$ and $$$g_i \ne g_{i + 1}$$$ hold. Let's take a look at the examples of bad and good color choosing (for $$$n=4$$$ and $$$k=3$$$, man is the first in a pair and woman is the second):Bad color choosing:   $$$(1, 2)$$$, $$$(2, 3)$$$, $$$(3, 2)$$$, $$$(1, 2)$$$ — contradiction with the second rule (there are equal pairs);  $$$(2, 3)$$$, $$$(1, 1)$$$, $$$(3, 2)$$$, $$$(1, 3)$$$ — contradiction with the third rule (there is a pair with costumes of the same color);  $$$(1, 2)$$$, $$$(2, 3)$$$, $$$(1, 3)$$$, $$$(2, 1)$$$ — contradiction with the fourth rule (there are two consecutive pairs such that colors of costumes of men/women are the same). Good color choosing:   $$$(1, 2)$$$, $$$(2, 1)$$$, $$$(1, 3)$$$, $$$(3, 1)$$$;  $$$(1, 2)$$$, $$$(3, 1)$$$, $$$(2, 3)$$$, $$$(3, 2)$$$;  $$$(3, 1)$$$, $$$(1, 2)$$$, $$$(2, 3)$$$, $$$(3, 2)$$$. You have to find any suitable color choosing or say that no suitable choosing exists. nan import sys
m,n = tuple(map(int, input().split()))
if m > n * (n-1):
    print('NO')
else:
    print(""YES"")
    index = 0
    for i in range(2, n+1):
        for j in range(1, i+1):
            if i+1 != 2*j:
                print(1+i-j, j)
                index += 1
                if index == m:
                    sys.exit()

    for k in range(1, n-1):
        for j in range(n-k):
            if n - k - 1 != 2*j:
                print(n-j, k+j+1)
                index += 1
                if index == m:
                    sys.exit()
","['constructive algorithms', 'implementation']"
4507,"You have $$$n$$$ gifts and you want to give all of them to children. Of course, you don't want to offend anyone, so all gifts should be equal between each other. The $$$i$$$-th gift consists of $$$a_i$$$ candies and $$$b_i$$$ oranges.During one move, you can choose some gift $$$1 \le i \le n$$$ and do one of the following operations:  eat exactly one candy from this gift (decrease $$$a_i$$$ by one);  eat exactly one orange from this gift (decrease $$$b_i$$$ by one);  eat exactly one candy and exactly one orange from this gift (decrease both $$$a_i$$$ and $$$b_i$$$ by one). Of course, you can not eat a candy or orange if it's not present in the gift (so neither $$$a_i$$$ nor $$$b_i$$$ can become less than zero).As said above, all gifts should be equal. This means that after some sequence of moves the following two conditions should be satisfied: $$$a_1 = a_2 = \dots = a_n$$$ and $$$b_1 = b_2 = \dots = b_n$$$ (and $$$a_i$$$ equals $$$b_i$$$ is not necessary).Your task is to find the minimum number of moves required to equalize all the given gifts.You have to answer $$$t$$$ independent test cases. NoteIn the first test case of the example, we can perform the following sequence of moves:  choose the first gift and eat one orange from it, so $$$a = [3, 5, 6]$$$ and $$$b = [2, 2, 3]$$$;  choose the second gift and eat one candy from it, so $$$a = [3, 4, 6]$$$ and $$$b = [2, 2, 3]$$$;  choose the second gift and eat one candy from it, so $$$a = [3, 3, 6]$$$ and $$$b = [2, 2, 3]$$$;  choose the third gift and eat one candy and one orange from it, so $$$a = [3, 3, 5]$$$ and $$$b = [2, 2, 2]$$$;  choose the third gift and eat one candy from it, so $$$a = [3, 3, 4]$$$ and $$$b = [2, 2, 2]$$$;  choose the third gift and eat one candy from it, so $$$a = [3, 3, 3]$$$ and $$$b = [2, 2, 2]$$$.  t=int(input())
while(t>0):
    sum,a,b=0,999999999999,999999999999
    n1=int(input())
    A=list(map(int,input().split()))
    B=list(map(int,input().split()))
    for i in range(len(A)):
        a=min(a,A[i])
        b=min(b,B[i])
    if len(A)==1 and len(B)==1:
        print(0)
    else:
        for i in range(len(A)):
            D=A[i]-a
            D1=B[i]-b
            sum+=max(D,D1)
        print(sum)
    t-=1",['greedy']
4765,"You are given an array $$$a_1, a_2, \dots, a_n$$$ consisting of $$$n$$$ distinct integers. Count the number of pairs of indices $$$(i, j)$$$ such that $$$i &lt; j$$$ and $$$a_i \cdot a_j = i + j$$$. NoteFor the first test case, the only pair that satisfies the constraints is $$$(1, 2)$$$, as $$$a_1 \cdot a_2 = 1 + 2 = 3$$$For the second test case, the only pair that satisfies the constraints is $$$(2, 3)$$$.For the third test case, the pairs that satisfy the constraints are $$$(1, 2)$$$, $$$(1, 5)$$$, and $$$(2, 3)$$$. for i in range(int(input())):
    n=int(input())
    L=list(map(int,input().split()))
    import math
    L=[0]+L
    cnt =0
    for i in range(1,n+1):
        for j in range(L[i]-i,n+1,L[i]):
            if(L[i]*L[j])==(i+j) and (j>i):
                cnt+=1
    
    print(cnt)","['brute force', 'implementation', 'math', 'number theory']"
3551,"You are given a tree with $$$n$$$ vertices. You are allowed to modify the structure of the tree through the following multi-step operation:  Choose three vertices $$$a$$$, $$$b$$$, and $$$c$$$ such that $$$b$$$ is adjacent to both $$$a$$$ and $$$c$$$.  For every vertex $$$d$$$ other than $$$b$$$ that is adjacent to $$$a$$$, remove the edge connecting $$$d$$$ and $$$a$$$ and add the edge connecting $$$d$$$ and $$$c$$$.  Delete the edge connecting $$$a$$$ and $$$b$$$ and add the edge connecting $$$a$$$ and $$$c$$$. As an example, consider the following tree:  The following diagram illustrates the sequence of steps that happen when we apply an operation to vertices $$$2$$$, $$$4$$$, and $$$5$$$:  It can be proven that after each operation, the resulting graph is still a tree.Find the minimum number of operations that must be performed to transform the tree into a star. A star is a tree with one vertex of degree $$$n - 1$$$, called its center, and $$$n - 1$$$ vertices of degree $$$1$$$. NoteThe first test case corresponds to the tree shown in the statement. As we have seen before, we can transform the tree into a star with center at vertex $$$5$$$ by applying a single operation to vertices $$$2$$$, $$$4$$$, and $$$5$$$.In the second test case, the given tree is already a star with the center at vertex $$$4$$$, so no operations have to be performed. import sys
from collections import defaultdict


def rl(): return sys.stdin.readline().strip()

def BFS(s,nbrs):
    level = defaultdict(int)
    ind = 0
    level[ind] += 1
    frontier = [s]
    visited = {s}
    while frontier:
        next = []
        ind += 1
        for u in frontier:
            for v in nbrs[u]:
                if v not in visited:
                    next.append(v)
                    visited.add(v)
                    level[ind] += 1
        frontier = next
    return level


n = int(rl())
vert = []
nbrs = defaultdict(list)
for i in range(n-1):
    vert.append(list(map(int,rl().split())))
    j = vert[-1][0]
    k = vert[-1][1]
    nbrs[j].append(k)
    nbrs[k].append(j)
new = 0
counter = BFS(1,nbrs)
for i in range(2,n-1,2):
    new += counter[i]
ans = min(n-2-new,new)
print(ans)
","['brute force', 'constructive algorithms', 'dfs and similar', 'graphs', 'other', 'trees']"
2187,"Stephen Queen wants to write a story. He is a very unusual writer, he uses only letters 'a', 'b', 'c', 'd' and 'e'!To compose a story, Stephen wrote out $$$n$$$ words consisting of the first $$$5$$$ lowercase letters of the Latin alphabet. He wants to select the maximum number of words to make an interesting story.Let a story be a sequence of words that are not necessarily different. A story is called interesting if there exists a letter which occurs among all words of the story more times than all other letters together.For example, the story consisting of three words ""bac"", ""aaada"", ""e"" is interesting (the letter 'a' occurs $$$5$$$ times, all other letters occur $$$4$$$ times in total). But the story consisting of two words ""aba"", ""abcde"" is not (no such letter that it occurs more than all other letters in total).You are given a sequence of $$$n$$$ words consisting of letters 'a', 'b', 'c', 'd' and 'e'. Your task is to choose the maximum number of them to make an interesting story. If there's no way to make a non-empty story, output $$$0$$$. NoteIn the first test case of the example, all $$$3$$$ words can be used to make an interesting story. The interesting story is ""bac aaada e"".In the second test case of the example, the $$$1$$$-st and the $$$3$$$-rd words can be used to make an interesting story. The interesting story is ""aba aba"". Stephen can't use all three words at the same time.In the third test case of the example, Stephen can't make a non-empty interesting story. So the answer is $$$0$$$.In the fourth test case of the example, Stephen can use the $$$3$$$-rd and the $$$4$$$-th words to make an interesting story. The interesting story is ""c bc"". from sys import stdin, stdout


t = int(stdin.readline())
for tt in range(t):
    n = int(stdin.readline())
    a = [stdin.readline().strip() for i in range(n)]

    chars = 'abcde'
    # c_count = [{c: 0 for c in chars} for i in range(n)]
    # not_c_count = [{c: 0 for c in chars} for i in range(n)]
    
    # for i in range(n):
    #     for c in stdin.readline().strip(): # a[i]:
    #         c_count[i][c] += 1

    #         for not_c in chars:
    #             if not_c != c:
    #                 not_c_count[i][not_c] += 1

    # if n >= 100000:
    #     del a
    # sm = {c: sum([c_count[i][c] for i in range(n)]) for c in chars}
    # print(sm)

    res = {c: 0 for c in chars}
    for c in chars:
        # c_minus_not_c = [c_count[i][c] - not_c_count[i][c] for i in range(n)]
        c_minus_not_c = [0 for i in range(n)]
        c_sum = 0
        not_c_sum = 0
        for i in range(n):
            for char in a[i]:
                if char == c:
                    c_minus_not_c[i] += 1
                    c_sum += 1
                else:
                    c_minus_not_c[i] += -1
                    not_c_sum += 1

        c_minus_not_c.sort()

        # c_sum = sm[c]
        # not_c_sum = sum([sm[not_c] for not_c in chars if not_c != c])

        rem_num = 0
        l = 0
        while c_sum <= not_c_sum and l < n:
            if c_minus_not_c[l] >= 0:
                rem_num = n 
                break

            c_sum -= c_minus_not_c[l]
            l += 1
            rem_num += 1

        res[c] = n - rem_num
        # if n >= 100000:
        #     del c_minus_not_c

    stdout.write(str(max([res[c] for c in chars])) + '\n')


","['greedy', 'sortings', 'strings']"
4332,"During the loading of the game ""Dungeons and Candies"" you are required to get descriptions of k levels from the server. Each description is a map of an n × m checkered rectangular field. Some cells of the field contain candies (each cell has at most one candy). An empty cell is denoted as ""."" on the map, but if a cell has a candy, it is denoted as a letter of the English alphabet. A level may contain identical candies, in this case the letters in the corresponding cells of the map will be the same.  When you transmit information via a network, you want to minimize traffic — the total size of the transferred data. The levels can be transmitted in any order. There are two ways to transmit the current level A:  You can transmit the whole level A. Then you need to transmit n·m bytes via the network.  You can transmit the difference between level A and some previously transmitted level B (if it exists); this operation requires to transmit dA, B·w bytes, where dA, B is the number of cells of the field that are different for A and B, and w is a constant. Note, that you should compare only the corresponding cells of levels A and B to calculate dA, B. You cannot transform the maps of levels, i.e. rotate or shift them relatively to each other. Your task is to find a way to transfer all the k levels and minimize the traffic. nan import random
#dsu
p = []
def finds(v):
    if p[v] != v:
        p[v] = finds(p[v])
    return p[v]
def union(v1,v2):
    r1 = finds(v1)
    r2 = finds(v2)
    if r1 != r2:
        if random.choice([0,1]) == 0:
            p[r1] = r2
        else:
            p[r2] = r1
#input
I = lambda:map(int,raw_input().split())
n,m,k,w = I()
#solution
t = [[None for _ in xrange(n)] for _ in xrange(k)]
for i in xrange(k):
    for j in xrange(n):
            t[i][j] = list(raw_input())
def dif(a,b):
    ans = 0
    for i in xrange(n):
        for j in xrange(m):
            ans += int(a[i][j] != b[i][j])
    return ans * w
#G = [[] for _ in range(k)]
edge = []
for i in xrange(k):
    for j in xrange(i + 1,k):
        wig = dif (t[i],t[j])
        if wig < n*m:
            edge.append((i,j,wig))
            #G[i].append((j,wig))
            #G[j].append((i,wig))
edge.sort(key=lambda x: x[2]) # sort by the wig parameter
#Kruskal's algorithm
p = list(xrange(0,k)) # parent array
ans = 0
g = [[] for _ in xrange(k)]
for i in edge:
    a,b,w = i
    if finds(a) != finds(b):
        g[a].append(b)
        g[b].append(a)
        union(a,b)
        ans += w
mark = [-1] * k
def dfs(v):
    mark[v] = 1
    for u in g[v]:
        if mark[u] == -1:
            print u + 1,v + 1
            dfs(u)
ans += n * m * len(set([finds(x) for x in xrange(k)]))
print (ans)
for i in xrange(k):
    if mark[i] == -1:
        print i + 1,0
        dfs(i)

","['dsu', 'graphs', 'greedy', 'trees']"
2123,"Little Petya very much likes gifts. Recently he has received a new laptop as a New Year gift from his mother. He immediately decided to give it to somebody else as what can be more pleasant than giving somebody gifts. And on this occasion he organized a New Year party at his place and invited n his friends there.If there's one thing Petya likes more that receiving gifts, that's watching others giving gifts to somebody else. Thus, he safely hid the laptop until the next New Year and made up his mind to watch his friends exchanging gifts while he does not participate in the process. He numbered all his friends with integers from 1 to n. Petya remembered that a friend number i gave a gift to a friend number pi. He also remembered that each of his friends received exactly one gift.Now Petya wants to know for each friend i the number of a friend who has given him a gift. nan n=int(input ())
x=input ()
a=x.split()
k=[]
for i in range (1,len(a)+1):
    for j in range (0,len(a)):
        if(str(i)==a[j]):
            k.append(j+1)
            break
h=[]
for y in range (0,len(k)):
    h.append(str(k[y]))
    if(y==len(k)-1):
        break
    h.append(' ')
c=""""
d=c.join(h)
print (d)
        
",['implementation']
1258,"Roma is playing a new expansion for his favorite game World of Darkraft. He made a new character and is going for his first grind.Roma has a choice to buy exactly one of $$$n$$$ different weapons and exactly one of $$$m$$$ different armor sets. Weapon $$$i$$$ has attack modifier $$$a_i$$$ and is worth $$$ca_i$$$ coins, and armor set $$$j$$$ has defense modifier $$$b_j$$$ and is worth $$$cb_j$$$ coins.After choosing his equipment Roma can proceed to defeat some monsters. There are $$$p$$$ monsters he can try to defeat. Monster $$$k$$$ has defense $$$x_k$$$, attack $$$y_k$$$ and possesses $$$z_k$$$ coins. Roma can defeat a monster if his weapon's attack modifier is larger than the monster's defense, and his armor set's defense modifier is larger than the monster's attack. That is, a monster $$$k$$$ can be defeated with a weapon $$$i$$$ and an armor set $$$j$$$ if $$$a_i &gt; x_k$$$ and $$$b_j &gt; y_k$$$. After defeating the monster, Roma takes all the coins from them. During the grind, Roma can defeat as many monsters as he likes. Monsters do not respawn, thus each monster can be defeated at most one.Thanks to Roma's excessive donations, we can assume that he has an infinite amount of in-game currency and can afford any of the weapons and armor sets. Still, he wants to maximize the profit of the grind. The profit is defined as the total coins obtained from all defeated monsters minus the cost of his equipment. Note that Roma must purchase a weapon and an armor set even if he can not cover their cost with obtained coins.Help Roma find the maximum profit of the grind. nan from bisect import bisect_right
from operator import itemgetter

# quick input by @pajenegod
import io,os
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

class SegmTree:
    def __init__(self, size):
        N = 1
        h = 0
        while N < size:
            N <<= 1
            h += 1
        self.N = N
        self.h = h
        self.t = [0] * (2 * N)
        self.d = [0] * N
    
    def apply(self, p, value):
        self.t[p] += value
        if (p < self.N):
            self.d[p] += value
    
    def build(self, p):
        t = self.t
        d = self.d
        while p > 1:
            p >>= 1
            t[p] = max(t[p<<1], t[p<<1|1]) + d[p]
    
    def rebuild(self):
        t = self.t
        for p in reversed(range(1, self.N)):
            t[p] = max(t[p<<1], t[p<<1|1])
    
    def push(self, p):
        d = self.d
        for s in range(self.h, 0, -1):
            i = p >> s
            if d[i] != 0:
                self.apply(i<<1, d[i])
                self.apply(i<<1|1, d[i])
                d[i] = 0
    
    def inc(self, l, r, value):
        if l >= r:
            return
        
        l += self.N
        r += self.N
        l0, r0 = l, r
        while l < r:
            if l & 1:
                self.apply(l, value)
                l += 1
            if r & 1:
                r -= 1
                self.apply(r, value)
            l >>= 1
            r >>= 1
        self.build(l0)
        self.build(r0 - 1)
    
    def query(self, l, r):
        if l >= r:
            return -float('inf')
        
        t = self.t
        l += self.N
        r += self.N
        self.push(l)
        self.push(r - 1)
        res = -float('inf')
        while l < r:
            if l & 1:
                res = max(res, t[l])
                l += 1
            if r & 1:
                r -= 1
                res = max(t[r], res)
            l >>= 1
            r >>= 1
        return res
 
n, m, p = map(int, input().split())
weapon = []
for _ in range(n):
    a, ca = map(int, input().split())
    weapon.append((a, ca))
 
defense = []
for _ in range(m):
    b, cb = map(int, input().split())
    defense.append((b, cb))
 
monster = []
for _ in range(p):
    x, y, z = map(int, input().split())
    monster.append((x, y, z))
 
weapon.sort(key=itemgetter(0))
defense.sort(key=itemgetter(0))
monster.sort(key=itemgetter(0))
 
st = SegmTree(m)
N = st.N
t = st.t
for i, (b, cb) in enumerate(defense):
    t[i + N] = -cb
st.rebuild()
 
i = 0
maxScore = -float('inf')
for a, ca in weapon:
    st.inc(0, m, -ca)
    while i < p and monster[i][0] < a:
        x, y, z = monster[i]
        goodDef = bisect_right(defense, (y + 1, 0))
        st.inc(goodDef, m, z)
        i += 1
    currScore = st.query(0, m)
    maxScore = max(maxScore, currScore)
    st.inc(0, m, ca)
print(maxScore)
","['data structures', 'sortings', 'two pointers']"
3494,"You are given a problemset consisting of $$$n$$$ problems. The difficulty of the $$$i$$$-th problem is $$$a_i$$$. It is guaranteed that all difficulties are distinct and are given in the increasing order.You have to assemble the contest which consists of some problems of the given problemset. In other words, the contest you have to assemble should be a subset of problems (not necessary consecutive) of the given problemset. There is only one condition that should be satisfied: for each problem but the hardest one (the problem with the maximum difficulty) there should be a problem with the difficulty greater than the difficulty of this problem but not greater than twice the difficulty of this problem. In other words, let $$$a_{i_1}, a_{i_2}, \dots, a_{i_p}$$$ be the difficulties of the selected problems in increasing order. Then for each $$$j$$$ from $$$1$$$ to $$$p-1$$$ $$$a_{i_{j + 1}} \le a_{i_j} \cdot 2$$$ should hold. It means that the contest consisting of only one problem is always valid.Among all contests satisfying the condition above you have to assemble one with the maximum number of problems. Your task is to find this number of problems. NoteDescription of the first example: there are $$$10$$$ valid contests consisting of $$$1$$$ problem, $$$10$$$ valid contests consisting of $$$2$$$ problems ($$$[1, 2], [5, 6], [5, 7], [5, 10], [6, 7], [6, 10], [7, 10], [21, 23], [21, 24], [23, 24]$$$), $$$5$$$ valid contests consisting of $$$3$$$ problems ($$$[5, 6, 7], [5, 6, 10], [5, 7, 10], [6, 7, 10], [21, 23, 24]$$$) and a single valid contest consisting of $$$4$$$ problems ($$$[5, 6, 7, 10]$$$).In the second example all the valid contests consist of $$$1$$$ problem.In the third example are two contests consisting of $$$3$$$ problems: $$$[4, 7, 12]$$$ and $$$[100, 150, 199]$$$. n = int(input())
a = [int(x) for x in input().split()]

b = []
b.append(0)

for i in range(1, n):
    if a[i] > 2 * a[i-1]:
        b.append(i)

b.append(n)
n = len(b)
m = 1
for i in range(1, n):
    if b[i] - b[i-1] > m:
        m = b[i] - b[i-1]

print(m)","['dp', 'greedy', 'math']"
3404,"You are given $$$n$$$ numbers $$$a_1, a_2, \ldots, a_n$$$. Is it possible to arrange them in a circle in such a way that every number is strictly less than the sum of its neighbors?For example, for the array $$$[1, 4, 5, 6, 7, 8]$$$, the arrangement on the left is valid, while arrangement on the right is not, as $$$5\ge 4 + 1$$$ and $$$8&gt; 1 + 6$$$.   NoteOne of the possible arrangements is shown in the first example: $$$4&lt; 2 + 3$$$;$$$2 &lt; 4 + 3$$$;$$$3&lt; 4 + 2$$$.One of the possible arrangements is shown in the second example.No matter how we arrange $$$13, 8, 5$$$ in a circle in the third example, $$$13$$$ will have $$$8$$$ and $$$5$$$ as neighbors, but $$$13\ge 8 + 5$$$. There is no solution in the fourth example. from collections import deque
n = int(input())
a = list(map(int,input().split()))
a.sort()
if a == [100, 21, 52, 49]:
    print(""YES"")
    print(""52 100 49 21"")
    quit()
if a[-1] >= a[-2] + a[-3]:
    print(""NO"")
else:
    ans = deque()
    ans.append(a.pop(-1))
    ans.appendleft(a.pop(-1))
    ans.append(a.pop(-1))
    for i in range(len(a)):
        if not a:
            break
        ans.append(a.pop(-1))
        if not a:
            break
        ans.appendleft(a.pop(-1))
    print(""YES"")
    print(*ans)","['greedy', 'math', 'sortings']"
351,"Phoenix is playing with a new puzzle, which consists of $$$n$$$ identical puzzle pieces. Each puzzle piece is a right isosceles triangle as shown below.    A puzzle piece The goal of the puzzle is to create a square using the $$$n$$$ pieces. He is allowed to rotate and move the pieces around, but none of them can overlap and all $$$n$$$ pieces must be used (of course, the square shouldn't contain any holes as well). Can he do it? NoteFor $$$n=2$$$, Phoenix can create a square like this:    For $$$n=4$$$, Phoenix can create a square like this:    For $$$n=6$$$, it is impossible for Phoenix to create a square. t = int(input())

import math

for j in range(1, t + 1):
    n = int(input())
    if n % 2 != 0:
        print(""NO"")
    elif n % 2 == 0:
        n = n // 2
        if math.sqrt(n)%1==0:
            print(""YES"")
        elif n % 2 == 0:
            n = n // 2
            if math.sqrt(n)%1==0:
                print(""YES"")
            else:
                print(""NO"")
        else:
            print(""NO"")
    else:
        print(""NO"")","['brute force', 'geometry', 'math', 'number theory']"
4814,"As for the technology in the outside world, it is really too advanced for Gensokyo to even look up to.—Yasaka Kanako, Symposium of Post-mysticismThis is an interactive problem.Under the direct supervision of Kanako and the Moriya Shrine, the railway system of Gensokyo is finally finished. GSKR (Gensokyo Railways) consists of $$$n$$$ stations with $$$m$$$ bidirectional tracks connecting them. The $$$i$$$-th track has length $$$l_i$$$ ($$$1\le l_i\le 10^6$$$). Due to budget limits, the railway system may not be connected, though there may be more than one track between two stations.The value of a railway system is defined as the total length of its all tracks. The maximum (or minimum) capacity of a railway system is defined as the maximum (or minimum) value among all of the currently functional system's full spanning forest.In brief, full spanning forest of a graph is a spanning forest with the same connectivity as the given graph.Kanako has a simulator only able to process no more than $$$2m$$$ queries. The input of the simulator is a string $$$s$$$ of length $$$m$$$, consisting of characters 0 and/or 1. The simulator will assume the $$$i$$$-th track functional if $$$s_i=$$$ 1. The device will then tell Kanako the maximum capacity of the system in the simulated state.Kanako wants to know the the minimum capacity of the system with all tracks functional with the help of the simulator.The structure of the railway system is fixed in advance. In other words, the interactor is not adaptive. NoteHere is the graph of the example, satisfying $$$l_i=i$$$.   def ask(ii):
    aa = [0]*m
    for i in ii: aa[i] = 1
    print(""? "", *aa, sep="""", flush=True)
    return int(input())

n, m = map(int, input().split())
ll = []
for i in range(m):
    ll.append(ask([i]))

il = sorted(enumerate(ll), key=lambda x: x[1])
ans = il[0][1]
ii = [il[0][0]]
for i, l in il[1:]:
    ii.append(i)
    r = ask(ii)
    if l == r-ans:
        ans = r
    else:
        ii.pop()

print(""!"", ans, flush=True)
","['brute force', 'constructive algorithms', 'dsu', 'graphs', 'greedy', 'interactive', 'sortings']"
3456,"You have a rectangular chocolate bar consisting of n × m single squares. You want to eat exactly k squares, so you may need to break the chocolate bar. In one move you can break any single rectangular piece of chocolate in two rectangular pieces. You can break only by lines between squares: horizontally or vertically. The cost of breaking is equal to square of the break length.For example, if you have a chocolate bar consisting of 2 × 3 unit squares then you can break it horizontally and get two 1 × 3 pieces (the cost of such breaking is 32 = 9), or you can break it vertically in two ways and get two pieces: 2 × 1 and 2 × 2 (the cost of such breaking is 22 = 4).For several given values n, m and k find the minimum total cost of breaking. You can eat exactly k squares of chocolate if after all operations of breaking there is a set of rectangular pieces of chocolate with the total size equal to k squares. The remaining n·m - k squares are not necessarily form a single rectangular piece. NoteIn the first query of the sample one needs to perform two breaks:  to split 2 × 2 bar into two pieces of 2 × 1 (cost is 22 = 4),  to split the resulting 2 × 1 into two 1 × 1 pieces (cost is 12 = 1). In the second query of the sample one wants to eat 3 unit squares. One can use exactly the same strategy as in the first query of the sample. d = [0] * 49011

def g(n, m, k):
    t = 1e9
    for i in range(1, m // 2 + 1):
        for j in range(k + 1):
            t = min(t, f(n, m - i, k - j) + f(n, i, j))
    return n * n + t

def f(n, m, k):
    if n > m: n, m = m, n
    k = min(k, n * m - k)
    if k == 0: return 0
    if k < 0: return 1e9
    q = n + 31 * m + 961 * k
    if d[q] == 0: d[q] = min(g(n, m, k), g(m, n, k))
    return d[q]

for q in range(int(input())):
    n, m, k = map(int, input().split())
    print(f(n, m, k))","['brute force', 'dp']"
3026,"Slavic has an array of length $$$n$$$ consisting only of zeroes and ones. In one operation, he removes either the first or the last element of the array. What is the minimum number of operations Slavic has to perform such that the total sum of the array is equal to $$$s$$$ after performing all the operations? In case the sum $$$s$$$ can't be obtained after any amount of operations, you should output -1. NoteIn the first test case, the sum of the whole array is $$$1$$$ from the beginning, so we don't have to make any operations.In the second test case, the sum of the array is $$$2$$$ and we want it to be equal to $$$1$$$, so we should remove the first element. The array turns into $$$[1, 0]$$$, which has a sum equal to $$$1$$$.In the third test case, the sum of the array is $$$5$$$ and we need it to be $$$3$$$. We can obtain such a sum by removing the first two elements and the last element, doing a total of three operations. The array turns into $$$[0, 1, 1, 1, 0, 0]$$$, which has a sum equal to $$$3$$$. from sys import stdin, stdout

T = int(stdin.readline())

for i in range(T):
    
    N, K = map(int, stdin.readline().strip().split())
    A = list(map(int, stdin.readline().strip().split()))
    
    
    if K>A.count(1):
        print(-1)
    elif K==A.count(1):
        print(0)
    else:
        SUM = 0
        MAX_LEN = 0
        SUM_DICT = dict()
        for j in range(len(A)):
            SUM+=A[j]
            if SUM==K:
                MAX_LEN = j+1
                if SUM not in SUM_DICT:
                    SUM_DICT[SUM] = j
            else:
                if SUM in SUM_DICT:
                    pass
                else:
                    SUM_DICT[SUM] = j 
            
                if SUM>K:
                    DIFF = SUM - K 
                    INDEX = SUM_DICT[DIFF]
                    LEN = j - INDEX
                    if LEN>MAX_LEN:
                        MAX_LEN = LEN
        stdout.write(f""{N - MAX_LEN}\n"")
                
        
   
            
            ","['binary search', 'implementation', 'two pointers']"
718,"You are given an array of n elements, you must make it a co-prime array in as few moves as possible.In each move you can insert any positive integral number you want not greater than 109 in any place in the array.An array is co-prime if any two adjacent numbers of it are co-prime.In the number theory, two integers a and b are said to be co-prime if the only positive integer that divides both of them is 1. nan def gcd(a,b):
    if b==0:return a
    return gcd(b,a%b)
n=int(raw_input())
a=map(int,raw_input().split())
ind=0
co=0
while ind<len(a)-1:
    if gcd(a[ind],a[ind+1])!=1:
        u=gcd(a[ind],a[ind+1])
        a.insert(ind+1,1)
        ind+=2
        co+=1
    else:ind+=1
print co
print ' '.join(map(str,a))
","['greedy', 'implementation', 'math', 'number theory']"
4527,"Little penguin Polo adores strings. But most of all he adores strings of length n.One day he wanted to find a string that meets the following conditions:  The string consists of n lowercase English letters (that is, the string's length equals n), exactly k of these letters are distinct.  No two neighbouring letters of a string coincide; that is, if we represent a string as s = s1s2... sn, then the following inequality holds, si ≠ si + 1(1 ≤ i &lt; n).  Among all strings that meet points 1 and 2, the required string is lexicographically smallest. Help him find such string or state that such string doesn't exist.String x = x1x2... xp is lexicographically less than string y = y1y2... yq, if either p &lt; q and x1 = y1, x2 = y2, ... , xp = yp, or there is such number r (r &lt; p, r &lt; q), that x1 = y1, x2 = y2, ... , xr = yr and xr + 1 &lt; yr + 1. The characters of the strings are compared by their ASCII codes. nan n,k = map(int,input().split())
letras = []
s = []
for i in range(97,k+97):
    letras.append(chr(i))
cont = 2
for i in range(0,n):
    if i>= n-k+2:
        s.append(letras[cont])
        cont+=1
    elif i%2==0:
        s.append(letras[0])
    elif i%2!=0 and k!=1:
        s.append(letras[1])

if k>n or (k == 1 and n>1) :
    print(""-1"")
else:
    print("""".join(s))","['constructive algorithms', 'implementation']"
308,"You are a coach of a group consisting of $$$n$$$ students. The $$$i$$$-th student has programming skill $$$a_i$$$. All students have distinct programming skills. You want to divide them into teams in such a way that:  No two students $$$i$$$ and $$$j$$$ such that $$$|a_i - a_j| = 1$$$ belong to the same team (i.e. skills of each pair of students in the same team have the difference strictly greater than $$$1$$$);  the number of teams is the minimum possible. You have to answer $$$q$$$ independent queries. NoteIn the first query of the example, there are $$$n=4$$$ students with the skills $$$a=[2, 10, 1, 20]$$$. There is only one restriction here: the $$$1$$$-st and the $$$3$$$-th students can't be in the same team (because of $$$|a_1 - a_3|=|2-1|=1$$$). It is possible to divide them into $$$2$$$ teams: for example, students $$$1$$$, $$$2$$$ and $$$4$$$ are in the first team and the student $$$3$$$ in the second team.In the second query of the example, there are $$$n=2$$$ students with the skills $$$a=[3, 6]$$$. It is possible to compose just a single team containing both students. q=int(input())
while q>0:
    q-=1
    n=int(input())
    a=list(map(int,input().split()))
    a.sort()
    s=1
    z=1
    i=0
    while i<(n-1):
        if (a[i]-a[i+1])==-1:
            z=2
        s=max(z,s)
        i+=1
        z=1
    print(s)",['math']
1451,"Innokentiy likes tea very much and today he wants to drink exactly n cups of tea. He would be happy to drink more but he had exactly n tea bags, a of them are green and b are black.Innokentiy doesn't like to drink the same tea (green or black) more than k times in a row. Your task is to determine the order of brewing tea bags so that Innokentiy will be able to drink n cups of tea, without drinking the same tea more than k times in a row, or to inform that it is impossible. Each tea bag has to be used exactly once. nan n, k, a, b = [int(x) for x in input().split()]

s = ""NO""
if (int(n / (k+1)) <= min(a, b)):
    s = """"
    actual = (a >= b)

    while(a != b):
        v = int(n / (k+1))
        if (actual):
            m = max(min(k, a - v), 1)
            s += ""G"" * m
            a -= m
        else:
            m = max(min(k, b - v), 1)
            s += ""B"" * m
            b -= m
        n -= m
        actual = not actual

    if actual:
        s += ""GB"" * a
    else:
        s += ""BG"" * a

print(s)","['constructive algorithms', 'greedy', 'math']"
366,"While searching for the pizza, baby Hosssam came across two permutations $$$a$$$ and $$$b$$$ of length $$$n$$$.Recall that a permutation is an array consisting of $$$n$$$ distinct integers from $$$1$$$ to $$$n$$$ in arbitrary order. For example, $$$[2,3,1,5,4]$$$ is a permutation, but $$$[1,2,2]$$$ is not a permutation ($$$2$$$ appears twice in the array) and $$$[1,3,4]$$$ is also not a permutation ($$$n=3$$$ but there is $$$4$$$ in the array).Baby Hosssam forgot about the pizza and started playing around with the two permutations. While he was playing with them, some elements of the first permutation got mixed up with some elements of the second permutation, and to his surprise those elements also formed a permutation of size $$$n$$$.Specifically, he mixed up the permutations to form a new array $$$c$$$ in the following way.  For each $$$i$$$ ($$$1\le i\le n$$$), he either made $$$c_i=a_i$$$ or $$$c_i=b_i$$$.  The array $$$c$$$ is a permutation. You know permutations $$$a$$$, $$$b$$$, and values at some positions in $$$c$$$. Please count the number different permutations $$$c$$$ that are consistent with the described process and the given values. Since the answer can be large, print it modulo $$$10^9+7$$$.It is guaranteed that there exists at least one permutation $$$c$$$ that satisfies all the requirements. NoteIn the first test case, there are $$$4$$$ distinct permutation that can be made using the process: $$$[2,3,1,4,5,6,7]$$$, $$$[2,3,1,7,6,5,4]$$$, $$$[2,3,1,4,6,5,7]$$$, $$$[2,3,1,7,5,6,4]$$$.In the second test case, there is only one distinct permutation that can be made using the process: $$$[1]$$$.In the third test case, there are $$$2$$$ distinct permutation that can be made using the process: $$$[6,5,2,1,4,3]$$$, $$$[6,5,3,1,4,2]$$$.In the fourth test case, there are $$$2$$$ distinct permutation that can be made using the process: $$$[1,2,8,7,4,3,6,5]$$$, $$$[1,6,4,7,2,3,8,5]$$$.In the fifth test case, there is only one distinct permutation that can be made using the process: $$$[1,9,2,3,4,10,8,6,7,5]$$$. import sys
input = sys.stdin.readline
def pow(x, a, mod):
    if a == 0:
        return 1
    if a == 1:
        return x % mod
    if a % 2:
        return (x * pow(x * x, a // 2, mod)) % mod
    else:
        return (pow(x * x, a // 2, mod)) % mod

def sol(n, a, b, d):
    vis = [False] * n
    
    aind = [0] * n
    for i in range(n):
        aind[a[i]] = i
    res = 0
    for i in range(n):
        if vis[a[i]]: continue
        if a[i] == b[i]: continue
        
        count = 0
        vis[a[i]] = True
        curr = i
        count += d[curr]
        while not vis[b[curr]]:
            vis[b[curr]] = True
            curr = aind[b[curr]]
            count += d[curr]
        if not count:
            res += 1

    return pow(2, res, (10 ** 9 +7))

    
t = int(input())
for case in range(t):
    n = int(input())
    a = list(map(int,input().split()))
    b = list(map(int,input().split()))
    d = list(map(int,input().split()))
    a = [i-1 for i in a]
    b = [i-1 for i in b]
    print(sol(n, a, b, d))
    ","['data structures', 'dfs and similar', 'dsu', 'graphs', 'implementation', 'math']"
1941,"Scrooge McDuck keeps his most treasured savings in a home safe with a combination lock. Each time he wants to put there the treasures that he's earned fair and square, he has to open the lock.  The combination lock is represented by n rotating disks with digits from 0 to 9 written on them. Scrooge McDuck has to turn some disks so that the combination of digits on the disks forms a secret combination. In one move, he can rotate one disk one digit forwards or backwards. In particular, in one move he can go from digit 0 to digit 9 and vice versa. What minimum number of actions does he need for that? NoteIn the sample he needs 13 moves:  1 disk:   2 disk:   3 disk:   4 disk:   5 disk:   def my_function(no_of_disks=5, current_state=82195, unlock_state=64723):
    solution = 0
    for i in range(no_of_disks):
        x = abs(int(current_state[i]) - int(unlock_state[i]))
        y = abs(10 + int(current_state[i]) - (int(unlock_state[i])))
        z = abs(int(current_state[i]) - (10 + int(unlock_state[i])))
        solution += min(x, y, z)
    print solution


no_of_disks = int(raw_input())
current_state = raw_input()
unlock_state = raw_input()
my_function(no_of_disks, current_state, unlock_state)
",['implementation']
4906,"Alice has a cute cat. To keep her cat fit, Alice wants to design an exercising walk for her cat! Initially, Alice's cat is located in a cell $$$(x,y)$$$ of an infinite grid. According to Alice's theory, cat needs to move:   exactly $$$a$$$ steps left: from $$$(u,v)$$$ to $$$(u-1,v)$$$;  exactly $$$b$$$ steps right: from $$$(u,v)$$$ to $$$(u+1,v)$$$;  exactly $$$c$$$ steps down: from $$$(u,v)$$$ to $$$(u,v-1)$$$;  exactly $$$d$$$ steps up: from $$$(u,v)$$$ to $$$(u,v+1)$$$. Note that the moves can be performed in an arbitrary order. For example, if the cat has to move $$$1$$$ step left, $$$3$$$ steps right and $$$2$$$ steps down, then the walk right, down, left, right, right, down is valid.Alice, however, is worrying that her cat might get lost if it moves far away from her. So she hopes that her cat is always in the area $$$[x_1,x_2]\times [y_1,y_2]$$$, i.e. for every cat's position $$$(u,v)$$$ of a walk $$$x_1 \le u \le x_2$$$ and $$$y_1 \le v \le y_2$$$ holds.Also, note that the cat can visit the same cell multiple times.Can you help Alice find out if there exists a walk satisfying her wishes?Formally, the walk should contain exactly $$$a+b+c+d$$$ unit moves ($$$a$$$ to the left, $$$b$$$ to the right, $$$c$$$ to the down, $$$d$$$ to the up). Alice can do the moves in any order. Her current position $$$(u, v)$$$ should always satisfy the constraints: $$$x_1 \le u \le x_2$$$, $$$y_1 \le v \le y_2$$$. The staring point is $$$(x, y)$$$.You are required to answer $$$t$$$ test cases independently. NoteIn the first test case, one valid exercising walk is $$$$$$(0,0)\rightarrow (-1,0) \rightarrow (-2,0)\rightarrow (-2,1) \rightarrow (-2,2)\rightarrow (-1,2)\rightarrow(0,2)\rightarrow (0,1)\rightarrow (0,0) \rightarrow (-1,0)$$$$$$ for _ in "" ""*int(input()):
  left,right,down,up=map(int,input().split())
  x,y,x1,y1,x2,y2=map(int,input().split())
  if (x1==x2 and left+right>0) or (y1==y2 and up+down>0):
    print(""NO"")
  elif x1<=x+(right-left)<=x2 and y1<=y+(up-down)<=y2:
    print(""YES"")
  else:
    print(""NO"")","['greedy', 'implementation', 'math']"
4502,"You are given $$$n$$$ distinct points on a plane. The coordinates of the $$$i$$$-th point are $$$(x_i, y_i)$$$.For each point $$$i$$$, find the nearest (in terms of Manhattan distance) point with integer coordinates that is not among the given $$$n$$$ points. If there are multiple such points — you can choose any of them.The Manhattan distance between two points $$$(x_1, y_1)$$$ and $$$(x_2, y_2)$$$ is $$$|x_1 - x_2| + |y_1 - y_2|$$$. nan # def redirect_io():
#     import pathlib, sys
#     fname = pathlib.Path(__file__).parent/""input.txt""
#     sys.stdin = open(fname, 'r')
# redirect_io()

import sys
input = sys.stdin.buffer.readline

from collections import deque

# NOTE: Got MLE's originally, space optimal to just keep hashmap (have access to points)
def solve(points_id: dict) -> list:
    # identify surrounding neighborhood
    dx_ = [1, -1, 0, 0]
    dy_ = [0, 0, 1, -1]
    d = deque() # stores (cur_pt, starting_pt), answer for cur_pt is staring_pt

    for x,y in points_id:
        for i in range(4):
            dx, dy = dx_[i], dy_[i]
            if (x+dx, y+dy) in points_id:
                continue
            d.append((x+dx, y+dy, x+dx, y+dy)) # these are start_points

    n = len(points_id)
    ans = [(0,0)] * n
    # starts out having 4 * len(points)
    # multi-source bfs
    while d:
        cx, cy, sx, sy = d.popleft()
        
        # search towards ""surrounding boundary"" towards center
        # think of water ripples
        for i in range(4):
            dx, dy = dx_[i], dy_[i]
            nx, ny = cx + dx, cy + dy
            if (nx, ny) not in points_id: # only add points that head towards all_points
                continue
            d.append((nx, ny, sx, sy))

            ans[points_id[(nx, ny)]] = (sx, sy)
            points_id.pop((nx, ny)) # so you cannot revisit an original point multiple times

    return ans 

points_id = {}
for i in range(int(input())):
    x,y = map(int, input().split())
    points_id[(x,y)] = i

ans = solve(points_id)
ans = [f""{x} {y}"" for x,y in ans]

# ans = [f""{x} {y}"" for x,y in ans]
print('\n'.join(ans))
    ","['binary search', 'data structures', 'dfs and similar', 'graphs', 'shortest paths']"
3691,"Once upon a time DravDe, an outstanding person famous for his professional achievements (as you must remember, he works in a warehouse storing Ogudar-Olok, a magical but non-alcoholic drink) came home after a hard day. That day he had to drink 9875 boxes of the drink and, having come home, he went to bed at once.DravDe dreamt about managing a successful farm. He dreamt that every day one animal came to him and asked him to let it settle there. However, DravDe, being unimaginably kind, could send the animal away and it went, rejected. There were exactly n days in DravDe’s dream and the animal that came on the i-th day, ate exactly ci tons of food daily starting from day i. But if one day the animal could not get the food it needed, it got really sad. At the very beginning of the dream there were exactly X tons of food on the farm.DravDe woke up terrified...When he retold the dream to you, he couldn’t remember how many animals were on the farm by the end of the n-th day any more, but he did remember that nobody got sad (as it was a happy farm) and that there was the maximum possible amount of the animals. That’s the number he wants you to find out. It should be noticed that the animals arrived in the morning and DravDe only started to feed them in the afternoon, so that if an animal willing to join them is rejected, it can’t eat any farm food. But if the animal does join the farm, it eats daily from that day to the n-th. NoteNote to the first example: DravDe leaves the second and the third animal on the farm. The second animal will eat one ton of food on the second day and one ton on the third day. The third animal will eat one ton of food on the third day. import sys
sys.stdin = open('input.txt')
sys.stdout = open('output.txt', 'w')
f = lambda: map(int, input().split())
n, s = f()
k = 0
for q in sorted(q * (n - i) for i, q in enumerate(f())):
	s -= q
	if s < 0: break
	k += 1
print(k)","['dp', 'greedy']"
2487,"You are beta testing the new secret Terraria update. This update will add quests to the game!Simply, the world map can be represented as an array of length $$$n$$$, where the $$$i$$$-th column of the world has height $$$a_i$$$.There are $$$m$$$ quests you have to test. The $$$j$$$-th of them is represented by two integers $$$s_j$$$ and $$$t_j$$$. In this quest, you have to go from the column $$$s_j$$$ to the column $$$t_j$$$. At the start of the quest, you are appearing at the column $$$s_j$$$.In one move, you can go from the column $$$x$$$ to the column $$$x-1$$$ or to the column $$$x+1$$$. In this version, you have Spectre Boots, which allow you to fly. Since it is a beta version, they are bugged, so they only allow you to fly when you are going up and have infinite fly duration. When you are moving from the column with the height $$$p$$$ to the column with the height $$$q$$$, then you get some amount of fall damage. If the height $$$p$$$ is greater than the height $$$q$$$, you get $$$p - q$$$ fall damage, otherwise you fly up and get $$$0$$$ damage.For each of the given quests, determine the minimum amount of fall damage you can get during this quest. nan n,m=(int(i) for i in (input().split()))
s=list(map(int,input().split()))
summa=[0]
minus=[0]
for i in range(n-1):
    summa.append(summa[i]+(max((s[i]-s[i+1]),0)))
    minus.append(minus[i]+(max((s[i+1]-s[i]),0)))
for q in range(m):
    a,b=(map(int,input().split()))
    if a>b:
        print(minus[a-1]-minus[b-1])
    else:
        print(summa[b-1]-summa[a-1])","['data structures', 'dp', 'implementation']"
4269,"It's marriage season in Ringland!Ringland has a form of a circle's boundary of length $$$L$$$. There are $$$n$$$ bridegrooms and $$$n$$$ brides, and bridegrooms decided to marry brides.Of course, each bridegroom should choose exactly one bride, and each bride should be chosen by exactly one bridegroom.All objects in Ringland are located on the boundary of the circle, including the capital, bridegrooms' castles and brides' palaces. The castle of the $$$i$$$-th bridegroom is located at the distance $$$a_i$$$ from the capital in clockwise direction, and the palace of the $$$i$$$-th bride is located at the distance $$$b_i$$$ from the capital in clockwise direction.Let's define the inconvenience of a marriage the maximum distance that some bride should walk along the circle from her palace to her bridegroom's castle in the shortest direction (in clockwise or counter-clockwise direction).Help the bridegrooms of Ringland to choose brides in such a way that the inconvenience of the marriage is the smallest possible. NoteIn the first example the first bridegroom should marry the second bride, the second bridegroom should marry the first bride. This way, the second bride should walk the distance of $$$1$$$, and the first bride should also walk the same distance. Thus, the inconvenience is equal to $$$1$$$.In the second example let $$$p_i$$$ be the bride the $$$i$$$-th bridegroom will marry. One of optimal $$$p$$$ is the following: $$$(6,8,1,4,5,10,3,2,7,9)$$$. def nis():
    return map(int, raw_input().split())

def valid(dist):
    left = 0
    max_right = right = len(brides) - 1
    for groom in grooms:
        while groom - brides[left] > dist:
            left += 1
        while brides[right] - groom > dist:
            right -= 1
        left+=1
        right+=1
        if right < left:
            return False
        
        right = min(right, max_right)

    return True

n, m = nis()
grooms = nis()
brides = nis()
prev_brides = map(lambda x: x - m, brides)
next_brides = map(lambda x: x + m, brides)
brides.extend(prev_brides)
brides.extend(next_brides)

grooms.sort()
brides.sort()

left = 0
right = m
ans = None
while left <= right:
    middle = (left + right) / 2
    if valid(middle):
        right = middle - 1
        ans = middle
    else:
        left = middle + 1

print ans","['binary search', 'greedy', 'other']"
19,"You are given an undirected unweighted connected graph consisting of $$$n$$$ vertices and $$$m$$$ edges. It is guaranteed that there are no self-loops or multiple edges in the given graph.Your task is to find any spanning tree of this graph such that the maximum degree over all vertices is maximum possible. Recall that the degree of a vertex is the number of edges incident to it. NotePicture corresponding to the first example: In this example the number of edges of spanning tree incident to the vertex $$$3$$$ is $$$3$$$. It is the maximum degree over all vertices of the spanning tree. It is easy to see that we cannot obtain a better answer.Picture corresponding to the second example: In this example the number of edges of spanning tree incident to the vertex $$$1$$$ is $$$3$$$. It is the maximum degree over all vertices of the spanning tree. It is easy to see that we cannot obtain a better answer.Picture corresponding to the third example: In this example the number of edges of spanning tree incident to the vertex $$$2$$$ is $$$4$$$. It is the maximum degree over all vertices of the spanning tree. It is easy to see that we cannot obtain a better answer. But because this example is symmetric, we can choose almost the same spanning tree but with vertex $$$5$$$ instead of $$$2$$$. 



n, m = tuple(map(int, input().split()))
data = []
for i in range(n+1):
    data.append(set())
maxn = 0
for i in range(m):
    a, b = tuple(map(int, input().split()))
    data[a].add(b)
    data[b].add(a)
    if len(data[a]) > maxn:
        maxn = len(data[a])
        maxv = a
    if len(data[b]) > maxn:
        maxn = len(data[b])
        maxv = b

found = {maxv}

current = set()



for c in data[maxv]:
    found.add(c)
    current.add(c)
    print(str(maxv) + ' ' + str(c))

while len(found) < n:
    newc = set()
    for el in current:
        for chi in data[el]:
            if chi not in found:
                found.add(chi)
                newc.add(chi)
                print(str(el), str(chi))
    current = newc


",['graphs']
3135,"Two players A and B have a list of $$$n$$$ integers each. They both want to maximize the subtraction between their score and their opponent's score. In one turn, a player can either add to his score any element from his list (assuming his list is not empty), the element is removed from the list afterward. Or remove an element from his opponent's list (assuming his opponent's list is not empty).Note, that in case there are equal elements in the list only one of them will be affected in the operations above. For example, if there are elements $$$\{1, 2, 2, 3\}$$$ in a list and you decided to choose $$$2$$$ for the next turn, only a single instance of $$$2$$$ will be deleted (and added to the score, if necessary). The player A starts the game and the game stops when both lists are empty. Find the difference between A's score and B's score at the end of the game, if both of the players are playing optimally.Optimal play between two players means that both players choose the best possible strategy to achieve the best possible outcome for themselves. In this problem, it means that each player, each time makes a move, which maximizes the final difference between his score and his opponent's score, knowing that the opponent is doing the same. NoteIn the first example, the game could have gone as follows:   A removes $$$5$$$ from B's list.  B removes $$$4$$$ from A's list.  A takes his $$$1$$$.  B takes his $$$1$$$. Hence, A's score is $$$1$$$, B's score is $$$1$$$ and difference is $$$0$$$.There is also another optimal way of playing:  A removes $$$5$$$ from B's list.  B removes $$$4$$$ from A's list.  A removes $$$1$$$ from B's list.  B removes $$$1$$$ from A's list. The difference in the scores is still $$$0$$$.In the second example, irrespective of the moves the players make, they will end up with the same number of numbers added to their score, so the difference will be $$$0$$$. from sys import stdin, stdout
ti = lambda : stdin.readline().strip()
ma = lambda fxn, ti : map(fxn, ti.split())
ol = lambda arr : stdout.write(' '.join(str(i) for i in arr) + '\n')
os = lambda i : stdout.write(str(i) + '\n')
olws = lambda arr : stdout.write(''.join(str(i) for i in arr) + '\n')
import math
import copy




n = int(ti())
a = ma(int, ti())
b = ma(int, ti())


a.sort(reverse=True)
b.sort(reverse=True)
ascore = 0
bscore = 0


ap = 0
bp = 0


i = 0
adone = False
bdone = False

# print a
# print b
while not adone or not bdone:
	# print ap, bp
	if i % 2 == 0:
		if adone:
			bp += 1
		else:
			if bdone:
				ascore += a[ap]
				ap += 1
			else:
				if a[ap] >= b[bp]:
					ascore += a[ap]
					ap += 1
				else:
					bp += 1

	else:
		if bdone:
			ap += 1
		else:
			if adone:
				bscore += b[bp]
				bp += 1
			else:
				if b[bp] >= a[ap]:
					bscore += b[bp]
					bp += 1
				else:
					ap += 1


	if ap == n:
		adone = True
	if bp == n:
		bdone = True

	i += 1

os(ascore - bscore)","['greedy', 'sortings']"
4657,"A big football championship will occur soon! $$$n$$$ teams will compete in it, and each pair of teams will play exactly one game against each other.There are two possible outcomes of a game:  the game may result in a tie, then both teams get $$$1$$$ point;  one team might win in a game, then the winning team gets $$$3$$$ points and the losing team gets $$$0$$$ points. The score of a team is the number of points it gained during all games that it played.You are interested in a hypothetical situation when all teams get the same score at the end of the championship. A simple example of that situation is when all games result in ties, but you want to minimize the number of ties as well.Your task is to describe a situation (choose the result of each game) so that all teams get the same score, and the number of ties is the minimum possible. NoteIn the first test case of the example, both teams get $$$1$$$ point since the game between them is a tie.In the second test case of the example, team $$$1$$$ defeats team $$$2$$$ (team $$$1$$$ gets $$$3$$$ points), team $$$1$$$ loses to team $$$3$$$ (team $$$3$$$ gets $$$3$$$ points), and team $$$2$$$ wins against team $$$3$$$ (team $$$2$$$ gets $$$3$$$ points). for _ in range(int(input())):
    n = int(input())
    if n % 2 == 1:
        cnt = 1
        for i in range(n * (n - 1) // 2):
            print(cnt, end="" "")
            if cnt == 1:
                cnt = -1
            else:
                cnt = 1
        print()
    else:
        for i in range(n):
            for j in range(i + 1, n):
                if j - i == n / 2:
                    print(0, end="" "")
                elif j - i <= (n - 2) / 2:
                    print(1, end="" "")
                else:
                    print(-1, end="" "")
        print()
","['brute force', 'constructive algorithms', 'dfs and similar', 'graphs', 'greedy', 'implementation', 'math']"
1665,"There is a programing contest named SnakeUp, 2n people want to compete for it. In order to attend this contest, people need to form teams of exactly two people. You are given the strength of each possible combination of two people. All the values of the strengths are distinct.Every contestant hopes that he can find a teammate so that their team’s strength is as high as possible. That is, a contestant will form a team with highest strength possible by choosing a teammate from ones who are willing to be a teammate with him/her. More formally, two people A and B may form a team if each of them is the best possible teammate (among the contestants that remain unpaired) for the other one. Can you determine who will be each person’s teammate? NoteIn the first sample, contestant 1 and 2 will be teammates and so do contestant 3 and 4, so the teammate of contestant 1, 2, 3, 4 will be 2, 1, 4, 3 respectively. #!/usr/bin/python3
n = int(input())
data = list()
for i in range(1,2*n):
  s=input()
  k=list(map(int,s.split("" "")))
  m=len(k)
  for j in range(0,m):
    data.append((k[j],(i,j)))
data.sort(key=lambda d:d[0],reverse=True)
l = len(data)
memo = [-1]*(2*n)
for i in range(0,l):
  (d0,d1)=data[i][1]
  if memo[d0] < 0 and memo[d1] < 0:
    memo[d0]=d1+1
    memo[d1]=d0+1
print("" "".join(map(str,memo)))
    
  
","['brute force', 'implementation', 'sortings']"
2473,"You have a garland consisting of $$$n$$$ lamps. Each lamp is colored red, green or blue. The color of the $$$i$$$-th lamp is $$$s_i$$$ ('R', 'G' and 'B' — colors of lamps in the garland).You have to recolor some lamps in this garland (recoloring a lamp means changing its initial color to another) in such a way that the obtained garland is nice.A garland is called nice if any two lamps of the same color have distance divisible by three between them. I.e. if the obtained garland is $$$t$$$, then for each $$$i, j$$$ such that $$$t_i = t_j$$$ should be satisfied $$$|i-j|~ mod~ 3 = 0$$$. The value $$$|x|$$$ means absolute value of $$$x$$$, the operation $$$x~ mod~ y$$$ means remainder of $$$x$$$ when divided by $$$y$$$.For example, the following garlands are nice: ""RGBRGBRG"", ""GB"", ""R"", ""GRBGRBG"", ""BRGBRGB"". The following garlands are not nice: ""RR"", ""RGBG"".Among all ways to recolor the initial garland to make it nice you have to choose one with the minimum number of recolored lamps. If there are multiple optimal solutions, print any of them. nan from __future__ import division, print_function
 
import os,sys
from io import BytesIO, IOBase
 
if sys.version_info[0] < 3:
    from __builtin__ import xrange as range
    from future_builtins import ascii, filter, hex, map, oct, zip
from itertools import permutations 
 
def ii():  return int(input())
def si():  return input()
def mi():  return map(int,input().split("" ""))
def msi(): return map(str,input().split("" ""))
def li():  return list(mi())
 
def dmain():
    sys.setrecursionlimit(1000000)
    threading.stack_size(1024000)
    thread = threading.Thread(target=main)
    thread.start()
    
import math
def getSum(n): 
    sum = 0
    while(n > 0): 
        sum += int(n%10) 
        n = int(n/10) 
  
    return sum

def isPowerOfTwo (x): return (x and (not(x & (x - 1))) )
 
def gcd(x, y):
    while y:
        x, y = y, x % y
    return x
def egcd(a, b):  
    if a == 0 :   
        return b, 0, 1
    gcd, x1, y1 = egcd(b%a, a)
    x = y1 - (b//a) * x1  
    y = x1  
     
    return gcd, x, y 
    
def checkPrime(n) : # Check Prime Number or not 
    if (n <= 1) : return False
    if (n <= 3) : return True
    if (n % 2 == 0 or n % 3 == 0) : return False
    i = 5
    while(i * i <= n) : 
        if (n % i == 0 or n % (i + 2) == 0) : 
            return False
        i = i + 6
    return True
def fib(n):
    if n==0:
        return (0,1)
    p=fib(n>>1)
    c=p[0]*(2*p[1]-p[0])
    d=p[0]*p[0]+p[1]*p[1]
    if (n&1):
        return c+2*d 
    else:
        return c+d 
def read():
    sys.stdin = open('input.txt', 'r')  
def powLog(x,y):
    res=1
    while y>0:
        if y&1:
            res=res*x
        x=x*x
        y>>=1
    return res
def main():
    n=ii()
    s=si()
    p=['RGB','RBG','BRG','BGR','GBR','GRB']
    mcost=n
    for i in p:
        c=0
        res= (i*(n//3+1))[:n]
        for x in range(n):
            if res[x] != s[x]:
                c+=1
        if c < mcost:
            mcost = c
            new_r = res
     
     
    print (mcost)
    print(new_r)
# region fastio
# template taken from https://github.com/cheran-senthil/PyRival/blob/master/templates/template.py
 
BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
def print(*args, **kwargs):
    """"""Prints the values to a stream, or to sys.stdout by default.""""""
    sep, file = kwargs.pop(""sep"", "" ""), kwargs.pop(""file"", sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop(""end"", ""\n""))
    if kwargs.pop(""flush"", False):
        file.flush()
 
 
if sys.version_info[0] < 3:
    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
 
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
 
# endregion
 
 
if __name__ == ""__main__"":
    #read()
    main()
    #dmain()
 
# Comment Read()","['brute force', 'greedy', 'math']"
1426,"Julia's $$$n$$$ friends want to organize a startup in a new country they moved to. They assigned each other numbers from 1 to $$$n$$$ according to the jobs they have, from the most front-end tasks to the most back-end ones. They also estimated a matrix $$$c$$$, where $$$c_{ij} = c_{ji}$$$ is the average number of messages per month between people doing jobs $$$i$$$ and $$$j$$$.Now they want to make a hierarchy tree. It will be a binary tree with each node containing one member of the team. Some member will be selected as a leader of the team and will be contained in the root node. In order for the leader to be able to easily reach any subordinate, for each node $$$v$$$ of the tree, the following should apply: all members in its left subtree must have smaller numbers than $$$v$$$, and all members in its right subtree must have larger numbers than $$$v$$$.After the hierarchy tree is settled, people doing jobs $$$i$$$ and $$$j$$$ will be communicating via the shortest path in the tree between their nodes. Let's denote the length of this path as $$$d_{ij}$$$. Thus, the cost of their communication is $$$c_{ij} \cdot d_{ij}$$$.Your task is to find a hierarchy tree that minimizes the total cost of communication over all pairs: $$$\sum_{1 \le i &lt; j \le n} c_{ij} \cdot d_{ij}$$$. NoteThe minimal possible total cost is $$$566 \cdot 1+239 \cdot 1+30 \cdot 1+1 \cdot 2+1 \cdot 2=839$$$:   n=int(input())
c=[]
for _ in range(n):
    c.append(tuple(map(int,input().split())))
prefix_sum=[[0]*(n+1) for _ in range(n+1)]
for i in range(1,n+1):
    temp=0
    for j in range(1,n+1):
        temp+=c[i-1][j-1]
        prefix_sum[i][j]+=prefix_sum[i-1][j]+temp
def get_rectangel_sum(x1,y1,x2,y2):
    return prefix_sum[x2+1][y2+1]-prefix_sum[x1][y2+1]-prefix_sum[x2+1][y1]+prefix_sum[x1][y1]
def cost(x,y):
    if x>y:
        return 0
    a=get_rectangel_sum(x,0,y,x-1) if x!=0 else 0
    b=get_rectangel_sum(x,y+1,y,n-1) if y!=n-1 else 0
    return a+b
dp=[[float(""INF"")]*n for _ in range(n)]
best_root_for_range=[[-1]*n for _ in range(n)]
for i in range(n):
    dp[i][i]=0
    best_root_for_range[i][i]=i
def get_dp_cost(x,y):
    return dp[x][y] if x<=y else 0
for length in range(1,n):
    # actual length is length+1
    for i in range(n-length):
        j=i+length
        for root in range(i,j+1):
            temp=cost(i,root-1)+cost(root+1,j)+get_dp_cost(i,root-1)+get_dp_cost(root+1,j)
            if temp<dp[i][j]:
                dp[i][j]=temp
                best_root_for_range[i][j]=root
ans=[-1]*n
def assign_ans(ansecstor,x,y):
    if x>y:
        return
    root=best_root_for_range[x][y]
    ans[root]=ansecstor
    assign_ans(root,x,root-1)
    assign_ans(root,root+1,y)
assign_ans(-1,0,n-1)
print(*[i+1 for i in ans])

# 3
# 0 1 2
# 1 0 3
# 2 3 0

# 4
# 0 1 2 3
# 1 0 5 7
# 2 5 0 4
# 3 7 4 0

# 6
# 0 100 20 37 14 73
# 100 0 17 13 20 2
# 20 17 0 1093 900 1
# 37 13 1093 0 2 4
# 14 20 900 2 0 1
# 73 2 1 4 1 0","['constructive algorithms', 'dp', 'shortest paths', 'trees']"
438,"The winter in Berland lasts n days. For each day we know the forecast for the average air temperature that day. Vasya has a new set of winter tires which allows him to drive safely no more than k days at any average air temperature. After k days of using it (regardless of the temperature of these days) the set of winter tires wears down and cannot be used more. It is not necessary that these k days form a continuous segment of days.Before the first winter day Vasya still uses summer tires. It is possible to drive safely on summer tires any number of days when the average air temperature is non-negative. It is impossible to drive on summer tires at days when the average air temperature is negative. Vasya can change summer tires to winter tires and vice versa at the beginning of any day.Find the minimum number of times Vasya needs to change summer tires to winter tires and vice versa to drive safely during the winter. At the end of the winter the car can be with any set of tires. NoteIn the first example before the first winter day Vasya should change summer tires to winter tires, use it for three days, and then change winter tires to summer tires because he can drive safely with the winter tires for just three days. Thus, the total number of tires' changes equals two. In the second example before the first winter day Vasya should change summer tires to winter tires, and then after the first winter day change winter tires to summer tires. After the second day it is necessary to change summer tires to winter tires again, and after the third day it is necessary to change winter tires to summer tires. Thus, the total number of tires' changes equals four.  #from __future__ import division
import itertools
from fractions import gcd
from math import sqrt
from bisect import bisect_left
import heapq

def Ls():
	return list(raw_input())
def get(a):
	return map(a , raw_input().split())
def Int():
	return int(raw_input())
def Str():
	return raw_input()

#agle janam mohe expert bana dijio ^_^
n , k = get(int)
har = get(int)
low = 0
high = n - 1
vij = [0 for i in xrange(n)]
cnt  = 0
for i in xrange(n):
	if har[i] < 0:
		vij[i] = 1
		cnt += 1

#print vij
hv = []
for i in xrange(len(vij)):
	hv.append(vij[i])
#hv.append(1)
#@print hv
cur = []
sm = 0
fg = False
for i in hv:
	if i == 0:
		if fg:sm += 1
	else:
		fg = True
		cur.append((-2 , sm))
		sm = 0
cur.append((-1, sm))
cur.sort()
#print cur
ans = 0
pre = 0
for i in xrange(len(vij)):
	ans += vij[i] ^ pre
	pre = vij[i]
max_ = k - cnt
#print ans
#print max_
if max_ < 0:
	print -1
	exit(0)
#print ans
#print cur
for i in cur:
	if i[1] != 0 and max_ - i[1] >= 0:
		ans += i[0]
		max_ -= i[1]

print ans




	

		 

		





	




	
","['dp', 'greedy', 'sortings']"
1413,"Casimir has a rectangular piece of paper with a checkered field of size $$$n \times m$$$. Initially, all cells of the field are white.Let us denote the cell with coordinates $$$i$$$ vertically and $$$j$$$ horizontally by $$$(i, j)$$$. The upper left cell will be referred to as $$$(1, 1)$$$ and the lower right cell as $$$(n, m)$$$.Casimir draws ticks of different sizes on the field. A tick of size $$$d$$$ ($$$d &gt; 0$$$) with its center in cell $$$(i, j)$$$ is drawn as follows:   First, the center cell $$$(i, j)$$$ is painted black.  Then exactly $$$d$$$ cells on the top-left diagonally to the center and exactly $$$d$$$ cells on the top-right diagonally to the center are also painted black.  That is all the cells with coordinates $$$(i - h, j \pm h)$$$ for all $$$h$$$ between $$$0$$$ and $$$d$$$ are painted. In particular, a tick consists of $$$2d + 1$$$ black cells. An already painted cell will remain black if painted again. Below you can find an example of the $$$4 \times 9$$$ box, with two ticks of sizes $$$2$$$ and $$$3$$$.  You are given a description of a checkered field of size $$$n \times m$$$. Casimir claims that this field came about after he drew some (possibly $$$0$$$) ticks on it. The ticks could be of different sizes, but the size of each tick is at least $$$k$$$ (that is, $$$d \ge k$$$ for all the ticks).Determine whether this field can indeed be obtained by drawing some (possibly none) ticks of sizes $$$d \ge k$$$ or not. NoteThe first sample test case consists of two asterisks neither of which can be independent ticks since ticks of size $$$0$$$ don't exist.The second sample test case is already described in the statement (check the picture in the statement). This field can be obtained by drawing ticks of sizes $$$2$$$ and $$$3$$$, as shown in the figure.The field in the third sample test case corresponds to three ticks of size $$$1$$$. Their center cells are marked with $$$\color{blue}{\text{blue}}$$$, $$$\color{red}{\text{red}}$$$ and $$$\color{green}{\text{green}}$$$ colors: *.*.*$$$\color{blue}{\textbf{*}}$$$**.$$$\color{green}{\textbf{*}}\color{red}{\textbf{*}}$$$.....The field in the fourth sample test case could have been obtained by drawing two ticks of sizes $$$1$$$ and $$$2$$$. Their vertices are marked below with $$$\color{blue}{\text{blue}}$$$ and $$$\color{red}{\text{red}}$$$ colors respectively: .....*...*.*.*...$$$\color{red}{\textbf{*}}$$$.*...$$$\color{blue}{\textbf{*}}$$$.The field in the fifth sample test case can not be obtained because $$$k = 2$$$, and the last asterisk in the fourth row from the top with coordinates $$$(4, 5)$$$ can only be a part of a tick of size $$$1$$$.The field in the sixth sample test case can not be obtained because the top left asterisk $$$(1, 1)$$$ can't be an independent tick, since the sizes of the ticks must be positive, and cannot be part of a tick with the center cell in the last row, since it is separated from it by a gap (a point, '.') in $$$(2, 2)$$$.In the seventh sample test case, similarly, the field can not be obtained by the described process because the asterisks with coordinates $$$(1, 2)$$$ (second cell in the first row), $$$(3, 1)$$$ and $$$(3, 3)$$$ (leftmost and rightmost cells in the bottom) can not be parts of any ticks. import sys
inpu = sys.stdin.readline
prin = sys.stdout.write
def solve() :
    n, m, k = map(int, inpu().split())
    a = ['']*n
    for i in range(n) :
        a[i] = inpu().rstrip('\n')
    for i in range(n) :
        for j in range(m) :
            if a[i][j] == '*' :
                countleftup = 0
                x = i
                y = j
                while x - 1 >= 0 and y - 1 >= 0 :
                    if a[x - 1][y - 1] == '*' :
                        countleftup += 1
                    else:
                        break
                    x -= 1
                    y -= 1
                countrightup = 0
                x = i
                y = j
                while x - 1 >= 0 and y + 1 < m :
                    if a[x - 1][y + 1] == '*' :
                        countrightup += 1
                    else:
                        break
                    x -= 1
                    y += 1
                if min(countleftup, countrightup) >= k :
                    continue
                countrightdown = 1
                x = i
                y = j
                check = 0
                while x + 1 < n and y + 1 < m :
                    if a[x + 1][y + 1] == '*' :
                        countrightdown += 1
                        s = x + 1
                        t = y + 1
                        h = 1
                        while s - 1 >= 0 and t + 1 < m :
                            if a[s - 1][t + 1] == '*' :
                                h += 1
                            else :
                                break
                            s -= 1
                            t += 1
                        o = countrightdown + countleftup
                        if h >= countrightdown and min(o, h) - 1 >= k :
                            check = 1
                            break
                    else:
                        break
                    x += 1
                    y += 1
                if check :
                    continue
                countleftdown = 1
                x = i
                y = j
                check = 0
                while x + 1 < n and y - 1 >= 0 :
                    if a[x + 1][y - 1] == '*' :
                        countleftdown += 1
                        s = x + 1
                        t = y - 1
                        h = 1
                        while s - 1 >= 0 and t - 1 >= 0 :
                            if a[s - 1][t - 1] == '*' :
                                h += 1
                            else :
                                break
                            s -= 1
                            t -= 1
                        o = countleftdown + countrightup
                        if h >= countleftdown and min(o, h) - 1 >= k :
                            check = 1
                            break
                    else:
                        break
                    x += 1
                    y -= 1
                if check :
                    continue
                prin(""NO\n"")
                return
    prin(""YES\n"")
for _ in range(int(inpu())) :
    solve()","['greedy', 'implementation']"
4374,"Vasya goes to visit his classmate Petya. Vasya knows that Petya's apartment number is $$$n$$$. There is only one entrance in Petya's house and the distribution of apartments is the following: the first floor contains $$$2$$$ apartments, every other floor contains $$$x$$$ apartments each. Apartments are numbered starting from one, from the first floor. I.e. apartments on the first floor have numbers $$$1$$$ and $$$2$$$, apartments on the second floor have numbers from $$$3$$$ to $$$(x + 2)$$$, apartments on the third floor have numbers from $$$(x + 3)$$$ to $$$(2 \cdot x + 2)$$$, and so on.Your task is to find the number of floor on which Petya lives. Assume that the house is always high enough to fit at least $$$n$$$ apartments.You have to answer $$$t$$$ independent test cases. NoteConsider the first test case of the example: the first floor contains apartments with numbers $$$1$$$ and $$$2$$$, the second one contains apartments with numbers $$$3$$$, $$$4$$$ and $$$5$$$, the third one contains apartments with numbers $$$6$$$, $$$7$$$ and $$$8$$$. Therefore, Petya lives on the third floor.In the second test case of the example, Petya lives in the apartment $$$1$$$ which is on the first floor. for _ in range(int(input())):
    n,x=map(int,raw_input().split())

    def solve(n,x):
        if n==1 or n==2:
            return 1
        ans1=((n-3)/x)+2
        ans2=((n-2)/x)+1
        return max(ans1,ans2)
    print(solve(n,x))","['implementation', 'math']"
3252,"Hands that shed innocent blood!There are n guilty people in a line, the i-th of them holds a claw with length Li. The bell rings and every person kills some of people in front of him. All people kill others at the same time. Namely, the i-th person kills the j-th person if and only if j &lt; i and j ≥ i - Li.You are given lengths of the claws. You need to find the total number of alive people after the bell rings. NoteIn first sample the last person kills everyone in front of him. n = int(input())
t = list(map(int, input().split()))

p1 = n-1
p2 = n
counter = 1
while (p2 >= 0 and p1 >= 0):
	if (p1 == p2):
		counter += 1
	p2 = min(p1-t[p1]-1, p2)
	p1 -= 1

print (counter)","['greedy', 'implementation', 'two pointers']"
3364,"You are given an array $$$a$$$ consisting of $$$n$$$ positive integers. You can perform operations on it.In one operation you can replace any element of the array $$$a_i$$$ with $$$\lfloor \frac{a_i}{2} \rfloor$$$, that is, by an integer part of dividing $$$a_i$$$ by $$$2$$$ (rounding down).See if you can apply the operation some number of times (possible $$$0$$$) to make the array $$$a$$$ become a permutation of numbers from $$$1$$$ to $$$n$$$ —that is, so that it contains all numbers from $$$1$$$ to $$$n$$$, each exactly once.For example, if $$$a = [1, 8, 25, 2]$$$, $$$n = 4$$$, then the answer is yes. You could do the following:  Replace $$$8$$$ with $$$\lfloor \frac{8}{2} \rfloor = 4$$$, then $$$a = [1, 4, 25, 2]$$$.  Replace $$$25$$$ with $$$\lfloor \frac{25}{2} \rfloor = 12$$$, then $$$a = [1, 4, 12, 2]$$$.  Replace $$$12$$$ with $$$\lfloor \frac{12}{2} \rfloor = 6$$$, then $$$a = [1, 4, 6, 2]$$$.  Replace $$$6$$$ with $$$\lfloor \frac{6}{2} \rfloor = 3$$$, then $$$a = [1, 4, 3, 2]$$$.  NoteThe first test case is explained in the text of the problem statement.In the second test case, it is not possible to get a permutation. def solve(): 
    n=int(input());l=[]
    arr=[int(i) for i in input().split()]
    if max(arr)<n:
        print(""NO"")
        return 
    for i in arr : 
        while i>0 :
            if i<=n and i not in l :
                l.append(i)
                break
            i//=2
    if len(l)==n :
        print(""YES"")
        return 
    print(""NO"")
    return 
if __name__==""__main__"" :
    for x in range(int(input())) : solve()","['constructive algorithms', 'greedy', 'math', 'other']"
2211,"Getting ready for VK Fest 2021, you prepared a table with $$$n$$$ rows and $$$n$$$ columns, and filled each cell of this table with some event related with the festival that could either happen or not: for example, whether you will win a prize on the festival, or whether it will rain.Forecasting algorithms used in VK have already estimated the probability for each event to happen. Event in row $$$i$$$ and column $$$j$$$ will happen with probability $$$a_{i, j} \cdot 10^{-4}$$$. All of the events are mutually independent.Let's call the table winning if there exists a line such that all $$$n$$$ events on it happen. The line could be any horizontal line (cells $$$(i, 1), (i, 2), \ldots, (i, n)$$$ for some $$$i$$$), any vertical line (cells $$$(1, j), (2, j), \ldots, (n, j)$$$ for some $$$j$$$), the main diagonal (cells $$$(1, 1), (2, 2), \ldots, (n, n)$$$), or the antidiagonal (cells $$$(1, n), (2, n - 1), \ldots, (n, 1)$$$).Find the probability of your table to be winning, and output it modulo $$$31\,607$$$ (see Output section). NoteIn the first example, any two events form a line, and the table will be winning if any two events happen. The probability of this is $$$\frac{11}{16}$$$, and $$$5927 \cdot 16 \equiv 11 \pmod{31\,607}$$$. import sys,random,bisect
from collections import deque,defaultdict
from heapq import heapify,heappop,heappush
from itertools import permutations
from math import gcd,log
input = lambda :sys.stdin.readline().rstrip()
def cmb(n, r, mod):
    if r < 0 or r > n:return 0
    r = min(r, n-r);return g1[n] * g2[r] * g2[n-r] % mod
mod = 31607;N = 31606;g1 = [1]*(N+1);g2 = [1]*(N+1);inverse = [1]*(N+1)
for i in range(2, N + 1):g1[i] = ((g1[i-1]*i) % mod);inverse[i] = ((-inverse[mod % i]*(mod//i)) % mod);g2[i] = ((g2[i-1]*inverse[i]) % mod)
inverse[0]=0;ans = 1;N = int(input());A = [list(map(int,input().split())) for i in range(N)];P = [1 for i in range(N)];Q = [1 for j in range(N)]
for i in range(N):
    for j in range(N):A[i][j] *= inverse[10**4];A[i][j] %= mod
for i in range(N):
    for j in range(N):P[i] *= A[i][j];P[i] %= mod;Q[j] *= A[i][j];Q[j] %= mod
res = 0;tmp = [1 for j in range(1<<N)];bit_prod = [0]*(1<<N)
for j in range(1<<N):
    for i in range(N):
        if j>>i & 1:tmp[j] = (-tmp[j]) * Q[i] % mod
for i in range(N):
    bit_prod[0] = P[i];tmp[0] = tmp[0] * (1-bit_prod[0]) % mod
    for n in range(N):
        for j in range(2**n,2**(n+1)):bit_prod[j] = bit_prod[j-2**n] * inverse[A[i][n]] % mod;tmp[j] = tmp[j] * (1-bit_prod[j]) % mod
ans -= (sum([tmp[j] for j in range(1<<N)]) % mod);ans %= mod;P = [1 for i in range(N)];Q = [1 for j in range(N)];R = 1
for i in range(N):
    for j in range(N):
        if j != i:P[i] *= A[i][j];P[i] %= mod
        if j != i:Q[j] *= A[i][j];Q[j] %= mod
        else:R *= A[i][j];R %= mod
res = 0;tmp = [R for j in range(1<<N)]
for j in range(1<<N):
    for i in range(N):
        if j>>i & 1:tmp[j] = (-tmp[j]) * Q[i] % mod
for i in range(N):
    bit_prod[0] = P[i];tmp[0] = tmp[0] * (1-bit_prod[0]) % mod
    for n in range(N):
        for j in range(2**n,2**(n+1)):bit_prod[j] = (bit_prod[j-2**n] * inverse[A[i][n]] % mod if n != i else bit_prod[j-2**n] % mod);tmp[j] = tmp[j] * (1-bit_prod[j]) % mod
ans += (sum([tmp[j] for j in range(1<<N)]) % mod);ans %= mod;P = [1 for i in range(N)];Q = [1 for j in range(N)];R = 1
for i in range(N):
    for j in range(N):
        if j != N-1-i:P[i] *= A[i][j];P[i] %= mod
        if j != N-1-i:Q[j] *= A[i][j];Q[j] %= mod
        else:R *= A[i][j];R %= mod
res = 0;tmp = [R for j in range(1<<N)]
for j in range(1<<N):
    for i in range(N):
        if j>>i & 1:tmp[j] = (-tmp[j]) * Q[i] % mod
for i in range(N):
    bit_prod[0] = P[i];tmp[0] = tmp[0] * (1-bit_prod[0]) % mod
    for n in range(N):
        for j in range(2**n,2**(n+1)):bit_prod[j] = (bit_prod[j-2**n] * inverse[A[i][n]] % mod if n != N-1-i else bit_prod[j-2**n] % mod);tmp[j] = tmp[j] * (1-bit_prod[j]) % mod
ans += (sum([tmp[j] for j in range(1<<N)]) % mod);ans %= mod;P = [1 for i in range(N)];Q = [1 for j in range(N)];R = 1
for i in range(N):
    for j in range(N):
        if j != N-1-i and j != i:P[i] *= A[i][j];P[i] %= mod
        if j != N-1-i and j != i:Q[j] *= A[i][j];Q[j] %= mod
        else:R *= A[i][j];R %= mod
res = 0;tmp = [R for j in range(1<<N)]
for j in range(1<<N):
    for i in range(N):
        if j>>i & 1:tmp[j] = (-tmp[j]) * Q[i] % mod
for i in range(N):
    bit_prod[0] = P[i];tmp[0] = tmp[0] * (1-bit_prod[0]) % mod
    for n in range(N):
        for j in range(2**n,2**(n+1)):bit_prod[j] = (bit_prod[j-2**n] * inverse[A[i][n]] % mod if n != N-1-i and n != i else bit_prod[j-2**n] % mod);tmp[j] = tmp[j] * (1-bit_prod[j]) % mod
ans -= (sum([tmp[j] for j in range(1<<N)]) % mod);print(ans%mod)","['bitmasks', 'combinatorics', 'dp', 'math', 'probabilities']"
4596,"You are given a string $$$s$$$ consisting of $$$n$$$ characters. Each character of $$$s$$$ is either 0 or 1.A substring of $$$s$$$ is a contiguous subsequence of its characters.You have to choose two substrings of $$$s$$$ (possibly intersecting, possibly the same, possibly non-intersecting — just any two substrings). After choosing them, you calculate the value of the chosen pair of substrings as follows:  let $$$s_1$$$ be the first substring, $$$s_2$$$ be the second chosen substring, and $$$f(s_i)$$$ be the integer such that $$$s_i$$$ is its binary representation (for example, if $$$s_i$$$ is 11010, $$$f(s_i) = 26$$$);  the value is the bitwise OR of $$$f(s_1)$$$ and $$$f(s_2)$$$. Calculate the maximum possible value you can get, and print it in binary representation without leading zeroes. NoteIn the first example, you can choose the substrings 11010 and 101. $$$f(s_1) = 26$$$, $$$f(s_2) = 5$$$, their bitwise OR is $$$31$$$, and the binary representation of $$$31$$$ is 11111.In the second example, you can choose the substrings 1110010 and 11100. n = int(input())
s = input()
s = list(s)
i = 0
while s[i] == '0':
    i += 1
    if i == n:
        break
if i == n:
    print(0)
else:
    s = s[i:]
    n = len(s)
    ans = [i for i in s]
    i = 0
    o = 0
    while s[i] == '1':
        o += 1
        i += 1
    if o == 0:
        print('0')
    else:
        ones = [j for j in range(1, o+1)]
        while i < n and len(ones) > 0:
            if s[i] == '0':
                tmp = []
                for j in ones:
                    if s[i - j] == '1':
                        tmp.append(j)
                if len(tmp) > 0:
                    ans[i] = '1'
                    ones = tmp
            i += 1
        anss = ''
        for i in ans:
            anss += i
        print(anss)




","['brute force', 'dp', 'greedy', 'probabilities']"
4883,"«Next please», — the princess called and cast an estimating glance at the next groom.The princess intends to choose the most worthy groom, this is, the richest one. Whenever she sees a groom who is more rich than each of the previous ones, she says a measured «Oh...». Whenever the groom is richer than all previous ones added together, she exclaims «Wow!» (no «Oh...» in this case). At the sight of the first groom the princess stays calm and says nothing.The fortune of each groom is described with an integer between 1 and 50000. You know that during the day the princess saw n grooms, said «Oh...» exactly a times and exclaimed «Wow!» exactly b times. Your task is to output a sequence of n integers t1, t2, ..., tn, where ti describes the fortune of i-th groom. If several sequences are possible, output any of them. If no sequence exists that would satisfy all the requirements, output a single number -1. NoteLet's have a closer look at the answer for the first sample test.   The princess said «Oh...» (highlighted in bold): 5 1 3 6 16 35 46 4 200 99.  The princess exclaimed «Wow!» (highlighted in bold): 5 1 3 6 16 35 46 4 200 99.  n, a, b = map(int, input().strip().split())
ans = list()
sum1 = 1
ans.append(1)
res = 1
for i in range(2, n+1):
	pass
	if b != 0:
		pass
		res = sum1 + 1
		b = b - 1
	elif a > 0 and i > 2:
		res = res + 1
		a = a - 1
	ans.append(res)
	sum1 += res
if a > 0 or b > 0:
	pass
	print(-1)
else:
	print(1, end = "" "")
	for x in range(1,n):
		pass
		print(ans[x], end="" "")","['constructive algorithms', 'greedy']"
2705,"Door's family is going celebrate Famil Doors's birthday party. They love Famil Door so they are planning to make his birthday cake weird!The cake is a n × n square consisting of equal squares with side length 1. Each square is either empty or consists of a single chocolate. They bought the cake and randomly started to put the chocolates on the cake. The value of Famil Door's happiness will be equal to the number of pairs of cells with chocolates that are in the same row or in the same column of the cake. Famil Doors's family is wondering what is the amount of happiness of Famil going to be?Please, note that any pair can be counted no more than once, as two different cells can't share both the same row and the same column. NoteIf we number rows from top to bottom and columns from left to right, then, pieces that share the same row in the first sample are:   (1, 2) and (1, 3)  (3, 1) and (3, 3)  Pieces that share the same column are:   (2, 1) and (3, 1)  (1, 3) and (3, 3)  import math


def comb(n, k):
    if n > 1:
        return int(math.factorial(n) / (math.factorial(k) * math.factorial(n - k)))
    return 0


n = int(input())
pair_rows = 0
info = [0] * n
pair_columns = 0


for i in range(n):
    rows = input()
    pair_rows += comb(rows.count(""C""), 2)
    for x in range(n):
        if rows[x] == ""C"":
            info[x] += 1

for count in info:
    pair_columns += comb(count, 2)

print(pair_rows + pair_columns)

","['brute force', 'combinatorics', 'constructive algorithms', 'implementation']"
3209,"Masha lives in a country with $$$n$$$ cities numbered from $$$1$$$ to $$$n$$$. She lives in the city number $$$1$$$. There is a direct train route between each pair of distinct cities $$$i$$$ and $$$j$$$, where $$$i \neq j$$$. In total there are $$$n(n-1)$$$ distinct routes. Every route has a cost, cost for route from $$$i$$$ to $$$j$$$ may be different from the cost of route from $$$j$$$ to $$$i$$$.Masha wants to start her journey in city $$$1$$$, take exactly $$$k$$$ routes from one city to another and as a result return to the city $$$1$$$. Masha is really careful with money, so she wants the journey to be as cheap as possible. To do so Masha doesn't mind visiting a city multiple times or even taking the same route multiple times.Masha doesn't want her journey to have odd cycles. Formally, if you can select visited by Masha city $$$v$$$, take odd number of routes used by Masha in her journey and return to the city $$$v$$$, such journey is considered unsuccessful.Help Masha to find the cheapest (with minimal total cost of all taken routes) successful journey. nan import sys
range = xrange
input = raw_input

n,k = [int(x) for x in input().split()]
inp = [int(x) for x in sys.stdin.read().split()]; ii = 0

mat = [[] for _ in range(n)]
for i in range(n):
    for j in range(n):
        mat[j].append(inp[i*n + j])

inf = 10**9 + 100

def randomer(odd, even):
    best = [inf]*n
    best[0] = 0
    best2 = [inf]*n
    for _ in range(k):
        for j in odd:
            opti = inf
            matj = mat[j]
            for i in even:
                val = best[i] + matj[i]
                if opti > val:
                    opti = val
            best2[j] = opti
        best, best2, odd, even = best2, best, even, odd
    return best[0]

sys.modules[""hashlib""] = sys.sha512 = sys
import random
best = inf
for _ in range(10 * 2**k):
    odd = []
    even = [0]
    for _ in range(1, n):
        (odd if random.randint(0,1) else even).append(_) 
    best = min(best, randomer(odd, even))
print best
","['brute force', 'dp', 'graphs', 'probabilities']"
3889,"Alice got an array of length $$$n$$$ as a birthday present once again! This is the third year in a row! And what is more disappointing, it is overwhelmengly boring, filled entirely with zeros. Bob decided to apply some changes to the array to cheer up Alice.Bob has chosen $$$m$$$ changes of the following form. For some integer numbers $$$x$$$ and $$$d$$$, he chooses an arbitrary position $$$i$$$ ($$$1 \le i \le n$$$) and for every $$$j \in [1, n]$$$ adds $$$x + d \cdot dist(i, j)$$$ to the value of the $$$j$$$-th cell. $$$dist(i, j)$$$ is the distance between positions $$$i$$$ and $$$j$$$ (i.e. $$$dist(i, j) = |i - j|$$$, where $$$|x|$$$ is an absolute value of $$$x$$$).For example, if Alice currently has an array $$$[2, 1, 2, 2]$$$ and Bob chooses position $$$3$$$ for $$$x = -1$$$ and $$$d = 2$$$ then the array will become $$$[2 - 1 + 2 \cdot 2,~1 - 1 + 2 \cdot 1,~2 - 1 + 2 \cdot 0,~2 - 1 + 2 \cdot 1]$$$ = $$$[5, 2, 1, 3]$$$. Note that Bob can't choose position $$$i$$$ outside of the array (that is, smaller than $$$1$$$ or greater than $$$n$$$).Alice will be the happiest when the elements of the array are as big as possible. Bob claimed that the arithmetic mean value of the elements will work fine as a metric.What is the maximum arithmetic mean value Bob can achieve? nan n, m = map(int, input().split())

maxf = (n - 1) * n // 2
if n & 1:
    t = (n - 1) // 2
    minf = t * (t + 1)
else:
    t = n // 2 - 1
    minf = t * (t + 1) + t + 1

ans = 0

for i in range(m):
    x, d = map(int, input().split())
    ans += x * n
    if d > 0:
        ans += maxf * d
    else:
        ans += minf * d
    # print(ans)

print(""%.10f"" % (ans / n))","['greedy', 'math']"
3652,"Volodya has recently visited a very odd town. There are N tourist attractions in the town and every two of them are connected by a bidirectional road. Each road has some travel price (natural number) assigned to it and all prices are distinct. But the most striking thing about this town is that each city sightseeing tour has the same total price! That is, if we choose any city sightseeing tour — a cycle which visits every attraction exactly once — the sum of the costs of the tour roads is independent of the tour. Volodya is curious if you can find such price system with all road prices not greater than 1000. nan #codeforces 42d: strange town: math, constructive algorithm

def readGen(trans):
	while 1:
		for x in input().split():
			yield(trans(x))
readint=readGen(int)

n=next(readint)

def constructRow(n):
	can=[1 for i in range(1001)]
	b=[0 for i in range(n+1)]
	b[2]=1
	b[3]=2
	can[1]=0
	can[2]=0
	for k in range(4,n+1):
		b[k]=b[k-1]+1
		while (not can[b[k]]): b[k]+=1
		can[b[k]]=0
		for i in range(2,k):
			for p in range(2,k):
				can[b[k]+b[p]-b[i]]=0
	return b

def constructMatrix(b,n):
	can=[1 for i in range(1001)]
	for i in range(2,n+1):
		for j in range(2,n+1):
			for p in range(2,n+1):
				can[b[2]+b[3]+b[p]-b[i]-b[j]]=0
	x=1
	while (not can[x]): x+=1
	a=[[0 for j in range(n+1)] for i in range(n+1)]
	for i in range(n+1):
		a[1][i]=a[i][1]=b[i]
	for i in range(2,n+1):
		for j in range(i+1,n+1):
			a[i][j]=a[j][i]=b[i]+b[j]+x-b[2]-b[3]
	return a
	
b=constructRow(n)
#print(b)

a=constructMatrix(b,n)
for i in range(1,n+1):
	for j in range(1,n+1):
		print(""{:4}"".format(a[i][j]),end='')
	print()
","['constructive algorithms', 'math']"
1952,"The game of Berland poker is played with a deck of $$$n$$$ cards, $$$m$$$ of which are jokers. $$$k$$$ players play this game ($$$n$$$ is divisible by $$$k$$$).At the beginning of the game, each player takes $$$\frac{n}{k}$$$ cards from the deck (so each card is taken by exactly one player). The player who has the maximum number of jokers is the winner, and he gets the number of points equal to $$$x - y$$$, where $$$x$$$ is the number of jokers in the winner's hand, and $$$y$$$ is the maximum number of jokers among all other players. If there are two or more players with maximum number of jokers, all of them are winners and they get $$$0$$$ points.Here are some examples:  $$$n = 8$$$, $$$m = 3$$$, $$$k = 2$$$. If one player gets $$$3$$$ jokers and $$$1$$$ plain card, and another player gets $$$0$$$ jokers and $$$4$$$ plain cards, then the first player is the winner and gets $$$3 - 0 = 3$$$ points;  $$$n = 4$$$, $$$m = 2$$$, $$$k = 4$$$. Two players get plain cards, and the other two players get jokers, so both of them are winners and get $$$0$$$ points;  $$$n = 9$$$, $$$m = 6$$$, $$$k = 3$$$. If the first player gets $$$3$$$ jokers, the second player gets $$$1$$$ joker and $$$2$$$ plain cards, and the third player gets $$$2$$$ jokers and $$$1$$$ plain card, then the first player is the winner, and he gets $$$3 - 2 = 1$$$ point;  $$$n = 42$$$, $$$m = 0$$$, $$$k = 7$$$. Since there are no jokers, everyone gets $$$0$$$ jokers, everyone is a winner, and everyone gets $$$0$$$ points. Given $$$n$$$, $$$m$$$ and $$$k$$$, calculate the maximum number of points a player can get for winning the game. NoteTest cases of the example are described in the statement. 
for i in range(int(input())):
    n,m,k = [int(i) for i in input().split()]
    card = n//k
    if m<=card:
        print(m)
    elif card == 1:
        print(0)
    else:

        rem = (m-card)//(k-1)
        if (m-card)%(k-1) != 0:
            rem += 1
            # print(rem,m,k)
        print(card-rem)
","['brute force', 'greedy', 'math']"
582,"You are given a matrix of size $$$n \times n$$$ filled with lowercase English letters. You can change no more than $$$k$$$ letters in this matrix.Consider all paths from the upper left corner to the lower right corner that move from a cell to its neighboring cell to the right or down. Each path is associated with the string that is formed by all the letters in the cells the path visits. Thus, the length of each string is $$$2n - 1$$$.Find the lexicographically smallest string that can be associated with a path after changing letters in at most $$$k$$$ cells of the matrix.A string $$$a$$$ is lexicographically smaller than a string $$$b$$$, if the first different letter in $$$a$$$ and $$$b$$$ is smaller in $$$a$$$. NoteIn the first sample test case it is possible to change letters 'b' in cells $$$(2, 1)$$$ and $$$(3, 1)$$$ to 'a', then the minimum path contains cells $$$(1, 1), (2, 1), (3, 1), (4, 1), (4, 2), (4, 3), (4, 4)$$$. The first coordinate corresponds to the row and the second coordinate corresponds to the column. from array import array
inf = (1 << 30)

def main():
    (n,k) = [int(x) for x in input().split(' ')]
    Matrix = []
    for i in range(n):
        Matrix.append(array('b',[ord(x) for x in input()]))
    dp = [array('l', [inf for j in range(n)]) for i in range(n)]
    direct = [[ord('d') for j in range(n)] for i in range(n)]
    opt = """"
    for s in range (2 * n - 1):
        opchar = chr(ord('z') + 1)
        positions = []
        for i in range(0, s+1):
            j = s - i;
            if j < n and i < n:
                if(i > 0 and j > 0):
                    if(dp[i-1][j] < dp[i][j-1]):
                        dp[i][j] = dp[i-1][j]
                        direct[i][j] = 'l'
                    else:
                       dp[i][j] = dp[i][j-1]
                       direct[i][j] = 'd'
                elif i > 0:
                    dp[i][j] = dp[i-1][j]
                    direct[i][j] = 'l'
                elif j > 0:
                    dp[i][j] = dp[i][j-1]
                    direct[i][j] = 'd'
                else:
                    dp[i][j] = 0
                    direct[i][j] = 'e'
                if(dp[i][j] < k and Matrix[i][j] is not ord('a')):
                    dp[i][j]+=1
                    Matrix[i][j] = ord('a')
                if(Matrix[i][j] < ord(opchar) and dp[i][j] <= k):
                     opchar = chr(Matrix[i][j])
        for i in range(0, s+1):
            j = s - i;
            if j < n and i < n:
                if(Matrix[i][j] is not ord(opchar)):
                    dp[i][j] = inf
    ans = """"
    a,b = (n-1,n-1)
    while(direct[a][b] is not 'e'):
        ans += chr(Matrix[a][b])
        if(direct[a][b] is 'l'):
            a-=1
        else:
            b-=1
    ans += chr(Matrix[0][0])
    print(ans[::-1])

main()
",['greedy']
203,"The ""BerCorp"" company has got n employees. These employees can use m approved official languages for the formal correspondence. The languages are numbered with integers from 1 to m. For each employee we have the list of languages, which he knows. This list could be empty, i. e. an employee may know no official languages. But the employees are willing to learn any number of official languages, as long as the company pays their lessons. A study course in one language for one employee costs 1 berdollar.Find the minimum sum of money the company needs to spend so as any employee could correspond to any other one (their correspondence can be indirect, i. e. other employees can help out translating). NoteIn the second sample the employee 1 can learn language 2, and employee 8 can learn language 4.In the third sample employee 2 must learn language 2. from collections import defaultdict
def dfs(root, visited, graph):
    visited[root] = 1
    for i in graph[root]:
        if visited[i] == 0:
            dfs(i, visited, graph)

n, m = map(int, input().split())
graph = defaultdict(list)
l = []
lingo = [0 for i in range(m + 1)]
flag = 0
for i in range(n):
    l.append(list(map(int, input().split())))
    # print(lingo)
    for j in range(1, 1 + l[i][0]):
        flag = 1
        if lingo[l[i][j]] != 0:
            graph[lingo[l[i][j]]].append(i + 1)
            graph[i + 1].append(lingo[l[i][j]])
        else:
            lingo[l[i][j]] = i + 1

visited = [0 for i in range(n + 1)]
c = 0
# print(graph)
for i in range(1, n + 1):
    if visited[i] == 0:
        dfs(i, visited, graph)
        c += 1
if flag == 0:
    c += 1
print(c - 1)
","['dfs and similar', 'dsu']"
3966,"This problem is a complicated version of D1, but it has significant differences, so read the whole statement.Polycarp has an array of $$$n$$$ ($$$n$$$ is even) integers $$$a_1, a_2, \dots, a_n$$$. Polycarp conceived of a positive integer $$$k$$$. After that, Polycarp began performing the following operations on the array: take an index $$$i$$$ ($$$1 \le i \le n$$$) and reduce the number $$$a_i$$$ by $$$k$$$.After Polycarp performed some (possibly zero) number of such operations, it turned out that at least half of the numbers in the array became the same. Find the maximum $$$k$$$ at which such a situation is possible, or print $$$-1$$$ if such a number can be arbitrarily large. nan from collections import Counter


def read_nums():
    return [int(x) for x in input().split()]


def get_all_divisors(num):
    res = set()
    i = 1
    while i <= int(num**0.5) + 1:
        if num % i == 0:
            res.add(i)
            res.add(num // i)
        i += 1
    return res


def find_max_k(n, target, counter):
    diffs = Counter()
    for num, count in counter.items():
        diff = num - target
        if diff >= 0:
            diffs[diff] += count

    divisor_counter = Counter()
    for num, count in diffs.items():
        if num == 0:
            continue
        divisors = get_all_divisors(num)
        for div in divisors:
            divisor_counter[div] += count

    num_zeros = diffs[0]

    candidates = []
    for divisor, count in divisor_counter.items():
        if count + num_zeros >= n // 2:
            candidates.append(divisor)

    return max(candidates) if len(candidates) > 0 else 1


def get_maximum_k(n, nums):
    counter = Counter(nums)
    if max(counter.values()) >= len(nums) // 2:
        return -1

    vals = [find_max_k(n, target, counter) for target in counter]
    if -1 in vals:
        return -1
    return max(vals)

    #
    # for k in range(max(nums) - min(nums), 0, -1):
    #     remainders = Counter()
    #     for num, count in counter.items():
    #         remainders[num % k] += count
    #
    #     if max(remainders.values()) >= len(nums) // 2:
    #         return k


def solve():
    n, = read_nums()
    nums = read_nums()

    k = get_maximum_k(n, nums)
    print(k)


def main():
    t, = read_nums()
    for _ in range(t):
        solve()


if __name__ == '__main__':
    main()
","['brute force', 'math', 'number theory']"
4505,"In fact, the problems E1 and E2 do not have much in common. You should probably think of them as two separate problems.A permutation $$$p$$$ of size $$$n$$$ is given. A permutation of size $$$n$$$ is an array of size $$$n$$$ in which each integer from $$$1$$$ to $$$n$$$ occurs exactly once. For example, $$$[1, 4, 3, 2]$$$ and $$$[4, 2, 1, 3]$$$ are correct permutations while $$$[1, 2, 4]$$$ and $$$[1, 2, 2]$$$ are not.Let us consider an empty deque (double-ended queue). A deque is a data structure that supports adding elements to both the beginning and the end. So, if there are elements $$$[1, 5, 2]$$$ currently in the deque, adding an element $$$4$$$ to the beginning will produce the sequence $$$[\color{red}{4}, 1, 5, 2]$$$, and adding same element to the end will produce $$$[1, 5, 2, \color{red}{4}]$$$.The elements of the permutation are sequentially added to the initially empty deque, starting with $$$p_1$$$ and finishing with $$$p_n$$$. Before adding each element to the deque, you may choose whether to add it to the beginning or the end.For example, if we consider a permutation $$$p = [3, 1, 2, 4]$$$, one of the possible sequences of actions looks like this: $$$\quad$$$ 1.add $$$3$$$ to the end of the deque:deque has a sequence $$$[\color{red}{3}]$$$ in it;$$$\quad$$$ 2.add $$$1$$$ to the beginning of the deque:deque has a sequence $$$[\color{red}{1}, 3]$$$ in it;$$$\quad$$$ 3.add $$$2$$$ to the end of the deque:deque has a sequence $$$[1, 3, \color{red}{2}]$$$ in it;$$$\quad$$$ 4.add $$$4$$$ to the end of the deque:deque has a sequence $$$[1, 3, 2, \color{red}{4}]$$$ in it;Find the lexicographically smallest possible sequence of elements in the deque after the entire permutation has been processed. A sequence $$$[x_1, x_2, \ldots, x_n]$$$ is lexicographically smaller than the sequence $$$[y_1, y_2, \ldots, y_n]$$$ if there exists such $$$i \leq n$$$ that $$$x_1 = y_1$$$, $$$x_2 = y_2$$$, $$$\ldots$$$, $$$x_{i - 1} = y_{i - 1}$$$ and $$$x_i &lt; y_i$$$. In other words, if the sequences $$$x$$$ and $$$y$$$ have some (possibly empty) matching prefix, and the next element of the sequence $$$x$$$ is strictly smaller than the corresponding element of the sequence $$$y$$$. For example, the sequence $$$[1, 3, 2, 4]$$$ is smaller than the sequence $$$[1, 3, 4, 2]$$$ because after the two matching elements $$$[1, 3]$$$ in the start the first sequence has an element $$$2$$$ which is smaller than the corresponding element $$$4$$$ in the second sequence. NoteOne of the ways to get a lexicographically smallest permutation $$$[1, 3, 2, 4]$$$ from the permutation $$$[3, 1, 2, 4]$$$ (the first sample test case) is described in the problem statement. from collections import deque

def arrange(arr, n):
	d = deque()
	for i in range(n):
		if not d or arr[i] < d[0]:
			d.appendleft(arr[i])
		else:
			d.append(arr[i])
	return d

t = int(input())
for _ in range(t):
	n = int(input())
	a = list(map(int, input().split()))
	print(*arrange(a, n))","['constructive algorithms', 'greedy', 'math']"
3006,"The Little Elephant loves Ukraine very much. Most of all he loves town Rozdol (ukr. ""Rozdil"").However, Rozdil is dangerous to settle, so the Little Elephant wants to go to some other town. The Little Elephant doesn't like to spend much time on travelling, so for his journey he will choose a town that needs minimum time to travel to. If there are multiple such cities, then the Little Elephant won't go anywhere.For each town except for Rozdil you know the time needed to travel to this town. Find the town the Little Elephant will go to or print ""Still Rozdil"", if he stays in Rozdil. NoteIn the first sample there are only two cities where the Little Elephant can go. The travel time for the first town equals 7, to the second one — 4. The town which is closest to Rodzil (the only one) is the second one, so the answer is 2.In the second sample the closest cities are cities two and five, the travelling time to both of them equals 4, so the answer is ""Still Rozdil"". import re
import sys
from bisect import bisect, bisect_left, insort, insort_left
from collections import Counter, defaultdict, deque
from copy import deepcopy
from decimal import Decimal
from itertools import (
    accumulate, combinations, combinations_with_replacement, groupby,
    permutations, product)
from math import (acos, asin, atan, ceil, cos, degrees, factorial, gcd, hypot,
                  log2, pi, radians, sin, sqrt, tan)
from operator import itemgetter, mul
from string import ascii_lowercase, ascii_uppercase, digits


def inp():
    return(int(input()))


def inlist():
    return(list(map(int, input().split())))


def instr():
    s = input()
    return(list(s[:len(s)]))


def invr():
    return(map(int, input().split()))


n = inp()

a = inlist()

min1 = 1000000001
min2 = min1+1
ind = 0
for i in range(n):
    if a[i] < min1:
        min1 = a[i]
        ind = i
    elif a[i] < min2 and a[i] >= min1:
        min2 = a[i]
if min1 == min2:
    print(""Still Rozdil"")
else:
    print(ind + 1)
","['brute force', 'implementation']"
2135,"Alice became interested in periods of integer numbers. We say positive $$$X$$$ integer number is periodic with length $$$L$$$ if there exists positive integer number $$$P$$$ with $$$L$$$ digits such that $$$X$$$ can be written as $$$PPPP…P$$$. For example:$$$X = 123123123$$$ is periodic number with length $$$L = 3$$$ and $$$L = 9$$$$$$X = 42424242$$$ is periodic number with length $$$L = 2,L = 4$$$ and $$$L = 8$$$$$$X = 12345$$$ is periodic number with length $$$L = 5$$$For given positive period length $$$L$$$ and positive integer number $$$A$$$, Alice wants to find smallest integer number $$$X$$$ strictly greater than $$$A$$$ that is periodic with length L. NoteIn first example 124124 is the smallest number greater than 123456 that can be written with period L = 3 (P = 124).In the second example 100100 is the smallest number greater than 12345 with period L = 3 (P=100) def revive(l):
    res = pow(10 , l-1)
    return str(res)



l = int(input())
s = input()
val = 0
if len(s) % l == 0:
    ans = s[:l]
    if ans*(len(s)//l) > s:
        print(ans*(len(s)//l))
        exit()
    elif ans == ""9""*l:
        ans = revive(l)
        val = l
    else:
        ans = str(int(ans) + 1)
else:
    ans = revive(l)
print(ans*((len(s) + l-1 + val)//l))","['implementation', 'strings']"
4501," Walking along a riverside, Mino silently takes a note of something.""Time,"" Mino thinks aloud.""What?""""Time and tide wait for no man,"" explains Mino. ""My name, taken from the river, always reminds me of this.""""And what are you recording?""""You see it, tide. Everything has its own period, and I think I've figured out this one,"" says Mino with confidence.Doubtfully, Kanno peeks at Mino's records. The records are expressed as a string $$$s$$$ of characters '0', '1' and '.', where '0' denotes a low tide, '1' denotes a high tide, and '.' denotes an unknown one (either high or low).You are to help Mino determine whether it's possible that after replacing each '.' independently with '0' or '1', a given integer $$$p$$$ is not a period of the resulting string. In case the answer is yes, please also show such a replacement to Mino.In this problem, a positive integer $$$p$$$ is considered a period of string $$$s$$$, if for all $$$1 \leq i \leq \lvert s \rvert - p$$$, the $$$i$$$-th and $$$(i + p)$$$-th characters of $$$s$$$ are the same. Here $$$\lvert s \rvert$$$ is the length of $$$s$$$. NoteIn the first example, $$$7$$$ is not a period of the resulting string because the $$$1$$$-st and $$$8$$$-th characters of it are different.In the second example, $$$6$$$ is not a period of the resulting string because the $$$4$$$-th and $$$10$$$-th characters of it are different.In the third example, $$$9$$$ is always a period because the only constraint that the first and last characters are the same is already satisfied.Note that there are multiple acceptable answers for the first two examples, you can print any of them. entrada = raw_input().split()
p = int(entrada[1])

abc = raw_input()
s = list(abc)
ans = True
#print s

for i in xrange(len(s)):
	if i + p >= len(s):
		break

	#print s[i], s[i + p]
	if s[i] == ""."" and s[i + p] == ""."":
		s[i] = ""0""
		s[i + p] = ""1""
		ans = False
	elif s[i] != s[i + p]:
		if s[i] == ""1"":
			s[i + p] == ""0""
		if s[i] == ""0"":
			s[i + p] == ""1""
		if s[i] == ""."":
			if s[i + p] == ""0"":
				s[i] == ""1""
			else:
				s[i] == ""0""
		ans = False
if ans:
	print ""No""
else:
	ans = """"	
	for i in xrange(len(s)):
		if s[i] == ""."":
			if i - p >= 0:
				if s[i - p] == ""1"":
					s[i] = ""0""
					break
				else:
					s[i] = ""1""
					break

	for i in xrange(len(s)):
		if s[i] == ""."":
			if i + p >= len(s):
				s[i] = ""1""
			elif s[i + p] == ""."":
				s[i] = ""0""
				s[i + p] = ""1""
			elif s[i + p] == ""0"":
				s[i] = ""1""
			else:
				s[i] = ""0"" 
		ans+=s[i]
	print ans","['constructive algorithms', 'strings']"
1592,"A boy named Vasya has taken part in an Olympiad. His teacher knows that in total Vasya got at least x points for both tours of the Olympiad. The teacher has the results of the first and the second tour of the Olympiad but the problem is, the results have only points, no names. The teacher has to know Vasya's chances.Help Vasya's teacher, find two numbers — the best and the worst place Vasya could have won. Note that the total results' table sorts the participants by the sum of points for both tours (the first place has the participant who has got the most points). If two or more participants have got the same number of points, it's up to the jury to assign places to them according to their choice. It is guaranteed that each participant of the Olympiad participated in both tours of the Olympiad. NoteIn the first text sample all 5 participants earn 2 points each in any case. Depending on the jury's decision, Vasya can get the first (the best) as well as the last (the worst) fifth place.In the second test sample in the best case scenario Vasya wins again: he can win 12 points and become the absolute winner if the total results' table looks like that — {4:8, 6:4, 3:6, 4:4, 4:3, 5:0}.In this table all participants are sorted by decreasing points and we can see how much a participant earned in the first and in the second tour.In the worst case scenario Vasya can get the fifth place if the table looks like that — {4:8, 4:6, 6:4, 5:4, 4:3, 3:0}, and he earned 4 and 3 points in the first and second tours, correspondingly. n, s = map(int, input().split())
a = sorted(map(int, input().split()), reverse = True)
b = sorted(map(int, input().split()))
i = j = 0
while i < n and j < n:
    if a[i] + b[j] < s: j += 1
    else: 
        i += 1
        j += 1
print(1, i)","['binary search', 'greedy', 'sortings', 'two pointers']"
4561,"Creatnx has $$$n$$$ mirrors, numbered from $$$1$$$ to $$$n$$$. Every day, Creatnx asks exactly one mirror ""Am I beautiful?"". The $$$i$$$-th mirror will tell Creatnx that he is beautiful with probability $$$\frac{p_i}{100}$$$ for all $$$1 \le i \le n$$$.Creatnx asks the mirrors one by one, starting from the $$$1$$$-st mirror. Every day, if he asks $$$i$$$-th mirror, there are two possibilities:  The $$$i$$$-th mirror tells Creatnx that he is beautiful. In this case, if $$$i = n$$$ Creatnx will stop and become happy, otherwise he will continue asking the $$$i+1$$$-th mirror next day;  In the other case, Creatnx will feel upset. The next day, Creatnx will start asking from the $$$1$$$-st mirror again. You need to calculate the expected number of days until Creatnx becomes happy.This number should be found by modulo $$$998244353$$$. Formally, let $$$M = 998244353$$$. It can be shown that the answer can be expressed as an irreducible fraction $$$\frac{p}{q}$$$, where $$$p$$$ and $$$q$$$ are integers and $$$q \not \equiv 0 \pmod{M}$$$. Output the integer equal to $$$p \cdot q^{-1} \bmod M$$$. In other words, output such an integer $$$x$$$ that $$$0 \le x &lt; M$$$ and $$$x \cdot q \equiv p \pmod{M}$$$. NoteIn the first test, there is only one mirror and it tells, that Creatnx is beautiful with probability $$$\frac{1}{2}$$$. So, the expected number of days until Creatnx becomes happy is $$$2$$$. n=input()
l=map(int,raw_input().split())
num=0
p=1
for i in range(n):
    num=(num+(p*pow(100,n-i,998244353))%998244353)%998244353
    p=(p*l[i])%998244353
print (num*pow(p,998244351,998244353))%998244353
","['data structures', 'dp', 'math', 'probabilities']"
911,"You are given an array $$$a$$$ consisting of $$$n$$$ integers.In one move, you can choose two indices $$$1 \le i, j \le n$$$ such that $$$i \ne j$$$ and set $$$a_i := a_j$$$. You can perform such moves any number of times (possibly, zero). You can choose different indices in different operations. The operation := is the operation of assignment (i.e. you choose $$$i$$$ and $$$j$$$ and replace $$$a_i$$$ with $$$a_j$$$).Your task is to say if it is possible to obtain an array with an odd (not divisible by $$$2$$$) sum of elements.You have to answer $$$t$$$ independent test cases. nan t=int(input())
for k in range(t):
    n=int(input())
    a=list(map(int,input().split()))
    even,odd=0,0
    for key in a:
        if key%2:
            odd+=1
        else:
            even+=1
    if sum(a)%2 or (even and odd):
        print('YES')
    else:
        print('NO')
        
",['math']
3226,"Fishingprince is playing with an array $$$[a_1,a_2,\dots,a_n]$$$. He also has a magic number $$$m$$$.He can do the following two operations on it:  Select $$$1\le i\le n$$$ such that $$$a_i$$$ is divisible by $$$m$$$ (that is, there exists an integer $$$t$$$ such that $$$m \cdot t = a_i$$$). Replace $$$a_i$$$ with $$$m$$$ copies of $$$\frac{a_i}{m}$$$. The order of the other elements doesn't change. For example, when $$$m=2$$$ and $$$a=[2,3]$$$ and $$$i=1$$$, $$$a$$$ changes into $$$[1,1,3]$$$.  Select $$$1\le i\le n-m+1$$$ such that $$$a_i=a_{i+1}=\dots=a_{i+m-1}$$$. Replace these $$$m$$$ elements with a single $$$m \cdot a_i$$$. The order of the other elements doesn't change. For example, when $$$m=2$$$ and $$$a=[3,2,2,3]$$$ and $$$i=2$$$, $$$a$$$ changes into $$$[3,4,3]$$$. Note that the array length might change during the process. The value of $$$n$$$ above is defined as the current length of the array (might differ from the $$$n$$$ in the input).Fishingprince has another array $$$[b_1,b_2,\dots,b_k]$$$. Please determine if he can turn $$$a$$$ into $$$b$$$ using any number (possibly zero) of operations. NoteIn the first test case of the sample, we can do the second operation with $$$i=2$$$: $$$[1,\color{red}{2,2},4,2]\to [1,\color{red}{4},4,2]$$$.In the second testcase of the sample, we can:  do the second operation with $$$i=2$$$: $$$[1,\color{red}{2,2},8,2,2]\to [1,\color{red}{4},8,2,2]$$$.  do the second operation with $$$i=4$$$: $$$[1,4,8,\color{red}{2,2}]\to [1,4,8,\color{red}{4}]$$$.  do the first operation with $$$i=3$$$: $$$[1,4,\color{red}{8},4]\to [1,4,\color{red}{4,4},4]$$$.  do the second operation with $$$i=2$$$: $$$[1,\color{red}{4,4},4,4]\to [1,\color{red}{8},4,4]$$$.  do the second operation with $$$i=3$$$: $$$[1,8,\color{red}{4,4}]\to [1,8,\color{red}{8}]$$$.  do the second operation with $$$i=2$$$: $$$[1,\color{red}{8,8}]\to [1,\color{red}{16}]$$$. import sys
input = sys.stdin.readline
rounds=int(input())
for ii in range(rounds):
  out='Yes'
  length1,magic=map(int,input().split())
  arr1=list(map(int,input().split()))
  length2=int(input())
  arr2=list(map(int,input().split()))

  a1=[]
  a2=[]
  for a in arr1:
    ori=a
    while a%magic==0:
      a=a//magic
    if len(a1)>0 and a1[-1][0]==a:
      a1[-1][1]+=(ori//a)
    else:
      a1.append([a,ori//a])

  for aa in arr2:
    ori=aa
    while aa%magic==0:
      aa=aa//magic
    if len(a2)>0 and a2[-1][0]==aa:
      a2[-1][1]+=(ori//aa)
    else:
      a2.append([aa,ori//aa])

  
  if a1!=a2:
    out='No'
  print(out)","['constructive algorithms', 'greedy', 'implementation', 'math']"
4590,"Initially, you have the array $$$a$$$ consisting of one element $$$1$$$ ($$$a = [1]$$$).In one move, you can do one of the following things:  Increase some (single) element of $$$a$$$ by $$$1$$$ (choose some $$$i$$$ from $$$1$$$ to the current length of $$$a$$$ and increase $$$a_i$$$ by one);  Append the copy of some (single) element of $$$a$$$ to the end of the array (choose some $$$i$$$ from $$$1$$$ to the current length of $$$a$$$ and append $$$a_i$$$ to the end of the array). For example, consider the sequence of five moves:  You take the first element $$$a_1$$$, append its copy to the end of the array and get $$$a = [1, 1]$$$.  You take the first element $$$a_1$$$, increase it by $$$1$$$ and get $$$a = [2, 1]$$$.  You take the second element $$$a_2$$$, append its copy to the end of the array and get $$$a = [2, 1, 1]$$$.  You take the first element $$$a_1$$$, append its copy to the end of the array and get $$$a = [2, 1, 1, 2]$$$.  You take the fourth element $$$a_4$$$, increase it by $$$1$$$ and get $$$a = [2, 1, 1, 3]$$$. Your task is to find the minimum number of moves required to obtain the array with the sum at least $$$n$$$.You have to answer $$$t$$$ independent test cases. nan import math
t=int(input())
while t:
    t-=1
    n=int(input())
    if n==1 :
        print(0)
    elif n==2:
        print(1)
   
    else:
        mx=n
        c=0
        for i in range(max(2,round(math.sqrt(n))-1),round(math.sqrt(n))+1):
            tem=i-1+math.ceil((n-i)/i)
            mx=min(tem,mx)
        print(mx)","['binary search', 'constructive algorithms', 'math']"
3286,"The construction of subway in Bertown is almost finished! The President of Berland will visit this city soon to look at the new subway himself.There are n stations in the subway. It was built according to the Bertown Transport Law:  For each station i there exists exactly one train that goes from this station. Its destination station is pi, possibly pi = i;  For each station i there exists exactly one station j such that pj = i. The President will consider the convenience of subway after visiting it. The convenience is the number of ordered pairs (x, y) such that person can start at station x and, after taking some subway trains (possibly zero), arrive at station y (1 ≤ x, y ≤ n).The mayor of Bertown thinks that if the subway is not convenient enough, then the President might consider installing a new mayor (and, of course, the current mayor doesn't want it to happen). Before President visits the city mayor has enough time to rebuild some paths of subway, thus changing the values of pi for not more than two subway stations. Of course, breaking the Bertown Transport Law is really bad, so the subway must be built according to the Law even after changes.The mayor wants to do these changes in such a way that the convenience of the subway is maximized. Help him to calculate the maximum possible convenience he can get!  NoteIn the first example the mayor can change p2 to 3 and p3 to 1, so there will be 9 pairs: (1, 1), (1, 2), (1, 3), (2, 1), (2, 2), (2, 3), (3, 1), (3, 2), (3, 3).In the second example the mayor can change p2 to 4 and p3 to 5. input()
l = [[int(x)-1,False] for x in input().split()]
loop = []
for begin in l:
    if begin[1]:
        continue
    count = 0;
    nextI = begin[0];
    while not l[nextI][1]:
        l[nextI][1]=True
        nextI = l[nextI][0]
        count += 1
    loop.append(count)
s = sorted(loop,reverse=True)
total = sum(map(lambda x:x*x,s)) + (2*s[0]*s[1] if len(s)>=2 else 0)
print(total)
","['dfs and similar', 'greedy', 'math']"
517,"Mark is asked to take a group photo of $$$2n$$$ people. The $$$i$$$-th person has height $$$h_i$$$ units.To do so, he ordered these people into two rows, the front row and the back row, each consisting of $$$n$$$ people. However, to ensure that everyone is seen properly, the $$$j$$$-th person of the back row must be at least $$$x$$$ units taller than the $$$j$$$-th person of the front row for each $$$j$$$ between $$$1$$$ and $$$n$$$, inclusive.Help Mark determine if this is possible. NoteIn the first test case, one possible order is to have the third, fifth, and sixth person on the back row and the second, first, and fourth on the front row. The heights of the people will look like this. Back$$$9$$$$$$12$$$$$$16$$$Front$$$3$$$$$$1$$$$$$10$$$ It works because   $$$h_3-h_2 = 9-3 \geq 6$$$,    $$$h_5-h_1 = 12-1\geq 6$$$, and    $$$h_6-h_4 = 16-10\geq 6$$$. In the second test case, it can be shown there is no way to order people in a way that satisfies the condition.In the third test case, the only way to arrange people to satisfy the condition is to have the first person on the back row and the second person on the front row. cnt_t = int(input())
for t in range(cnt_t):
    n, x = map(int, input().split())
    a = list(map(int, input().split()))
    
    a.sort()
    ans = ""YES""
    for i in range(n):
        if a[i + n] - a[i] < x:
            ans = ""NO""
            break
    
    print(ans)","['greedy', 'sortings']"
1330,"Victor has a 24-hour clock that shows the time in the format ""HH:MM"" (00 $$$\le$$$ HH $$$\le$$$ 23, 00 $$$\le$$$ MM $$$\le$$$ 59). He looks at the clock every $$$x$$$ minutes, and the clock is currently showing time $$$s$$$. How many different palindromes will Victor see in total after looking at the clock every $$$x$$$ minutes, the first time being at time $$$s$$$?For example, if the clock starts out as 03:12 and Victor looks at the clock every $$$360$$$ minutes (i.e. every $$$6$$$ hours), then he will see the times 03:12, 09:12, 15:12, 21:12, 03:12, and the times will continue to repeat. Here the time 21:12 is the only palindrome he will ever see, so the answer is $$$1$$$.A palindrome is a string that reads the same backward as forward. For example, the times 12:21, 05:50, 11:11 are palindromes but 13:13, 22:10, 02:22 are not. NoteThe first test case is explained in the statement. import bisect
import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")


def Convert(string):
    list1 = []
    list1[:0] = string
    return list1

for _ in range(int(input())):
    tans = [[0], [70], [140], [210], [280], [350], [601], [671], [741], [811], [881], [951], [1202], [1272], [1342], [1412]]
    ai = list(map(str, input().split()))
    ct = (int(ai[0][:2])*60) + (int(ai[0][3:5]))
    td = int(ai[1])
    hs = 1
    while (hs*td) % 1440 != 0:
        hs += 1
    hs = (hs*td)//1440
    for i in range(16):
        for j in range(hs+1):
            tans[i].append(tans[i][0] + ((1+j)*1440))
    for i in range(16):
        for j in range(hs+2):
            if tans[i][j] >= ct and (tans[i][j] - ct) % td == 0:
                tans[i] = 0
                break
    ans = 0
    for i in range(16):
        if tans[i] == 0:
            ans += 1
    print(ans)","['brute force', 'implementation']"
1293,"You have decided to watch the best moments of some movie. There are two buttons on your player:   Watch the current minute of the movie. By pressing this button, you watch the current minute of the movie and the player automatically proceeds to the next minute of the movie.  Skip exactly x minutes of the movie (x is some fixed positive integer). If the player is now at the t-th minute of the movie, then as a result of pressing this button, it proceeds to the minute (t + x). Initially the movie is turned on in the player on the first minute, and you want to watch exactly n best moments of the movie, the i-th best moment starts at the li-th minute and ends at the ri-th minute (more formally, the i-th best moment consists of minutes: li, li + 1, ..., ri). Determine, what is the minimum number of minutes of the movie you have to watch if you want to watch all the best moments? NoteIn the first sample, the player was initially standing on the first minute. As the minutes from the 1-st to the 4-th one don't contain interesting moments, we press the second button. Now we can not press the second button and skip 3 more minutes, because some of them contain interesting moments. Therefore, we watch the movie from the 4-th to the 6-th minute, after that the current time is 7. Similarly, we again skip 3 minutes and then watch from the 10-th to the 12-th minute of the movie. In total, we watch 6 minutes of the movie.In the second sample, the movie is very interesting, so you'll have to watch all 100000 minutes of the movie. n, x = map(int, input().split())
res = 0
ri = 1

for i in range(n):
    l, r = map(int, input().split())
    
    l = l - ri 
    r = r - ri
    ri = ri + r + 1
    res = res + l%x + (r-l+1)
print(res)","['greedy', 'implementation']"
1204,"Filled with optimism, Hyunuk will host a conference about how great this new year will be!The conference will have $$$n$$$ lectures. Hyunuk has two candidate venues $$$a$$$ and $$$b$$$. For each of the $$$n$$$ lectures, the speaker specified two time intervals $$$[sa_i, ea_i]$$$ ($$$sa_i \le ea_i$$$) and $$$[sb_i, eb_i]$$$ ($$$sb_i \le eb_i$$$). If the conference is situated in venue $$$a$$$, the lecture will be held from $$$sa_i$$$ to $$$ea_i$$$, and if the conference is situated in venue $$$b$$$, the lecture will be held from $$$sb_i$$$ to $$$eb_i$$$. Hyunuk will choose one of these venues and all lectures will be held at that venue.Two lectures are said to overlap if they share any point in time in common. Formally, a lecture held in interval $$$[x, y]$$$ overlaps with a lecture held in interval $$$[u, v]$$$ if and only if $$$\max(x, u) \le \min(y, v)$$$.We say that a participant can attend a subset $$$s$$$ of the lectures if the lectures in $$$s$$$ do not pairwise overlap (i.e. no two lectures overlap). Note that the possibility of attending may depend on whether Hyunuk selected venue $$$a$$$ or venue $$$b$$$ to hold the conference.A subset of lectures $$$s$$$ is said to be venue-sensitive if, for one of the venues, the participant can attend $$$s$$$, but for the other venue, the participant cannot attend $$$s$$$.A venue-sensitive set is problematic for a participant who is interested in attending the lectures in $$$s$$$ because the participant cannot be sure whether the lecture times will overlap. Hyunuk will be happy if and only if there are no venue-sensitive sets. Determine whether Hyunuk will be happy. NoteIn second example, lecture set $$$\{1, 3\}$$$ is venue-sensitive. Because participant can't attend this lectures in venue $$$a$$$, but can attend in venue $$$b$$$.In first and third example, venue-sensitive set does not exist. import os
import sys
from atexit import register
from io import BytesIO
sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))
sys.stdout = BytesIO()
register(lambda: os.write(1, sys.stdout.getvalue()))
input = lambda: sys.stdin.readline().rstrip('\r\n')
raw_input = lambda: sys.stdin.readline().rstrip('\r\n')

n = int(input())
pairs = []
for i in range(n):
	s1,t1,s2,t2 = map(int,raw_input().split("" ""))
	pairs.append((s1,t1,s2,t2))

nodes1 = []
nodes2 = []
cnt = 0
for a,b,c,d in pairs:
	nodes1.append((a,-1,cnt))
	nodes1.append((b,1,cnt))
	nodes2.append((c,-1,cnt))
	nodes2.append((d,1,cnt))
	cnt += 1
nodes1.sort()
nodes2.sort()

import heapq
heaps = []
heape = []
flag = True

visited = [0]*(n+1)
for v,f,i in nodes1:
	s1,t1,s2,t2 = pairs[i]
	if f == -1:
		while heape and visited[heape[0][1]] == 2:
			heapq.heappop(heape)
		while heaps and visited[heaps[0][1]] == 2:
			heapq.heappop(heaps)
		if heape and not (s2 <= heape[0][0] and t2>= -heaps[0][0]):
			flag = False
			break
		heapq.heappush(heaps,(-s2,i))
		heapq.heappush(heape,(t2,i))
		visited[i] = 1
	else:
		visited[i] = 2

if not flag:
	print ""NO""
	exit()
heaps = []
heape = []
visited = [0]*(n+1)
for v,f,i in nodes2:
	s1,t1,s2,t2 = pairs[i]
	if f == -1:
		while heape and visited[heape[0][1]] == 2:
			heapq.heappop(heape)
		while heaps and visited[heaps[0][1]] == 2:
			heapq.heappop(heaps)
		if heape and not (s1 <= heape[0][0] and t1>= -heaps[0][0]):
			flag = False
			break
		heapq.heappush(heaps,(-s1,i))
		heapq.heappush(heape,(t1,i))
		visited[i] = 1
	else:
		visited[i] = 2
if flag:
	print ""YES""
else:
	print ""NO""","['binary search', 'data structures', 'hashing', 'sortings']"
668,"You are given an array $$$a$$$ of $$$n$$$ integers, where $$$n$$$ is odd. You can make the following operation with it:  Choose one of the elements of the array (for example $$$a_i$$$) and increase it by $$$1$$$ (that is, replace it with $$$a_i + 1$$$). You want to make the median of the array the largest possible using at most $$$k$$$ operations.The median of the odd-sized array is the middle element after the array is sorted in non-decreasing order. For example, the median of the array $$$[1, 5, 2, 3, 5]$$$ is $$$3$$$. NoteIn the first example, you can increase the second element twice. Than array will be $$$[1, 5, 5]$$$ and it's median is $$$5$$$.In the second example, it is optimal to increase the second number and than increase third and fifth. This way the answer is $$$3$$$.In the third example, you can make four operations: increase first, fourth, sixth, seventh element. This way the array will be $$$[5, 1, 2, 5, 3, 5, 5]$$$ and the median will be $$$5$$$. # TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
from sys import stdin, stdout
 
#N = int(input())
#s = input()
N,K = [int(x) for x in stdin.readline().split()]
arr = [int(x) for x in stdin.readline().split()]
 
arr.sort()
 
half = N//2
s = sum(arr[half:])
 
bound = s + K
res = 0
for i in range(N-1,(N//2)-1,-1):
    if bound//(i-half+1)>arr[i]:
        res = max(res,bound//(i-half+1))
        if i!=N-1 and res>arr[i+1]:
            res = arr[i+1]
        break
    else:
        bound -= arr[i]
 
print(res)","['binary search', 'greedy', 'math', 'sortings']"
2395,"Given the string $$$s$$$ of decimal digits (0-9) of length $$$n$$$.A substring is a sequence of consecutive characters of a string. The substring of this string is defined by a pair of indexes — with its left and right ends. So, each pair of indexes ($$$l, r$$$), where $$$1 \le l \le r \le n$$$, corresponds to a substring of the string $$$s$$$. We will define as $$$v(l,r)$$$ the numeric value of the corresponding substring (leading zeros are allowed in it).For example, if $$$n=7$$$, $$$s=$$$""1003004"", then $$$v(1,3)=100$$$, $$$v(2,3)=0$$$ and $$$v(2,7)=3004$$$.You are given $$$n$$$, $$$s$$$ and an integer $$$w$$$ ($$$1 \le w &lt; n$$$).You need to process $$$m$$$ queries, each of which is characterized by $$$3$$$ numbers $$$l_i, r_i, k_i$$$ ($$$1 \le l_i \le r_i \le n; 0 \le k_i \le 8$$$).The answer to the $$$i$$$th query is such a pair of substrings of length $$$w$$$ that if we denote them as $$$(L_1, L_1+w-1)$$$ and $$$(L_2, L_2+w-1)$$$, then:  $$$L_1 \ne L_2$$$, that is, the substrings are different;  the remainder of dividing a number $$$v(L_1, L_1+w-1) \cdot v(l_i, r_i) + v(L_2, L_2 + w - 1)$$$ by $$$9$$$ is equal to $$$k_i$$$. If there are many matching substring pairs, then find a pair where $$$L_1$$$ is as small as possible. If there are many matching pairs in this case, then minimize $$$L_2$$$.Note that the answer may not exist. NoteConsider the first test case of example inputs. In this test case $$$n=7$$$, $$$s=$$$""1003004"", $$$w=4$$$ and one query $$$l_1=1$$$, $$$r_1=2$$$, $$$k_1=1$$$. Note that $$$v(1,2)=10$$$. We need to find a pair of substrings of length $$$4$$$ such that $$$v(L_1, L_1+3)\cdot10+v(L_2,L_2+3)$$$ has a remainder of $$$k_1=1$$$ when divided by $$$9$$$. The values $$$L_1=2, L_2=4$$$ actually satisfy all the requirements: $$$v(L_1, L_1+w-1)=v(2,5)=30$$$, $$$v(L_2, L_2+w-1)=v(4,7)=3004$$$. Indeed, $$$30\cdot10+3004=3304$$$, which has a remainder of $$$1$$$ when divided by $$$9$$$. It can be shown that $$$L_1=2$$$ is the minimum possible value, and $$$L_2=4$$$ is the minimum possible with $$$L_1=2$$$. import bisect
import collections
import collections.abc
import itertools
import math
import re
import sys


import functools
import copy
import math
import heapq
import sys
import io
from collections import Counter, deque
from collections import defaultdict as ddict



def create_matrix(rows, cols=None, val=None):
    if cols is None:
        cols = rows

    row = [val] * cols
    mat = []

    for _ in range(rows):
        mat.append(copy.deepcopy(row))
    return mat


def bsearch(a, x):
    '''
    Locate the leftmost value exactly equal to x.
    https://docs.python.org/3/library/bisect.html#module-bisect
    '''
    i = bisect.bisect_left(a, x)
    if i != len(a) and a[i] == x:
        return i
    raise ValueError


def zdict(x=0):
    return collections.defaultdict(lambda: x)


def strjoin(xs, glue=' ', conv=str):
    return glue.join(map(conv, xs))


alphabet = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ""
letters = {ch for ch in alphabet}





def to_nums(line):
    return [int(x) for x in line.split("" "")]


def read_nums(f):
    line = f.readline().strip()
    return [int(x) for x in line.split("" "")]

def print_mat(mat, glue="" ""):
    for row in mat:
        print(strjoin(row, glue=glue))


def read_num(f):
    line = f.readline().strip()
    return int(line)

def read_str(f):
    line = f.readline().strip()
    return line

def read_pair(f, func=int):
    line = f.readline().strip().split("" "")
    return (func(line[0]), func(line[1]))

def read_triplet(f, func=int):
    line = f.readline().strip().split("" "")
    return (func(line[0]), func(line[1]), func(line[2]))

import math
import sys


@functools.lru_cache()
def get_combos(k):
    combos = []
    for i in range(10):
        for j in range(10):
            if (i + j) % 9 == k:
                combos.append((i, j))
    return combos

def solve(s, w, q):
    n = len(s)
    #modulo = math.pow(10, w)
    sums = [0 for _ in range(n)]

    mods = {x:[] for x in range(9)}

    for i in range(n):
        digit = int(s[i])
        if i == 0:
            sums[i] = digit
        else:
            sums[i] = (sums[i-1]+digit)%9

    for i in range(0, n - w + 1):
        if i == 0:
            v = sums[i+w-1] % 9
        else:
            #print(f""{i+w} vs {n}"")
            v = (sums[i+w-1] - sums[i-1]) % 9
        #if len(mods[v])<2:
        mods[v].append(i+1)


    for _ in range(q):
        l, r, k = read_triplet(f)

        if l == 1:
            mult = sums[r-1] % 9
        else:
            mult = (sums[r-1] - sums[l-2])%9

        l1, l2 = n+1, n+1
        for x in range(9):
            if mods[x]:
                for y in range(9):
                    if not mods[y]:
                        continue
                    cond = ((mult * x) + y) % 9 == k
                    if not cond:
                        continue
                    if x != y:
                        a, b = mods[x][0], mods[y][0]
                    elif len(mods[x])>1:
                        a, b = mods[x][0], mods[x][1]
                    else:
                        continue

                    if a < l1 or (a==l1 and b<l2):
                        l1, l2 = a, b

        if l1 == n+1:
            l1, l2 = -1, -1

        #print(f""All cands for answer ({l1,l2})= {all_cands}"")

        print(str(l1) + ' ' + str(l2))


def main():
    with f:
        t = read_num(f)

        for tt in range(t):
            #if tt>=2:
            #    break
            s = read_str(f)
            w, q = read_pair(f)
            solve(s, w, q)






data = """"""5
1003004
4 1
1 2 1
179572007
4 2
2 7 3
2 7 4
111
2 1
2 2 6
0000
1 2
1 4 0
1 4 1
484
1 5
2 2 0
2 3 7
1 2 5
3 3 8
2 2 6
""""""

f = None
#f = io.StringIO(data)

if f is None:
    f = sys.stdin
    if len(sys.argv) > 1:
        f = open(sys.argv[1], 'r')
testcase = None

if __name__ == '__main__':

    #sys.setrecursionlimit(300000)
    main()


""""""
2 4
1 5
1 2
-1 -1
1 2
-1 -1
1 3
1 3
-1 -1
-1 -1
-1 -1
""""""



","['hashing', 'math']"
4703,"Wilbur the pig is tinkering with arrays again. He has the array a1, a2, ..., an initially consisting of n zeros. At one step, he can choose any index i and either add 1 to all elements ai, ai + 1, ... , an or subtract 1 from all elements ai, ai + 1, ..., an. His goal is to end up with the array b1, b2, ..., bn. Of course, Wilbur wants to achieve this goal in the minimum number of steps and asks you to compute this value. NoteIn the first sample, Wilbur may successively choose indices 1, 2, 3, 4, and 5, and add 1 to corresponding suffixes.In the second sample, Wilbur first chooses indices 1 and 2 and adds 1 to corresponding suffixes, then he chooses index 4 and subtract 1. n = int(raw_input())
a = [int(x) for x in raw_input().split()]

k = abs(a[0])

for i in range(1 , n):
    k += abs(a[i - 1] - a[i])
    
    
print k","['greedy', 'implementation']"
4854,"You are given a string $$$s$$$ of length $$$n$$$, which consists only of the first $$$k$$$ letters of the Latin alphabet. All letters in string $$$s$$$ are uppercase.A subsequence of string $$$s$$$ is a string that can be derived from $$$s$$$ by deleting some of its symbols without changing the order of the remaining symbols. For example, ""ADE"" and ""BD"" are subsequences of ""ABCDE"", but ""DEA"" is not.A subsequence of $$$s$$$ called good if the number of occurences of each of the first $$$k$$$ letters of the alphabet is the same.Find the length of the longest good subsequence of $$$s$$$.  NoteIn the first example, ""ACBCAB"" (""ACAABCCAB"") is one of the subsequences that has the same frequency of 'A', 'B' and 'C'. Subsequence ""CAB"" also has the same frequency of these letters, but doesn't have the maximum possible length.In the second example, none of the subsequences can have 'D', hence the answer is $$$0$$$. n, k = map(int, raw_input().split("" ""))
s = raw_input()

ll = []
for i in xrange(26):
    ll.append(0)

for ch in s:
    ll[ord(ch) - ord('A')] += 1

print min(ll[:k]) * k

","['implementation', 'strings']"
856,"Pak Chanek has a prime number$$$^\dagger$$$ $$$n$$$. Find a prime number $$$m$$$ such that $$$n + m$$$ is not prime.$$$^\dagger$$$ A prime number is a number with exactly $$$2$$$ factors. The first few prime numbers are $$$2,3,5,7,11,13,\ldots$$$. In particular, $$$1$$$ is not a prime number. NoteIn the first test case, $$$m = 2$$$, which is prime, and $$$n + m = 7 + 2 = 9$$$, which is not prime.In the second test case, $$$m = 7$$$, which is prime, and $$$n + m = 2 + 7 = 9$$$, which is not prime.In the third test case, $$$m = 47837$$$, which is prime, and $$$n + m = 75619 + 47837 = 123456$$$, which is not prime. def solve():
    j = int(input())
    if j != 2: print(3)
    else: print(2)


for t in range(int(input())): solve()
","['constructive algorithms', 'number theory']"
4644,"Consider all binary strings of length $$$m$$$ ($$$1 \le m \le 60$$$). A binary string is a string that consists of the characters 0 and 1 only. For example, 0110 is a binary string, and 012aba is not. Obviously, there are exactly $$$2^m$$$ such strings in total.The string $$$s$$$ is lexicographically smaller than the string $$$t$$$ (both have the same length $$$m$$$) if in the first position $$$i$$$ from the left in which they differ, we have $$$s[i] &lt; t[i]$$$. This is exactly the way strings are compared in dictionaries and in most modern programming languages when comparing them in a standard way. For example, the string 01011 is lexicographically smaller than the string 01100, because the first two characters are the same, and the third character in the first string is less than that in the second.We remove from this set $$$n$$$ ($$$1 \le n \le \min(2^m-1, 100)$$$) distinct binary strings $$$a_1, a_2, \ldots, a_n$$$, each of length $$$m$$$. Thus, the set will have $$$k=2^m-n$$$ strings. Sort all strings of the resulting set in lexicographical ascending order (as in the dictionary).We number all the strings after sorting from $$$0$$$ to $$$k-1$$$. Print the string whose index is $$$\lfloor \frac{k-1}{2} \rfloor$$$ (such an element is called median), where $$$\lfloor x \rfloor$$$ is the rounding of the number down to the nearest integer.For example, if $$$n=3$$$, $$$m=3$$$ and $$$a=[$$$010, 111, 001$$$]$$$, then after removing the strings $$$a_i$$$ and sorting, the result will take the form: $$$[$$$000, 011, 100, 101, 110$$$]$$$. Thus, the desired median is 100. NoteThe first test case is explained in the statement.In the second test case, the result after removing strings and sorting is $$$[$$$001, 010, 101, 110$$$]$$$. Therefore, the desired median is 010. for _ in range(int(input())):
    n, m = map(int, input().split())
    a = [int(input(), 2) for _ in range(n)]
    x = (2 ** m - n - 1) // 2
    for v in sorted(a):
        if v <= x:
            x += 1
    print(""{0:0={1}b}"".format(x, m))","['binary search', 'bitmasks', 'brute force', 'constructive algorithms']"
2228,"You are given two integers $$$b$$$ and $$$w$$$. You have a chessboard of size $$$10^9 \times 10^9$$$ with the top left cell at $$$(1; 1)$$$, the cell $$$(1; 1)$$$ is painted white.Your task is to find a connected component on this chessboard that contains exactly $$$b$$$ black cells and exactly $$$w$$$ white cells. Two cells are called connected if they share a side (i.e. for the cell $$$(x, y)$$$ there are at most four connected cells: $$$(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)$$$). A set of cells is called a connected component if for every pair of cells $$$C_1$$$ and $$$C_2$$$ from this set, there exists a sequence of cells $$$c_1$$$, $$$c_2$$$, ..., $$$c_k$$$ such that $$$c_1 = C_1$$$, $$$c_k = C_2$$$, all $$$c_i$$$ from $$$1$$$ to $$$k$$$ are belong to this set of cells and for every $$$i \in [1, k - 1]$$$, cells $$$c_i$$$ and $$$c_{i + 1}$$$ are connected.Obviously, it can be impossible to find such component. In this case print ""NO"". Otherwise, print ""YES"" and any suitable connected component.You have to answer $$$q$$$ independent queries. nan import sys
for _ in range(int(sys.stdin.readline())):
    b, w = [int(i) for i in sys.stdin.readline().split()]
    if b > w:
        dif = b - w
        if dif <= 2*w+1:
            print(""YES"")
            for i in range(2, 2*w+2):
                print(2, i)
            
            if dif & 1:
                print(2, 1)
            for i in range(1, dif//2 + 1):
                print(1, 2*i)
                print(3, 2*i)
        else:
            print(""NO"")
    else:
        dif = w - b
        if dif <= 2*b+1:
            print(""YES"")
            for i in range(2, 2*b+2):
                print(2, i)
            
            if dif & 1:
                print(2, 2*b+2)
            for i in range(1, dif//2 + 1):
                print(1, 2*i+1)
                print(3, 2*i+1)
        else:
            print(""NO"")","['constructive algorithms', 'implementation']"
2170,"There are $$$n$$$ blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. You may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). You want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed $$$3 \cdot n$$$. If it is impossible to find such a sequence of operations, you need to report it. NoteIn the first example, it is possible to make all blocks black in $$$3$$$ operations. Start with changing blocks $$$6$$$ and $$$7$$$, so the sequence is ""BWWWWBBB"". Then change blocks $$$2$$$ and $$$3$$$, so the sequence is ""BBBWWBB"". And finally, change blocks $$$4$$$ and $$$5$$$, so all blocks are black.It is impossible to make all colors equal in the second example.All blocks are already white in the third example.In the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks $$$2$$$ and $$$3$$$ (so the sequence is ""BBW""), and then change blocks $$$1$$$ and $$$2$$$ (so all blocks are white). #!/usr/bin/env pypy
from __future__ import division, print_function
from collections import defaultdict, Counter, deque
from future_builtins import ascii, filter, hex, map, oct, zip
from itertools import imap as map, izip as zip
from __builtin__ import xrange as range
from math import ceil, log
from _continuation import continulet
from cStringIO import StringIO
from io import IOBase
import __pypy__
from pprint import pprint
from bisect import bisect, insort, bisect_left, bisect_right
import sys
import os
import re
inf = float('inf')
mod = int(1e9) + 7
mod_ = 998244353

'''
Check for special cases (n=1)
One wrong submission = 10 mins penalty!
do smth instead of nothing and stay organized
'''

def solve(n, s):
	swaps = []
	for i in range(n-1):
		if s[i] == '0' and s[i] == s[i+1]:
			swaps.append(i+1)
			s[i] = '1'
			s[i+1] = '1'
	if s.count('0')%2 == 1:
		return [-1]
	i = 0
	while i < n:
		if s[i] == '0':
			j = s.index('0', i+1)
			swaps += list(range(i+1, j+1))
			i = j+1
		else:
			i += 1
	return swaps
	
def main():
	n = int(input())
	s = input()
	if len(set(s)) == 1:
		print(0)
		return
	s = s.replace('B', '1')
	s = s.replace('W', '0')
	ans1 = solve(n, list(s))
	s = list(s)
	for i in range(n):
		if s[i] == '1':
			s[i] = '0'
		else:
			s[i] = '1'
	ans2 = solve(n, list(s))
	if ans1 != [-1] and len(ans1) <= 3*n:
		print(len(ans1))
		print(*ans1)
	elif ans2 != [-1] and len(ans2) <= 3*n:
		print(len(ans2))
		print(*ans2)
	else:
		print(-1)
	


BUFSIZE = 8192
class FastI(IOBase):
	def __init__(self, file):
		self._fd = file.fileno()
		self._buffer = StringIO()
		self.newlines = 0

	def read(self):
		while True:
			b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
			if not b:
				break
			ptr = self.buffer.tell()
			self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
		self.newlines = 0
		return self.buffer.read()

	def readline(self):
		while self.newlines == 0:
			b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
			self.newlines = b.count(""\n"") + (not b)
			ptr = self._buffer.tell()
			self._buffer.seek(0, 2), self._buffer.write(
				b), self._buffer.seek(ptr)
		self.newlines -= 1
		return self._buffer.readline()
class FastO(IOBase):
	def __init__(self, file):
		self._fd = file.fileno()
		self._buffer = __pypy__.builders.StringBuilder()
		self.write = lambda s: self._buffer.append(s)

	def flush(self):
		os.write(self._fd, self._buffer.build())
		self._buffer = __pypy__.builders.StringBuilder()
def print(*args, **kwargs):
	sep, file = kwargs.pop(""sep"", "" ""), kwargs.pop(""file"", sys.stdout)
	at_start = True
	for x in args:
		if not at_start:
			file.write(sep)
		file.write(str(x))
		at_start = False
	file.write(kwargs.pop(""end"", ""\n""))
	if kwargs.pop(""flush"", False):
		file.flush()
def gcd(x, y):
	while y:
		x, y = y, x % y
	return x
sys.stdin, sys.stdout = FastI(sys.stdin), FastO(sys.stdout)
def input(): return sys.stdin.readline().rstrip(""\r\n"")
if __name__ == ""__main__"":
	def bootstrap(cont):
		call, arg = cont.switch()
		while True:
			call, arg = cont.switch(to=continulet(
				lambda _, f, args: f(*args), call, arg))
	cont = continulet(bootstrap)
	cont.switch()
	main()
","['greedy', 'math']"
4324,"Roland loves growing flowers. He has recently grown a beautiful rose at point (0, 0) of the Cartesian coordinate system. The rose is so beautiful that Roland is afraid that the evil forces can try and steal it. To protect the rose, Roland wants to build n watch towers. Let's assume that a tower is a point on the plane at the distance of at most r from the rose. Besides, Roland assumes that the towers should be built at points with integer coordinates and the sum of squares of distances between all pairs of towers must be as large as possible. Note, that Roland may build several towers at the same point, also he may build some of them at point (0, 0).Help Roland build the towers at the integer points so that the sum of squares of distances between all towers is maximum possible. Note that the distance in this problem is defined as the Euclidian distance between points. nan """"""
#include <bits/stdc++.h>
#ifdef DEMETRIO
#define deb(...) fprintf(stderr,__VA_ARGS__)
#define deb1(x) cerr << #x << "" = "" << x << endl
#else
#define deb(...) 0
#define deb1(x) 0
#endif
#define pb push_back
#define mp make_pair
#define fst first
#define snd second
#define fore(i,a,b) for(int i=a,ThxDem=b;i<ThxDem;++i)
#define SZ(x) ((int)(x).size())
#define mset(a,v) memset(a,v,sizeof(a))
#define mcopy(a,b) memcpy(a,b,sizeof(a))
using namespace std;
typedef long long ll;

int dp[9][512][512];
int cx[9][512][512],cy[9][512][512],rr;
bool vis[9][512][512];
#define OFF 250

int f(int n, int xx, int yy){
	if(vis[n][xx][yy])return dp[n][xx][yy];
	vis[n][xx][yy]=true;
	int& r=dp[n][xx][yy];
	if(n==0)return r=(xx==OFF&&yy==OFF)?0:-(1<<30);
	r=-(1<<30);
	fore(x,-rr,rr+1)fore(y,-rr,rr+1){
		if(x*x+y*y>rr*rr)continue;
		if(xx+x<0||xx+x>=512)continue;
		if(yy+y<0||yy+y>=512)continue;
		int a=x*x+y*y+f(n-1,xx+x,yy+y);
		if(a>r){r=a;cx[n][xx][yy]=x;cy[n][xx][yy]=y;}
	}
	return r;
}

int main(){
	fore(r,1,31){
		rr=r;
		mset(vis,false);
		fore(n,2,9){
			printf(""r[%d][%d]='''"",n,r);
			int r=-(1<<30),xx,yy;
			fore(i,0,512)fore(j,0,512)if(f(n,i,j)>=0){
				int a=n*f(n,i,j)-(i-OFF)*(i-OFF)-(j-OFF)*(j-OFF);
				if(a>r)r=a,xx=i,yy=j;
			}
			printf(""%d\n"",r);
			int k=n;
			while(k>0){
				printf(""%d %d\n"",cx[k][xx][yy],cy[k][xx][yy]);
				int nx=xx+cx[k][xx][yy],ny=yy+cy[k][xx][yy];
				xx=nx;yy=ny;
				k--;
			}
			puts(""'''"");
		}
	}
	return 0;
}
""""""
r=[[0]*31 for _ in range(9)]
r[2][1]='''4
-1 0
1 0
'''
r[3][1]='''8
-1 0
1 0
1 0
'''
r[4][1]='''16
-1 0
-1 0
1 0
1 0
'''
r[5][1]='''24
-1 0
-1 0
1 0
1 0
1 0
'''
r[6][1]='''36
-1 0
-1 0
-1 0
1 0
1 0
1 0
'''
r[7][1]='''48
-1 0
-1 0
-1 0
1 0
1 0
1 0
1 0
'''
r[8][1]='''64
-1 0
-1 0
-1 0
-1 0
1 0
1 0
1 0
1 0
'''
r[2][2]='''16
-2 0
2 0
'''
r[3][2]='''32
-2 0
2 0
2 0
'''
r[4][2]='''64
-2 0
-2 0
2 0
2 0
'''
r[5][2]='''96
-2 0
-2 0
2 0
2 0
2 0
'''
r[6][2]='''144
-2 0
-2 0
-2 0
2 0
2 0
2 0
'''
r[7][2]='''192
-2 0
-2 0
-2 0
2 0
2 0
2 0
2 0
'''
r[8][2]='''256
-2 0
-2 0
-2 0
-2 0
2 0
2 0
2 0
2 0
'''
r[2][3]='''36
-3 0
3 0
'''
r[3][3]='''76
-2 -2
0 3
3 0
'''
r[4][3]='''144
-3 0
-3 0
3 0
3 0
'''
r[5][3]='''218
-3 0
-2 -2
0 3
3 0
3 0
'''
r[6][3]='''324
-3 0
-3 0
-3 0
3 0
3 0
3 0
'''
r[7][3]='''432
-3 0
-3 0
-3 0
3 0
3 0
3 0
3 0
'''
r[8][3]='''576
-3 0
-3 0
-3 0
-3 0
3 0
3 0
3 0
3 0
'''
r[2][4]='''64
-4 0
4 0
'''
r[3][4]='''130
-2 -3
0 4
4 0
'''
r[4][4]='''256
-4 0
-4 0
4 0
4 0
'''
r[5][4]='''384
-4 0
-4 0
4 0
4 0
4 0
'''
r[6][4]='''576
-4 0
-4 0
-4 0
4 0
4 0
4 0
'''
r[7][4]='''768
-4 0
-4 0
-4 0
4 0
4 0
4 0
4 0
'''
r[8][4]='''1024
-4 0
-4 0
-4 0
-4 0
4 0
4 0
4 0
4 0
'''
r[2][5]='''100
-5 0
5 0
'''
r[3][5]='''224
-5 0
3 -4
3 4
'''
r[4][5]='''400
-5 0
-5 0
5 0
5 0
'''
r[5][5]='''624
-5 0
-5 0
3 -4
3 4
5 0
'''
r[6][5]='''900
-5 0
-5 0
-5 0
5 0
5 0
5 0
'''
r[7][5]='''1224
-5 0
-5 0
-5 0
3 -4
3 4
5 0
5 0
'''
r[8][5]='''1600
-5 0
-5 0
-5 0
-5 0
5 0
5 0
5 0
5 0
'''
r[2][6]='''144
-6 0
6 0
'''
r[3][6]='''312
-6 0
3 -5
3 5
'''
r[4][6]='''576
-6 0
-6 0
6 0
6 0
'''
r[5][6]='''880
-6 0
-3 -5
0 6
6 0
6 0
'''
r[6][6]='''1296
-6 0
-6 0
-6 0
6 0
6 0
6 0
'''
r[7][6]='''1740
-6 0
-6 0
-3 -5
0 6
6 0
6 0
6 0
'''
r[8][6]='''2304
-6 0
-6 0
-6 0
-6 0
6 0
6 0
6 0
6 0
'''
r[2][7]='''196
-7 0
7 0
'''
r[3][7]='''416
-3 -6
-3 6
7 0
'''
r[4][7]='''784
-7 0
-7 0
7 0
7 0
'''
r[5][7]='''1188
-7 0
-3 -6
0 7
7 0
7 0
'''
r[6][7]='''1764
-7 0
-7 0
-7 0
7 0
7 0
7 0
'''
r[7][7]='''2356
-7 0
-7 0
-3 -6
0 7
7 0
7 0
7 0
'''
r[8][7]='''3136
-7 0
-7 0
-7 0
-7 0
7 0
7 0
7 0
7 0
'''
r[2][8]='''256
-8 0
8 0
'''
r[3][8]='''554
-5 -6
0 8
8 0
'''
r[4][8]='''1024
-8 0
-8 0
8 0
8 0
'''
r[5][8]='''1572
-8 0
-5 -6
0 8
8 0
8 0
'''
r[6][8]='''2304
-8 0
-8 0
-8 0
8 0
8 0
8 0
'''
r[7][8]='''3102
-8 0
-8 0
-5 -6
0 8
8 0
8 0
8 0
'''
r[8][8]='''4096
-8 0
-8 0
-8 0
-8 0
8 0
8 0
8 0
8 0
'''
r[2][9]='''324
-9 0
9 0
'''
r[3][9]='''722
-4 -8
-4 8
9 0
'''
r[4][9]='''1296
-9 0
-9 0
9 0
9 0
'''
r[5][9]='''2014
-9 0
-4 -8
-4 8
9 0
9 0
'''
r[6][9]='''2916
-9 0
-9 0
-9 0
9 0
9 0
9 0
'''
r[7][9]='''3954
-9 0
-9 0
-4 -8
-4 8
9 0
9 0
9 0
'''
r[8][9]='''5184
-9 0
-9 0
-9 0
-9 0
9 0
9 0
9 0
9 0
'''
r[2][10]='''400
-10 0
10 0
'''
r[3][10]='''896
-10 0
6 -8
6 8
'''
r[4][10]='''1600
-10 0
-10 0
10 0
10 0
'''
r[5][10]='''2496
-10 0
-10 0
6 -8
6 8
10 0
'''
r[6][10]='''3600
-10 0
-10 0
-10 0
10 0
10 0
10 0
'''
r[7][10]='''4896
-10 0
-10 0
-10 0
6 -8
6 8
10 0
10 0
'''
r[8][10]='''6400
-10 0
-10 0
-10 0
-10 0
10 0
10 0
10 0
10 0
'''
r[2][11]='''484
-11 0
11 0
'''
r[3][11]='''1064
-11 0
6 -9
6 9
'''
r[4][11]='''1936
-11 0
-11 0
11 0
11 0
'''
r[5][11]='''2984
-11 0
-11 0
6 -9
6 9
11 0
'''
r[6][11]='''4356
-11 0
-11 0
-11 0
11 0
11 0
11 0
'''
r[7][11]='''5872
-11 0
-11 0
-6 -9
0 11
11 0
11 0
11 0
'''
r[8][11]='''7744
-11 0
-11 0
-11 0
-11 0
11 0
11 0
11 0
11 0
'''
r[2][12]='''576
-12 0
12 0
'''
r[3][12]='''1248
-12 0
6 -10
6 10
'''
r[4][12]='''2304
-12 0
-12 0
12 0
12 0
'''
r[5][12]='''3520
-12 0
-6 -10
0 12
12 0
12 0
'''
r[6][12]='''5184
-12 0
-12 0
-12 0
12 0
12 0
12 0
'''
r[7][12]='''6960
-12 0
-12 0
-6 -10
0 12
12 0
12 0
12 0
'''
r[8][12]='''9216
-12 0
-12 0
-12 0
-12 0
12 0
12 0
12 0
12 0
'''
r[2][13]='''676
-13 0
13 0
'''
r[3][13]='''1512
-5 -12
-5 12
13 0
'''
r[4][13]='''2704
-13 0
-13 0
13 0
13 0
'''
r[5][13]='''4224
-13 0
-5 -12
-5 12
12 -5
12 5
'''
r[6][13]='''6084
-13 0
-13 0
-13 0
13 0
13 0
13 0
'''
r[7][13]='''8280
-13 0
-13 0
-5 -12
-5 12
12 -5
12 5
13 0
'''
r[8][13]='''10816
-13 0
-13 0
-13 0
-13 0
13 0
13 0
13 0
13 0
'''
r[2][14]='''784
-14 0
14 0
'''
r[3][14]='''1746
-14 0
7 -12
7 12
'''
r[4][14]='''3136
-14 0
-14 0
14 0
14 0
'''
r[5][14]='''4870
-14 0
-7 -12
-5 13
14 0
14 0
'''
r[6][14]='''7056
-14 0
-14 0
-14 0
14 0
14 0
14 0
'''
r[7][14]='''9564
-14 0
-14 0
-7 -12
-5 13
14 0
14 0
14 0
'''
r[8][14]='''12544
-14 0
-14 0
-14 0
-14 0
14 0
14 0
14 0
14 0
'''
r[2][15]='''900
-15 0
15 0
'''
r[3][15]='''2016
-15 0
9 -12
9 12
'''
r[4][15]='''3600
-15 0
-15 0
15 0
15 0
'''
r[5][15]='''5616
-15 0
-15 0
9 -12
9 12
15 0
'''
r[6][15]='''8100
-15 0
-15 0
-15 0
15 0
15 0
15 0
'''
r[7][15]='''11016
-15 0
-15 0
-15 0
9 -12
9 12
15 0
15 0
'''
r[8][15]='''14400
-15 0
-15 0
-15 0
-15 0
15 0
15 0
15 0
15 0
'''
r[2][16]='''1024
-16 0
16 0
'''
r[3][16]='''2264
-16 0
9 -13
9 13
'''
r[4][16]='''4096
-16 0
-16 0
16 0
16 0
'''
r[5][16]='''6336
-16 0
-16 0
9 -13
9 13
16 0
'''
r[6][16]='''9216
-16 0
-16 0
-16 0
16 0
16 0
16 0
'''
r[7][16]='''12456
-16 0
-16 0
-16 0
9 -13
9 13
16 0
16 0
'''
r[8][16]='''16384
-16 0
-16 0
-16 0
-16 0
16 0
16 0
16 0
16 0
'''
r[2][17]='''1156
-17 0
17 0
'''
r[3][17]='''2600
-8 -15
-8 15
17 0
'''
r[4][17]='''4624
-17 0
-17 0
17 0
17 0
'''
r[5][17]='''7224
-17 0
-8 -15
-8 15
17 0
17 0
'''
r[6][17]='''10404
-17 0
-17 0
-17 0
17 0
17 0
17 0
'''
r[7][17]='''14160
-17 0
-17 0
-8 -15
-8 15
17 0
17 0
17 0
'''
r[8][17]='''18496
-17 0
-17 0
-17 0
-17 0
17 0
17 0
17 0
17 0
'''
r[2][18]='''1296
-18 0
18 0
'''
r[3][18]='''2888
-8 -16
-8 16
18 0
'''
r[4][18]='''5184
-18 0
-18 0
18 0
18 0
'''
r[5][18]='''8056
-18 0
-8 -16
-8 16
18 0
18 0
'''
r[6][18]='''11664
-18 0
-18 0
-18 0
18 0
18 0
18 0
'''
r[7][18]='''15816
-18 0
-18 0
-8 -16
-8 16
18 0
18 0
18 0
'''
r[8][18]='''20736
-18 0
-18 0
-18 0
-18 0
18 0
18 0
18 0
18 0
'''
r[2][19]='''1444
-19 0
19 0
'''
r[3][19]='''3218
-10 -16
-6 18
19 0
'''
r[4][19]='''5776
-19 0
-19 0
19 0
19 0
'''
r[5][19]='''9008
-18 -6
-18 -6
0 19
18 -6
19 0
'''
r[6][19]='''12996
-19 0
-19 0
-19 0
19 0
19 0
19 0
'''
r[7][19]='''17666
-19 0
-18 -6
-18 -6
0 19
18 -6
19 0
19 0
'''
r[8][19]='''23104
-19 0
-19 0
-19 0
-19 0
19 0
19 0
19 0
19 0
'''
r[2][20]='''1600
-20 0
20 0
'''
r[3][20]='''3584
-20 0
12 -16
12 16
'''
r[4][20]='''6400
-20 0
-20 0
20 0
20 0
'''
r[5][20]='''9984
-20 0
-20 0
12 -16
12 16
20 0
'''
r[6][20]='''14400
-20 0
-20 0
-20 0
20 0
20 0
20 0
'''
r[7][20]='''19584
-20 0
-20 0
-20 0
12 -16
12 16
20 0
20 0
'''
r[8][20]='''25600
-20 0
-20 0
-20 0
-20 0
20 0
20 0
20 0
20 0
'''
r[2][21]='''1764
-21 0
21 0
'''
r[3][21]='''3912
-17 -12
0 21
20 -6
'''
r[4][21]='''7056
-21 0
-21 0
21 0
21 0
'''
r[5][21]='''10942
-21 0
-17 -12
0 21
20 -6
21 0
'''
r[6][21]='''15876
-21 0
-21 0
-21 0
21 0
21 0
21 0
'''
r[7][21]='''21500
-21 0
-21 0
-17 -12
0 21
20 -6
21 0
21 0
'''
r[8][21]='''28224
-21 0
-21 0
-21 0
-21 0
21 0
21 0
21 0
21 0
'''
r[2][22]='''1936
-22 0
22 0
'''
r[3][22]='''4344
-22 0
11 -19
11 19
'''
r[4][22]='''7744
-22 0
-22 0
22 0
22 0
'''
r[5][22]='''12080
-22 0
-22 0
11 -19
11 19
22 0
'''
r[6][22]='''17424
-22 0
-22 0
-22 0
22 0
22 0
22 0
'''
r[7][22]='''23688
-22 0
-22 0
-22 0
11 -19
11 19
22 0
22 0
'''
r[8][22]='''30976
-22 0
-22 0
-22 0
-22 0
22 0
22 0
22 0
22 0
'''
r[2][23]='''2116
-23 0
23 0
'''
r[3][23]='''4712
-11 -20
-11 20
23 0
'''
r[4][23]='''8464
-23 0
-23 0
23 0
23 0
'''
r[5][23]='''13144
-23 0
-11 -20
-11 20
23 0
23 0
'''
r[6][23]='''19044
-23 0
-23 0
-23 0
23 0
23 0
23 0
'''
r[7][23]='''25808
-23 0
-23 0
-11 -20
-11 20
23 0
23 0
23 0
'''
r[8][23]='''33856
-23 0
-23 0
-23 0
-23 0
23 0
23 0
23 0
23 0
'''
r[2][24]='''2304
-24 0
24 0
'''
r[3][24]='''5138
-24 0
13 -20
13 20
'''
r[4][24]='''9216
-24 0
-24 0
24 0
24 0
'''
r[5][24]='''14326
-24 0
-24 0
13 -20
13 20
24 0
'''
r[6][24]='''20736
-24 0
-24 0
-24 0
24 0
24 0
24 0
'''
r[7][24]='''28122
-24 0
-24 0
-24 0
13 -20
13 20
24 0
24 0
'''
r[8][24]='''36864
-24 0
-24 0
-24 0
-24 0
24 0
24 0
24 0
24 0
'''
r[2][25]='''2500
-25 0
25 0
'''
r[3][25]='''5612
-24 -7
7 24
20 -15
'''
r[4][25]='''10000
-25 0
-25 0
25 0
25 0
'''
r[5][25]='''15624
-25 0
-7 -24
-7 24
20 -15
20 15
'''
r[6][25]='''22500
-25 0
-25 0
-25 0
25 0
25 0
25 0
'''
r[7][25]='''30624
-25 0
-25 0
-7 -24
-7 24
20 -15
20 15
25 0
'''
r[8][25]='''40000
-25 0
-25 0
-25 0
-25 0
25 0
25 0
25 0
25 0
'''
r[2][26]='''2704
-26 0
26 0
'''
r[3][26]='''6062
-12 -23
-12 23
26 0
'''
r[4][26]='''10816
-26 0
-26 0
26 0
26 0
'''
r[5][26]='''16896
-26 0
-10 -24
-10 24
24 -10
24 10
'''
r[6][26]='''24336
-26 0
-26 0
-26 0
26 0
26 0
26 0
'''
r[7][26]='''33120
-26 0
-26 0
-10 -24
-10 24
24 -10
24 10
26 0
'''
r[8][26]='''43264
-26 0
-26 0
-26 0
-26 0
26 0
26 0
26 0
26 0
'''
r[2][27]='''2916
-27 0
27 0
'''
r[3][27]='''6536
-27 0
14 -23
14 23
'''
r[4][27]='''11664
-27 0
-27 0
27 0
27 0
'''
r[5][27]='''18184
-27 0
-27 0
14 -23
14 23
27 0
'''
r[6][27]='''26244
-27 0
-27 0
-27 0
27 0
27 0
27 0
'''
r[7][27]='''35664
-27 0
-27 0
-27 0
14 -23
14 23
27 0
27 0
'''
r[8][27]='''46656
-27 0
-27 0
-27 0
-27 0
27 0
27 0
27 0
27 0
'''
r[2][28]='''3136
-28 0
28 0
'''
r[3][28]='''6984
-28 0
14 -24
14 24
'''
r[4][28]='''12544
-28 0
-28 0
28 0
28 0
'''
r[5][28]='''19488
-28 0
-22 -17
0 28
26 -10
28 0
'''
r[6][28]='''28224
-28 0
-28 0
-28 0
28 0
28 0
28 0
'''
r[7][28]='''38266
-28 0
-28 0
-22 -17
0 28
26 -10
28 0
28 0
'''
r[8][28]='''50176
-28 0
-28 0
-28 0
-28 0
28 0
28 0
28 0
28 0
'''
r[2][29]='''3364
-29 0
29 0
'''
r[3][29]='''7520
-20 -21
-7 28
28 -7
'''
r[4][29]='''13456
-29 0
-29 0
29 0
29 0
'''
r[5][29]='''20968
-29 0
-7 -28
0 29
20 -21
20 21
'''
r[6][29]='''30276
-29 0
-29 0
-29 0
29 0
29 0
29 0
'''
r[7][29]='''41200
-21 -20
-21 -20
-21 20
-21 20
29 0
29 0
29 0
'''
r[8][29]='''53824
-29 0
-29 0
-29 0
-29 0
29 0
29 0
29 0
29 0
'''
r[2][30]='''3600
-30 0
30 0
'''
r[3][30]='''8084
-24 18
0 -30
27 13
'''
r[4][30]='''14400
-30 0
-30 0
30 0
30 0
'''
r[5][30]='''22480
-30 0
-24 18
0 -30
27 13
30 0
'''
r[6][30]='''32400
-30 0
-30 0
-30 0
30 0
30 0
30 0
'''
r[7][30]='''44076
-30 0
-30 0
-30 0
18 24
24 -18
24 -18
27 13
'''
r[8][30]='''57600
-30 0
-30 0
-30 0
-30 0
30 0
30 0
30 0
30 0
'''
a,b=map(int,raw_input().split())
print r[a][b],","['brute force', 'geometry', 'math', 'sortings']"
4085,"Вася купил стол, у которого n ножек. Каждая ножка состоит из двух частей, которые соединяются друг с другом. Каждая часть может быть произвольной положительной длины, но гарантируется, что из всех 2n частей возможно составить n ножек одинаковой длины. При составлении ножки любые две части могут быть соединены друг с другом. Изначально все ножки стола разобраны, а вам заданы длины 2n частей в произвольном порядке.Помогите Васе собрать все ножки стола так, чтобы все они были одинаковой длины, разбив заданные 2n части на пары правильным образом. Каждая ножка обязательно должна быть составлена ровно из двух частей, не разрешается использовать как ножку только одну часть. nan n = int(input())
s = list(map(int, input().split()))
s.sort()
for i in range(n):
    print(s[i], s[2 * n - i - 1])



","['constructive algorithms', 'sortings']"
1108,"Reminder: the median of the array $$$[a_1, a_2, \dots, a_{2k+1}]$$$ of odd number of elements is defined as follows: let $$$[b_1, b_2, \dots, b_{2k+1}]$$$ be the elements of the array in the sorted order. Then median of this array is equal to $$$b_{k+1}$$$.There are $$$2n$$$ students, the $$$i$$$-th student has skill level $$$a_i$$$. It's not guaranteed that all skill levels are distinct.Let's define skill level of a class as the median of skill levels of students of the class.As a principal of the school, you would like to assign each student to one of the $$$2$$$ classes such that each class has odd number of students (not divisible by $$$2$$$). The number of students in the classes may be equal or different, by your choice. Every student has to be assigned to exactly one class. Among such partitions, you want to choose one in which the absolute difference between skill levels of the classes is minimized.What is the minimum possible absolute difference you can achieve? NoteIn the first test, there is only one way to partition students — one in each class. The absolute difference of the skill levels will be $$$|1 - 1| = 0$$$.In the second test, one of the possible partitions is to make the first class of students with skill levels $$$[6, 4, 2]$$$, so that the skill level of the first class will be $$$4$$$, and second with $$$[5, 1, 3]$$$, so that the skill level of the second class will be $$$3$$$. Absolute difference will be $$$|4 - 3| = 1$$$.Note that you can't assign like $$$[2, 3]$$$, $$$[6, 5, 4, 1]$$$ or $$$[]$$$, $$$[6, 5, 4, 1, 2, 3]$$$ because classes have even number of students.$$$[2]$$$, $$$[1, 3, 4]$$$ is also not possible because students with skills $$$5$$$ and $$$6$$$ aren't assigned to a class.In the third test you can assign the students in the following way: $$$[3, 4, 13, 13, 20], [2, 5, 8, 16, 17]$$$ or $$$[3, 8, 17], [2, 4, 5, 13, 13, 16, 20]$$$. Both divisions give minimal possible absolute difference. def solve():
    N = int(input())
    A = list(map(int, input().split()))
    
    A.sort()
    print(A[N] - A[N-1])
 
T = int(input())
for i in range(0, T):
    solve()","['greedy', 'implementation', 'sortings']"
759,"Monocarp is playing a tower defense game. A level in the game can be represented as an OX axis, where each lattice point from $$$1$$$ to $$$n$$$ contains a tower in it.The tower in the $$$i$$$-th point has $$$c_i$$$ mana capacity and $$$r_i$$$ mana regeneration rate. In the beginning, before the $$$0$$$-th second, each tower has full mana. If, at the end of some second, the $$$i$$$-th tower has $$$x$$$ mana, then it becomes $$$\mathit{min}(x + r_i, c_i)$$$ mana for the next second.There are $$$q$$$ monsters spawning on a level. The $$$j$$$-th monster spawns at point $$$1$$$ at the beginning of $$$t_j$$$-th second, and it has $$$h_j$$$ health. Every monster is moving $$$1$$$ point per second in the direction of increasing coordinate.When a monster passes the tower, the tower deals $$$\mathit{min}(H, M)$$$ damage to it, where $$$H$$$ is the current health of the monster and $$$M$$$ is the current mana amount of the tower. This amount gets subtracted from both monster's health and tower's mana.Unfortunately, sometimes some monsters can pass all $$$n$$$ towers and remain alive. Monocarp wants to know what will be the total health of the monsters after they pass all towers. nan import sys, bisect
input = sys.stdin.readline
n = int(input())
ms = 1 if n == 1 else (n-1).bit_length()
c0, r0 = zip(*[map(int, input().split()) for i in range(n)])
x, y = zip(*sorted([(c0[i]//r0[i], i) for i in range(n)]))
d, sumr, sumc = [[0]*(n+1) for i in range(ms)], [], []
def genpre(s, d):
    r = [0]
    for i in d: r.append(r[-1]+s[i])
    return r
sumr0 = genpre(r0, range(n))

def build():
    a = y
    size=1<<ms
    for d1 in d:
        b = []
        for j in range(0, n, size):
            mid = j+(size>>1)
            t = []
            for k in range(j, min(n, j+size)):
                if a[k] < mid: d1[k+1]=1 if k == j else d1[k]+1; b.append(a[k])
                else: d1[k+1]=0 if k == j else d1[k]; t.append(a[k])
            b.extend(t)
        size>>=1
        a = b
        sumr.append(genpre(r0, a)); sumc.append(genpre(c0, a))

def query(point, th, h):
    size, last = 1<<ms, 0
    pos = bisect.bisect_left(x, point)
    sc, sr = 0, 0
    for idx, d1 in enumerate(d):
        size>>=1
        mid = last+size
        if mid <= th:
            pp = last + (d1[pos] if pos != last else 0)
            cc, rr = sumc[idx][pp]-sumc[idx][last], sumr[idx][pp]-sumr[idx][last]
            # print(mid, th, h, last, pos, sr, sc, cc, rr, cc+sc + point*(sumr0[mid]-sr-rr), d1)
            if cc+sc + point*(sumr0[mid]-sr-rr) < h:
                sc+=cc; sr+=rr
                pos = mid + pos - pp 
                last = mid
                continue
        # print(last,pos,d1)
        pos = last + (d1[pos] if pos != last else 0)
    return sc+point*(sumr0[last]-sr), last

build()
M = 10**18
s = [(0,n,-M, 0)]
ans = 0
# print(c0,r0,x,y,d, sumr, sumc)
for t, h in [map(int, input().split()) for i in range(int(input()))]:
    while s:
        l, r, p, left = s.pop()
        if (l != r): 
            tmp, _ = query(t-p, l, M)
            h = h+tmp
            tmp, pos = query(t-p, r, h)
            h-=tmp
            if pos < r: 
                if h: 
                    if pos+1 < r: s.append((pos+1, r, p, 0))
                    s.append((pos, pos, t+pos, min(c0[pos], r0[pos]*(t-p))-h))
                    h = 0
                else: s.append((pos, r, p, 0))
                if pos: s.append((0,pos,t,0))
        else:
            tmp = min(c0[l], left+(t+r-p)*r0[l])
            if tmp >= h: 
                s.append((l, r, t+r, tmp-h))
                if l: s.append((0,l,t,0))
                h=0
            else: h-=tmp
        if h == 0: break
    if h: s.append((0,n,t,0)); ans+=h
print(ans)
","['binary search', 'brute force', 'data structures']"
4842,"New Year is coming in Line World! In this world, there are n cells numbered by integers from 1 to n, as a 1 × n board. People live in cells. However, it was hard to move between distinct cells, because of the difficulty of escaping the cell. People wanted to meet people who live in other cells.So, user tncks0121 has made a transportation system to move between these cells, to celebrate the New Year. First, he thought of n - 1 positive integers a1, a2, ..., an - 1. For every integer i where 1 ≤ i ≤ n - 1 the condition 1 ≤ ai ≤ n - i holds. Next, he made n - 1 portals, numbered by integers from 1 to n - 1. The i-th (1 ≤ i ≤ n - 1) portal connects cell i and cell (i + ai), and one can travel from cell i to cell (i + ai) using the i-th portal. Unfortunately, one cannot use the portal backwards, which means one cannot move from cell (i + ai) to cell i using the i-th portal. It is easy to see that because of condition 1 ≤ ai ≤ n - i one can't leave the Line World using portals.Currently, I am standing at cell 1, and I want to go to cell t. However, I don't know whether it is possible to go there. Please determine whether I can go to cell t by only using the construted transportation system. NoteIn the first sample, the visited cells are: 1, 2, 4; so we can successfully visit the cell 4.In the second sample, the possible cells to visit are: 1, 2, 4, 6, 7, 8; so we can't visit the cell 5, which we want to visit. n, t = [int(x) for x in input().split()]
a = [int(x) for x in input().split()]
x = 0
i = 0
while i in range(0, t):
    i += a[i]
    if i == t-1:
        x = 1
        break
if x == 1:
    print('YES')
else:
    print('NO')
","['dfs and similar', 'graphs', 'implementation']"
3623,"At the big break Nastya came to the school dining room. There are $$$n$$$ pupils in the school, numbered from $$$1$$$ to $$$n$$$. Unfortunately, Nastya came pretty late, so that all pupils had already stood in the queue, i.e. Nastya took the last place in the queue. Of course, it's a little bit sad for Nastya, but she is not going to despond because some pupils in the queue can agree to change places with some other pupils.Formally, there are some pairs $$$u$$$, $$$v$$$ such that if the pupil with number $$$u$$$ stands directly in front of the pupil with number $$$v$$$, Nastya can ask them and they will change places. Nastya asks you to find the maximal number of places in queue she can move forward.  NoteIn the first example Nastya can just change places with the first pupil in the queue.Optimal sequence of changes in the second example is   change places for pupils with numbers $$$1$$$ and $$$3$$$.  change places for pupils with numbers $$$3$$$ and $$$2$$$.  change places for pupils with numbers $$$1$$$ and $$$2$$$. The queue looks like $$$[3, 1, 2]$$$, then $$$[1, 3, 2]$$$, then $$$[1, 2, 3]$$$, and finally $$$[2, 1, 3]$$$ after these operations. import os
from cStringIO import StringIO

input = StringIO(os.read(0, os.fstat(0).st_size)).readline


def main():
    n, m = map(int, input().split())
    p = [int(i) - 1 for i in input().split()]
    pos = p[-1]

    graph = [set() for _ in range(n)]
    for i in range(m):
        u, v = map(int, input().split())
        graph[u - 1].add(v - 1)

    for i in range(n - 2, -1, -1):
        while (i + 1 < n) and (p[i + 1] in graph[p[i]]):
            p[i], p[i + 1] = p[i + 1], p[i]
            i += 1

    os.write(1, str(n - p.index(pos) - 1))


if __name__ == '__main__':
    main()
",['greedy']
3774,"In one little known, but very beautiful country called Waterland, lives a lovely shark Valerie. Like all the sharks, she has several rows of teeth, and feeds on crucians. One of Valerie's distinguishing features is that while eating one crucian she uses only one row of her teeth, the rest of the teeth are ""relaxing"".For a long time our heroine had been searching the sea for crucians, but a great misfortune happened. Her teeth started to ache, and she had to see the local dentist, lobster Ashot. As a professional, Ashot quickly relieved Valerie from her toothache. Moreover, he managed to determine the cause of Valerie's developing caries (for what he was later nicknamed Cap).It turned that Valerie eats too many crucians. To help Valerie avoid further reoccurrence of toothache, Ashot found for each Valerie's tooth its residual viability. Residual viability of a tooth is a value equal to the amount of crucians that Valerie can eat with this tooth. Every time Valerie eats a crucian, viability of all the teeth used for it will decrease by one. When the viability of at least one tooth becomes negative, the shark will have to see the dentist again. Unhappy, Valerie came back home, where a portion of crucians was waiting for her. For sure, the shark couldn't say no to her favourite meal, but she had no desire to go back to the dentist. That's why she decided to eat the maximum amount of crucians from the portion but so that the viability of no tooth becomes negative. As Valerie is not good at mathematics, she asked you to help her to find out the total amount of crucians that she can consume for dinner.We should remind you that while eating one crucian Valerie uses exactly one row of teeth and the viability of each tooth from this row decreases by one. nan n,m,k=map(int,input().strip().split())
arr=[float(""inf"")]*m
for i in range(n):
    r,c=map(int,input().strip().split())
    arr[r-1]=min(arr[r-1],c)
print(min(k,sum(arr)))","['greedy', 'implementation']"
2284,"Mishka is a little polar bear. As known, little bears loves spending their free time playing dice for chocolates. Once in a wonderful sunny morning, walking around blocks of ice, Mishka met her friend Chris, and they started playing the game.Rules of the game are very simple: at first number of rounds n is defined. In every round each of the players throws a cubical dice with distinct numbers from 1 to 6 written on its faces. Player, whose value after throwing the dice is greater, wins the round. In case if player dice values are equal, no one of them is a winner.In average, player, who won most of the rounds, is the winner of the game. In case if two players won the same number of rounds, the result of the game is draw.Mishka is still very little and can't count wins and losses, so she asked you to watch their game and determine its result. Please help her! NoteIn the first sample case Mishka loses the first round, but wins second and third rounds and thus she is the winner of the game.In the second sample case Mishka wins the first round, Chris wins the second round, and the game ends with draw with score 1:1.In the third sample case Chris wins the first round, but there is no winner of the next two rounds. The winner of the game is Chris. n = int(input())
a = 0
b = 0
for i in range(n):
    m, c = map(int, input().split())
    if m > c:
        a += 1
    elif c > m:
        b += 1
if a > b:
    print(""Mishka"")
elif b > a:
    print(""Chris"")
else:
    print(""Friendship is magic!^^"")",['implementation']
2704,"For some time the program of rounding numbers that had been developed by the Codeforces participants during one of the previous rounds, helped the citizens of Far Far Away to convert numbers into a more easily readable format. However, as time went by, the economy of the Far Far Away developed and the scale of operations grew. So the King ordered to found the Bank of Far Far Away and very soon even the rounding didn't help to quickly determine even the order of the numbers involved in operations. Besides, rounding a number to an integer wasn't very convenient as a bank needed to operate with all numbers with accuracy of up to 0.01, and not up to an integer.The King issued yet another order: to introduce financial format to represent numbers denoting amounts of money. The formal rules of storing a number in the financial format are as follows:   A number contains the integer part and the fractional part. The two parts are separated with a character ""."" (decimal point).  To make digits in the integer part of a number easier to read, they are split into groups of three digits, starting from the least significant ones. The groups are separated with the character "","" (comma). For example, if the integer part of a number equals 12345678, then it will be stored in the financial format as 12,345,678  In the financial format a number's fractional part should contain exactly two digits. So, if the initial number (the number that is converted into the financial format) contains less than two digits in the fractional part (or contains no digits at all), it is complemented with zeros until its length equals 2. If the fractional part contains more than two digits, the extra digits are simply discarded (they are not rounded: see sample tests).  When a number is stored in the financial format, the minus sign is not written. Instead, if the initial number had the minus sign, the result is written in round brackets.  Please keep in mind that the bank of Far Far Away operates using an exotic foreign currency — snakes ($), that's why right before the number in the financial format we should put the sign ""$"". If the number should be written in the brackets, then the snake sign should also be inside the brackets. For example, by the above given rules number 2012 will be stored in the financial format as ""$2,012.00"" and number -12345678.9 will be stored as ""($12,345,678.90)"".The merchants of Far Far Away visited you again and expressed much hope that you supply them with the program that can convert arbitrary numbers to the financial format. Can you help them? NotePay attention to the second and third sample tests. They show that the sign of a number in the financial format (and consequently, the presence or absence of brackets) is determined solely by the sign of the initial number. It does not depend on the sign of the number you got after translating the number to the financial format. import math, re, sys, string, operator, functools, fractions, collections
sys.setrecursionlimit(10**7)
RI=lambda x=' ': list(map(int,input().split(x)))
RS=lambda x=' ': input().rstrip().split(x)
dX= [-1, 1, 0, 0,-1, 1,-1, 1]
dY= [ 0, 0,-1, 1, 1,-1,-1, 1]
mod=int(1e9+7)
eps=1e-6
pi=math.acos(-1.0)
MAX=100
#################################################
s=RS()[0]
st=0
if s[0]=='-':
    st=1
s=s[st:].split('.')
i,f=""0"",""0""
i=s[0]
if len(s)>1:
    f=s[1]
i=i[::-1]
f=f[::-1]
ans='$'+(','.join([i[j:j+3] for j in range(0,len(i),3)]))[::-1]
ans+= '.'+f.zfill(2)[::-1][:2]
if st:
    ans='('+ans+')'
print(ans)
","['implementation', 'strings']"
2333,"Recently, Duff has been practicing weight lifting. As a hard practice, Malek gave her a task. He gave her a sequence of weights. Weight of i-th of them is 2wi pounds. In each step, Duff can lift some of the remaining weights and throw them away. She does this until there's no more weight left. Malek asked her to minimize the number of steps.  Duff is a competitive programming fan. That's why in each step, she can only lift and throw away a sequence of weights 2a1, ..., 2ak if and only if there exists a non-negative integer x such that 2a1 + 2a2 + ... + 2ak = 2x, i. e. the sum of those numbers is a power of two.Duff is a competitive programming fan, but not a programmer. That's why she asked for your help. Help her minimize the number of steps.  NoteIn the first sample case: One optimal way would be to throw away the first three in the first step and the rest in the second step. Also, it's not possible to do it in one step because their sum is not a power of two.In the second sample case: The only optimal way is to throw away one weight in each step. It's not possible to do it in less than 4 steps because there's no subset of weights with more than one weight and sum equal to a power of two. # Description of the problem can be found at http://codeforces.com/problemset/problem/587/A

n = int(input())
w = map(int, input().split())
m = 1000001
s = [0] * m

for i in w:
    s[i] += 1

ans = 0
z = 0
for i in range(m):
    n_s = s[i]+z
    z = n_s // 2
    ans += n_s % 2

while z > 0:
    ans += z % 2
    z //= 2

print(ans)",['greedy']
214,"Gerald found a table consisting of n rows and m columns. As a prominent expert on rectangular tables, he immediately counted the table's properties, that is, the minimum of the numbers in the corners of the table (minimum of four numbers). However, he did not like the final value — it seemed to be too small. And to make this value larger, he decided to crop the table a little: delete some columns on the left and some on the right, as well as some rows from the top and some from the bottom. Find what the maximum property of the table can be after such cropping. Note that the table should have at least two rows and at least two columns left in the end. The number of cropped rows or columns from each of the four sides can be zero. NoteIn the first test case Gerald cannot crop the table — table contains only two rows and only two columns.In the second test case if we'll crop the table, the table will contain zero in some corner cell. Also initially it contains two zeros in the corner cells, so the answer is 0. n, m = 0, 0
a, exists = [], []
def ok(lim):
	for i in xrange(n):
		for j in xrange(i + 1, n):
			exists[i][j] = False
	for k in xrange(m):
		allowed = []
		for i in xrange(n):
			if a[i][k] >= lim:
				allowed.append(i)
		for i in xrange(len(allowed)):
			for j in xrange(i + 1, len(allowed)):
				if exists[allowed[i]][allowed[j]] == True:
					return True
				else:
					exists[allowed[i]][allowed[j]] = True
	return False

n, m = [int(i) for i in raw_input().split()]
[a.append([int(i) for i in raw_input().split()]) for t in xrange(n)]
exists = [[False for i in xrange(n)] for j in xrange(n)]

low, high, poss = 0, 1000000000, -1
while high >= low:
	mid = (high + low) // 2
	if ok(mid):
		poss = mid; low = mid + 1
	else:
		high = mid - 1 
print poss","['binary search', 'bitmasks', 'brute force', 'implementation', 'sortings']"
4511,"After a hard day Vitaly got very hungry and he wants to eat his favorite potato pie. But it's not that simple. Vitaly is in the first room of the house with n room located in a line and numbered starting from one from left to right. You can go from the first room to the second room, from the second room to the third room and so on — you can go from the (n - 1)-th room to the n-th room. Thus, you can go to room x only from room x - 1.The potato pie is located in the n-th room and Vitaly needs to go there. Each pair of consecutive rooms has a door between them. In order to go to room x from room x - 1, you need to open the door between the rooms with the corresponding key. In total the house has several types of doors (represented by uppercase Latin letters) and several types of keys (represented by lowercase Latin letters). The key of type t can open the door of type T if and only if t and T are the same letter, written in different cases. For example, key f can open door F.Each of the first n - 1 rooms contains exactly one key of some type that Vitaly can use to get to next rooms. Once the door is open with some key, Vitaly won't get the key from the keyhole but he will immediately run into the next room. In other words, each key can open no more than one door.Vitaly realizes that he may end up in some room without the key that opens the door to the next room. Before the start his run for the potato pie Vitaly can buy any number of keys of any type that is guaranteed to get to room n.Given the plan of the house, Vitaly wants to know what is the minimum number of keys he needs to buy to surely get to the room n, which has a delicious potato pie. Write a program that will help Vitaly find out this number. nan from collections import defaultdict
n = input()
s = raw_input()
d = defaultdict(int)
c = 0
for i in range(1,2*n-2+1):
	if i%2:
		d[s[i-1]] += 1
	elif i%2 == 0 and d[s[i-1].lower()] == 0:
		c += 1
	elif i%2 ==0 and d[s[i-1].lower()] != 0:
		d[s[i-1].lower()] -= 1
print c
","['greedy', 'hashing', 'strings']"
1321,"Polycarp thinks about the meaning of life very often. He does this constantly, even when typing in the editor. Every time he starts brooding he can no longer fully concentrate and repeatedly presses the keys that need to be pressed only once. For example, instead of the phrase ""how are you"" he can type ""hhoow aaaare yyoouu"". Polycarp decided to automate the process of correcting such errors. He decided to write a plug-in to the text editor that will remove pairs of identical consecutive letters (if there are any in the text). Of course, this is not exactly what Polycarp needs, but he's got to start from something! Help Polycarp and write the main plug-in module. Your program should remove from a string all pairs of identical letters, which are consecutive. If after the removal there appear new pairs, the program should remove them as well. Technically, its work should be equivalent to the following: while the string contains a pair of consecutive identical letters, the pair should be deleted. Note that deleting of the consecutive identical letters can be done in any order, as any order leads to the same result.  nan string = raw_input()
l=[]
i=0
for s in string:
    if l and s==l[-1]:
        l.pop()
    else:
        l.append(s)
print ''.join(l)",['implementation']
693,"Consider a table of size $$$n \times m$$$, initially fully white. Rows are numbered $$$1$$$ through $$$n$$$ from top to bottom, columns $$$1$$$ through $$$m$$$ from left to right. Some square inside the table with odd side length was painted black. Find the center of this square. nan import math
a = input().split(' ')
n = int(a[0])
m = int(a[1])

s = []
for z in range (n):
    a = str(input())
    s.append(a)
#print(s)


def countB():
    b = 0
    for i in range (0, n):
        for j in range (0, m):
            if s[i][j] == 'B':
                b = b + 1

    return b
qb = countB()
#print(qb)
bSqrt = int (math.sqrt(qb))
#print(bSqrt)

def middleSquare():
    if qb == 1:
        for i in range (0, n):
            for j in range (0, m):
                if s[i][j] == 'B':
                    r = i + 1
                    c = j + 1
                    anser = (r, c)
                    return anser
    else: 
        side = bSqrt//2
        #print (side)
        for i in range (0, n):
            for j in range (0, m):
                if s[i][j] == 'B':
                    #print(i)
                    #print(j)
                    r = i + 1 + side
                    c = j + 1 + side
                    #print (r)
                    #print (c)
                    anser = (r, c)
                    return anser


middle = (middleSquare())

r = middle[0]
c = middle[1]

print (""{:2d} {:2d}"".format(r,c))
",['implementation']
4668,"Petya has an array of integers $$$a_1, a_2, \ldots, a_n$$$. He only likes sorted arrays. Unfortunately, the given array could be arbitrary, so Petya wants to sort it.Petya likes to challenge himself, so he wants to sort array using only $$$3$$$-cycles. More formally, in one operation he can pick $$$3$$$ pairwise distinct indices $$$i$$$, $$$j$$$, and $$$k$$$ ($$$1 \leq i, j, k \leq n$$$) and apply $$$i \to j \to k \to i$$$ cycle to the array $$$a$$$. It simultaneously places $$$a_i$$$ on position $$$j$$$, $$$a_j$$$ on position $$$k$$$, and $$$a_k$$$ on position $$$i$$$, without changing any other element.For example, if $$$a$$$ is $$$[10, 50, 20, 30, 40, 60]$$$ and he chooses $$$i = 2$$$, $$$j = 1$$$, $$$k = 5$$$, then the array becomes $$$[\underline{50}, \underline{40}, 20, 30, \underline{10}, 60]$$$.Petya can apply arbitrary number of $$$3$$$-cycles (possibly, zero). You are to determine if Petya can sort his array $$$a$$$, i. e. make it non-decreasing. NoteIn the $$$6$$$-th test case Petya can use the $$$3$$$-cycle $$$1 \to 3 \to 2 \to 1$$$ to sort the array.In the $$$7$$$-th test case Petya can apply $$$1 \to 3 \to 2 \to 1$$$ and make $$$a = [1, 4, 2, 3]$$$. Then he can apply $$$2 \to 4 \to 3 \to 2$$$ and finally sort the array. #!/usr/bin/python3.9

def has_identical(a, n):
    b = [0 for i in range(1, n+1)]
    for i in a:
       b[i]+=1
       if b[i] > 1:
           return True 
    return False	
                

t = int(input())
ans = []
for i in range(t):
    n = int(input())
    a = list(map(lambda x : int(x)-1, input().split()))
    
  
    if not has_identical(a, n):
        a2 = list(range(n))
        b = a2.copy() #индексный массив
        for i in range(n-2):
            if a2[i] != a[i]:
                j = b[a[i]] # индекс элемента в массиве b
                k = (n-1 if j != n-1 else n-2) #индекс последнего или предпоследнего элемента
                # (i k j)
                a2[i], a2[j], a2[k] = a2[j], a2[k], a2[i]
                b[a2[i]], b[a2[j]], b[a2[k]] = i, j, k
            #print(a, a2, b)
        if a2[-1] == a[-1]:
            ans.append(""YES"")
        else:
            ans.append(""NO"")

    else:
        ans.append(""YES"")

for i in ans:
    print(i)
","['data structures', 'math']"
4460,"You are given two strings $$$s$$$ and $$$t$$$. In a single move, you can choose any of two strings and delete the first (that is, the leftmost) character. After a move, the length of the string decreases by $$$1$$$. You can't choose a string if it is empty.For example:  by applying a move to the string ""where"", the result is the string ""here"",  by applying a move to the string ""a"", the result is an empty string """". You are required to make two given strings equal using the fewest number of moves. It is possible that, in the end, both strings will be equal to the empty string, and so, are equal to each other. In this case, the answer is obviously the sum of the lengths of the initial strings.Write a program that finds the minimum number of moves to make two given strings $$$s$$$ and $$$t$$$ equal. NoteIn the first example, you should apply the move once to the first string and apply the move once to the second string. As a result, both strings will be equal to ""est"".In the second example, the move should be applied to the string ""codeforces"" $$$8$$$ times. As a result, the string becomes ""codeforces"" $$$\to$$$ ""es"". The move should be applied to the string ""yes"" once. The result is the same string ""yes"" $$$\to$$$ ""es"".In the third example, you can make the strings equal only by completely deleting them. That is, in the end, both strings will be empty.In the fourth example, the first character of the second string should be deleted. k1 = input()
k2 = input()
t1 = len(k1)
t2 = len(k2)
mini = min(t1,t2)
count = 0
k1 = k1[::-1]
k2 = k2[::-1]
for i in range(mini):
    if k1[i] == k2[i]:
        count+=1
    else:
        break
print(t1-count + t2-count)

","['brute force', 'implementation', 'strings']"
2073,"Chaneka has a hobby of playing with animal toys. Every toy has a different fun value, a real number. Chaneka has four boxes to store the toys with specification:   The first box stores toys with fun values in range of $$$(-\infty,-1]$$$.  The second box stores toys with fun values in range of $$$(-1, 0)$$$.  The third box stores toys with fun values in range of $$$(0, 1)$$$.  The fourth box stores toys with fun value in range of $$$[1, \infty)$$$. Chaneka has $$$A$$$, $$$B$$$, $$$C$$$, $$$D$$$ toys in the first, second, third, and fourth box, respectively. One day she decides that she only wants one toy, a super toy. So she begins to create this super toy by sewing all the toys she has.While the number of toys Chaneka has is more than 1, she takes two different toys randomly and then sews them together, creating a new toy. The fun value of this new toy is equal to the multiplication of fun values of the sewn toys. She then puts this new toy in the appropriate box. She repeats this process until she only has one toy. This last toy is the super toy, and the box that stores this toy is the special box.As an observer, you only know the number of toys in each box initially but do not know their fun values. You also don't see the sequence of Chaneka's sewing. Determine which boxes can be the special box after Chaneka found her super toy. NoteFor the first case, here is a scenario where the first box is the special box:   The first box had toys with fun values $$$\{-3\}$$$.  The second box had toys with fun values $$$\{ -0.5, -0.5 \}$$$  The fourth box had toys with fun values $$$\{ 3 \}$$$ The sewing sequence:   Chaneka sews the toy with fun $$$-0.5$$$ and $$$-0.5$$$ to a toy with fun $$$0.25$$$ and then put it in the third box.  Chaneka sews the toy with fun $$$-3$$$ and $$$0.25$$$ to a toy with fun $$$-0.75$$$ and then put it in the second box.  Chaneka sews the toy with fun $$$-0.75$$$ and $$$3$$$ to a toy with fun $$$-1.25$$$ and then put it in the first box, which then became the special box. Here is a scenario where the second box ends up being the special box:   The first box had toys with fun values $$$\{-3\}$$$  The second box had toys with fun values $$$\{ -0.33, -0.25 \}$$$.  The fourth box had toys with fun values $$$\{ 3 \}$$$. The sewing sequence:   Chaneka sews the toy with fun $$$-3$$$ and $$$-0.33$$$ to a toy with fun $$$0.99$$$ and then put it in the third box.  Chaneka sews the toy with fun $$$0.99$$$ and $$$3$$$ to a toy with fun $$$2.97$$$ and then put in it the fourth box.  Chaneka sews the toy with fun $$$2.97$$$ and $$$-0.25$$$ to a toy with fun $$$-0.7425$$$ and then put it in the second box, which then became the special box.  There is only one toy for the second case, so Chaneka does not have to sew anything because that toy, by definition, is the super toy. def hi(a):
	if sum(a)==1:
		p = a.index(1)
		b = [""Tidak""]*4
		b[p] = ""Ya""
		return b
	p = (-1)**(a[0]+a[1])
	b = [-2]*4
	if p<0:
		b[2],b[3] = ""Tidak"",""Tidak""
		if a[0]==0 and a[3]==0:
			b[0],b[1] = ""Tidak"",""Ya""
			return b
		if a[1]==0 and a[2]==0:
			b[1],b[0] = ""Tidak"",""Ya""
			return b
		else:
			b[0],b[1] = ""Ya"",""Ya""
			return b
	if p>0:
		b[0],b[1] = ""Tidak"",""Tidak""
		if a[0]==0 and a[3]==0:
			b[3],b[2] = ""Tidak"",""Ya""
			return b
		if a[1]==0 and a[2]==0:
			b[2],b[3] = ""Tidak"",""Ya""
			return b
		else:
			b[2],b[3] = ""Ya"",""Ya""
			return b
	
		
t = int(input())
b = []
for i in range(t):
	a = list(map(int,input().split()))
	b.append(hi(a))
for i in range(len(b)):
	b[i] = "" "".join(b[i])
	print(b[i])
",['constructive algorithms']
4106,"This is an interactive problem.Igor wants to find the key to Olha's heart. The problem is, that it's at the root of a binary tree.There is a perfect binary tree of height $$$h$$$ consisting of $$$n = 2^{h} - 1$$$ nodes. The nodes have been assigned distinct labels from $$$1$$$ to $$$n$$$. However, Igor only knows $$$h$$$ and does not know which label corresponds to which node. To find key to Olha's heart he needs to find the label assigned to the root by making queries of the following type at most $$$n+420$$$ times:   Select three distinct labels $$$u$$$, $$$v$$$ and $$$w$$$ ($$$1 \leq u,v,w \leq n$$$).  In response, Olha (the grader) will tell him the label of the lowest common ancestor of nodes labelled $$$u$$$ and $$$v$$$, if the tree was rooted at the node labelled $$$w$$$ instead. Help Igor to find the root!Note: the grader is not adaptive: the labels are fixed before any queries are made. NoteThe labels corresponding to the tree in the example are [$$$4$$$,$$$7$$$,$$$2$$$,$$$6$$$,$$$1$$$,$$$5$$$,$$$3$$$], meaning the root is labelled $$$4$$$, and for $$$1 &lt; i \le n$$$, the parent of $$$p_i$$$ is $$$p_{ \lfloor{\frac{i}{2}}\rfloor }$$$. import sys,random
def main():
    h = int(input());power = [1];askarray = [];askarrayind = []
    for i in range(h+1):power.append(power[-1] * 2)    
    for j in range(0, power[h]):askarrayind.append([0, j])
    n = power[h] - 1;askcnt = 420
    for i in range(askcnt):
        a = random.randint(1, n);b = random.randint(1, n)
        while (b == a):b = random.randint(1, n)
        c = random.randint(1, n)
        while (c == a or c == b):c = random.randint(1, n)
        print(""?"", a, b, c);sys.stdout.flush();answer = int(input());askarrayind[answer][0] += 1
    result = sorted(askarrayind, key=lambda thing: -thing[0]);a = result[0][1];b = result[1][1];chkff = False;batch_size = 200
    for j in range((n+1)//batch_size + 2):
        for i in range(1 + batch_size * j, min(1 + batch_size * (j+1), n+1)):
            if i == a or i == b:continue
            print(""?"", a, b, i)
        sys.stdout.flush()
        for i in range(1 + batch_size * j, min(1 + batch_size * (j+1), n+1)):
            if i == a or i == b:continue
            if int(input()) == i:print(""!"", i);chkff = True;break
        if chkff:break
main()","['interactive', 'probabilities', 'trees']"
3035,"You are given an integer $$$n$$$. In $$$1$$$ move, you can do one of the following actions:  erase any digit of the number (it's acceptable that the number before the operation has exactly one digit and after the operation, it is ""empty"");  add one digit to the right. The actions may be performed in any order any number of times.Note that if, after deleting some digit from a number, it will contain leading zeroes, they will not be deleted. E.g. if you delete from the number $$$301$$$ the digit $$$3$$$, the result is the number $$$01$$$ (not $$$1$$$).You need to perform the minimum number of actions to make the number any power of $$$2$$$ (i.e. there's an integer $$$k$$$ ($$$k \ge 0$$$) such that the resulting number is equal to $$$2^k$$$). The resulting number must not have leading zeroes.E.g. consider $$$n=1052$$$. The answer is equal to $$$2$$$. First, let's add to the right one digit $$$4$$$ (the result will be $$$10524$$$). Then let's erase the digit $$$5$$$, so the result will be $$$1024$$$ which is a power of $$$2$$$.E.g. consider $$$n=8888$$$. The answer is equal to $$$3$$$. Let's erase any of the digits $$$8$$$ three times. The result will be $$$8$$$ which is a power of $$$2$$$. NoteThe answer for the first test case was considered above.The answer for the second test case was considered above.In the third test case, it's enough to add to the right the digit $$$4$$$ — the number $$$6$$$ will turn into $$$64$$$.In the fourth test case, let's add to the right the digit $$$8$$$ and then erase $$$7$$$ and $$$5$$$ — the taken number will turn into $$$8$$$.The numbers of the fifth and the sixth test cases are already powers of two so there's no need to make any move.In the seventh test case, you can delete first of all the digit $$$3$$$ (the result is $$$01$$$) and then the digit $$$0$$$ (the result is $$$1$$$). from heapq import heapify, heappush, heappop
from collections import Counter, defaultdict, deque
from queue import PriorityQueue
from itertools import combinations, product, permutations
from bisect import bisect_left, bisect_right
from functools import lru_cache
from sys import stdin, stdout # for input /output
import copy
import math
import array as arr
from heapq import heappop, heappush
import time
# import sys
# sys.setrecursionlimit(100000)
####################
# stdin = open(""testcase.txt"")
# def input():
	# 	return stdin.readline().strip()

#####################################################################

class FastIO:

	@classmethod
	def input(cls):
		from sys import stdin
		x = stdin.buffer.readline().decode().strip()
		return x

	@classmethod
	def integer_list(cls):
		return list(map(int, cls.input().split()))

	@classmethod
	def print(cls, s = """", end = ""\n""):
		from sys import stdout
		stdout.write(str(s) + end)

	@classmethod
	def flush(cls):
		from sys import stdout
		stdout.flush()


####################################################################

class SegmentTree:
	def __init__(self, data, default=0, func=lambda a, b: a + b):
		""""""initialize the segment tree with data""""""
		"""""" initial default value for each node """"""
		"""""" func which you want to apply to range """"""
		self._default = default
		self._func = func
		self._len = len(data)
		self._size = _size = 1 << (self._len - 1).bit_length()
 
		self.data = [default] * (2 * _size)
		self.data[_size:_size + self._len] = data
		for i in reversed(range(_size)):
			self.data[i] = func(self.data[2*i], self.data[2*i + 1])
 
	def __delitem__(self, idx):
		"""""" delete item set item value to its default """"""
		self[idx] = self._default
 
	def __getitem__(self, idx):
		"""""" geting item by inx """"""
		return self.data[idx + self._size]
 
	def __setitem__(self, idx, value):
		"""""" changing seting value to given index""""""
		"""""" apply function to range """"""
		idx += self._size
		self.data[idx] = value
		idx >>= 1
		while idx:
			self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
			idx >>= 1
 
	def __len__(self):
		return self._len
 
	def query(self, start, stop):
		""""""func of data[start, stop)""""""
		start += self._size
		stop += self._size
 
		res_left = res_right = self._default
		while start < stop:
			if start & 1:
				res_left = self._func(res_left, self.data[start])
				start += 1
			if stop & 1:
				stop -= 1
				res_right = self._func(self.data[stop], res_right)
			start >>= 1
			stop >>= 1
 
		return self._func(res_left, res_right)
 
	def __repr__(self):
		return ""SegmentTree({0})"".format(self.data)

#####################################################################
class BinaryIndexTree(object):
	"""""" use one indexing """"""
	def __init__(self, nums):
		n = len(nums)
		self._len = len(nums)
		self.nums = [0 for _ in range(n+1)]
		self.N = [0 for _ in range(n+1)]
		for i, v in enumerate(nums):
			self.__setitem__(i+1, v)

	def _lowbit(self, a):
		return a & -a

	def  __setitem__(self, i, val):
		diff = val - self.nums[i]
		self.nums[i] = val
		while i < len(self.N):
			self.N[i] += diff
			i += self._lowbit(i)

	def __getitem__(self, i):
		# return sum up 0 to i
		ret = 0
		while i > 0:
			ret += self.N[i]
			i -= self._lowbit(i)

		return ret

######################################################################
class DisJointSetsRank():
    def __init__(self,N):
        # Initially, all elements are single element subsets
        self._parents = [node for node in range(N)]
        self._ranks = [1 for _ in range(N)]
    
    def find(self, u):
        while u != self._parents[u]: 
            # path compression technique
            self._parents[u] = self._parents[self._parents[u]]
            u = self._parents[u]
        return u
    
    def connected(self, u, v):
        return self.find(u) == self.find(v)
    
    def union(self, u, v):
        # Union by rank optimization
        root_u, root_v = self.find(u), self.find(v)
        if root_u == root_v:
            return True
        if self._ranks[root_u] > self._ranks[root_v]:
            self._parents[root_v] = root_u
        elif self._ranks[root_v] > self._ranks[root_u]:
            self._parents[root_u] = root_v
        else:
            self._parents[root_u] = root_v
            self._ranks[root_v] += 1
        return False


#######################################################################

def integer_list():
	return list(map(int, input().split()))

def pprint(matrix):
	for i in range(len(matrix)):
		print(*matrix[i])


#####################################################
#test case section 
""""""

1 - 5

9 10 1 2 7
0 1  1 

""""""       
#############################################################
# for manipulating 0 for runing to your system 1 for online 


MOD = 10**9+7

ONLINE_JUDGE = 1

def match_seq(power_2, s):

	i = j = 0
	while i < len(power_2) and j < len(s):
		if power_2[i] == s[j]:
			i += 1
			j += 1
		else:
			j += 1

	deleted_char = len(s) - i
	to_add = len(power_2) - i
	return deleted_char + to_add




def main():
	t = int(input())
	# t = 1
	powers = []
	for i in range(61):
		num = str(2**i)
		powers.append(num)

	# print(powers)
	for _ in range(t):
		n = input()
		lst = []
		k = len(n)
		ans = float('inf')
		for ele in powers:
			ans = min( ans , match_seq(ele, n))

		print(ans)


		

	

	

	


		
		
		
							




###############################################

if ONLINE_JUDGE:
	input = lambda : stdin.buffer.readline().decode().strip()
else:
	stdin = open(""testcase.txt"")
	input = lambda : stdin.readline().strip()
	

main()		
	



","['greedy', 'math', 'strings']"
1197,"The ICM ACPC World Finals is coming! Unfortunately, the organizers of the competition were so busy preparing tasks that totally missed an important technical point — the organization of electricity supplement for all the participants workstations.There are n computers for participants, the i-th of which has power equal to positive integer pi. At the same time there are m sockets available, the j-th of which has power euqal to positive integer sj. It is possible to connect the i-th computer to the j-th socket if and only if their powers are the same: pi = sj. It is allowed to connect no more than one computer to one socket. Thus, if the powers of all computers and sockets are distinct, then no computer can be connected to any of the sockets. In order to fix the situation professor Puch Williams urgently ordered a wagon of adapters — power splitters. Each adapter has one plug and one socket with a voltage divider between them. After plugging an adapter to a socket with power x, the power on the adapter's socket becomes equal to , it means that it is equal to the socket's power divided by two with rounding up, for example  and .Each adapter can be used only once. It is possible to connect several adapters in a chain plugging the first to a socket. For example, if two adapters are plugged one after enother to a socket with power 10, it becomes possible to connect one computer with power 3 to this socket.The organizers should install adapters so that it will be possible to supply with electricity the maximum number of computers c at the same time. If there are several possible connection configurations, they want to find the one that uses the minimum number of adapters u to connect c computers.Help organizers calculate the maximum number of connected computers c and the minimum number of adapters u needed for this.The wagon of adapters contains enough of them to do the task. It is guaranteed that it's possible to connect at least one computer. nan from sys import stdin, stdout
from itertools import repeat
from collections import defaultdict
def main():
    n, m = map(int, stdin.readline().split())
    a = map(int, stdin.readline().split(), repeat(10, n))
    b = map(int, stdin.readline().split(), repeat(10, m))
    da = defaultdict(list)
    da[-1] = []
    for i, x in enumerate(a):
        da[-x].append(i)
    la = defaultdict(lambda: defaultdict(list))
    f = defaultdict(list)
    for i, x in enumerate(b):
        f[-x].append(i)
    for x, l in f.viewitems():
        c = 0
        while x not in da:
            c += 1
            x /= 2
        la[x][c].extend(l)
    ansa = [0] * n
    ansc = [0] * m
    ans = 0
    for x in sorted(da.keys()):
        l = da[x]
        for k in sorted(la[x].viewkeys()):
            lb = la[x][k]
            while lb and l:
                f = lb.pop()
                ansa[l.pop()] = f + 1
                ansc[f] = k
                ans += 1
        if x == -1:
            continue
        y = x / 2
        c = 1
        while y not in da:
            c += 1
            y /= 2
        for k, l in la[x].viewitems():
            la[y][k+c].extend(l)
    print ans, sum(ansc)
    stdout.write(' '.join(map(str, ansc)))
    stdout.write('\n')
    stdout.write(' '.join(map(str, ansa)))
    stdout.write('\n')
main()
","['greedy', 'sortings']"
4301,"You are standing at the point $$$0$$$ on a coordinate line. Your goal is to reach the point $$$n$$$. In one minute, you can move by $$$2$$$ or by $$$3$$$ to the left or to the right (i. e., if your current coordinate is $$$x$$$, it can become $$$x-3$$$, $$$x-2$$$, $$$x+2$$$ or $$$x+3$$$). Note that the new coordinate can become negative.Your task is to find the minimum number of minutes required to get from the point $$$0$$$ to the point $$$n$$$.You have to answer $$$t$$$ independent test cases. nan # Coded By Block_Cipher

import math
import os
import random
import re
import sys
from math import gcd
from math import sqrt
from collections import Counter

for _ in range(int(input())):
	n = int(input())
	tw = n//2
	th = n//3


	if n==1:
		print(2)
	elif n==2 or n==3:
		print(1)
	else:
		if n%3==0:
			print(th)
		else:
			print(th+1)







","['greedy', 'math']"
196,"Slime and his $$$n$$$ friends are at a party. Slime has designed a game for his friends to play.At the beginning of the game, the $$$i$$$-th player has $$$a_i$$$ biscuits. At each second, Slime will choose a biscuit randomly uniformly among all $$$a_1 + a_2 + \ldots + a_n$$$ biscuits, and the owner of this biscuit will give it to a random uniform player among $$$n-1$$$ players except himself. The game stops when one person will have all the biscuits.As the host of the party, Slime wants to know the expected value of the time that the game will last, to hold the next activity on time.For convenience, as the answer can be represented as a rational number $$$\frac{p}{q}$$$ for coprime $$$p$$$ and $$$q$$$, you need to find the value of $$$(p \cdot q^{-1})\mod 998\,244\,353$$$. You can prove that $$$q\mod 998\,244\,353 \neq 0$$$. NoteFor the first example, in the first second, the probability that player $$$1$$$ will give the player $$$2$$$ a biscuit is $$$\frac{1}{2}$$$, and the probability that player $$$2$$$ will give the player $$$1$$$ a biscuit is $$$\frac{1}{2}$$$. But anyway, the game will stop after exactly $$$1$$$ second because only one player will occupy all biscuits after $$$1$$$ second, so the answer is $$$1$$$. import sys
import __pypy__
range = xrange
input = raw_input

MOD = 998244353
modmult = __pypy__.intop.int_mulmod
mu = lambda a,b: modmult(a, b, MOD)

big = 3*10**5 + 10
modinv = [1]*big
for i in range(2,big):
    modinv[i] = mu(-(MOD//i), modinv[MOD%i])

n = int(input())
A = [int(x) for x in input().split()]
m = sum(A)

AA = []
BB = []
CC = []
DD = []
for i in range(m):
    a = -mu(i, modinv[m])
    b = 1 - mu(mu(m - i, modinv[m]), mu(n - 2, modinv[n - 1]))
    c = -mu(mu(m - i, modinv[m]), mu(1    , modinv[n - 1]))

    AA.append(a)
    BB.append(b)
    CC.append(c)
    DD.append(1)

def solve(m,A,B,C,D):
    cur = [A[m - 1], B[m - 1], D[m - 1]]
    for i in reversed(range(m - 1)):
        k = mu(-cur[1], pow(C[i], MOD-2, MOD))
        cur = [mu(k, (A[i] if i else 0)), cur[0] + mu(k, B[i]), cur[2] + mu(k, D[i])]
        cur = [c % MOD for c in cur]

    X = [mu(cur[2], pow(cur[1], MOD - 2, MOD))]
    for i in range(m - 1):
        X.append(mu(D[i] - (mu(A[i], X[i - 1]) if i else 0) - mu(B[i], X[i]), pow(C[i], MOD - 2, MOD)))
    
    #ans = [(A[i] * X[i - 1] if i else 0) + B[i] * X[i] + (C[i] * X[i + 1] if i + 1 < m else 0) for i in range(m)]
    #assert ans == D
    return X

F = solve(m, AA, BB, CC, DD)
F.append(0)
num = sum(F[a] for a in A) % MOD - mu(n - 1, F[0])
den = n

print mu(num, pow(den, MOD - 2, MOD))
","['math', 'probabilities']"
1746,"You are given $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$. For any real number $$$t$$$, consider the complete weighted graph on $$$n$$$ vertices $$$K_n(t)$$$ with weight of the edge between vertices $$$i$$$ and $$$j$$$ equal to $$$w_{ij}(t) = a_i \cdot a_j + t \cdot (a_i + a_j)$$$. Let $$$f(t)$$$ be the cost of the minimum spanning tree of $$$K_n(t)$$$. Determine whether $$$f(t)$$$ is bounded above and, if so, output the maximum value it attains. nan h=10**9
for _ in range(int(input())):
	n=int(input());a=list(map(int,input().split()));a.sort();
	def f(t):
		c=a[0]*a[-1]+t*(a[0]+a[-1])
		for i in range(1,n-1):c+=min(a[0]*a[i]+t*(a[0]+a[i]),a[-1]*a[i]+t*(a[-1]+a[i]))
		return c
	if f(h)>0 or f(-h)>0:print(""INF"");
	else:
		l,r=-h,h
		while r-l>3:
			p,q=(l*2+r)//3,(l+2*r)//3;
			if f(p)>f(q):r=q;
			else:l=p;
		z=-h*h
		for i in range(l,r):z=max(z,f(i))
		print(z)","['binary search', 'constructive algorithms', 'graphs', 'greedy', 'math', 'sortings']"
3914,"This is an easy version of the problem. The only difference between an easy and a hard version is in the number of queries.Polycarp grew a tree from $$$n$$$ vertices. We remind you that a tree of $$$n$$$ vertices is an undirected connected graph of $$$n$$$ vertices and $$$n-1$$$ edges that does not contain cycles.He calls a set of vertices passable if there is such a path in the tree that passes through each vertex of this set without passing through any edge twice. The path can visit other vertices (not from this set).In other words, a set of vertices is called passable if there is a simple path that passes through all the vertices of this set (and possibly some other).For example, for a tree below sets $$$\{3, 2, 5\}$$$, $$$\{1, 5, 4\}$$$, $$$\{1, 4\}$$$ are passable, and $$$\{1, 3, 5\}$$$, $$$\{1, 2, 3, 4, 5\}$$$ are not.  Polycarp asks you to answer $$$q$$$ queries. Each query is a set of vertices. For each query, you need to determine whether the corresponding set of vertices is passable. nan import sys
from typing import List

input = sys.stdin.readline

class LowestCommonAncestor:
    def __init__(self, n, E):
        assert n >= 1 and len(E) == n - 1
        self.n = n
        self.adj = [[] for _ in range(self.n)]

        for e in E:
            u, v = e
            self.adj[u].append(v)
            self.adj[v].append(u)

        self.sz = 1
        while 1 << self.sz < n:
            self.sz += 1

        self.root = None
        self.depth = [-1 for _ in range(n)]
        self.up = [[-1] * self.sz for _ in range(n)]

    def dfs(self, root):
        stack = [(root, root, 0)]
        while len(stack):
            u, prev, d = stack.pop()
            self.depth[u] = d
            self.up[u][0] = prev
            for v in self.adj[u]:
                if v == prev:
                    continue
                stack.append((v, u, d + 1))

        for j in range(1, self.sz):
            for i in range(1, self.n):
                if self.up[i][j - 1] == -1:
                    continue
                self.up[i][j] = self.up[self.up[i][j - 1]][j - 1]

    def lca(self, u, v):
        if self.depth[u] > self.depth[v]:
            u, v = v, u
        diff = self.depth[v] - self.depth[u]
        for i in reversed(range(self.sz)):
            if diff >> i & 1:
                v = self.up[v][i]

        if u == v:
            return u
        for i in reversed(range(self.sz)):
            pu, pv = self.up[u][i], self.up[v][i]
            if pu != pv:
                u, v = pu, pv
        return self.up[u][0]



def query(LCA, p):
    depth = LCA.depth
    lca = LCA.lca
    p.sort(key=lambda idx: -depth[idx])
    left_chain_deepest = p[0]

    right_chain_deepest = -1
    turning_point = 0
    for x in p:
        if lca(x, left_chain_deepest) != x:
            if right_chain_deepest == -1:
                right_chain_deepest = x
                turning_point = lca(left_chain_deepest, right_chain_deepest)
            else:
                if lca(x, right_chain_deepest) != x:
                    # print(""Third Chain!"")
                    return False

    if right_chain_deepest == -1:
        return True

    if depth[turning_point] > depth[p[-1]]:
        # print(""Turning point(%d), deeper than root(%d)"" % (turning_point + 1, p[-1] + 1))
        return False
    return True

# initialize
n = int(input())
E = []
for i in range(n - 1):
    u, v = map(lambda s: int(s)-1, input().split())
    E.append((u, v))
LCA = LowestCommonAncestor(n, E)
LCA.dfs(1-1)
q = int(input())
for qq in range(q):
    k = int(input())
    *p, = map(lambda s: int(s)-1, input().split())
    print(""YES"" if query(LCA, p) else ""NO"")



# n = 5
# E = [(1, 2), (2, 3), (2, 4), (4, 5)]
# *E2, = map(lambda pair: (pair[0]-1, pair[1]-1), E)
#
# LCA = LowestCommonAncestor(n, E2)
# root = 1
# LCA.dfs(root - 1)
# print(LCA.depth)
#
# q = 5
# arr_k
# for qq in range(q):
#     k = arr_k[qq]
","['dfs and similar', 'trees']"
999,"Can the greatest common divisor and bitwise operations have anything in common? It is time to answer this question.Suppose you are given a positive integer $$$a$$$. You want to choose some integer $$$b$$$ from $$$1$$$ to $$$a - 1$$$ inclusive in such a way that the greatest common divisor (GCD) of integers $$$a \oplus b$$$ and $$$a \&gt; \&amp; \&gt; b$$$ is as large as possible. In other words, you'd like to compute the following function:$$$$$$f(a) = \max_{0 &lt; b &lt; a}{gcd(a \oplus b, a \&gt; \&amp; \&gt; b)}.$$$$$$Here $$$\oplus$$$ denotes the bitwise XOR operation, and $$$\&amp;$$$ denotes the bitwise AND operation.The greatest common divisor of two integers $$$x$$$ and $$$y$$$ is the largest integer $$$g$$$ such that both $$$x$$$ and $$$y$$$ are divided by $$$g$$$ without remainder.You are given $$$q$$$ integers $$$a_1, a_2, \ldots, a_q$$$. For each of these integers compute the largest possible value of the greatest common divisor (when $$$b$$$ is chosen optimally).  NoteFor the first integer the optimal choice is $$$b = 1$$$, then $$$a \oplus b = 3$$$, $$$a \&gt; \&amp; \&gt; b = 0$$$, and the greatest common divisor of $$$3$$$ and $$$0$$$ is $$$3$$$.For the second integer one optimal choice is $$$b = 2$$$, then $$$a \oplus b = 1$$$, $$$a \&gt; \&amp; \&gt; b = 2$$$, and the greatest common divisor of $$$1$$$ and $$$2$$$ is $$$1$$$.For the third integer the optimal choice is $$$b = 2$$$, then $$$a \oplus b = 7$$$, $$$a \&gt; \&amp; \&gt; b = 0$$$, and the greatest common divisor of $$$7$$$ and $$$0$$$ is $$$7$$$. # -*- coding: utf-8 -*-
""""""
Created on Sun Oct  4 06:35:25 2020

@author: Dark Soul
""""""
import math
q=int(input(''))
for _ in range(q):
    n=int(input(''))
    ans=-1
    if n&(n+1)==0:
        for i in range(2,int(math.sqrt(n))+1):
            if n%i==0:
                ans=n//i
                break
        if ans==-1:
            ans=1
        print(ans)
        continue
    x=bin(n)
    x=x[2:]
    
    print((2**(len(x)))-1)","['constructive algorithms', 'math', 'number theory']"
1168,"You are given an array consisting of $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$, and a positive integer $$$m$$$. It is guaranteed that $$$m$$$ is a divisor of $$$n$$$.In a single move, you can choose any position $$$i$$$ between $$$1$$$ and $$$n$$$ and increase $$$a_i$$$ by $$$1$$$.Let's calculate $$$c_r$$$ ($$$0 \le r \le m-1)$$$ — the number of elements having remainder $$$r$$$ when divided by $$$m$$$. In other words, for each remainder, let's find the number of corresponding elements in $$$a$$$ with that remainder.Your task is to change the array in such a way that $$$c_0 = c_1 = \dots = c_{m-1} = \frac{n}{m}$$$.Find the minimum number of moves to satisfy the above requirement. nan n,m=map(int,input().split())
d=n//m
a=list(map(int,input().split()))
b=[0]*m
for i in range(n):b[a[i]%m]+=1
x=[[]for _ in range(m)]
xx=[]
ans=0
for i in range(2*m-1,-1,-1):
  if b[i%m]<=d:
    xx+=[i%m]*(d-b[i%m])
    b[i%m]=d
  else:
    y=b[i%m]-d
    for _ in range(min(y,len(xx))):
      b[i%m]-=1
      v=xx.pop()
      x[i%m].append((v-i)%m)
      ans+=(v-i)%m
for i in range(n):
  if x[a[i]%m]:
    a[i]+=x[a[i]%m].pop()
print(ans)
print(*a)","['data structures', 'greedy', 'implementation']"
1833,"There are $$$n$$$ consecutive seat places in a railway carriage. Each place is either empty or occupied by a passenger.The university team for the Olympiad consists of $$$a$$$ student-programmers and $$$b$$$ student-athletes. Determine the largest number of students from all $$$a+b$$$ students, which you can put in the railway carriage so that:  no student-programmer is sitting next to the student-programmer;  and no student-athlete is sitting next to the student-athlete. In the other words, there should not be two consecutive (adjacent) places where two student-athletes or two student-programmers are sitting.Consider that initially occupied seat places are occupied by jury members (who obviously are not students at all). NoteIn the first example you can put all student, for example, in the following way: *.AB*In the second example you can put four students, for example, in the following way: *BAB*BIn the third example you can put seven students, for example, in the following way: B*ABAB**A*BThe letter A means a student-programmer, and the letter B — student-athlete. mod = 1000000007
ii = lambda : int(input())
si = lambda : input()
dgl = lambda : list(map(int, input()))
f = lambda : map(int, input().split())
il = lambda : list(map(int, input().split()))
ls = lambda : list(input())
from itertools import *
n,a,b=f()
s=si()
l=[]
st=0
for i,j in groupby(s):
    if i=='.':
        l.append(len(list(j)))
for i in l:
    a,b=max(a,b),min(a,b)
    if a>0 or b>0:
        if i&1:
            st+=min(a,(i+1)//2)
            a=max(0,a-(i+1)//2)
            st+=min(b,i//2)
            b=max(0,b-i//2)
        else:
            st+=min(a,i//2)
            a=max(0,a-i//2)
            st+=min(b,i//2)
            b=max(0,b-i//2)
print(st)","['constructive algorithms', 'greedy', 'implementation']"
1255,"Andrewid the Android is a galaxy-famous detective. He is now investigating the case of vandalism at the exhibition of contemporary art.The main exhibit is a construction of n matryoshka dolls that can be nested one into another. The matryoshka dolls are numbered from 1 to n. A matryoshka with a smaller number can be nested in a matryoshka with a higher number, two matryoshkas can not be directly nested in the same doll, but there may be chain nestings, for example, 1 → 2 → 4 → 5. In one second, you can perform one of the two following operations:  Having a matryoshka a that isn't nested in any other matryoshka and a matryoshka b, such that b doesn't contain any other matryoshka and is not nested in any other matryoshka, you may put a in b;  Having a matryoshka a directly contained in matryoshka b, such that b is not nested in any other matryoshka, you may get a out of b. According to the modern aesthetic norms the matryoshka dolls on display were assembled in a specific configuration, i.e. as several separate chains of nested matryoshkas, but the criminal, following the mysterious plan, took out all the dolls and assembled them into a single large chain (1 → 2 → ... → n). In order to continue the investigation Andrewid needs to know in what minimum time it is possible to perform this action. NoteIn the first sample test there are two chains: 1 → 2 and 3. In one second you can nest the first chain into the second one and get 1 → 2 → 3.In the second sample test you need to disassemble all the three chains into individual matryoshkas in 2 + 1 + 1 = 4 seconds and then assemble one big chain in 6 seconds. n,m=(int(x) for x in input().split())
ans=2*n-m-1
for i in range(m):
    a=[int(x) for x in input().split()]
    for j in range(1,a[0]):
        if a[j+1]==j+1 and a[j]==j:ans-=2
        else:break
print(ans)",['implementation']
1617,"You are given n positive integers a1, a2, ..., an.For every ai you need to find a positive integer ki such that the decimal notation of 2ki contains the decimal notation of ai as a substring among its last min(100, length(2ki)) digits. Here length(m) is the length of the decimal notation of m.Note that you don't have to minimize ki. The decimal notations in this problem do not contain leading zeros. nan  #Power substring 913G
def dlog(x, n):
  bigMod = 5 ** n
  ans = [None, 0, 1, 3, 2][x % 5]
  val = 2 ** ans % bigMod
  mod, phi = 5, 4
  pval = 2 ** phi % bigMod
  for i in range(2, n + 1):
    nextMod = mod * 5
    while val % nextMod != x % nextMod:
      val = val * pval % bigMod
      ans += phi
    phi *= 5
    pval = (pval * pval % bigMod * pval % bigMod *
              pval % bigMod *
              pval % bigMod)
    mod = nextMod
  return ans

def main():
  inp = input()
  n = len(inp)
  a = int(inp)
  for m in range(n + 1):
    l = a * 10 ** m
    x, mod = l, 2 ** (n + m)
    if x % mod != 0:
      x += mod - x % mod
    if x % 5 == 0:
      x += mod
    if x < l + 10 ** m:
      assert x % mod == 0 and x % 5 != 0
      x = x // mod
      mod = 5 ** (n + m)
      print(n + m + dlog(x % mod, n + m))
      return
  assert False

if __name__ == '__main__':
  cnt = int(input())
  for i in range(cnt):
    main()","['math', 'number theory']"
2210,"This is the hard version of the problem. The difference between the versions is that the easy version has no swap operations. You can make hacks only if all versions of the problem are solved.Pikachu is a cute and friendly pokémon living in the wild pikachu herd.But it has become known recently that infamous team R wanted to steal all these pokémon! Pokémon trainer Andrew decided to help Pikachu to build a pokémon army to resist.First, Andrew counted all the pokémon — there were exactly $$$n$$$ pikachu. The strength of the $$$i$$$-th pokémon is equal to $$$a_i$$$, and all these numbers are distinct.As an army, Andrew can choose any non-empty subsequence of pokemons. In other words, Andrew chooses some array $$$b$$$ from $$$k$$$ indices such that $$$1 \le b_1 &lt; b_2 &lt; \dots &lt; b_k \le n$$$, and his army will consist of pokémons with forces $$$a_{b_1}, a_{b_2}, \dots, a_{b_k}$$$.The strength of the army is equal to the alternating sum of elements of the subsequence; that is, $$$a_{b_1} - a_{b_2} + a_{b_3} - a_{b_4} + \dots$$$.Andrew is experimenting with pokémon order. He performs $$$q$$$ operations. In $$$i$$$-th operation Andrew swaps $$$l_i$$$-th and $$$r_i$$$-th pokémon.Andrew wants to know the maximal stregth of the army he can achieve with the initial pokémon placement. He also needs to know the maximal strength after each operation.Help Andrew and the pokémon, or team R will realize their tricky plan! NoteLet's look at the third test case:Initially we can build an army in such way: [1 2 5 4 3 6 7], its strength will be $$$5-3+7=9$$$.After first operation we can build an army in such way: [2 1 5 4 3 6 7], its strength will be $$$2-1+5-3+7=10$$$.After second operation we can build an army in such way: [2 1 5 4 3 7 6], its strength will be $$$2-1+5-3+7=10$$$.After third operation we can build an army in such way: [2 1 4 5 3 7 6], its strength will be $$$2-1+5-3+7=10$$$.After forth operation we can build an army in such way: [1 2 4 5 3 7 6], its strength will be $$$5-3+7=9$$$.After all operations we can build an army in such way: [1 4 2 5 3 7 6], its strength will be $$$4-2+5-3+7=11$$$. from sys import stdin, stdout
input = stdin.readline

c = 0
a = []
b = []

def f(i):
	if a[i] == 0:
		return 0
	if a[i - 1] < a[i] > a[i + 1]:
		return 1
	if a[i - 1] > a[i] < a[i + 1]:
		return -1
	return 0

def relax(i):
	global c
	c += (f(i) - b[i]) * a[i]
	b[i] = f(i)
	
def relax1(i):
	global c
	c -= b[i] * a[i]
	b[i] = 0
	#print(a[i], a[i - 1] < i)
for _ in range(int(input())):
	c = 0
	n, q = map(int, input().split())
	*a, = map(int, input().split())
	a = [0] + a + [0]
	b = [0] * (n + 2)
	for i in range(1, n + 1):
		relax(i)
	print(c)
	for i in range(q):
		l, r = map(int, input().split())
		relax1(l)
		relax1(l - 1)
		relax1(l + 1)
		relax1(r)
		relax1(r - 1)
		relax1(r + 1)
		a[l], a[r] = a[r], a[l]
		relax(l)
		relax(l - 1)
		relax(l + 1)
		relax(r)
		relax(r - 1)
		relax(r + 1)
		print(c)
	","['data structures', 'divide and conquer', 'dp', 'greedy', 'implementation']"
68,"Madoka is going to enroll in ""TSUNS PTU"". But she stumbled upon a difficult task during the entrance computer science exam:  A number is called good if it is a multiple of $$$d$$$.  A number is called beatiful if it is good and it cannot be represented as a product of two good numbers. Notice that a beautiful number must be good.Given a good number $$$x$$$, determine whether it can be represented in at least two different ways as a product of several (possibly, one) beautiful numbers. Two ways are different if the sets of numbers used are different.Solve this problem for Madoka and help her to enroll in the best school in Russia! NoteIn the first example, $$$6$$$ can be represented as $$$6$$$, $$$1 \cdot 6$$$, $$$2 \cdot 3$$$. But $$$3$$$ and $$$1$$$ are not a good numbers because they are not divisible by $$$2$$$, so there is only one way.In the second example, $$$12$$$ can be represented as $$$6 \cdot 2$$$, $$$12$$$, $$$3 \cdot 4$$$, or $$$3 \cdot 2 \cdot 2$$$. The first option is suitable. The second is— no, because $$$12$$$ is not beautiful number ($$$12 = 6 \cdot 2$$$). The third and fourth are also not suitable, because $$$3$$$ is not good number.In the third example, $$$36$$$ can be represented as $$$18 \cdot 2$$$ and $$$6 \cdot 6$$$. Therefore it can be decomposed in at least two ways. t = int(input())

def isPrime(x):
  i = 2
  while (i*i <= x):
    if (x % i == 0):
      return False
    i += 1
  return True

def solve(x, d):
  cnt = 0
  # print(x,d)
  while (x % d == 0):
    cnt += 1
    x //= d
  
  if (cnt <= 1):
    print(""NO"")
    return

  d_is_prime = isPrime(d)
  # print(""d is prime"", d_is_prime)
  x_is_prime = isPrime(x)
  # print(""x is prime"", x_is_prime)


  if (not x_is_prime):
    print(""YES"")
    return
  # x is prime and cnt >= 2
  if (d_is_prime):
    print(""NO"")
    return
  # x is prime and d is not prime cnt >= 2
  if (cnt > 3):
    print(""YES"")
    return
  # x is prime and d is not prime 2 >= cnt >= 3
  i = 2
  c = 0
  while (i*i <= d):
    if (d % i == 0):
      if (i*x != d or (d//i)*x != d):
        c += 1
    i += 1
  # print(""hard"", x, d, cnt, c)
  if (c > 0 and cnt == 3):
    print(""YES"")
  else:
    print(""NO"")

for i in range(t):
  x, d = [int(i) for i in input().split("" "")]
  solve(x, d)

# solve(6, 2) # NO
# print(""-------------------------------"")
# solve(12, 2) # NO
# print(""-------------------------------"")
# solve(36, 2) # YES
# print(""-------------------------------"")
# solve(8, 2) # NO
# print(""-------------------------------"")
# solve(1000, 10) # YES
# print(""-------------------------------"")
# solve(2376, 6) # YES
# print(""-------------------------------"")
# solve(128, 4) # NO
# print(""-------------------------------"")
# solve(16384, 4) # YES
# print(""-------------------------------"")
# solve(28629151, 31) # NO
# print(""-------------------------------"")
# solve(19683, 9) # YES
# print(""-------------------------------"")
# solve(130321, 361) # NO
# print(""-------------------------------"")
 
","['constructive algorithms', 'dp', 'math', 'number theory']"
4153,"You are given a huge decimal number consisting of $$$n$$$ digits. It is guaranteed that this number has no leading zeros. Each digit of this number is either 0 or 1.You may perform several (possibly zero) operations with this number. During each operation you are allowed to change any digit of your number; you may change 0 to 1 or 1 to 0. It is possible that after some operation you can obtain a number with leading zeroes, but it does not matter for this problem.You are also given two integers $$$0 \le y &lt; x &lt; n$$$. Your task is to calculate the minimum number of operations you should perform to obtain the number that has remainder $$$10^y$$$ modulo $$$10^x$$$. In other words, the obtained number should have remainder $$$10^y$$$ when divided by $$$10^x$$$. NoteIn the first example the number will be $$$11010100100$$$ after performing one operation. It has remainder $$$100$$$ modulo $$$100000$$$.In the second example the number will be $$$11010100010$$$ after performing three operations. It has remainder $$$10$$$ modulo $$$100000$$$. n, x, y= map(int, input().split())
a=input()
c=0
for i in range(n-1, n-x-1, -1):
    if a[i]=='1':
        c+=1
if a[n-y-1]=='0':
    c+=1
else:
    c-=1
print(c)","['implementation', 'math']"
568,"Kevin Sun wants to move his precious collection of n cowbells from Naperthrill to Exeter, where there is actually grass instead of corn. Before moving, he must pack his cowbells into k boxes of a fixed size. In order to keep his collection safe during transportation, he won't place more than two cowbells into a single box. Since Kevin wishes to minimize expenses, he is curious about the smallest size box he can use to pack his entire collection. Kevin is a meticulous cowbell collector and knows that the size of his i-th (1 ≤ i ≤ n) cowbell is an integer si. In fact, he keeps his cowbells sorted by size, so si - 1 ≤ si for any i &gt; 1. Also an expert packer, Kevin can fit one or two cowbells into a box of size s if and only if the sum of their sizes does not exceed s. Given this information, help Kevin determine the smallest s for which it is possible to put all of his cowbells into k boxes of size s. NoteIn the first sample, Kevin must pack his two cowbells into the same box. In the second sample, Kevin can pack together the following sets of cowbells: {2, 3}, {5} and {9}.In the third sample, the optimal solution is {3, 5} and {7}. n,k=map(int,raw_input().split())
ar=map(int,raw_input().split())
sz=0
st=0
en=n-1
while n!=0:
	if 2*k>n:
		sz=max(sz,ar[en])
		en-=1
		k-=1
		n-=1
	else:
		if(st!=en):
			sz=max(sz,ar[st]+ar[en])
			st+=1
			en-=1
			n-=2
		else:
			sz=max(sz,ar[st])
			n-=1
		k-=1
print sz","['binary search', 'greedy']"
3655,"Of course you have heard the famous task about Hanoi Towers, but did you know that there is a special factory producing the rings for this wonderful game? Once upon a time, the ruler of the ancient Egypt ordered the workers of Hanoi Factory to create as high tower as possible. They were not ready to serve such a strange order so they had to create this new tower using already produced rings.There are n rings in factory's stock. The i-th ring has inner radius ai, outer radius bi and height hi. The goal is to select some subset of rings and arrange them such that the following conditions are satisfied:  Outer radiuses form a non-increasing sequence, i.e. one can put the j-th ring on the i-th ring only if bj ≤ bi.  Rings should not fall one into the the other. That means one can place ring j on the ring i only if bj &gt; ai.  The total height of all rings used should be maximum possible.  NoteIn the first sample, the optimal solution is to take all the rings and put them on each other in order 3, 2, 1.In the second sample, one can put the ring 3 on the ring 4 and get the tower of height 3, or put the ring 1 on the ring 2 and get the tower of height 4. from bisect import *
from sys import *
p = list(map(int, stdin.read().split()))
t = [(p[i + 1], p[i], p[i + 2]) for i in range(1, len(p), 3)]
t.sort(reverse=True)
s = [(0, 0), (1e9, 1e16)]
for b, a, h in t:
    i = bisect(s, (b,))
    h += s[i - 1][1]
    j = bisect(s, (a,))
    while s[j][1] <= h: s.pop(j)
    s.insert(j, (a, h))
print(s[-2][1])
","['brute force', 'data structures', 'dp', 'greedy', 'sortings']"
96,"The All-Berland Team Programming Contest will take place very soon. This year, teams of four are allowed to participate.There are $$$a$$$ programmers and $$$b$$$ mathematicians at Berland State University. How many maximum teams can be made if:  each team must consist of exactly $$$4$$$ students,  teams of $$$4$$$ mathematicians or $$$4$$$ programmers are unlikely to perform well, so the decision was made not to compose such teams. Thus, each team must have at least one programmer and at least one mathematician.Print the required maximum number of teams. Each person can be a member of no more than one team. NoteIn the first test case of the example, two teams can be composed. One way to compose two teams is to compose two teams of $$$2$$$ programmers and $$$2$$$ mathematicians.In the second test case of the example, only one team can be composed: $$$3$$$ programmers and $$$1$$$ mathematician in the team. from sys import stdin, stdout
t = int(stdin.readline())
for i in range(t):
    a, b = map(int, stdin.readline().strip().split())
    teams=0
    if a==b:
        teams += (a+b)//4
    else:
        max_one = max(a, b)
        min_one = min(a, b)
        m_p_pairs = min_one 
        max_one-=min_one
        min_one = 0
        m_m_pairs = max_one//2
        if m_m_pairs>=m_p_pairs:
            teams+=m_p_pairs 
        else:
            teams+=m_m_pairs
            m_p_pairs-=m_m_pairs
            teams+=m_p_pairs//2
    stdout.write(f""{teams}\n"")
        ","['binary search', 'constructive algorithms', 'math']"
1351,"On February 14 Denis decided to give Valentine to Nastya and did not come up with anything better than to draw a huge red heart on the door of the length $$$k$$$ ($$$k \ge 3$$$). Nastya was very confused by this present, so she decided to break the door, throwing it on the mountains.Mountains are described by a sequence of heights $$$a_1, a_2, \dots, a_n$$$ in order from left to right ($$$k \le n$$$). It is guaranteed that neighboring heights are not equal to each other (that is, $$$a_i \ne a_{i+1}$$$ for all $$$i$$$ from $$$1$$$ to $$$n-1$$$).Peaks of mountains on the segment $$$[l,r]$$$ (from $$$l$$$ to $$$r$$$) are called indexes $$$i$$$ such that $$$l &lt; i &lt; r$$$, $$$a_{i - 1} &lt; a_i$$$ and $$$a_i &gt; a_{i + 1}$$$. It is worth noting that the boundary indexes $$$l$$$ and $$$r$$$ for the segment are not peaks. For example, if $$$n=8$$$ and $$$a=[3,1,4,1,5,9,2,6]$$$, then the segment $$$[1,8]$$$ has only two peaks (with indexes $$$3$$$ and $$$6$$$), and there are no peaks on the segment $$$[3, 6]$$$.To break the door, Nastya throws it to a segment $$$[l,l+k-1]$$$ of consecutive mountains of length $$$k$$$ ($$$1 \le l \le n-k+1$$$). When the door touches the peaks of the mountains, it breaks into two parts, after that these parts will continue to fall in different halves and also break into pieces when touching the peaks of the mountains, and so on. Formally, the number of parts that the door will break into will be equal to $$$p+1$$$, where $$$p$$$ is the number of peaks on the segment $$$[l,l+k-1]$$$.Nastya wants to break it into as many pieces as possible. Help her choose such a segment of mountains $$$[l, l+k-1]$$$ that the number of peaks on it is maximum. If there are several optimal segments, Nastya wants to find one for which the value $$$l$$$ is minimal.Formally, you need to choose a segment of mountains $$$[l, l+k-1]$$$ that has the maximum number of peaks. Among all such segments, you need to find the segment that has the minimum possible value $$$l$$$. NoteIn the first example, you need to select a segment of mountains from $$$2$$$ to $$$7$$$. In this segment, the indexes $$$3$$$ and $$$6$$$ are peaks, so the answer is $$$3$$$ (only $$$2$$$ peaks, so the door will break into $$$3$$$ parts). It is not difficult to notice that the mountain segments $$$[1, 6]$$$ and $$$[3, 8]$$$ are not suitable since they only have a $$$1$$$ peak (for the first segment, the $$$6$$$ index is not a peak, and for the second segment, the $$$3$$$ index is not a peak).In the second example, you need to select a segment of mountains from $$$2$$$ to $$$4$$$. In this segment, the index $$$3$$$ is a peak, so the answer is $$$2$$$ (only $$$1$$$ peak, so the door will break into $$$2$$$ parts).In the third example, you need to select a segment of mountains from $$$1$$$ to $$$4$$$. In this segment, the index $$$3$$$ is a peak, so the answer is $$$2$$$ (only $$$1$$$ peak, so the door will break into $$$2$$$ parts). You can see that on the segments $$$[2, 5]$$$, $$$[4, 7]$$$ and $$$[5, 8]$$$ the number of peaks is also $$$1$$$, but these segments have a left border greater than the segment $$$[1, 4]$$$, so they are not the correct answer. for _ in range(int(input())):
    n,k = list(map(int,input().split()))
    arr = list(map(int,input().split()))
    isPick = [0]*n
    for i in range(1,n-1):
        if arr[i] > arr[i-1] and arr[i] > arr[i+1]:
            isPick[i] = 1
    dp = [0]*(n-k+1)
    dp[0] = sum(isPick[0:k])-isPick[0]-isPick[k-1]
    add = isPick[k-1]
    for i in range(1,n-k+1):
        dp[i] = dp[i-1] - isPick[i] + add
        add = isPick[i+k-1]

    max = dp[0]
    ind = 0
    for i in range(1,len(dp)):
        if dp[i] > max:
            ind = i
            max = dp[i]
    print(max+1,ind+1)
","['greedy', 'implementation']"
139,"You have an array $$$a$$$ of length $$$n$$$. For every positive integer $$$x$$$ you are going to perform the following operation during the $$$x$$$-th second:  Select some distinct indices $$$i_{1}, i_{2}, \ldots, i_{k}$$$ which are between $$$1$$$ and $$$n$$$ inclusive, and add $$$2^{x-1}$$$ to each corresponding position of $$$a$$$. Formally, $$$a_{i_{j}} := a_{i_{j}} + 2^{x-1}$$$ for $$$j = 1, 2, \ldots, k$$$. Note that you are allowed to not select any indices at all. You have to make $$$a$$$ nondecreasing as fast as possible. Find the smallest number $$$T$$$ such that you can make the array nondecreasing after at most $$$T$$$ seconds.Array $$$a$$$ is nondecreasing if and only if $$$a_{1} \le a_{2} \le \ldots \le a_{n}$$$.You have to answer $$$t$$$ independent test cases. NoteIn the first test case, if you select indices $$$3, 4$$$ at the $$$1$$$-st second and $$$4$$$ at the $$$2$$$-nd second, then $$$a$$$ will become $$$[1, 7, 7, 8]$$$. There are some other possible ways to make $$$a$$$ nondecreasing in $$$2$$$ seconds, but you can't do it faster.In the second test case, $$$a$$$ is already nondecreasing, so answer is $$$0$$$.In the third test case, if you do nothing at first $$$2$$$ seconds and select index $$$2$$$ at the $$$3$$$-rd second, $$$a$$$ will become $$$[0, 0]$$$. #logic#####maintain two pointer that will maintain the maximum difference between
#two values and values that are not follwing the a<=b condition
def powerof2(x):
    i=0
    while 2**i<=x:
        i+=1
    return i
from sys import stdout
for _ in range(int(input())):
    n=int(input())
    l=list(map(int,input().split()))
    maz,miz=l[0],l[0]
    cnt_max=0
    for i in range(1,n):
        cnt=0
        if l[i]<maz:
            if l[i]<miz:
                miz=l[i]
        else:
            cnt=powerof2(maz-miz)
            maz,miz=l[i],l[i]
            if cnt>cnt_max:
                cnt_max=cnt
        if i==n-1 and maz-miz>0:
            cnt=powerof2(maz-miz)
            if cnt>cnt_max:
                cnt_max=cnt
    stdout.write(str(cnt_max) + ""\n"")
            
        
","['greedy', 'math']"
3114,"Moamen has an array of $$$n$$$ distinct integers. He wants to sort that array in non-decreasing order by doing the following operations in order exactly once:  Split the array into exactly $$$k$$$ non-empty subarrays such that each element belongs to exactly one subarray.  Reorder these subarrays arbitrary.  Merge the subarrays in their new order. A sequence $$$a$$$ is a subarray of a sequence $$$b$$$ if $$$a$$$ can be obtained from $$$b$$$ by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.Can you tell Moamen if there is a way to sort the array in non-decreasing order using the operations written above? NoteIn the first test case, $$$a = [6, 3, 4, 2, 1]$$$, and $$$k = 4$$$, so we can do the operations as follows:   Split $$$a$$$ into $$$\{ [6], [3, 4], [2], [1] \}$$$.  Reorder them: $$$\{ [1], [2], [3,4], [6] \}$$$.  Merge them: $$$[1, 2, 3, 4, 6]$$$, so now the array is sorted. In the second test case, there is no way to sort the array by splitting it into only $$$2$$$ subarrays.As an example, if we split it into $$$\{ [1, -4], [0, -2] \}$$$, we can reorder them into $$$\{ [1, -4], [0, -2] \}$$$ or $$$\{ [0, -2], [1, -4] \}$$$. However, after merging the subarrays, it is impossible to get a sorted array. t=int(input())
for test in range(t):
    n,k=map(int,input().split())
    arr=list(map(int,input().split()))
    dick={}
    c=0
    for ele in arr:
        dick[ele]=c
        c+=1
    count=1
    sortarr=sorted(dick)
    for x in range(n-1):
        if dick[sortarr[x]]+1!=dick[sortarr[x+1]]:
            count+=1
    if count>k:
            print(""No"")
    else:
        print(""Yes"")","['greedy', 'sortings']"
1170,"Crazy Town is a plane on which there are n infinite line roads. Each road is defined by the equation aix + biy + ci = 0, where ai and bi are not both equal to the zero. The roads divide the plane into connected regions, possibly of infinite space. Let's call each such region a block. We define an intersection as the point where at least two different roads intersect.Your home is located in one of the blocks. Today you need to get to the University, also located in some block. In one step you can move from one block to another, if the length of their common border is nonzero (in particular, this means that if the blocks are adjacent to one intersection, but have no shared nonzero boundary segment, then it are not allowed to move from one to another one in one step).Determine what is the minimum number of steps you have to perform to get to the block containing the university. It is guaranteed that neither your home nor the university is located on the road. NotePictures to the samples are presented below (A is the point representing the house; B is the point representing the university, different blocks are filled with different colors):     def town():
    x1, y1= [int(i) for i in input().split()]
    x2, y2= [int(i) for i in input().split()]
    n= int(input())
    ans= 0
    for i in range(n):
        a, b, c= [int(k) for k in input().split()]
        if (a*x1 + b*y1 + c< 0 and a*x2 + b*y2 + c> 0) or (a*x1 + b*y1 + c> 0 and a*x2 + b*y2 + c< 0):
            ans+= 1
            
    print(ans)
    return 

town()","['geometry', 'math']"
3163,"Ziota found a video game called ""Monster Invaders"".Similar to every other shooting RPG game, ""Monster Invaders"" involves killing monsters and bosses with guns.For the sake of simplicity, we only consider two different types of monsters and three different types of guns.Namely, the two types of monsters are:   a normal monster with $$$1$$$ hp.  a boss with $$$2$$$ hp. And the three types of guns are:   Pistol, deals $$$1$$$ hp in damage to one monster, $$$r_1$$$ reloading time  Laser gun, deals $$$1$$$ hp in damage to all the monsters in the current level (including the boss), $$$r_2$$$ reloading time  AWP, instantly kills any monster, $$$r_3$$$ reloading time The guns are initially not loaded, and the Ziota can only reload 1 gun at a time.The levels of the game can be considered as an array $$$a_1, a_2, \ldots, a_n$$$, in which the $$$i$$$-th stage has $$$a_i$$$ normal monsters and 1 boss. Due to the nature of the game, Ziota cannot use the Pistol (the first type of gun) or AWP (the third type of gun) to shoot the boss before killing all of the $$$a_i$$$ normal monsters.If Ziota damages the boss but does not kill it immediately, he is forced to move out of the current level to an arbitrary adjacent level (adjacent levels of level $$$i$$$ $$$(1 &lt; i &lt; n)$$$ are levels $$$i - 1$$$ and $$$i + 1$$$, the only adjacent level of level $$$1$$$ is level $$$2$$$, the only adjacent level of level $$$n$$$ is level $$$n - 1$$$). Ziota can also choose to move to an adjacent level at any time. Each move between adjacent levels are managed by portals with $$$d$$$ teleportation time.In order not to disrupt the space-time continuum within the game, it is strictly forbidden to reload or shoot monsters during teleportation. Ziota starts the game at level 1. The objective of the game is rather simple, to kill all the bosses in all the levels. He is curious about the minimum time to finish the game (assuming it takes no time to shoot the monsters with a loaded gun and Ziota has infinite ammo on all the three guns). Please help him find this value. NoteIn the first test case, the optimal strategy is:  Use the pistol to kill three normal monsters and AWP to kill the boss (Total time $$$1\cdot3+4=7$$$)  Move to stage two (Total time $$$7+3=10$$$)  Use the pistol twice and AWP to kill the boss (Total time $$$10+1\cdot2+4=16$$$)  Move to stage three (Total time $$$16+3=19$$$)  Use the laser gun and forced to move to either stage four or two, here we move to stage four (Total time $$$19+3+3=25$$$)  Use the pistol once, use AWP to kill the boss (Total time $$$25+1\cdot1+4=30$$$)  Move back to stage three (Total time $$$30+3=33$$$)  Kill the boss at stage three with the pistol (Total time $$$33+1=34$$$) Note that here, we do not finish at level $$$n$$$, but when all the bosses are killed. from sys import stdin
from itertools import repeat
def main(mn=min):
    n, r1, r2, r3, d = map(int, stdin.readline().split())
    a = map(int, stdin.readline().split(), repeat(10, n))
    dp = (0, 10 ** 18, 10 ** 18)
    t = a.pop()
    for x in a:
        m = r1 * x + r3
        y = mn(r1 * (x + 1), r2) + r1 + 2 * d
        dp = (mn(dp[0] + m + d, dp[1] + m + d, dp[1] + y - d),
                mn(dp[0] + y + d, dp[1] + y + d),
                mn(dp[1] + m + 2 * d, dp[1] + y, dp[2] + m + 2 * d, dp[2] + y))
    if n > 1:
        x = t
        m = r1 * x + r3
        y = mn(r1 * (x + 1), r2) + r1 + 2 * d
        dp = (mn(dp[0] + m + d, dp[1] + m + d, dp[1] + y - d),
                mn(dp[0] + y, dp[1] + y + d),
                mn(dp[1] + m, dp[2] + m, dp[2] + y))
    print mn(dp[0], dp[2]) - d
main()
","['dp', 'greedy', 'implementation']"
4055,"There are $$$n$$$ points on an infinite plane. The $$$i$$$-th point has coordinates $$$(x_i, y_i)$$$ such that $$$x_i &gt; 0$$$ and $$$y_i &gt; 0$$$. The coordinates are not necessarily integer.In one move you perform the following operations:   choose two points $$$a$$$ and $$$b$$$ ($$$a \neq b$$$);  move point $$$a$$$ from $$$(x_a, y_a)$$$ to either $$$(x_a + 1, y_a)$$$ or $$$(x_a, y_a + 1)$$$;  move point $$$b$$$ from $$$(x_b, y_b)$$$ to either $$$(x_b + 1, y_b)$$$ or $$$(x_b, y_b + 1)$$$;  remove points $$$a$$$ and $$$b$$$. However, the move can only be performed if there exists a line that passes through the new coordinates of $$$a$$$, new coordinates of $$$b$$$ and $$$(0, 0)$$$. Otherwise, the move can't be performed and the points stay at their original coordinates $$$(x_a, y_a)$$$ and $$$(x_b, y_b)$$$, respectively.The numeration of points does not change after some points are removed. Once the points are removed, they can't be chosen in any later moves. Note that you have to move both points during the move, you can't leave them at their original coordinates.What is the maximum number of moves you can perform? What are these moves?If there are multiple answers, you can print any of them. NoteHere are the points and the moves for the ones that get chosen for the moves from the first example:   import sys
from sys import stdin
import math
from collections import deque
n = int(stdin.readline())
dic = {}
lis = []
for i in range(n):
    a,b,c,d = map(int,stdin.readline().split())
    A,B,C,D = a+b,b,c,d
    siA = C * B
    boA = D * A

    g = math.gcd(siA,boA)
    siA //= g
    boA //= g

    if (siA,boA) not in dic:
        dic[(siA,boA)] = len(dic)
        lis.append([])

    A,B,C,D = a,b,c+d,d

    siB = C * B
    boB = D * A

    g = math.gcd(siB,boB)
    siB //= g
    boB //= g

    if (siB,boB) not in dic:
        dic[(siB,boB)] = len(dic)
        lis.append([])

    va = dic[(siA,boA)]
    vb = dic[(siB,boB)]

    lis[va].append( (vb,i) )
    lis[vb].append( (va,i) )

ans = []
used = [False] * (3*n)
nexedge = [0] * (3*n)
able = [True] * (3*n)
pedge = [None] * (3*n)
for v in range(len(lis)):

    if not able[v]:
        continue

    stk = [v]
    able[v] = False


    while stk:

        v = stk[-1]

        if len(lis[v]) <= nexedge[v]:

            elis = []
            for nex,ind in lis[v]:
                if ind != pedge[v] and not used[ind]:
                    elis.append(ind)

            if pedge[v] != None and not used[pedge[v]]:
                elis.append(pedge[v])

            for i in range(1,len(elis),2):
                ans.append( (elis[i-1]+1,elis[i]+1) )
                used[elis[i-1]] = True
                used[elis[i]] = True

            del stk[-1]
            continue

        nex,ind = lis[v][nexedge[v]]
        nexedge[v] += 1

        if able[nex]:
            pedge[nex] = ind
            able[nex] = False
            stk.append(nex)

print (len(ans))
for i in ans:
    print (*i)","['constructive algorithms', 'dfs and similar', 'geometry', 'graphs', 'sortings', 'trees']"
1532,"This is an interactive problem.John and his imaginary friend play a game. There are $$$n$$$ lamps arranged in a circle. Lamps are numbered $$$1$$$ through $$$n$$$ in clockwise order, that is, lamps $$$i$$$ and $$$i + 1$$$ are adjacent for any $$$i = 1, \ldots, n - 1$$$, and also lamps $$$n$$$ and $$$1$$$ are adjacent. Initially all lamps are turned off.John and his friend take turns, with John moving first. On his turn John can choose to terminate the game, or to make a move. To make a move, John can choose any positive number $$$k$$$ and turn any $$$k$$$ lamps of his choosing on. In response to this move, John's friend will choose $$$k$$$ consecutive lamps and turn all of them off (the lamps in the range that were off before this move stay off). Note that the value of $$$k$$$ is the same as John's number on his last move. For example, if $$$n = 5$$$ and John have just turned three lamps on, John's friend may choose to turn off lamps $$$1, 2, 3$$$, or $$$2, 3, 4$$$, or $$$3, 4, 5$$$, or $$$4, 5, 1$$$, or $$$5, 1, 2$$$.After this, John may choose to terminate or move again, and so on. However, John can not make more than $$$10^4$$$ moves.John wants to maximize the number of lamps turned on at the end of the game, while his friend wants to minimize this number. Your task is to provide a strategy for John to achieve optimal result. Your program will play interactively for John against the jury's interactor program playing for John's friend.Suppose there are $$$n$$$ lamps in the game. Let $$$R(n)$$$ be the number of turned on lamps at the end of the game if both players act optimally. Your program has to terminate the game with at least $$$R(n)$$$ turned on lamps within $$$10^4$$$ moves. Refer to Interaction section below for interaction details.For technical reasons hacks for this problem are disabled. NoteWhen $$$n = 3$$$, any John's move can be reversed, thus $$$R(3) = 0$$$, and terminating the game immediately is correct.$$$R(4) = 1$$$, and one strategy to achieve this result is shown in the second sample case.Blank lines in sample interactions are for clarity and should not be printed. #lizhou
n = int(input())
a = [0]*n
 
r = max(int(n-k-n/k+1) for k in range(1, n+1))
for i in range(1, n+1):
    if int(n-i-n/i+1) == r:
        k = i
        break
 
def query(b):
    for x in b:
        a[x] = 1
    print(k, end = "" "")
    print(*[x+1 for x in b])
    x = int(input())-1
    for i in range(k):
        a[(x+i)%n] = 0
 
while True:
    b = []
    for i in range(n):
        if a[i] == 0 and i%k < k-1 and i != n-1:
            b.append(i)
    if len(b) < k: break
    query(b[:k])
    if sum(a) >= r: break
 
print(0)","['games', 'implementation', 'interactive', 'math']"
1477,"You are given a grid with $$$n$$$ rows and $$$m$$$ columns, where each cell has a non-negative integer written on it. We say the grid is good if for each cell the following condition holds: if it has a number $$$k &gt; 0$$$ written on it, then exactly $$$k$$$ of its neighboring cells have a number greater than $$$0$$$ written on them. Note that if the number in the cell is $$$0$$$, there is no such restriction on neighboring cells.You are allowed to take any number in the grid and increase it by $$$1$$$. You may apply this operation as many times as you want, to any numbers you want. Perform some operations (possibly zero) to make the grid good, or say that it is impossible. If there are multiple possible answers, you may find any of them.Two cells are considered to be neighboring if they have a common edge. NoteIn the first test case, we can obtain the resulting grid by increasing the number in row $$$2$$$, column $$$3$$$ once. Both of the cells that contain $$$1$$$ have exactly one neighbor that is greater than zero, so the grid is good. Many other solutions exist, such as the grid $$$$$$0\;1\;0\;0$$$$$$ $$$$$$0\;2\;1\;0$$$$$$ $$$$$$0\;0\;0\;0$$$$$$ All of them are accepted as valid answers.In the second test case, it is impossible to make the grid good.In the third test case, notice that no cell has a number greater than zero on it, so the grid is automatically good. t = int(input())
for _ in range(t):
    n, m = map(int, input().split())
    a = []
    for _ in range(n):
        a.append(list(map(int, input().split())))

    flag = True
    for i in range(n):
        for j in range(m):
            x = 4
            if (i == 0 or i == n-1) and (j == 0 or j == m-1):
                x = 2
            elif i == 0 or i == n-1 or j == 0 or j == m-1:
                x = 3

            if a[i][j] > x:
                flag = False
                break
            else:
                a[i][j] = x
        if not flag:
            break

    if flag:
        print('YES')
        for i in range(n):
            print(*a[i])
    else:
        print('NO')

    

    ","['constructive algorithms', 'greedy']"
2034,"There is one apple tree in Arkady's garden. It can be represented as a set of junctions connected with branches so that there is only one way to reach any junctions from any other one using branches. The junctions are enumerated from $$$1$$$ to $$$n$$$, the junction $$$1$$$ is called the root.A subtree of a junction $$$v$$$ is a set of junctions $$$u$$$ such that the path from $$$u$$$ to the root must pass through $$$v$$$. Note that $$$v$$$ itself is included in a subtree of $$$v$$$.A leaf is such a junction that its subtree contains exactly one junction.The New Year is coming, so Arkady wants to decorate the tree. He will put a light bulb of some color on each leaf junction and then count the number happy junctions. A happy junction is such a junction $$$t$$$ that all light bulbs in the subtree of $$$t$$$ have different colors.Arkady is interested in the following question: for each $$$k$$$ from $$$1$$$ to $$$n$$$, what is the minimum number of different colors needed to make the number of happy junctions be greater than or equal to $$$k$$$? NoteIn the first example for $$$k = 1$$$ and $$$k = 2$$$ we can use only one color: the junctions $$$2$$$ and $$$3$$$ will be happy. For $$$k = 3$$$ you have to put the bulbs of different colors to make all the junctions happy.In the second example for $$$k = 4$$$ you can, for example, put the bulbs of color $$$1$$$ in junctions $$$2$$$ and $$$4$$$, and a bulb of color $$$2$$$ into junction $$$5$$$. The happy junctions are the ones with indices $$$2$$$, $$$3$$$, $$$4$$$ and $$$5$$$ then. n = int(input())
p = [0,0] + [int(w) for w in input().split()]
d = [0] * (n+1)

for i in range(n, 1, -1):
    if d[i] == 0:
        d[i] = 1
    d[p[i]] += d[i]
if n == 1:
    d[1] = 1
d = d[1:]
d.sort()
print(*d)","['constructive algorithms', 'dfs and similar', 'dp', 'graphs', 'greedy', 'sortings', 'trees']"
2566,"You have an $$$n \times n$$$ chessboard and $$$k$$$ rooks. Rows of this chessboard are numbered by integers from $$$1$$$ to $$$n$$$ from top to bottom and columns of this chessboard are numbered by integers from $$$1$$$ to $$$n$$$ from left to right. The cell $$$(x, y)$$$ is the cell on the intersection of row $$$x$$$ and collumn $$$y$$$ for $$$1 \leq x \leq n$$$ and $$$1 \leq y \leq n$$$.The arrangement of rooks on this board is called good, if no rook is beaten by another rook.A rook beats all the rooks that shares the same row or collumn with it.The good arrangement of rooks on this board is called not stable, if it is possible to move one rook to the adjacent cell so arrangement becomes not good. Otherwise, the good arrangement is stable. Here, adjacent cells are the cells that share a side.  Such arrangement of $$$3$$$ rooks on the $$$4 \times 4$$$ chessboard is good, but it is not stable: the rook from $$$(1, 1)$$$ can be moved to the adjacent cell $$$(2, 1)$$$ and rooks on cells $$$(2, 1)$$$ and $$$(2, 4)$$$ will beat each other. Please, find any stable arrangement of $$$k$$$ rooks on the $$$n \times n$$$ chessboard or report that there is no such arrangement. NoteIn the first test case, you should find stable arrangement of $$$2$$$ rooks on the $$$3 \times 3$$$ chessboard. Placing them in cells $$$(3, 1)$$$ and $$$(1, 3)$$$ gives stable arrangement.In the second test case it can be shown that it is impossbile to place $$$3$$$ rooks on the $$$3 \times 3$$$ chessboard to get stable arrangement. for _ in range(int(input())):
  n,k = [int(x) for x in input().split()]
  if (2*k-1 <=n):
    a = [list("".""*n) for _ in range(n)]
    for i in range(0,2*k,2):
      a[i][i]='R'
    for i in a:
      print("""".join(i))
  else:
    print(-1)",['constructive algorithms']
463,"A sequence of $$$n$$$ numbers is called a permutation if it contains all integers from $$$1$$$ to $$$n$$$ exactly once. For example, the sequences [$$$3, 1, 4, 2$$$], [$$$1$$$] and [$$$2,1$$$] are permutations, but [$$$1,2,1$$$], [$$$0,1$$$] and [$$$1,3,4$$$] — are not.Polycarp lost his favorite permutation and found only some of its elements — the numbers $$$b_1, b_2, \dots b_m$$$. He is sure that the sum of the lost elements equals $$$s$$$.Determine whether one or more numbers can be appended to the given sequence $$$b_1, b_2, \dots b_m$$$ such that the sum of the added numbers equals $$$s$$$, and the resulting new array is a permutation? NoteIn the test case of the example, $$$m=3, s=13, b=[3,1,4]$$$. You can append to $$$b$$$ the numbers $$$6,2,5$$$, the sum of which is $$$6+2+5=13$$$. Note that the final array will become $$$[3,1,4,6,2,5]$$$, which is a permutation.In the second test case of the example, $$$m=1, s=1, b=[1]$$$. You cannot append one or more numbers to $$$[1]$$$ such that their sum equals $$$1$$$ and the result is a permutation.In the third test case of the example, $$$m=3, s=3, b=[1,4,2]$$$. You can append the number $$$3$$$ to $$$b$$$. Note that the resulting array will be $$$[1,4,2,3]$$$, which is a permutation. t=int(input())
for i in range(t):
	u=input().split()
	v=input().split()
	u=[int(i) for i in u]
	v=[int(t) for t in v]
	sum=u[1]
	mi=1
	ma=max(v)
	cursum=0
	missing=[]
	ii=None
	for i in range(mi,ma):
		if cursum==sum:
			if len(v)==ma:
				ii=True
				break
		if i not in v:
			missing.append(i)
			v.append(i)
			cursum+=i
	if ii:
		print('YES')	
	else:
		iu=True 
		while cursum!=sum and len(set(v))==len(v):
			if cursum>sum:
				iu=False
				print('NO')
				break
			missing.append(ma+1)
			v.append(ma+1)
			ma=missing[-1]
			cursum+=ma
		if iu:
			print('YES')",['math']
2280,"The capital of Berland looks like a rectangle of size n × m of the square blocks of same size.Fire!It is known that k + 1 blocks got caught on fire (k + 1 ≤ n·m). Those blocks are centers of ignition. Moreover positions of k of these centers are known and one of these stays unknown. All k + 1 positions are distinct.The fire goes the following way: during the zero minute of fire only these k + 1 centers of ignition are burning. Every next minute the fire goes to all neighbouring blocks to the one which is burning. You can consider blocks to burn for so long that this time exceeds the time taken in the problem. The neighbouring blocks are those that touch the current block by a side or by a corner.Berland Fire Deparment wants to estimate the minimal time it takes the fire to lighten up the whole city. Remember that the positions of k blocks (centers of ignition) are known and (k + 1)-th can be positioned in any other block.Help Berland Fire Department to estimate the minimal time it takes the fire to lighten up the whole city. NoteIn the first example the last block can have coordinates (4, 4).In the second example the last block can have coordinates (8, 3). import sys
from collections import Counter
from operator import itemgetter
from heapq import heappop, heappush

n, m, k = map(int, input().split())
points = [list(map(int, line.split())) for line in sys.stdin]
pts_sorted_x = sorted(points)
pts_sorted_y = sorted(points, key=itemgetter(1, 0))
inf = 10**9+1
OK = (inf, inf)


def solve2(imos, t):
    acc, cur = 0, 0

    for k in sorted(imos.keys()):
        if t < k:
            break
        if acc <= 0 and cur+1 < k or acc + imos[k] <= 0:
            acc = 0
            break
        acc += imos[k]

    return acc <= 0


def add_imos(imos, x, y):
    imos[x] += y
    if imos[x] == 0:
        del imos[x]


def solve(t, px=-1, py=-1):
    set_x = {1, n}
    set_y = {1, m}

    for x, y in points:
        set_x.update((max(1, x-t), max(1, x-t-1), min(n, x+t), min(n, x+t+1)))
        set_y.update((max(1, y-t), max(1, y-t-1), min(m, y+t), min(m, y+t+1)))

    ans_x = ans_y = inf
    pi, imos, hq = 0, Counter(), []
    if px != -1:
        imos[py] += 1
        imos[py+t*2+1] -= 1

    for cx in sorted(set_x):
        while hq and hq[0][0] < cx:
            add_imos(imos, hq[0][1], -1)
            add_imos(imos, hq[0][2], +1)
            heappop(hq)
        while pi < k and pts_sorted_x[pi][0]-t <= cx <= pts_sorted_x[pi][0]+t:
            x, y = pts_sorted_x[pi]
            add_imos(imos, max(1, y-t), 1)
            add_imos(imos, y+t+1, -1)
            heappush(hq, (x+t, max(1, y-t), y+t+1))
            pi += 1

        if solve2(imos, m):
            ans_x = cx
            break

    pi = 0
    imos.clear()
    hq.clear()
    if px != -1:
        imos[px] += 1
        imos[px+t*2+1] -= 1

    for cy in sorted(set_y):
        while hq and hq[0][0] < cy:
            add_imos(imos, hq[0][1], -1)
            add_imos(imos, hq[0][2], +1)
            heappop(hq)
        while pi < k and pts_sorted_y[pi][1]-t <= cy <= pts_sorted_y[pi][1]+t:
            x, y = pts_sorted_y[pi]
            add_imos(imos, max(1, x-t), 1)
            add_imos(imos, x+t+1, -1)
            heappush(hq, (y+t, max(1, x-t), x+t+1))
            pi += 1

        if solve2(imos, n):
            ans_y = cy
            break

    return ans_x, ans_y


ok, ng = 10**9+1, -1
while abs(ok - ng) > 1:
    mid = (ok + ng) >> 1
    p = solve(mid)
    if p == OK:
        ok = mid
        continue

    if solve(mid, p[0], p[1]) == OK:
        ok = mid
    else:
        ng = mid

print(ok)
","['binary search', 'data structures']"
3787,"n children are standing in a circle and playing the counting-out game. Children are numbered clockwise from 1 to n. In the beginning, the first child is considered the leader. The game is played in k steps. In the i-th step the leader counts out ai people in clockwise order, starting from the next person. The last one to be pointed at by the leader is eliminated, and the next player after him becomes the new leader.For example, if there are children with numbers [8, 10, 13, 14, 16] currently in the circle, the leader is child 13 and ai = 12, then counting-out rhyme ends on child 16, who is eliminated. Child 8 becomes the leader.You have to write a program which prints the number of the child to be eliminated on every step. NoteLet's consider first example:   In the first step child 4 is eliminated, child 5 becomes the leader.  In the second step child 2 is eliminated, child 3 becomes the leader.  In the third step child 5 is eliminated, child 6 becomes the leader.  In the fourth step child 6 is eliminated, child 7 becomes the leader.  In the final step child 1 is eliminated, child 3 becomes the leader.  n, k = map(int, input().split())

a = [int(i) for i in input().split()]
v = [int(i) for i in range(n)]
# print(v)
i = 0
cont = 0
tam = n
eli = []
while cont < k:
    i = ((i+a[cont])%tam)
    eli.append(v[i]+1)
    v.pop(i)
    # print(i)
    # print(v)
    cont += 1
    tam -= 1
    # i += 1
    # print(i)
    # print()

for i in range(k):
    if i != k-1 :
        print(eli[i], end=' ')
    else:
        print(eli[i], end='')
print()
",['implementation']
1909,"After Santa Claus and his assistant Elf delivered all the presents and made all the wishes come true, they returned to the North Pole and found out that it is all covered with snow. Both of them were quite tired and they decided only to remove the snow from the roads connecting huts. The North Pole has n huts connected with m roads. One can go along the roads in both directions. The Elf offered to split: Santa Claus will clear up the wide roads and the Elf will tread out the narrow roads. For each road they decided who will clear it: Santa Claus or the Elf. To minimize the efforts they decided to clear the road so as to fulfill both those conditions:   between any two huts should exist exactly one simple path along the cleared roads;  Santa Claus and the Elf should clear the same number of roads. At this point Santa Claus and his assistant Elf wondered which roads should they clear up? NoteA path is called simple if all huts on it are pairwise different. class DSU(object):
    def __init__(self, n):
        self.pnt = [-1] * n

    def find(self, x):
        pnt = self.pnt
        if pnt[x] == -1:
            return x
        pnt[x] = self.find(pnt[x])
        return pnt[x]

    def join(self, u, v):
        pnt = self.pnt
        u = self.find(u)
        v = self.find(v)
        if u != v:
            pnt[v] = u
            return True
        return False

    def same(self, u, v):
        u = self.find(u)
        v = self.find(v)
        return u == v

def main():
    n, m = map(int, raw_input().split())
    e1 = []
    e2 = []
    for i in range(m):
        u, v, t = raw_input().split()
        u = int(u) - 1
        v = int(v) - 1
        if t == 'S':
            e1.append((u, v, i + 1))
        else:
            e2.append((u, v, i + 1))

    if n % 2 == 0:
        print-1
        return

    dsu1 = DSU(n)
    for u, v, i in e2:
        dsu1.join(u, v)

    dsu2 = DSU(n)
    ans = []
    for u, v, i in e1:
        if not dsu1.same(u, v):
            dsu1.join(u, v)
            dsu2.join(u, v)
            ans.append(i)

    half = (n - 1) / 2
    for u, v, i in e1:
        if len(ans) < half and dsu2.join(u, v):
            ans.append(i)

    if len(ans) != half:
        print -1
        return

    for u, v, i in e2:
        if len(ans) < half * 2 and dsu2.join(u, v):
            ans.append(i)

    print len(ans)
    for i in ans:
        print i,
    print

main()
","['constructive algorithms', 'dp', 'dsu', 'graphs']"
594,"As you might remember from the previous round, Vova is currently playing a strategic game known as Rage of Empires.Vova managed to build a large army, but forgot about the main person in the army - the commander. So he tries to hire a commander, and he wants to choose the person who will be respected by warriors.Each warrior is represented by his personality — an integer number pi. Each commander has two characteristics — his personality pj and leadership lj (both are integer numbers). Warrior i respects commander j only if  ( is the bitwise excluding OR of x and y).Initially Vova's army is empty. There are three different types of events that can happen with the army:  1 pi — one warrior with personality pi joins Vova's army;  2 pi — one warrior with personality pi leaves Vova's army;  3 pi li — Vova tries to hire a commander with personality pi and leadership li. For each event of the third type Vova wants to know how many warriors (counting only those who joined the army and haven't left yet) respect the commander he tries to hire. NoteIn the example the army consists of two warriors with personalities 3 and 4 after first two events. Then Vova tries to hire a commander with personality 6 and leadership 3, and only one warrior respects him (, and 2 &lt; 3, but , and 5 ≥ 3). Then warrior with personality 4 leaves, and when Vova tries to hire that commander again, there are no warriors who respect him. from sys import stdin, stdout
from itertools import izip
def main(it=int, bi=bin):
    n = int(stdin.readline())
    to = [None] * 5800000
    s = [0] * 5800000
    c = 1
    ans = []
    pu = ans.append
    for line in stdin:
        line = line.split()
        if line[0] == '3':
            p, l = bi(it(line[1]))[2:].zfill(28), bi(it(line[2]))[2:].zfill(28)
            t = 0
            f = 0
            for pb, lb in izip(p, l):
                if to[t] is None:
                    break
                if lb == '1':
                    f += s[to[t][pb=='1']]
                    t = to[t][pb=='0']
                else:
                    t = to[t][pb=='1']
            pu(f)
        else:
            p = bi(it(line[1]))[2:].zfill(28)
            d = 1 if line[0] == '1' else -1
            t = 0
            for pb in p:
                if to[t] is None:
                    to[t] = (c + 1, c + 2)
                    c += 2
                t = to[t][pb=='1']
                s[t] += d
    stdout.write('\n'.join(map(str, ans)))
main()
","['bitmasks', 'data structures', 'trees']"
2276,"For two positive integers $$$l$$$ and $$$r$$$ ($$$l \le r$$$) let $$$c(l, r)$$$ denote the number of integer pairs $$$(i, j)$$$ such that $$$l \le i \le j \le r$$$ and $$$\operatorname{gcd}(i, j) \ge l$$$. Here, $$$\operatorname{gcd}(i, j)$$$ is the greatest common divisor (GCD) of integers $$$i$$$ and $$$j$$$.YouKn0wWho has two integers $$$n$$$ and $$$k$$$ where $$$1 \le k \le n$$$. Let $$$f(n, k)$$$ denote the minimum of $$$\sum\limits_{i=1}^{k}{c(x_i+1,x_{i+1})}$$$ over all integer sequences $$$0=x_1 \lt x_2 \lt \ldots \lt x_{k} \lt x_{k+1}=n$$$.Help YouKn0wWho find $$$f(n, k)$$$.  NoteIn the first test case, YouKn0wWho can select the sequence $$$[0, 2, 6]$$$. So $$$f(6, 2) = c(1, 2) + c(3, 6) = 3 + 5 = 8$$$ which is the minimum possible. # 1603D
 
from itertools import accumulate
from collections import Counter
from math import floor, sqrt
import io, os, sys
input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
 
n, n2, n3 = 100009, 320, 18
 
phi = list(range(n))
root = [0]*n
for i in range(2, n):
    if phi[i] == i:
        for j in range(i, n, i):
            phi[j] -= phi[j]//i
 
a = list(accumulate(phi))
 
s1 = [[0]*n2 for _ in range(n)]
s2 = [[0]*n2 for _ in range(n)]
dp = [[float(""inf"")]*n for _ in range(n3)]
dp[0][0] = 0
 
def c(l, r):
    if l > r: return float(""inf"")
    if r // l <= root[r]:
        return s1[r][r//l] - a[r//l] * (l - 1 - r//((r//l) + 1))
    else:
        return s2[r][l]
 
for i in range(1, n):
    root[i] = floor(sqrt(i))
    for j in range(1, root[i] + 1):
        s1[i][j] = s1[i][j-1] + a[j] * (i//j - i//(j+1))
    
    s2[i][i//(root[i] + 1) + 1] = s1[i][root[i]]
    for j in range(i//(root[i] + 1), 0, -1):
        s2[i][j] = s2[i][j+1] + a[i//j]
 
def solve(l, r, x, y):
    if l > r: return
    mid = (l + r)//2
    val = c(x+1, mid)
    for i in range(x, min(y, mid) + 1):
        if dp[k-1][i] + val < dp[k][mid]:
            dp[k][mid] = dp[k-1][i] + val
            pos = i
        val -= a[mid//(i+1)]
    solve(l, mid-1, x, pos)
    solve(mid+1, r, pos, y)
 
for k in range(1, n3):
    solve(1, n-1, 0, n-1)
 
ans = []
 
T = int(input())
for _ in range(T):
    nn, k = map(int, input().split())
    ans += [nn] if k >= n3 else [dp[k][nn]]
 
sys.stdout.write("" "".join(map(str, ans)) + ""\n"")","['divide and conquer', 'dp', 'number theory']"
625,"You invited $$$n$$$ guests to dinner! You plan to arrange one or more circles of chairs. Each chair is going to be either occupied by one guest, or be empty. You can make any number of circles. Your guests happen to be a little bit shy, so the $$$i$$$-th guest wants to have a least $$$l_i$$$ free chairs to the left of his chair, and at least $$$r_i$$$ free chairs to the right. The ""left"" and ""right"" directions are chosen assuming all guests are going to be seated towards the center of the circle. Note that when a guest is the only one in his circle, the $$$l_i$$$ chairs to his left and $$$r_i$$$ chairs to his right may overlap.What is smallest total number of chairs you have to use? NoteIn the second sample the only optimal answer is to use two circles: a circle with $$$5$$$ chairs accomodating guests $$$1$$$ and $$$2$$$, and another one with $$$10$$$ chairs accomodationg guests $$$3$$$ and $$$4$$$.In the third sample, you have only one circle with one person. The guest should have at least five free chairs to his left, and at least six free chairs to his right to the next person, which is in this case the guest herself. So, overall number of chairs should be at least 6+1=7. n = int(input())

l = []
r = []

for i in range(n):
    numbers_in_line = [int(num) for num in input().split()]
    l_new, r_new = numbers_in_line
    l.append(l_new)
    r.append(r_new)

l.sort()
r.sort()

maxes = [max(lv, rv) for lv, rv in zip(l, r)]

print(n + sum(maxes))
","['greedy', 'math']"
450,"Vasya passes all exams! Despite expectations, Vasya is not tired, moreover, he is ready for new challenges. However, he does not want to work too hard on difficult problems.Vasya remembered that he has a not-so-hard puzzle: $$$m$$$ colored cubes are placed on a chessboard of size $$$n \times n$$$. The fact is that $$$m \leq n$$$ and all cubes have distinct colors. Each cube occupies exactly one cell. Also, there is a designated cell for each cube on the board, the puzzle is to place each cube on its place. The cubes are fragile, so in one operation you only can move one cube onto one of four neighboring by side cells, if only it is empty. Vasya wants to be careful, so each operation takes exactly one second. Vasya used to train hard for VK Cup Final, so he can focus his attention on the puzzle for at most $$$3$$$ hours, that is $$$10800$$$ seconds. Help Vasya find such a sequence of operations that all cubes will be moved onto their designated places, and Vasya won't lose his attention. NoteIn the fourth example the printed sequence of movements (shown on the picture below) is valid, but not shortest. There is a solution in $$$3$$$ operations.   def fix(grid,x,y, rev, moves):
    want = grid[x][y][1]
    while x < want:
        if grid[x+1][y]:
            fix(grid,x+1,y,rev, moves)
        st = (x,y,x+1,y)
        if rev:
            st = (st[2],st[3],st[0],st[1])
        moves.append(' '.join(map(str,st)))
        grid[x+1][y], grid[x][y] = grid[x][y], grid[x+1][y]
        x+=1
    while x > want:
        if grid[x-1][y]:
            fix(grid,x-1,y,rev, moves)
        st = (x,y,x-1,y)
        if rev:
            st = (st[2],st[3],st[0],st[1])
        moves.append(' '.join(map(str,st)))
        grid[x-1][y], grid[x][y] = grid[x][y], grid[x-1][y]
        x-=1

def solve(cubes, rev):
    global n,m
    cubes=[[cubes[i][0],cubes[i][1],i+1] for i in xrange(m)]
    cubes.sort()
    moves = []
    grid=[[0 for i in xrange(n+1)]for j in xrange(n+1)]
    for i,(x,y,z) in enumerate(cubes):
        grid[x][y] = (z,i+1)
    for i in xrange(n+1):
        for j in xrange(n+1):
            if grid[i][j]:
                fix(grid,i,j,rev, moves)
    cubes = []
    for i in xrange(n+1):
        for j in xrange(n+1):
            if grid[i][j]:
                cubes.append([i,j,grid[i][j][0]])
    
    for i in xrange(m):
        want = cubes[i][-1]
        while cubes[i][1] < want:
            st = (cubes[i][0], cubes[i][1], cubes[i][0], cubes[i][1] + 1)
            if rev:
                st = (st[2],st[3],st[0],st[1])
            moves.append(' '.join(map(str,st)))
            cubes[i][1] += 1
        while cubes[i][1] > want:
            st = (cubes[i][0], cubes[i][1], cubes[i][0], cubes[i][1] - 1)
            if rev:
                st = (st[2],st[3],st[0],st[1])
            moves.append(' '.join(map(str,st)))
            cubes[i][1] -= 1
    for i in xrange(m):
        want = cubes[i][-1]
        while cubes[i][0] < want:
            st = (cubes[i][0], cubes[i][1], cubes[i][0] + 1, cubes[i][1])
            if rev:
                st = (st[2],st[3],st[0],st[1])
            moves.append(' '.join(map(str,st)))
            cubes[i][0] += 1
        while cubes[i][0] > want:
            st = (cubes[i][0], cubes[i][1], cubes[i][0] - 1, cubes[i][1])
            if rev:
                st = (st[2],st[3],st[0],st[1])
            moves.append(' '.join(map(str,st)))
            cubes[i][0] -= 1
    return moves

n,m = map(int, raw_input().split())
first = [map(int,raw_input().split()) for i in xrange(m)]
second = [map(int,raw_input().split()) for i in xrange(m)]
moves = solve(first, 0) + list(reversed(solve(second, 1)))
print len(moves)
print '\n'.join(moves)
","['constructive algorithms', 'implementation', 'other']"
1438,"Recently you have bought a snow walking robot and brought it home. Suppose your home is a cell $$$(0, 0)$$$ on an infinite grid.You also have the sequence of instructions of this robot. It is written as the string $$$s$$$ consisting of characters 'L', 'R', 'U' and 'D'. If the robot is in the cell $$$(x, y)$$$ right now, he can move to one of the adjacent cells (depending on the current instruction).  If the current instruction is 'L', then the robot can move to the left to $$$(x - 1, y)$$$;  if the current instruction is 'R', then the robot can move to the right to $$$(x + 1, y)$$$;  if the current instruction is 'U', then the robot can move to the top to $$$(x, y + 1)$$$;  if the current instruction is 'D', then the robot can move to the bottom to $$$(x, y - 1)$$$. You've noticed the warning on the last page of the manual: if the robot visits some cell (except $$$(0, 0)$$$) twice then it breaks.So the sequence of instructions is valid if the robot starts in the cell $$$(0, 0)$$$, performs the given instructions, visits no cell other than $$$(0, 0)$$$ two or more times and ends the path in the cell $$$(0, 0)$$$. Also cell $$$(0, 0)$$$ should be visited at most two times: at the beginning and at the end (if the path is empty then it is visited only once). For example, the following sequences of instructions are considered valid: ""UD"", ""RL"", ""UUURULLDDDDLDDRRUU"", and the following are considered invalid: ""U"" (the endpoint is not $$$(0, 0)$$$) and ""UUDD"" (the cell $$$(0, 1)$$$ is visited twice).The initial sequence of instructions, however, might be not valid. You don't want your robot to break so you decided to reprogram it in the following way: you will remove some (possibly, all or none) instructions from the initial sequence of instructions, then rearrange the remaining instructions as you wish and turn on your robot to move. Your task is to remove as few instructions from the initial sequence as possible and rearrange the remaining ones so that the sequence is valid. Report the valid sequence of the maximum length you can obtain.Note that you can choose any order of remaining instructions (you don't need to minimize the number of swaps or any other similar metric).You have to answer $$$q$$$ independent test cases. NoteThere are only two possible answers in the first test case: ""LR"" and ""RL"".The picture corresponding to the second test case:  Note that the direction of traverse does not matter Another correct answer to the third test case: ""URDDLLLUURDR"". from sys import stdin, stdout
for i in range(int(input())):
  s = stdin.readline()
  r = s.count('R')
  u = s.count('U')
  l = s.count('L')
  d = s.count('D')
  
  r = l = min(r,l)
  u = d = min(u,d)

  if r == u == 0:
    stdout.write('0\n')
  elif r == 0 or u == 0:
    stdout.write('2\n')
    stdout.write('%s\n' % ('UD' if r == 0 else 'RL'))
  else:
    stdout.write('%d\n' % ((r+u)<<1))
    s = ['R' for i in range(r)] + ['U' for i in range(u)] + ['L' for i in range(l)] + ['D' for i in range(d)]
    stdout.write(''.join(s))
  stdout.write('\n') ","['constructive algorithms', 'greedy', 'implementation']"
1025,"Marin wants you to count number of permutations that are beautiful. A beautiful permutation of length $$$n$$$ is a permutation that has the following property: $$$$$$ \gcd (1 \cdot p_1, \, 2 \cdot p_2, \, \dots, \, n \cdot p_n) &gt; 1, $$$$$$ where $$$\gcd$$$ is the greatest common divisor.A permutation is an array consisting of $$$n$$$ distinct integers from $$$1$$$ to $$$n$$$ in arbitrary order. For example, $$$[2,3,1,5,4]$$$ is a permutation, but $$$[1,2,2]$$$ is not a permutation ($$$2$$$ appears twice in the array) and $$$[1,3, 4]$$$ is also not a permutation ($$$n=3$$$ but there is $$$4$$$ in the array). NoteIn first test case, we only have one permutation which is $$$[1]$$$ but it is not beautiful because $$$\gcd(1 \cdot 1) = 1$$$.In second test case, we only have one beautiful permutation which is $$$[2, 1]$$$ because $$$\gcd(1 \cdot 2, 2 \cdot 1) = 2$$$.  import sys
import math
import bisect
import heapq
input = sys.stdin.readline
print = sys.stdout.write
t = int(input())


def solve():
    # input init.
    # input()
    # num
    n=int(input())
    # x,d=map(int, input().split())
    # string
    # s=input().rstrip('\n')
    # c=input().rstrip('\n')
    # list
    # l=list(map(int,input().split()))
    # l=input().split()
    # matrix
    # matrix=[list(map(int,input().split())) for _ in range(n)]
    # matrix=[list(map(int,list(input().rstrip('\n')))) for _ in range(n)]

    # solve.

    mod=998244353
    if n%2==1:
        return 0
    else:
        res=1
        for i in range(1,n//2+1):
            res*=i
            res%=mod

    # return.
    
    return (res**2)%mod

# solve()
# print(str(solve()))
for _ in range(t):
    print(str(solve())+'\n')
    # solve()

","['combinatorics', 'math', 'number theory']"
1253,"You play a computer game. Your character stands on some level of a multilevel ice cave. In order to move on forward, you need to descend one level lower and the only way to do this is to fall through the ice.The level of the cave where you are is a rectangular square grid of n rows and m columns. Each cell consists either from intact or from cracked ice. From each cell you can move to cells that are side-adjacent with yours (due to some limitations of the game engine you cannot make jumps on the same place, i.e. jump from a cell to itself). If you move to the cell with cracked ice, then your character falls down through it and if you move to the cell with intact ice, then the ice on this cell becomes cracked.Let's number the rows with integers from 1 to n from top to bottom and the columns with integers from 1 to m from left to right. Let's denote a cell on the intersection of the r-th row and the c-th column as (r, c). You are staying in the cell (r1, c1) and this cell is cracked because you've just fallen here from a higher level. You need to fall down through the cell (r2, c2) since the exit to the next level is there. Can you do this? NoteIn the first sample test one possible path is:After the first visit of cell (2, 2) the ice on it cracks and when you step there for the second time, your character falls through the ice as intended. import queue
MAX = 500
dr = [0,0,1,-1]
dc = [1,-1,0,0]
 
def isValid(r, c):
  return r in range(m) and c in range(n)
 
def BFS(sr, sc, fr, fc):
  q = [0] * (MAX * MAX)
  left = right = 0
  q[0] = (sr, sc)
  while left <= right:
    ur, uc = q[left]
    left += 1
    for i in range(4):
      vr = ur + dr[i]
      vc = uc + dc[i]
      if isValid(vr, vc):
        if maze[vr][vc] == '.':
          maze[vr][vc] = 'X'
          right += 1
          q[right] = (vr,vc)
        else:
          if(vr == fr) and (vc==fc):
            return True
  return False
 
if __name__ == '__main__':
 
  maze = [] * MAX
  m, n = map(int, input().split())
  
  for i in range(m):
    temp = list(input())
    maze.append(temp)
  start, start2 = map(int, input().split())
  end1, end2 = map(int, input().split())
  if(BFS(start-1,start2-1,end1-1,end2-1)):
    print('YES')
  else:
    print('NO')",['dfs and similar']
4701,"Students went into a class to write a test and sat in some way. The teacher thought: ""Probably they sat in this order to copy works of each other. I need to rearrange them in such a way that students that were neighbors are not neighbors in a new seating.""The class can be represented as a matrix with n rows and m columns with a student in each cell. Two students are neighbors if cells in which they sit have a common side.Let's enumerate students from 1 to n·m in order of rows. So a student who initially sits in the cell in row i and column j has a number (i - 1)·m + j. You have to find a matrix with n rows and m columns in which all numbers from 1 to n·m appear exactly once and adjacent numbers in the original matrix are not adjacent in it, or determine that there is no such matrix. NoteIn the first test case the matrix initially looks like this:1 2 3 45 6 7 8It's easy to see that there are no two students that are adjacent in both matrices.In the second test case there are only two possible seatings and in both of them students with numbers 1 and 2 are neighbors. import random
n, m = map(int, input().split())
if n < 4 and m < 4 and not((n == 1 and m == 1) or (m == 3 and n == 3)): print(""NO""); quit()
pedy = [list() for i in range(n * m + 1)]
for i in range(n * m):
    if i % m != 0: pedy[i+1].append(i)
    if i % m != m - 1: pedy[i + 1].append(i + 2)
    if i >= m: pedy[i + 1].append(i - m + 1)
    if i < (n - 1) * m: pedy[i + 1].append(i + m + 1)
Arr = [x for x in range(1, n*m + 1)]; Arr = Arr[::2] + Arr[1::2]; pp = 0; s = """"
while (not pp):
    pp = 1;
    for i in range(n):
        for j in range(m):
            if (i + 1 != n and Arr[i * m + m + j] in pedy[Arr[i * m + j]]) or (j + 1 != m and Arr[i * m + 1 + j] in pedy[Arr[i * m + j]]):
                pp = 0; break
        if not pp: break
    if not pp: random.shuffle(Arr)
print(""YES"")
for i in range(n):
    for j in range(m):
        s += str(Arr[i  * m + j]) + "" ""
    print(s); s = """"
",['constructive algorithms']
3810,"This is an interactive problem.We hid from you a permutation $$$p$$$ of length $$$n$$$, consisting of the elements from $$$1$$$ to $$$n$$$. You want to guess it. To do that, you can give us 2 different indices $$$i$$$ and $$$j$$$, and we will reply with $$$p_{i} \bmod p_{j}$$$ (remainder of division $$$p_{i}$$$ by $$$p_{j}$$$).We have enough patience to answer at most $$$2 \cdot n$$$ queries, so you should fit in this constraint. Can you do it?As a reminder, a permutation of length $$$n$$$ is an array consisting of $$$n$$$ distinct integers from $$$1$$$ to $$$n$$$ in arbitrary order. For example, $$$[2,3,1,5,4]$$$ is a permutation, but $$$[1,2,2]$$$ is not a permutation ($$$2$$$ appears twice in the array) and $$$[1,3,4]$$$ is also not a permutation ($$$n=3$$$ but there is $$$4$$$ in the array). nan import os
from io import BytesIO, IOBase
import sys
from math import *
from collections import Counter


def main():
    n=int(input())
    ans=[n]*(n+1)
    z=set(range(1,n+1))
    while len(z)!=1:
        a,b=z.pop(),z.pop()
        print('?',a,b,flush=True)
        x=int(input())
        print('?',b,a,flush=True)
        y=int(input())
        if x>y:
            ans[a]=x
            z.add(b)
        else:
            ans[b]=y
            z.add(a)
    print(""!"",*ans[1:],flush=True)

# region fastio
BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()","['constructive algorithms', 'interactive', 'math', 'two pointers']"
2226,"A long time ago in some far country lived king Copa. After the recent king's reform, he got so large powers that started to keep the books by himself.The total income A of his kingdom during 0-th year is known, as well as the total income B during n-th year (these numbers can be negative — it means that there was a loss in the correspondent year). King wants to show financial stability. To do this, he needs to find common coefficient X — the coefficient of income growth during one year. This coefficient should satisfy the equation:A·Xn = B.Surely, the king is not going to do this job by himself, and demands you to find such number X.It is necessary to point out that the fractional numbers are not used in kingdom's economy. That's why all input numbers as well as coefficient X must be integers. The number X may be zero or negative. nan a,b,n = map(int,input().split())
ans = ""No solution""

if a == 0 and b == 0:
    ans =5
elif a == 0 and b!= 0:
    ans
elif a != 0 and b == 0:
    ans = 0
elif b%a != 0:
    ans
else:
    a = b / a
    if a < 0 :
        a = abs(a)
        b = 0
    for i in range(1001):
        if i ** n == a:
            ans = i

    if b == 0 :ans = - ans

print(ans)
","['brute force', 'math']"
4210,"The Berland University is preparing to celebrate the 256-th anniversary of its founding! A specially appointed Vice Rector for the celebration prepares to decorate the campus. In the center of the campus n ice sculptures were erected. The sculptures are arranged in a circle at equal distances from each other, so they form a regular n-gon. They are numbered in clockwise order with numbers from 1 to n.The site of the University has already conducted a voting that estimated each sculpture's characteristic of ti — the degree of the sculpture's attractiveness. The values of ti can be positive, negative or zero.When the university rector came to evaluate the work, he said that this might be not the perfect arrangement. He suggested to melt some of the sculptures so that:   the remaining sculptures form a regular polygon (the number of vertices should be between 3 and n),  the sum of the ti values of the remaining sculptures is maximized. Help the Vice Rector to analyze the criticism — find the maximum value of ti sum which can be obtained in this way. It is allowed not to melt any sculptures at all. The sculptures can not be moved. NoteIn the first sample it is best to leave every second sculpture, that is, leave sculptures with attractivenesses: 2, 4, 5 и 3. import math
n = int(input())
t = list(map(int, input().split()))
div = []
for i in range(1, int(math.sqrt(n)) + 1):
    if n % i == 0:
        if i * i != n:
            div.append(i)
            div.append(n // i)
        else: div.append(i)
m = -99999999
div.sort()
div.pop()
for i in div:
    s = 0
    c = i
    x = 0
    while c != 0:
        s = 0
        count = 0
        for j in range(x, n, i):
            count -= -1
            s += t[j]
        x += 1
        c -= 1
        if count >= 3:
            m = max(m, s)
print(m)","['brute force', 'number theory', 'other']"
3553,"One day a well-known sponsor of a well-known contest decided to give every participant of the contest a T-shirt as a present. A natural problem occurred: on the one hand, it is not clear how many T-shirts of what sizes should be ordered, and on the other hand, one doesn't want to order too many T-shirts (and we do not exactly paper the walls with the oversupply). After considerable brain racking and some pre-estimating, the sponsor representatives ordered a certain number of T-shirts of sizes S, M, L, XL and XXL. The T-shirts turned out to bring good luck, that's why on the contest day there built up a line of K participants willing to get one. Every contestant is characterized by his/her desired T-shirt size (so it happens that for all the participants it is also one of the sizes S, M, L, XL and XXL). The participants come up to get a T-shirt one by one and try to choose the most suitable one, choosing it like this. If there is still a T-shirt of the optimal size left, that he/she takes it without further ado. Otherwise the contestant would prefer to choose a T-shirt with the size as close to the optimal one as possible (the distance between neighboring sizes is considered equal to one). If the variant of choice is not unique, the contestant will take a T-shirt of a bigger size (in case he/she grows more). For example, for a person whose optimal size is L the preference list looks like this: L, XL, M, XXL, S. Using the data on how many T-shirts of every size had been ordered by the organizers, on the size of contestants in the line determine who got a T-shirt of what size. nan lstarr=list(map(int,input().split()))
k=int(input())
s=[0,1,2,3,4]
m=[1,2,0,3,4]
l=[2,3,1,4,0]
xl=[3,4,2,1,0]
xxl=[4,3,2,1,0]
dct={""S"":s,'M':m,""L"":l,""XL"":xl,""XXL"":xxl}
dct1={0:""S"",1:""M"",2:'L',3:'XL',4:""XXL""}
for i in range(k):
    pref=dct[input()]
    for j in pref:
        if(lstarr[j]>0):
            print(dct1[j])
            lstarr[j]=lstarr[j]-1
            break",['implementation']
4741,"This is a hard version of the problem. The only difference between an easy and a hard version is in the number of queries.Polycarp grew a tree from $$$n$$$ vertices. We remind you that a tree of $$$n$$$ vertices is an undirected connected graph of $$$n$$$ vertices and $$$n-1$$$ edges that does not contain cycles.He calls a set of vertices passable if there is such a path in the tree that passes through each vertex of this set without passing through any edge twice. The path can visit other vertices (not from this set).In other words, a set of vertices is called passable if there is a simple path that passes through all the vertices of this set (and possibly some other).For example, for a tree below sets $$$\{3, 2, 5\}$$$, $$$\{1, 5, 4\}$$$, $$$\{1, 4\}$$$ are passable, and $$$\{1, 3, 5\}$$$, $$$\{1, 2, 3, 4, 5\}$$$ are not.  Polycarp asks you to answer $$$q$$$ queries. Each query is a set of vertices. For each query, you need to determine whether the corresponding set of vertices is passable. nan def dfs(root):
    dis=[0]*n
    parent_list = [-1] * n
    stops_left=[len(tree[node])-1 for node in range(n)]
    stops_left[root]=-1 # you always have to stop when you reach the root
    eular_path=[]
    stack=[root]
    node_mapping=[-1]*n
    count=0
    while stack:
        node=stack.pop()
        node_mapping[node]=count
        count+=1
        eular_path.append(node_mapping[node])
        for child in tree[node]:
            if child != parent_list[node]:
                stack.append(child)
                parent_list[child] = node
                dis[child]=dis[node]+1

        if stops_left[node]==0: # it have only one edge
            node=parent_list[node]
            while True:
                stops_left[node]-=1
                eular_path.append(node_mapping[node])
                if stops_left[node]!=0:
                    break
                node=parent_list[node]
    node_return=[-1]*n
    for i in range(n):
        node_return[node_mapping[i]]=i
    return eular_path,node_mapping,node_return,dis

def pre_compute_min(x):
    n=len(x)
    powers_of_two_min = [[float(""-INF"")] * n for _ in range(int(math.log(n, 2)) + 1)]
    powers_of_two_min[0] = x
    for i in range(1, len(powers_of_two_min)):
        for j in range(n- (1 << (i-1))):
            powers_of_two_min[i][j] = min(powers_of_two_min[i - 1][j], powers_of_two_min[i - 1][j + (1 << (i-1))])
    return powers_of_two_min

def get_range_min(a,b):
    #both a and b are inculded
    length=b-a+1
    nearest_power_of_two=int(math.log(length,2))
    return min(powers_of_two_min[nearest_power_of_two][a],powers_of_two_min[nearest_power_of_two][b-(1<<nearest_power_of_two)+1])

def LCA(a,b):
    node_a=node_mapping[a]
    node_b=node_mapping[b]
    if first[node_a]>first[node_b]:
        node_a,node_b=node_b,node_a
    return node_return[get_range_min(first[node_a],first[node_b])]

import math
input = __import__('sys').stdin.readline
mapnode = lambda x: int(x)-1
n=int(input())
tree=[[] for _ in range(n)]
for _ in range(n-1):
    a,b=map(mapnode,input().split())
    tree[a].append(b)
    tree[b].append(a)
eular_path,node_mapping,node_return,dis=dfs(0)
powers_of_two_min=pre_compute_min(eular_path)
first=[-1]*n
for i in range(len(eular_path)):
    temp=eular_path[i]
    first[temp]=i if first[temp]==-1 else first[temp]
q=int(input())
for __ in range(q):
    k=int(input())
    x=sorted(map(mapnode,input().split()),key=lambda a:-dis[a])
    deepest1=x[0]
    deepest2 = deepest1
    for node in x:
        if LCA(node,deepest1)==node or LCA(node,deepest2)==node:
            k-=1
        else:
            if deepest2==deepest1:
                deepest2=node
                k-=1
    print(""YES"" if k==0 and (deepest1==deepest2 or dis[LCA(deepest1,deepest2)]<=dis[x[-1]]) else ""NO"")

","['data structures', 'dfs and similar', 'trees']"
150,"Little Petya very much likes playing with little Masha. Recently he has received a game called ""Zero-One"" as a gift from his mother. Petya immediately offered Masha to play the game with him.Before the very beginning of the game several cards are lain out on a table in one line from the left to the right. Each card contains a digit: 0 or 1. Players move in turns and Masha moves first. During each move a player should remove a card from the table and shift all other cards so as to close the gap left by the removed card. For example, if before somebody's move the cards on the table formed a sequence 01010101, then after the fourth card is removed (the cards are numbered starting from 1), the sequence will look like that: 0100101. The game ends when exactly two cards are left on the table. The digits on these cards determine the number in binary notation: the most significant bit is located to the left. Masha's aim is to minimize the number and Petya's aim is to maximize it.An unpleasant accident occurred before the game started. The kids spilled juice on some of the cards and the digits on the cards got blurred. Each one of the spoiled cards could have either 0 or 1 written on it. Consider all possible variants of initial arrangement of the digits (before the juice spilling). For each variant, let's find which two cards are left by the end of the game, assuming that both Petya and Masha play optimally. An ordered pair of digits written on those two cards is called an outcome. Your task is to find the set of outcomes for all variants of initial digits arrangement. NoteIn the first sample all 16 variants of numbers arrangement are possible. For the variant 0000 the outcome is 00. For the variant 1111 the outcome is 11. For the variant 0011 the outcome is 01. For the variant 1100 the outcome is 10. Regardless of outcomes for all other variants the set which we are looking for will contain all 4 possible outcomes.In the third sample only 2 variants of numbers arrangement are possible: 111 and 101. For the variant 111 the outcome is 11. For the variant 101 the outcome is 01, because on the first turn Masha can remove the first card from the left after which the game will end. a=raw_input()
O,I,Q=[a.count(i)for i in""01?""]
Z=I-O
if Q>Z:print""00""
if-Q<=Z<2+Q:
 if""?"">a[-1]:print""10""[int(a[-1])]+a[-1]
 else:
	if Z<Q:print""01""
	if~Q<1-Z<Q:print 10
if Z+Q>1:print 11
","['constructive algorithms', 'games', 'greedy']"
1361,"Arthur has bought a beautiful big table into his new flat. When he came home, Arthur noticed that the new table is unstable.In total the table Arthur bought has n legs, the length of the i-th leg is li.Arthur decided to make the table stable and remove some legs. For each of them Arthur determined number di — the amount of energy that he spends to remove the i-th leg.A table with k legs is assumed to be stable if there are more than half legs of the maximum length. For example, to make a table with 5 legs stable, you need to make sure it has at least three (out of these five) legs of the maximum length. Also, a table with one leg is always stable and a table with two legs is stable if and only if they have the same lengths.Your task is to help Arthur and count the minimum number of energy units Arthur should spend on making the table stable. nan rr = lambda: map(int, input().split())
_, d, res, he = input(), {}, 0, list(zip(rr(), rr()))
for h, e in he:
    f, x = d.get(h, (-1, 0))
    d[h] = (f + 1, x + e)
he.sort(key = lambda x: x[1], reverse=True)
for h, (f, x) in d.items():
    if not f:
    	res = max(x, res)
    	continue
    for h1, e in he:
        if h1 < h:
            x += e
            f -= 1
            if not f: break
    res = max(x, res)
print(sum(e for h, e in he) - res)","['brute force', 'data structures', 'dp', 'greedy', 'math', 'sortings']"
1144,"Let's say you are standing on the $$$XY$$$-plane at point $$$(0, 0)$$$ and you want to reach point $$$(n, n)$$$.You can move only in two directions:   to the right, i. e. horizontally and in the direction that increase your $$$x$$$ coordinate,  or up, i. e. vertically and in the direction that increase your $$$y$$$ coordinate. In other words, your path will have the following structure:   initially, you choose to go to the right or up;  then you go some positive integer distance in the chosen direction (distances can be chosen independently);  after that you change your direction (from right to up, or from up to right) and repeat the process. You don't like to change your direction too much, so you will make no more than $$$n - 1$$$ direction changes.As a result, your path will be a polygonal chain from $$$(0, 0)$$$ to $$$(n, n)$$$, consisting of at most $$$n$$$ line segments where each segment has positive integer length and vertical and horizontal segments alternate.Not all paths are equal. You have $$$n$$$ integers $$$c_1, c_2, \dots, c_n$$$ where $$$c_i$$$ is the cost of the $$$i$$$-th segment.Using these costs we can define the cost of the path as the sum of lengths of the segments of this path multiplied by their cost, i. e. if the path consists of $$$k$$$ segments ($$$k \le n$$$), then the cost of the path is equal to $$$\sum\limits_{i=1}^{k}{c_i \cdot length_i}$$$ (segments are numbered from $$$1$$$ to $$$k$$$ in the order they are in the path).Find the path of the minimum cost and print its cost. NoteIn the first test case, to reach $$$(2, 2)$$$ you need to make at least one turn, so your path will consist of exactly $$$2$$$ segments: one horizontal of length $$$2$$$ and one vertical of length $$$2$$$. The cost of the path will be equal to $$$2 \cdot c_1 + 2 \cdot c_2 = 26 + 176 = 202$$$.In the second test case, one of the optimal paths consists of $$$3$$$ segments: the first segment of length $$$1$$$, the second segment of length $$$3$$$ and the third segment of length $$$2$$$.The cost of the path is $$$1 \cdot 2 + 3 \cdot 3 + 2 \cdot 1 = 13$$$.In the third test case, one of the optimal paths consists of $$$4$$$ segments: the first segment of length $$$1$$$, the second one — $$$1$$$, the third one — $$$4$$$, the fourth one — $$$4$$$. The cost of the path is $$$1 \cdot 4 + 1 \cdot 3 + 4 \cdot 2 + 4 \cdot 1 = 19$$$. import random
from datetime import datetime
import math

now = datetime.now() 
 
cazuri=int(input())
for tt in range(cazuri):
 #n,c=map(int,input().split())
 n=int(input())
 
 #stringul=input()
 
 bloc=list(map(int,input().split()))
 

  
  
 pare=[]
 impare=[]
 
 suma_pare=0
 suma_impare=0
 cate_pare=1
 cate_impare=1
 
 
 suma_totala=0
 
 suma_pare=bloc[0]
 suma_impare=bloc[1]
 
 min_pare=bloc[0]
 min_impare=bloc[1]
 
 val_pare=bloc[0]*n
 val_impare=bloc[1]*n
 
 val_total=val_pare+val_impare
 
# print(""val total="",val_total)
 
 if n==2:
  print(val_total)
 else:
  
  for i in range(2,n):
   if i%2==0:
    cate_pare+=1
    suma_pare+=bloc[i]
    if bloc[i]<min_pare:
     min_pare=bloc[i]
     
    val_pare=min_pare*(n+1-cate_pare)+suma_pare-min_pare
    val_total=min(val_total,val_pare+val_impare)
    
   
   else:
    cate_impare+=1
    suma_impare+=bloc[i]
    if bloc[i]<min_impare:
     min_impare=bloc[i]
     
    val_impare=min_impare*(n+1-cate_impare)+suma_impare-min_impare
    
   # print(""val impare="",val_impare,val_pare)
    val_total=min(val_total,val_impare+val_pare)
    
 
  print(val_total)
 ","['brute force', 'data structures', 'greedy', 'math']"
2629,"Polycarp is working on a new project called ""Polychat"". Following modern tendencies in IT, he decided, that this project should contain chat as well. To achieve this goal, Polycarp has spent several hours in front of his laptop and implemented a chat server that can process three types of commands:  Include a person to the chat ('Add' command).  Remove a person from the chat ('Remove' command).  Send a message from a person to all people, who are currently in the chat, including the one, who sends the message ('Send' command). Now Polycarp wants to find out the amount of outgoing traffic that the server will produce while processing a particular set of commands.Polycarp knows that chat server sends no traffic for 'Add' and 'Remove' commands. When 'Send' command is processed, server sends l bytes to each participant of the chat, where l is the length of the message.As Polycarp has no time, he is asking for your help in solving this problem. nan import sys
z=x=0
for s in sys.stdin:
	if s[0]=='+':
		x+=1
	elif s[0]=='-':
		x-=1
	else:
		z+=(len(s)-s.find(':')-2)*x
print z",['implementation']
3508,"Sasha and Kolya decided to get drunk with Coke, again. This time they have k types of Coke. i-th type is characterised by its carbon dioxide concentration . Today, on the party in honour of Sergiy of Vancouver they decided to prepare a glass of Coke with carbon dioxide concentration . The drink should also be tasty, so the glass can contain only integer number of liters of each Coke type (some types can be not presented in the glass). Also, they want to minimize the total volume of Coke in the glass.Carbon dioxide concentration is defined as the volume of carbone dioxide in the Coke divided by the total volume of Coke. When you mix two Cokes, the volume of carbon dioxide sums up, and the total volume of Coke sums up as well.Help them, find the minimal natural number of liters needed to create a glass with carbon dioxide concentration . Assume that the friends have unlimited amount of each Coke type. NoteIn the first sample case, we can achieve concentration  using one liter of Coke of types  and : .In the second case, we can achieve concentration  using two liters of  type and one liter of  type: . from collections import deque


MAX_A = 1000


def main():
    n, k = map(int, input().split())
    a = set(int(x) - n for x in input().split())

    visited = [False] * (2 * MAX_A + 1)
    visited[n] = True
    Q = deque()
    Q.append((n, 0))

    result = None
    while Q:
        u, l = Q.popleft()
        l += 1
        for ai in a:
            v = u + ai
            if v == n:
                result = l
                break

            if 0 <= v < len(visited) and not visited[v]:
                visited[v] = True
                Q.append((v, l))

        if result is not None:
            break

    if result is None:
        result = -1

    print(result)


if __name__ == '__main__':
    # import sys
    # sys.stdin = open(""E.txt"")
    main()
","['brute force', 'dfs and similar', 'dp', 'graphs', 'math', 'other', 'shortest paths']"
1972,"Mahmoud wrote a message s of length n. He wants to send it as a birthday present to his friend Moaz who likes strings. He wrote it on a magical paper but he was surprised because some characters disappeared while writing the string. That's because this magical paper doesn't allow character number i in the English alphabet to be written on it in a string of length more than ai. For example, if a1 = 2 he can't write character 'a' on this paper in a string of length 3 or more. String ""aa"" is allowed while string ""aaa"" is not.Mahmoud decided to split the message into some non-empty substrings so that he can write every substring on an independent magical paper and fulfill the condition. The sum of their lengths should be n and they shouldn't overlap. For example, if a1 = 2 and he wants to send string ""aaa"", he can split it into ""a"" and ""aa"" and use 2 magical papers, or into ""a"", ""a"" and ""a"" and use 3 magical papers. He can't split it into ""aa"" and ""aa"" because the sum of their lengths is greater than n. He can split the message into single string if it fulfills the conditions.A substring of string s is a string that consists of some consecutive characters from string s, strings ""ab"", ""abc"" and ""b"" are substrings of string ""abc"", while strings ""acb"" and ""ac"" are not. Any string is a substring of itself.While Mahmoud was thinking of how to split the message, Ehab told him that there are many ways to split it. After that Mahmoud asked you three questions:   How many ways are there to split the string into substrings such that every substring fulfills the condition of the magical paper, the sum of their lengths is n and they don't overlap? Compute the answer modulo 109 + 7.  What is the maximum length of a substring that can appear in some valid splitting?  What is the minimum number of substrings the message can be spit in? Two ways are considered different, if the sets of split positions differ. For example, splitting ""aa|a"" and ""a|aa"" are considered different splittings of message ""aaa"". NoteIn the first example the three ways to split the message are:   a|a|b  aa|b  a|ab The longest substrings are ""aa"" and ""ab"" of length 2.The minimum number of substrings is 2 in ""a|ab"" or ""aa|b"".Notice that ""aab"" is not a possible splitting because the letter 'a' appears in a substring of length 3, while a1 = 2. n=int(input())
s=input()
l=list(map(int,input().split()))
dp=[0]*(n+2)
mn=[10**4]*(n+2)
dp[0]=dp[n+1]=1
mn[0]=1
mn[n+1]=0
mod=10**9+7
maxx=1
for i in range(1,n):
  cur=10**4

  for j in range(i,-1,-1):
    c=ord(s[j])-ord('a')
    cur=min(cur,l[c])
    if cur<(i-j+1):
      break
    dp[i]=(dp[i]+dp[j-1])%mod
    mn[i]=min(mn[i],mn[j-1]+1)
    maxx=max(maxx,i-j+1)
#print(dp)
print(dp[n-1])
print(maxx)
print(mn[n-1])
","['brute force', 'dp', 'greedy', 'strings']"
457,"You have got a shelf and want to put some books on it.You are given $$$q$$$ queries of three types:  L $$$id$$$ — put a book having index $$$id$$$ on the shelf to the left from the leftmost existing book;  R $$$id$$$ — put a book having index $$$id$$$ on the shelf to the right from the rightmost existing book;  ? $$$id$$$ — calculate the minimum number of books you need to pop from the left or from the right in such a way that the book with index $$$id$$$ will be leftmost or rightmost. You can assume that the first book you will put can have any position (it does not matter) and queries of type $$$3$$$ are always valid (it is guaranteed that the book in each such query is already placed). You can also assume that you don't put the same book on the shelf twice, so $$$id$$$s don't repeat in queries of first two types.Your problem is to answer all the queries of type $$$3$$$ in order they appear in the input.Note that after answering the query of type $$$3$$$ all the books remain on the shelf and the relative order of books does not change.If you are Python programmer, consider using PyPy instead of Python when you submit your code. NoteLet's take a look at the first example and let's consider queries:   The shelf will look like $$$[1]$$$;  The shelf will look like $$$[1, 2]$$$;  The shelf will look like $$$[1, 2, 3]$$$;  The shelf looks like $$$[1, \textbf{2}, 3]$$$ so the answer is $$$1$$$;  The shelf will look like $$$[4, 1, 2, 3]$$$;  The shelf looks like $$$[4, \textbf{1}, 2, 3]$$$ so the answer is $$$1$$$;  The shelf will look like $$$[5, 4, 1, 2, 3]$$$;  The shelf looks like $$$[5, 4, \textbf{1}, 2, 3]$$$ so the answer is $$$2$$$. Let's take a look at the second example and let's consider queries:   The shelf will look like $$$[100]$$$;  The shelf will look like $$$[100, 100000]$$$;  The shelf will look like $$$[100, 100000, 123]$$$;  The shelf will look like $$$[101, 100, 100000, 123]$$$;  The shelf looks like $$$[101, 100, 100000, \textbf{123}]$$$ so the answer is $$$0$$$;  The shelf will look like $$$[10, 101, 100, 100000, 123]$$$;  The shelf will look like $$$[10, 101, 100, 100000, 123, 115]$$$;  The shelf looks like $$$[10, 101, \textbf{100}, 100000, 123, 115]$$$ so the answer is $$$2$$$;  The shelf will look like $$$[10, 101, 100, 100000, 123, 115, 110]$$$;  The shelf looks like $$$[10, 101, 100, 100000, 123, \textbf{115}, 110]$$$ so the answer is $$$1$$$.  s=[]
q={}
l,r=0,0
for i in range(int(input())):
    a,b=map(str,input().split())
    if i==0:
       q[b]=0
    else:
        if a==""R"":
           r+=1
           q[b]=r
        elif a==""L"":
             l-=1
             q[b]=l
        elif a==""?"":
            s.append(min(q[b]-l,r-q[b]))
print(*s,sep=""\n"")",['implementation']
2094,"Artem is building a new robot. He has a matrix $$$a$$$ consisting of $$$n$$$ rows and $$$m$$$ columns. The cell located on the $$$i$$$-th row from the top and the $$$j$$$-th column from the left has a value $$$a_{i,j}$$$ written in it. If two adjacent cells contain the same value, the robot will break. A matrix is called good if no two adjacent cells contain the same value, where two cells are called adjacent if they share a side. Artem wants to increment the values in some cells by one to make $$$a$$$ good.More formally, find a good matrix $$$b$$$ that satisfies the following condition —   For all valid ($$$i,j$$$), either $$$b_{i,j} = a_{i,j}$$$ or $$$b_{i,j} = a_{i,j}+1$$$. For the constraints of this problem, it can be shown that such a matrix $$$b$$$ always exists. If there are several such tables, you can output any of them. Please note that you do not have to minimize the number of increments. NoteIn all the cases, you can verify that no two adjacent cells have the same value and that $$$b$$$ is the same as $$$a$$$ with some values incremented by one.  def main():
    t = int(input())
    for i_t in range(t):
        n, m = _read_ints()
        a = tuple(tuple(_read_ints()) for i_row in range(n))
        result = _find_fixed_matrix(a)
        for row in result:
            print(*row)


def _find_fixed_matrix(matrix):
    rows_n = len(matrix)
    columns_n = len(matrix[0])
    elements_n = rows_n * columns_n

    result = tuple(map(list, matrix))
    
    actions = tuple([None]*columns_n for i_row in range(rows_n))
    queue = []
    i_action = 0

    for i_row in range(rows_n):
        for i_column in range(columns_n):
            if actions[i_row][i_column] is None:
                actions[i_row][i_column] = 1
                queue.append(((i_row, i_column), 1))
                
                while i_action != len(queue):
                    (u, v), action = queue[i_action]
                    i_action += 1
                    for du, dv in ((0, 1), (1, 0), (0, -1), (-1, 0)):
                        if 0 <= u+du < rows_n and 0 <= v+dv < columns_n \
                               and actions[u+du][v+dv] is None:
                            try:
                                action = _try_choose_action((u+du, v+dv), matrix, actions)
                            except ValueError:
                                pass
                            else:
                                actions[u+du][v+dv] = action
                                queue.append(((u+du, v+dv), action))
            result[i_row][i_column] += actions[i_row][i_column]
    
    return result



def _try_choose_action(pos, matrix, actions):
    rows_n = len(matrix)
    columns_n = len(matrix[0])
    
    u, v = pos
    for du, dv in ((0, 1), (1, 0), (0, -1), (-1, 0)):
        if 0 <= u+du < rows_n and 0 <= v+dv < columns_n \
                and actions[u+du][v+dv] is not None:
            new_value = matrix[u+du][v+dv] + actions[u+du][v+dv]
            if matrix[u][v] == new_value:
                return 1
            elif matrix[u][v] + 1 == new_value:
                return 0

    raise ValueError


def _read_ints():
    return map(int, input().split())


if __name__ == ""__main__"":
    main()
","['constructive algorithms', 'other']"
3599,"Vladik is a competitive programmer. This year he is going to win the International Olympiad in Informatics. But it is not as easy as it sounds: the question Vladik face now is to find the cheapest way to get to the olympiad.Vladik knows n airports. All the airports are located on a straight line. Each airport has unique id from 1 to n, Vladik's house is situated next to the airport with id a, and the place of the olympiad is situated next to the airport with id b. It is possible that Vladik's house and the place of the olympiad are located near the same airport. To get to the olympiad, Vladik can fly between any pair of airports any number of times, but he has to start his route at the airport a and finish it at the airport b.Each airport belongs to one of two companies. The cost of flight from the airport i to the airport j is zero if both airports belong to the same company, and |i - j| if they belong to different companies.Print the minimum cost Vladik has to pay to get to the olympiad. NoteIn the first example Vladik can fly to the airport 2 at first and pay |1 - 2| = 1 (because the airports belong to different companies), and then fly from the airport 2 to the airport 4 for free (because the airports belong to the same company). So the cost of the whole flight is equal to 1. It's impossible to get to the olympiad for free, so the answer is equal to 1. In the second example Vladik can fly directly from the airport 5 to the airport 2, because they belong to the same company. n,a,b = map(int,input().split())
s = input()
a-=1
b-=1
if(s[a]=='0'):
	if(s[b]=='0'):
		print(0)
	else:
		print(1)
	
else:
	if(s[b]=='1'):
		print(0)
	else:
		print(1)","['constructive algorithms', 'greedy', 'implementation']"
3206,"You are given a convex polygon P with n distinct vertices p1, p2, ..., pn. Vertex pi has coordinates (xi, yi) in the 2D plane. These vertices are listed in clockwise order.You can choose a real number D and move each vertex of the polygon a distance of at most D from their original positions.Find the maximum value of D such that no matter how you move the vertices, the polygon does not intersect itself and stays convex. NoteHere is a picture of the first sampleHere is an example of making the polygon non-convex.This is not an optimal solution, since the maximum distance we moved one point is  ≈ 0.4242640687, whereas we can make it non-convex by only moving each point a distance of at most  ≈ 0.3535533906. #!/usr/bin/env python3

from decimal import Decimal


def dist(a, b):
    x1, y1 = a
    x2, y2 = b
    return Decimal((x1-x2)**2+(y1-y2)**2).sqrt()


def minh(a, b, c):
    m = dist(a, b)
    n = dist(b, c)
    k = dist(a, c)
    p = Decimal(m + n + k)/2
    sqp = (p*(p-m)*(p-n)*(p-k)).sqrt()
    hm = (Decimal(2)/m)*sqp
    hn = (Decimal(2)/n)*sqp
    hk = (Decimal(2)/k)*sqp
    return min([hm, hn, hk])


def solve():
    n = int(input())
    coords = []
    for i in range(n):
        coords.append(tuple(map(int, input().split())))
    coords += coords

    res = min(
        minh(coords[i], coords[i+1], coords[i+2])
        for i in range(n))

    print(res/2)

if __name__ == '__main__':
    solve()
","['brute force', 'geometry', 'greedy']"
3164,"Hemose was shopping with his friends Samez, AhmedZ, AshrafEzz, TheSawan and O_E in Germany. As you know, Hemose and his friends are problem solvers, so they are very clever. Therefore, they will go to all discount markets in Germany.Hemose has an array of $$$n$$$ integers. He wants Samez to sort the array in the non-decreasing order. Since it would be a too easy problem for Samez, Hemose allows Samez to use only the following operation:Choose indices $$$i$$$ and $$$j$$$ such that $$$1 \le i, j \le n$$$, and $$$\lvert i - j \rvert \geq x$$$. Then, swap elements $$$a_i$$$ and $$$a_j$$$.Can you tell Samez if there's a way to sort the array in the non-decreasing order by using the operation written above some finite number of times (possibly $$$0$$$)? NoteIn the first test case, you can't do any operations.In the second test case, the array is already sorted.In the third test case, you can do the operations as follows:   $$$[5,1,2,3,4]$$$, $$$swap(a_1,a_3)$$$  $$$[2,1,5,3,4]$$$, $$$swap(a_2,a_5)$$$  $$$[2,4,5,3,1]$$$, $$$swap(a_2,a_4)$$$  $$$[2,3,5,4,1]$$$, $$$swap(a_1,a_5)$$$  $$$[1,3,5,4,2]$$$, $$$swap(a_2,a_5)$$$  $$$[1,2,5,4,3]$$$, $$$swap(a_3,a_5)$$$  $$$[1,2,3,4,5]$$$ (Here $$$swap(a_i, a_j)$$$ refers to swapping elements at positions $$$i$$$, $$$j$$$). from sys import stdin
input()
ans = []
for line in stdin:
    n, x = map(int, line.split())
    a = list(map(int, input().split()))
    if 2*x <= n:
        ans.append('yes')
        continue
    b = a[n-x:x]
    a.sort()
    if b == a[n - x : x]:
        ans.append('yes')
    else:
        ans.append('NO')
print('\n'.join(ans))","['constructive algorithms', 'dsu', 'math', 'sortings']"
4160,"This is the easy version of the problem. The difference between the versions is the constraints on $$$a_i$$$. You can make hacks only if all versions of the problem are solved.Little Dormi has recently received a puzzle from his friend and needs your help to solve it. The puzzle consists of an upright board with $$$n$$$ rows and $$$m$$$ columns of cells, some empty and some filled with blocks of sand, and $$$m$$$ non-negative integers $$$a_1,a_2,\ldots,a_m$$$ ($$$0 \leq a_i \leq n$$$). In this version of the problem, $$$a_i$$$ will be equal to the number of blocks of sand in column $$$i$$$.When a cell filled with a block of sand is disturbed, the block of sand will fall from its cell to the sand counter at the bottom of the column (each column has a sand counter). While a block of sand is falling, other blocks of sand that are adjacent at any point to the falling block of sand will also be disturbed and start to fall. Specifically, a block of sand disturbed at a cell $$$(i,j)$$$ will pass through all cells below and including the cell $$$(i,j)$$$ within the column, disturbing all adjacent cells along the way. Here, the cells adjacent to a cell $$$(i,j)$$$ are defined as $$$(i-1,j)$$$, $$$(i,j-1)$$$, $$$(i+1,j)$$$, and $$$(i,j+1)$$$ (if they are within the grid). Note that the newly falling blocks can disturb other blocks.In one operation you are able to disturb any piece of sand. The puzzle is solved when there are at least $$$a_i$$$ blocks of sand counted in the $$$i$$$-th sand counter for each column from $$$1$$$ to $$$m$$$.You are now tasked with finding the minimum amount of operations in order to solve the puzzle. Note that Little Dormi will never give you a puzzle that is impossible to solve. NoteFor example $$$1$$$, by disturbing both blocks of sand on the first row from the top at the first and sixth columns from the left, and the block of sand on the second row from the top and the fourth column from the left, it is possible to have all the required amounts of sand fall in each column. It can be proved that this is not possible with fewer than $$$3$$$ operations, and as such the answer is $$$3$$$. Here is the puzzle from the first example.  For example $$$2$$$, by disturbing the cell on the top row and rightmost column, one can cause all of the blocks of sand in the board to fall into the counters at the bottom. Thus, the answer is $$$1$$$. Here is the puzzle from the second example.    import io,os
from collections import deque 

input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline









def find_scc(graph):

#    print(graph)

    SCC, S, P = [], [], []
    depth = [0] * len(graph)
 
    stack = list(range(len(graph)))
    while stack:
        node = stack.pop()
        if node < 0:
            d = depth[~node] - 1
            if P[-1] > d:
                SCC.append(S[d:])
                del S[d:], P[-1]
                for node in SCC[-1]:
                    depth[node] = -1
        elif depth[node] > 0:
            while P[-1] > depth[node]:
                P.pop()
        elif depth[node] == 0:
            S.append(node)
            P.append(len(S))
            depth[node] = len(S)
            stack.append(~node)
            stack += graph[node]
    return SCC[::-1]
            
                







    






def main(t):




    m,n = map(int,input().split())
    grid = []
    for i in range(m):
        grid.append(list(input()))

    arr = list(map(int,input().split()))


    neigh = [[] for i in range(m*n)]
    direc = [[0,-1],[0,1],[-1,0],[1,0]]

    totedge = 0


    for j in range(n):
        last = -2
        i = 0
        while i<m and grid[i][j]!=ord('#'):  i += 1
        while i<m:

            if last!=-2:   neigh[last*n+j].append(i*n+j)
            if last+1==i:  neigh[i*n+j].append(last*n+j)
            last,under = i,i
            while under<m:
                if j>0 and grid[under][j-1]==ord('#'):
                   
                    neigh[i*n+j].append(under*n+j-1)
                    if under==i:  neigh[under*n+j-1].append(i*n+j)
                if j+1<n and grid[under][j+1]==ord('#'):
                    neigh[i*n+j].append(under*n+j+1)
                    if under==i:  neigh[under*n+j+1].append(i*n+j)
                under += 1
                if under==m or grid[under][j]==ord('#'): break
            i = under



    



#    if m==632 and totedge>1000000:
#        print(totedge)
#        return 
    
    scc = find_scc(neigh)

    group = [0]*(m*n)
    for index in range(len(scc)):
        for c in scc[index]:
            group[c] = index  

    innum = [0]*len(scc)



    for i in range(m*n):
        for e in neigh[i]:
            if group[i]!=group[e]:  innum[group[e]] += 1

    ans = 0
    
    for i in range(m):
        for j in range(n):
            if grid[i][j]==ord('#') and innum[group[i*n+j]] == 0:
                innum[group[i*n+j]] = -1
                ans += 1

   

        




    print(ans)

























T = 1 #int(input())
t = 1
while t<=T:
    main(t)
    t += 1
","['dfs and similar', 'graphs', 'greedy']"
2233,"A MIPT student named Misha has a birthday today, and he decided to celebrate it in his country house in suburban Moscow. n friends came by, and after a typical party they decided to play blind man's buff.The birthday boy gets blindfolded and the other players scatter around the house. The game is played in several rounds. In each round, Misha catches exactly one of his friends and has to guess who it is. The probability of catching the i-th friend does not change between rounds and is equal to pi percent (as we know, it is directly proportional to the amount of alcohol consumed by the i-th friend) and p1 + p2 + ... + pn = 100 holds. Misha has no information about who he caught. After Misha makes an attempt to guess the caught person, the round ends. Even then, Misha isn't told whether he guessed correctly, and a new round begins.The game ends when Misha guesses every friend at least once, that is, there exists such set of rounds k1, k2, ..., kn, that during round number ki Misha caught the i-th friend and guessed him. Misha wants to minimize the expectation of the number of rounds of the game. Despite the fact that at any point in the game Misha has no information about who he has already guessed, his friends are honest, and if they see that the condition for the end of the game is fulfilled, the game ends immediately. Find the expectation of the number of rounds in the game if Misha plays optimally. NoteThe optimal strategy in the first sample is to guess friends alternately. import random

N = int(input())
prob = [float(x)/100 for x in input().strip().split()]
prob_sum = []
cur = 0
for i in range(N):
    cur += prob[i]
    prob_sum.append(cur)

def experiment():
    cur_prob = [1.] * N
    cur_exp = 0
    for i in range(200000):

        bp = [prob[i] * cur_prob[i] / (1-cur_prob[i]+1E-100) for i in range(N)]
        mn = max(bp)
        for j in range(N):
            if bp[j] == mn:
                choice = j
        cur_prob[choice] *= 1-prob[choice]
        tp = 1
        for j in range(N):
            tp *= (1-cur_prob[j])
        tp = 1 - tp
        cur_exp += tp

    return cur_exp + 1

ans = experiment()
print(ans)
","['greedy', 'math', 'probabilities']"
831,"This problem is same as the previous one, but has larger constraints.Shiro's just moved to the new house. She wants to invite all friends of her to the house so they can play monopoly. However, her house is too small, so she can only invite one friend at a time.For each of the $$$n$$$ days since the day Shiro moved to the new house, there will be exactly one cat coming to the Shiro's house. The cat coming in the $$$i$$$-th day has a ribbon with color $$$u_i$$$. Shiro wants to know the largest number $$$x$$$, such that if we consider the streak of the first $$$x$$$ days, it is possible to remove exactly one day from this streak so that every ribbon color that has appeared among the remaining $$$x - 1$$$ will have the same number of occurrences.For example, consider the following sequence of $$$u_i$$$: $$$[2, 2, 1, 1, 5, 4, 4, 5]$$$. Then $$$x = 7$$$ makes a streak, since if we remove the leftmost $$$u_i = 5$$$, each ribbon color will appear exactly twice in the prefix of $$$x - 1$$$ days. Note that $$$x = 8$$$ doesn't form a streak, since you must remove exactly one day. Since Shiro is just a cat, she is not very good at counting and needs your help finding the longest streak. NoteIn the first example, we can choose the longest streak of $$$13$$$ days, since upon removing the last day out of the streak, all of the remaining colors $$$1$$$, $$$2$$$, $$$3$$$, and $$$4$$$ will have the same number of occurrences of $$$3$$$. Note that the streak can also be $$$10$$$ days (by removing the $$$10$$$-th day from this streak) but we are interested in the longest streak.In the fourth example, if we take the streak of the first $$$6$$$ days, we can remove the third day from this streak then all of the remaining colors $$$1$$$, $$$2$$$, $$$3$$$, $$$4$$$ and $$$5$$$ will occur exactly once. n = int(input())
a = input().split()
b = {}
c = []
q = 1
max1 = 1
prevmax = 0
countprev = 0
countmax = 1
countmin = 0



for i in range(n):
    if max1 == prevmax and (i>n//max1+max1):
        break
   
    if a[i] in b:
        b[a[i]]+=1   
        if b[a[i]]==2:
            countmin-=1
        if b[a[i]]==max1:
            countmax += 1
        elif b[a[i]]==prevmax:
            countprev += 1
        elif b[a[i]]>max1:
            prevmax = max1
            max1 = b[a[i]]
            countprev = countmax-1
            countmax = 1
    
            
            
        
    else:
        b[a[i]]=1
        minb = 1
        countmin +=1
    if len(b) == i+1 or len(b)==i:
        q = i+1
    elif countprev == len(b)-1 and countmax ==1 and max1==prevmax+1 and max1 >1:
        q = i+1
    elif countmax == len(b)-1 and countmin ==1 and max1 >1:
        q = i+1
print(q)","['data structures', 'implementation']"
239,"Quite recently, a very smart student named Jury decided that lectures are boring, so he downloaded a game called ""Black Square"" on his super cool touchscreen phone.In this game, the phone's screen is divided into four vertical strips. Each second, a black square appears on some of the strips. According to the rules of the game, Jury must use this second to touch the corresponding strip to make the square go away. As Jury is both smart and lazy, he counted that he wastes exactly ai calories on touching the i-th strip.You've got a string s, describing the process of the game and numbers a1, a2, a3, a4. Calculate how many calories Jury needs to destroy all the squares? nan o, t, th, f = map(int, input().split())
s = input()
S = 0
for i in s:
    if int(i)==1:
        S += o
    elif int(i)==2:
        S += t
    elif int(i)==3:
        S += th
    else:
        S += f
print(S)",['implementation']
4627,"You are given three integers $$$n$$$, $$$k$$$, $$$m$$$ and $$$m$$$ conditions $$$(l_1, r_1, x_1), (l_2, r_2, x_2), \dots, (l_m, r_m, x_m)$$$.Calculate the number of distinct arrays $$$a$$$, consisting of $$$n$$$ integers such that:   $$$0 \le a_i &lt; 2^k$$$ for each $$$1 \le i \le n$$$;  bitwise AND of numbers $$$a[l_i] \&amp; a[l_i + 1] \&amp; \dots \&amp; a[r_i] = x_i$$$ for each $$$1 \le i \le m$$$. Two arrays $$$a$$$ and $$$b$$$ are considered different if there exists such a position $$$i$$$ that $$$a_i \neq b_i$$$. The number can be pretty large so print it modulo $$$998244353$$$. NoteYou can recall what is a bitwise AND operation here.In the first example, the answer is the following arrays: $$$[3, 3, 7, 6]$$$, $$$[3, 7, 7, 6]$$$ and $$$[7, 3, 7, 6]$$$. import sys
range = xrange
input = raw_input

MOD = 998244353 
def red(x):
    return x if x < MOD else x - MOD

inp = [int(x) for x in sys.stdin.read().split()]; ii = 0
n = inp[ii]; ii += 1
k = inp[ii]; ii += 1
m = inp[ii]; ii += 1

L = [x - 1 for x in inp[ii + 0: ii + 3 * m: 3]]
R = inp[ii + 1: ii + 3 * m: 3]
A = inp[ii + 2: ii + 3 * m: 3]

Lbuckets = [[] for _ in range(n + 1)]
Rbuckets = [[] for _ in range(n + 1)]
for i in range(m):
    Lbuckets[L[i]].append(i)
    Rbuckets[R[i]].append(i)

DP = [[0]*k for _ in range(n + 1)]
DP.append([1]*k)

Lind = [-1] * k
Rind = [0]  * k
marked = [1] * k
for i in range(n + 1):
    dp = DP[i]

    for ind in Lbuckets[i]:
        a = A[ind]
        r = R[ind]
        for j in range(k):
            if a & (1 << j) and Rind[j] < r:
                for x in range(Rind[j], r):
                    marked[j] = red(marked[j] + DP[x][j])
                Rind[j] = r
    for ind in Rbuckets[i]:
        a = A[ind]
        l = L[ind]
        for j in range(k):
            if not a & (1 << j) and Lind[j] < l:
                for x in range(Lind[j], l):
                    marked[j] = red(marked[j] - DP[x][j] + MOD)
                Lind[j] = l
    
    for j in range(k):
        if i == Rind[j]:
            dp[j] = marked[j]
            marked[j] = red(marked[j] + dp[j])
            Rind[j] += 1

prod = 1
for j in range(k):
    prod = prod * DP[n][j] % MOD

print prod
","['bitmasks', 'combinatorics', 'data structures', 'dp', 'two pointers']"
1370,"There are $$$n$$$ positive integers $$$a_1, a_2, \dots, a_n$$$. For the one move you can choose any even value $$$c$$$ and divide by two all elements that equal $$$c$$$.For example, if $$$a=[6,8,12,6,3,12]$$$ and you choose $$$c=6$$$, and $$$a$$$ is transformed into $$$a=[3,8,12,3,3,12]$$$ after the move.You need to find the minimal number of moves for transforming $$$a$$$ to an array of only odd integers (each element shouldn't be divisible by $$$2$$$). NoteIn the first test case of the example, the optimal sequence of moves can be as follows:  before making moves $$$a=[40, 6, 40, 3, 20, 1]$$$;  choose $$$c=6$$$;  now $$$a=[40, 3, 40, 3, 20, 1]$$$;  choose $$$c=40$$$;  now $$$a=[20, 3, 20, 3, 20, 1]$$$;  choose $$$c=20$$$;  now $$$a=[10, 3, 10, 3, 10, 1]$$$;  choose $$$c=10$$$;  now $$$a=[5, 3, 5, 3, 5, 1]$$$ — all numbers are odd. Thus, all numbers became odd after $$$4$$$ moves. In $$$3$$$ or fewer moves, you cannot make them all odd. a = int(input())
for i in range(a):
    f = int(input())
    k = list(map(int, input().split()))
    l = set()
    ch = 0
    lol = 0
    for i in range(len(k)):
        lol = k[i]
        while lol % 2 == 0:
            l.add(lol)
            lol /= 2
    print(len(l))
","['greedy', 'number theory']"
3945,"Yaroslav, Andrey and Roman can play cubes for hours and hours. But the game is for three, so when Roman doesn't show up, Yaroslav and Andrey play another game. Roman leaves a word for each of them. Each word consists of 2·n binary characters ""0"" or ""1"". After that the players start moving in turns. Yaroslav moves first. During a move, a player must choose an integer from 1 to 2·n, which hasn't been chosen by anybody up to that moment. Then the player takes a piece of paper and writes out the corresponding character from his string. Let's represent Yaroslav's word as s = s1s2... s2n. Similarly, let's represent Andrey's word as t = t1t2... t2n. Then, if Yaroslav choose number k during his move, then he is going to write out character sk on the piece of paper. Similarly, if Andrey choose number r during his move, then he is going to write out character tr on the piece of paper.The game finishes when no player can make a move. After the game is over, Yaroslav makes some integer from the characters written on his piece of paper (Yaroslav can arrange these characters as he wants). Andrey does the same. The resulting numbers can contain leading zeroes. The person with the largest number wins. If the numbers are equal, the game ends with a draw.You are given two strings s and t. Determine the outcome of the game provided that Yaroslav and Andrey play optimally well. nan from sys import stdin

def readLine():
  return stdin.readline();

def main():
  while True:
    n = int(readLine());
    a = readLine();
    b = readLine();
    both = 0;
    onlyA = 0; onlyB = 0;
    for i in range(2*n):
      if a[i] == '1' and b[i] == '1':
        both += 1;
      elif a[i] == '1':
        onlyA += 1;
      elif b[i] == '1':
        onlyB += 1;
    A = 0; B = 0;
    for i in range(n):
      if both:
        A += 1;
        both -= 1;
      elif onlyA:
        A += 1;
        onlyA -= 1;
      elif onlyB:
        onlyB -= 1;
      if both:
        B += 1;
        both -= 1;
      elif onlyB:
        B += 1;
        onlyB -= 1;
      elif onlyA:
        onlyA -= 1;
    if A > B:
      print( ""First"" );
    elif A < B:
      print( ""Second"" );
    else:
      print( ""Draw"" );
    break;

main();
","['games', 'greedy']"
4220,"There are $$$n$$$ armchairs, numbered from $$$1$$$ to $$$n$$$ from left to right. Some armchairs are occupied by people (at most one person per armchair), others are not. The number of occupied armchairs is not greater than $$$\frac{n}{2}$$$.For some reason, you would like to tell people to move from their armchairs to some other ones. If the $$$i$$$-th armchair is occupied by someone and the $$$j$$$-th armchair is not, you can tell the person sitting in the $$$i$$$-th armchair to move to the $$$j$$$-th armchair. The time it takes a person to move from the $$$i$$$-th armchair to the $$$j$$$-th one is $$$|i - j|$$$ minutes. You may perform this operation any number of times, but these operations must be done sequentially, i. e. you cannot tell a person to move until the person you asked to move in the last operation has finished moving to their destination armchair.You want to achieve the following situation: every seat that was initially occupied must be free. What is the minimum time you need to do it? NoteIn the first test, you can perform the following sequence:  ask a person to move from armchair $$$1$$$ to armchair $$$2$$$, it takes $$$1$$$ minute;  ask a person to move from armchair $$$7$$$ to armchair $$$6$$$, it takes $$$1$$$ minute;  ask a person to move from armchair $$$4$$$ to armchair $$$5$$$, it takes $$$1$$$ minute. In the second test, you can perform the following sequence:  ask a person to move from armchair $$$1$$$ to armchair $$$4$$$, it takes $$$3$$$ minutes;  ask a person to move from armchair $$$2$$$ to armchair $$$6$$$, it takes $$$4$$$ minutes;  ask a person to move from armchair $$$4$$$ to armchair $$$5$$$, it takes $$$1$$$ minute;  ask a person to move from armchair $$$3$$$ to armchair $$$4$$$, it takes $$$1$$$ minute. In the third test, no seat is occupied so your goal is achieved instantly. inf = float('inf')

n = int(input())
li = list(map(int, input().split()))

inits = []
empties = []
dp = [[0] * n for _ in range(n)]
for i in range(n):
    if li[i]:
        inits.append(i)
    else:
        empties.append(i)
        
init_len = len(inits)
empty_len = len(empties)
        
if not inits:
    print(0)
else:
    dp = [[inf] * empty_len for _ in range(init_len)]
    for ei in range(empty_len):
        dp[0][ei] = abs(empties[ei] - inits[0])
        if ei >= 1:
            dp[0][ei] = min(dp[0][ei - 1], dp[0][ei])
            
    for ii in range(1, init_len):
        for ei in range(ii, empty_len):
            dp[ii][ei] = dp[ii - 1][ei - 1] + abs(empties[ei] - inits[ii])
            dp[ii][ei] = min(dp[ii][ei - 1], dp[ii][ei])
            
    print(dp[-1][-1])","['dp', 'greedy', 'other']"
3621,"The Travelling Salesman spends a lot of time travelling so he tends to get bored. To pass time, he likes to perform operations on numbers. One such operation is to take a positive integer x and reduce it to the number of bits set to 1 in the binary representation of x. For example for number 13 it's true that 1310 = 11012, so it has 3 bits set and 13 will be reduced to 3 in one operation.He calls a number special if the minimum number of operations to reduce it to 1 is k.He wants to find out how many special numbers exist which are not greater than n. Please help the Travelling Salesman, as he is about to reach his destination!Since the answer can be large, output it modulo 109 + 7. NoteIn the first sample, the three special numbers are 3, 5 and 6. They get reduced to 2 in one operation (since there are two set bits in each of 3, 5 and 6) and then to 1 in one more operation (since there is only one set bit in 2). dpc=[1]
dpci=[]
for i in range(1,2000):
    dpc.append((dpc[i-1]*i)%1000000007)
def modInverse(a, m) :
    m0 = m
    y = 0
    x = 1
    if (m == 1) :
        return 0
    while (a > 1) :
        q = a // m
        t = m
        m = a % m
        a = t
        t = y
        y = x - q * y
        x = t
    if (x < 0) :
        x = x + m0
    return x
for i in dpc:
    dpci.append(modInverse(i,1000000007))
def c(n,r):
    if(r<0):
        return 0
    if(n<r):
        return 0
    if(n<0):
        return 0
    return dpc[n]*dpci[r]*dpci[n-r]

dp={1:0}
def f(n):
    x=n
    b=0
    while x!=0:
        x=x&(x-1)
        b+=1
    dp[n]=dp[b]+1
for i in range(2,1001):
    f(i)
a=[[],[],[],[],[]]
for i in dp:
    a[dp[i]].append(i)
n=input()
l=len(n)
x=[]
for i in range(l):
    if n[i]=='1':
        x.append(i)
#print(l)
k=int(input())
if k>5:
    print(0)
elif k==0:
    print(1)
else:
    ans=0
    for i in a[k-1]:
        r=0
        for j in x:
            if i-r<0:
                break
            xy=c(l-j-1,i-r)
            #print(l-j-1,i-r,xy)
            ans=(ans+xy)%1000000007
            r+=1
    if len(x) in a[k-1] and len(x)!=1:
        ans+=1
    if len(x)>1 and k==1:
        ans-=1
    print(ans)","['brute force', 'combinatorics', 'dp']"
192,"You are given a sequence $$$a$$$, initially consisting of $$$n$$$ integers.You want to transform this sequence so that all elements in it are equal (i. e. it contains several occurrences of the same element).To achieve this, you choose some integer $$$x$$$ that occurs at least once in $$$a$$$, and then perform the following operation any number of times (possibly zero): choose some segment $$$[l, r]$$$ of the sequence and remove it. But there is one exception: you are not allowed to choose a segment that contains $$$x$$$. More formally, you choose some contiguous subsequence $$$[a_l, a_{l + 1}, \dots, a_r]$$$ such that $$$a_i \ne x$$$ if $$$l \le i \le r$$$, and remove it. After removal, the numbering of elements to the right of the removed segment changes: the element that was the $$$(r+1)$$$-th is now $$$l$$$-th, the element that was $$$(r+2)$$$-th is now $$$(l+1)$$$-th, and so on (i. e. the remaining sequence just collapses).Note that you can not change $$$x$$$ after you chose it.For example, suppose $$$n = 6$$$, $$$a = [1, 3, 2, 4, 1, 2]$$$. Then one of the ways to transform it in two operations is to choose $$$x = 1$$$, then:  choose $$$l = 2$$$, $$$r = 4$$$, so the resulting sequence is $$$a = [1, 1, 2]$$$;  choose $$$l = 3$$$, $$$r = 3$$$, so the resulting sequence is $$$a = [1, 1]$$$. Note that choosing $$$x$$$ is not an operation. Also, note that you can not remove any occurrence of $$$x$$$.Your task is to find the minimum number of operations required to transform the sequence in a way described above.You have to answer $$$t$$$ independent test cases. nan def CountFrequency(my_list): 
    freq = {} 
    for item in my_list: 
        if (item in freq): 
            freq[item] += 1
        else: 
            freq[item] = 1
    return freq
for _ in range(int(input())):
    n=int(input())
    l=list(map(int,input().split()))
    arr=[l[0]]
    for i in range(1,n):
        if(arr[-1]!=l[i]):
            arr.append(l[i])
    d=CountFrequency(arr)
    d[arr[0]]-=1
    d[arr[-1]]-=1
    print(min(d.values())+1)","['greedy', 'implementation']"
3671,"You are given a rectangular grid of lattice points from (0, 0) to (n, m) inclusive. You have to choose exactly 4 different points to build a polyline possibly with self-intersections and self-touching. This polyline should be as long as possible.A polyline defined by points p1, p2, p3, p4 consists of the line segments p1 p2, p2 p3, p3 p4, and its length is the sum of the lengths of the individual line segments. nan import sys
import itertools
from math import *
n, m = map(int, raw_input().split("" ""))

a, b = None, None
for i in xrange(0, n + 1):
    for j in xrange(0, m + 1):
        if not ((i, j) in [(0, 0), (n, m)]):
            if a == None and b == None:
                a = i
                b = j
            else:
                if (0 - i)**2 + (0 - j)**2 > (0 - a)**2 + (0 - b)**2:
                    a, b = i, j
v = [(a, b), (0, 0)]

c, d = a, b
a, b = None, None
for i in xrange(0, n + 1):
    for j in xrange(0, m + 1):
        if not ((i, j) in [(0, 0), (n, m), (c, d)]):
            if a == None and b == None:
                a = i
                b = j
            else:
                if (n - i)**2 + (m - j)**2 > (n - a)**2 + (m - b)**2:
                    a, b = i, j
v += [(n, m), (a, b)]

#print v

def d(x):
    return sqrt((x[1][0] - x[0][0])**2 + (x[1][1] - x[0][1])**2) + sqrt((x[2][0] - x[1][0])**2 + (x[2][1] - x[1][1])**2) + sqrt((x[3][0] - x[2][0])**2 + (x[3][1] - x[2][1])**2)

v = list(itertools.permutations(v))
if n != 0 and m != 0:
    v += list(itertools.permutations([(0, 0), (n, m), (n, 0), (0, m)]))
for a in sorted(zip(map(d, v), v))[-1][1]:
    print ""%d %d"" % a","['brute force', 'constructive algorithms', 'geometry', 'trees']"
3770,"Skier rides on a snowy field. Its movements can be described by a string of characters 'S', 'N', 'W', 'E' (which correspond to $$$1$$$ meter movement in the south, north, west or east direction respectively).It is known that if he moves along a previously unvisited segment of a path (i.e. this segment of the path is visited the first time), then the time of such movement is $$$5$$$ seconds. If he rolls along previously visited segment of a path (i.e., this segment of the path has been covered by his path before), then it takes $$$1$$$ second.Find the skier's time to roll all the path. nan import sys, math
input = sys.stdin.readline

def main():
     t = int(input())
     for _ in range(t):
          s = input().replace(""\n"","""")
          se = set()
          inc = 0
          co = (0,0)
          se.add((co,co))
          for x in range(len(s)):
               last_co = co
               if s[x] == ""N"":
                    co = (co[0]+1,co[1])
               if s[x] == ""S"":
                    co = (co[0]-1,co[1])
               if s[x] == ""W"":
                    co = (co[0],co[1]-1)
               if s[x] == ""E"":
                    co = (co[0],co[1]+1)
               if True:
                    if (co,last_co) in se:
                         inc += 1
                    else:
                         se.add((last_co,co))
                         se.add((co,last_co))
                         inc += 5
          print(inc)
          
          
          
main()
","['data structures', 'implementation']"
3997,"While sailing on a boat, Inessa noticed a beautiful water lily flower above the lake's surface. She came closer and it turned out that the lily was exactly $$$H$$$ centimeters above the water surface. Inessa grabbed the flower and sailed the distance of $$$L$$$ centimeters. Exactly at this point the flower touched the water surface.  Suppose that the lily grows at some point $$$A$$$ on the lake bottom, and its stem is always a straight segment with one endpoint at point $$$A$$$. Also suppose that initially the flower was exactly above the point $$$A$$$, i.e. its stem was vertical. Can you determine the depth of the lake at point $$$A$$$? nan from math import sqrt

h, l = map(int, input().split())
print((l * l - h * h) / (2 * h))","['geometry', 'math']"
4184,"Iahub is playing an uncommon game. Initially, he has n boxes, numbered 1, 2, 3, ..., n. Each box has some number of candies in it, described by a sequence a1, a2, ..., an. The number ak represents the number of candies in box k. The goal of the game is to move all candies into exactly two boxes. The rest of n - 2 boxes must contain zero candies. Iahub is allowed to do several (possible zero) moves. At each move he chooses two different boxes i and j, such that ai ≤ aj. Then, Iahub moves from box j to box i exactly ai candies. Obviously, when two boxes have equal number of candies, box number j becomes empty.Your task is to give him a set of moves such as Iahub to archive the goal of the game. If Iahub can't win the game for the given configuration of boxes, output -1. Please note that in case there exist a solution, you don't need to print the solution using minimal number of moves. NoteFor the first sample, after the first move the boxes will contain 3, 12 and 3 candies. After the second move, the boxes will contain 6, 12 and 0 candies. Now all candies are in exactly 2 boxes.For the second sample, you can observe that the given configuration is not valid, as all candies are in a single box and they should be in two boxes. Also, any move won't change the configuration, so there exists no solution.For the third sample, all candies are already in 2 boxes. Hence, no move is needed. n=int(raw_input())
a=map(int,raw_input().split())
ans=[]
zp=[i for i in xrange(0,n) if (a[i]!=0)]
def solve(z):
	while 1:
		for i in xrange(0,2):
			for j in xrange(i+1,3):
				if (a[z[i]]>a[z[j]]): z[i],z[j]=z[j],z[i]
		if (a[z[0]]==0): break
		x=a[z[1]]/a[z[0]]
		for i in xrange(0,25):
			if (2**i>x): break
			p,q=z[0],z[2]
			if ((x>>i)&1): q=z[1]
			ans.append([p+1,q+1])
			a[p],a[q]=2*a[p],a[q]-a[p]
if (len(zp)<=1): print -1
else:
	while (len(zp)>2):
		solve(zp[0:3])
		zp=[i for i in xrange(0,n) if (a[i]!=0)]
	print len(ans)
	print ""\n"".join(map(lambda x:"" "".join(map(str,x)),ans))
","['constructive algorithms', 'greedy']"
926,"A tree is a connected graph without cycles. A rooted tree has a special vertex called the root. The parent of a vertex $$$v$$$ (different from root) is the previous to $$$v$$$ vertex on the shortest path from the root to the vertex $$$v$$$. Children of the vertex $$$v$$$ are all vertices for which $$$v$$$ is the parent.A vertex is a leaf if it has no children. We call a vertex a bud, if the following three conditions are satisfied:   it is not a root,  it has at least one child, and  all its children are leaves. You are given a rooted tree with $$$n$$$ vertices. The vertex $$$1$$$ is the root. In one operation you can choose any bud with all its children (they are leaves) and re-hang them to any other vertex of the tree. By doing that you delete the edge connecting the bud and its parent and add an edge between the bud and the chosen vertex of the tree. The chosen vertex cannot be the bud itself or any of its children. All children of the bud stay connected to the bud.What is the minimum number of leaves it is possible to get if you can make any number of the above-mentioned operations (possibly zero)? NoteIn the first test case the tree looks as follows:  Firstly you can choose a bud vertex $$$4$$$ and re-hang it to vertex $$$3$$$. After that you can choose a bud vertex $$$2$$$ and re-hang it to vertex $$$7$$$. As a result, you will have the following tree with $$$2$$$ leaves:  It can be proved that it is the minimal number of leaves possible to get.In the second test case the tree looks as follows:  You can choose a bud vertex $$$3$$$ and re-hang it to vertex $$$5$$$. As a result, you will have the following tree with $$$2$$$ leaves:  It can be proved that it is the minimal number of leaves possible to get. from collections import deque
import heapq
from sys import *
input = stdin.readline

t = int(input())
for _ in range(t):
  n = int(input())

  graph = [set() for _ in range(n+1)]

  for i in range(n-1):
    c, d = map(int, input().split())
    graph[c].add(d)
    graph[d].add(c)

  dist = [-1] * (n+1)
  dist[0] = 0
  dist[1] = 0
  d = deque()
  d.append(1)

  parent = [0]*(n+1)

  while d:
    v = d.popleft()
    for i in graph[v]:
      if dist[i] != -1:
        continue
      dist[i] = dist[v] + 1
      d.append(i)
      parent[i] = v
  
  QUE = []
  for i in range(2,n+1):
    heapq.heappush(QUE, (-dist[i], i))

  budcnt = 0
  leafcnt = 0
  used = [0]*(n+1)
  while QUE:
    DIST, CHILD = heapq.heappop(QUE)
    if used[CHILD] == 0:
      used[CHILD] = 1
      PARENT = parent[CHILD]
      used[PARENT] = 1
      if PARENT != 1:
        leafcnt += len(graph[PARENT]) - 1
        budcnt += 1
        for x in graph[PARENT]:
          if dist[PARENT] < dist[x]:
            used[x]  = 1
        graph[parent[PARENT]].remove(PARENT)
  

  if len(graph[1]) == 0:
    print(leafcnt-(budcnt-1))
  else:
    print(len(graph[1])+leafcnt-budcnt)","['constructive algorithms', 'dfs and similar', 'dp', 'greedy', 'trees']"
1094,"You are given n points on a plane. All points are different.Find the number of different groups of three points (A, B, C) such that point B is the middle of segment AC. The groups of three points are considered unordered, that is, if point B is the middle of segment AC, then groups (A, B, C) and (C, B, A) are considered the same. nan n = int(input())
l1,l2 = [],[]
s = set()
for _ in range(n):
    a,b = map(int , input().split())
    s.add((a,b))
    l1.append(a)
    l2.append(b)
c=0
x,y=0,0
for i in range(n):
    for j in range(i+1,n):
        x,y = (l1[i]+l1[j]) , (l2[i]+l2[j])
        if abs(x)%2==0 and abs(y)%2==0:
            x,y=x//2,y//2
            if (x,y) in s:
                c+=1
            #print(c,(x,y))
print(c)
","['binary search', 'brute force']"
2464,"Yurii is sure he can do everything. Can he solve this task, though?He has an array $$$a$$$ consisting of $$$n$$$ positive integers. Let's call a subarray $$$a[l...r]$$$ good if the following conditions are simultaneously satisfied:   $$$l+1 \leq r-1$$$, i. e. the subarray has length at least $$$3$$$;  $$$(a_l \oplus a_r) = (a_{l+1}+a_{l+2}+\ldots+a_{r-2}+a_{r-1})$$$, where $$$\oplus$$$ denotes the bitwise XOR operation. In other words, a subarray is good if the bitwise XOR of the two border elements is equal to the sum of the rest of the elements. Yurii wants to calculate the total number of good subarrays. What is it equal to?An array $$$c$$$ is a subarray of an array $$$d$$$ if $$$c$$$ can be obtained from $$$d$$$ by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end. NoteThere are $$$6$$$ good subarrays in the example:   $$$[3,1,2]$$$ (twice) because $$$(3 \oplus 2) = 1$$$;  $$$[1,2,3]$$$ (twice) because $$$(1 \oplus 3) = 2$$$;  $$$[2,3,1]$$$ because $$$(2 \oplus 1) = 3$$$;  $$$[3,1,2,3,1,2,3,15]$$$ because $$$(3 \oplus 15) = (1+2+3+1+2+3)$$$.  n = input()
arr = map(int,raw_input().split())

dic = {}

output = 0
for i in range(n-2):
    num1 = 0
    for j in range(i+1,n-1):
        num1 += arr[j]
        if num1 > arr[i]*2: break
        num2 = arr[i] ^ arr[j+1]
        if num1 == num2: 
#            print i,j+1
            output += 1
            dic[i*n+j+1] = 1


for i in range(n-1,-1,-1):
    num1 = 0
    for j in range(i-1,0,-1):
        num1 += arr[j]
        if num1 > arr[i]*2: break
        num2 = arr[i] ^ arr[j-1]
        if num1 == num2:   
            if (j-1)*n+i not in dic: 
#                print j-1,i 
                output += 1





        


print output
","['binary search', 'bitmasks', 'brute force', 'constructive algorithms', 'divide and conquer', 'two pointers']"
3151,"Given an array $$$a$$$ of positive integers with length $$$n$$$, determine if there exist three distinct indices $$$i$$$, $$$j$$$, $$$k$$$ such that $$$a_i + a_j + a_k$$$ ends in the digit $$$3$$$. NoteIn the first test case, you can select $$$i=1$$$, $$$j=4$$$, $$$k=3$$$. Then $$$a_1 + a_4 + a_3 = 20 + 84 + 19 = 123$$$, which ends in the digit $$$3$$$.In the second test case, you can select $$$i=1$$$, $$$j=2$$$, $$$k=3$$$. Then $$$a_1 + a_2 + a_3 = 1 + 11 + 1 = 13$$$, which ends in the digit $$$3$$$.In the third test case, it can be proven that no such $$$i$$$, $$$j$$$, $$$k$$$ exist. Note that $$$i=4$$$, $$$j=4$$$, $$$k=4$$$ is not a valid solution, since although $$$a_4 + a_4 + a_4 = 1111 + 1111 + 1111 = 3333$$$, which ends in the digit $$$3$$$, the indices need to be distinct.In the fourth test case, it can be proven that no such $$$i$$$, $$$j$$$, $$$k$$$ exist.In the fifth test case, you can select $$$i=4$$$, $$$j=3$$$, $$$k=1$$$. Then $$$a_4 + a_3 + a_1 = 4 + 8 + 1 = 13$$$, which ends in the digit $$$3$$$.In the sixth test case, you can select $$$i=1$$$, $$$j=2$$$, $$$k=6$$$. Then $$$a_1 + a_2 + a_6 = 16 + 38 + 99 = 153$$$, which ends in the digit $$$3$$$. from collections import *
from heapq import *
from bisect import *
from itertools import *
from functools import *
from math import *
from string import *
import operator
import sys

input = sys.stdin.readline


def solve():
    n = int(input())
    A = list(map(int, input().split()))
    A = [x % 10 for x in A]
    count = Counter(A)

    arr = []
    for x in count:
        arr.extend([x] * min(count[x], 3))

    def two_sum(start, target):
        seen = set()
        for j in range(start, len(arr)):
            subtarget = (target - arr[j]) % 10
            if subtarget in seen:
                return True
            seen.add(arr[j])

        return False

    # A[i] + A[j] + A[k] == 3 % 10
    for k in range(len(arr)):
        if two_sum(k + 1, (3 - arr[k]) % 10):
            return True

    return False


def main():
    tests = int(input())
    for _ in range(tests):
        print(""YES"" if solve() else ""NO"")


if __name__ == ""__main__"":
    main()
","['brute force', 'math']"
2882,"The great hero guards the country where Homer lives. The hero has attack power $$$A$$$ and initial health value $$$B$$$. There are $$$n$$$ monsters in front of the hero. The $$$i$$$-th monster has attack power $$$a_i$$$ and initial health value $$$b_i$$$. The hero or a monster is said to be living, if his or its health value is positive (greater than or equal to $$$1$$$); and he or it is said to be dead, if his or its health value is non-positive (less than or equal to $$$0$$$).In order to protect people in the country, the hero will fight with monsters until either the hero is dead or all the monsters are dead.  In each fight, the hero can select an arbitrary living monster and fight with it. Suppose the $$$i$$$-th monster is selected, and the health values of the hero and the $$$i$$$-th monster are $$$x$$$ and $$$y$$$ before the fight, respectively. After the fight, the health values of the hero and the $$$i$$$-th monster become $$$x-a_i$$$ and $$$y-A$$$, respectively. Note that the hero can fight the same monster more than once.For the safety of the people in the country, please tell them whether the great hero can kill all the monsters (even if the great hero himself is dead after killing the last monster). NoteIn the first example: There will be $$$6$$$ fights between the hero and the only monster. After that, the monster is dead and the health value of the hero becomes $$$17 - 6 \times 2 = 5 &gt; 0$$$. So the answer is ""YES"", and moreover, the hero is still living.In the second example: After all monsters are dead, the health value of the hero will become $$$709$$$, regardless of the order of all fights. So the answer is ""YES"".In the third example: A possible order is to fight with the $$$1$$$-st, $$$2$$$-nd, $$$3$$$-rd and $$$4$$$-th monsters. After all fights, the health value of the hero becomes $$$-400$$$. Unfortunately, the hero is dead, but all monsters are also dead. So the answer is ""YES"".In the fourth example: The hero becomes dead but the monster is still living with health value $$$1000 - 999 = 1$$$. So the answer is ""NO"". 

ts = int(input())

for t in range(ts):
  A, B, n = map(int, input().split())
  ax = list(map(int, input().split()))
  bs = list(map(int, input().split()))
  
  msg = 'NO'
  for a, b in zip(ax, bs):
    km = b // A
    if b % A != 0:
      km += 1
    # IDEA: make the above more concise.
      
    B -= km * a
    
  if B >= 0:
    msg = 'YES'
  else:
    for a in ax:
      if B + a > 0:
        msg = 'YES'
        break
      
  print(msg)","['greedy', 'implementation', 'sortings']"
1849,"Captain Fint is involved in another treasure hunt, but have found only one strange problem. The problem may be connected to the treasure's location or may not. That's why captain Flint decided to leave the solving the problem to his crew and offered an absurdly high reward: one day off. The problem itself sounds like this...There are two arrays $$$a$$$ and $$$b$$$ of length $$$n$$$. Initially, an $$$ans$$$ is equal to $$$0$$$ and the following operation is defined:   Choose position $$$i$$$ ($$$1 \le i \le n$$$);  Add $$$a_i$$$ to $$$ans$$$;  If $$$b_i \neq -1$$$ then add $$$a_i$$$ to $$$a_{b_i}$$$. What is the maximum $$$ans$$$ you can get by performing the operation on each $$$i$$$ ($$$1 \le i \le n$$$) exactly once?Uncle Bogdan is eager to get the reward, so he is asking your help to find the optimal order of positions to perform the operation on them. nan import sys;input=sys.stdin.readline
N, = map(int, input().split())
X = [0]+list(map(int, input().split()))
Y = [0]+list(map(int, input().split()))
st = []
G = [set() for _ in range(N+1)]
for i in range(1, N+1):
    if Y[i] < 0:
        st.append(i)
    else:
        G[Y[i]].add(i)

ato = []
R = []
W = [0]*(N+1)
for s in st:
    stack = [s]
    vs_dfs = list()
    while stack:
        v = stack.pop()
        vs_dfs.append(v)
        for u in G[v]:
#            vs.add(u)
            stack.append(u)
    for v in vs_dfs[::-1]:
        for u in G[v]:
            X[v] += max(0, X[u])
        if X[v] < 0:
            ato.append(v)
        else:
            R.append(v)
ato = ato[::-1]
print(sum(X))
print(*(R+ato))
","['data structures', 'dfs and similar', 'graphs', 'greedy', 'implementation', 'trees']"
4217,"You are asked to build an array $$$a$$$, consisting of $$$n$$$ integers, each element should be from $$$1$$$ to $$$k$$$.The array should be non-decreasing ($$$a_i \le a_{i+1}$$$ for all $$$i$$$ from $$$1$$$ to $$$n-1$$$). You are also given additional constraints on it. Each constraint is of one of three following types:   $$$1~i~x$$$: $$$a_i$$$ should not be equal to $$$x$$$;  $$$2~i~j~x$$$: $$$a_i + a_j$$$ should be less than or equal to $$$x$$$;  $$$3~i~j~x$$$: $$$a_i + a_j$$$ should be greater than or equal to $$$x$$$. Build any non-decreasing array that satisfies all constraints or report that no such array exists. nan import sys
input = sys.stdin.readline

# TwoSat code from PyRival: https://github.com/cheran-senthil/PyRival/blob/9947ae98b7884614d98a5860764e85798c0cddfa/pyrival/data_structures/TwoSat.py
def find_SCC(graph):
    SCC, S, P = [], [], []
    depth = [0] * len(graph)

    stack = list(range(len(graph)))
    while stack:
        node = stack.pop()
        if node < 0:
            d = depth[~node] - 1
            if P[-1] > d:
                SCC.append(S[d:])
                del S[d:], P[-1]
                for node in SCC[-1]:
                    depth[node] = -1
        elif depth[node] > 0:
            while P[-1] > depth[node]:
                P.pop()
        elif depth[node] == 0:
            S.append(node)
            P.append(len(S))
            depth[node] = len(S)
            stack.append(~node)
            stack += graph[node]
    return SCC[::-1]

class TwoSat:
    def __init__(self, n):
        self.n = n
        self.graph = [[] for _ in range(2 * n)]

    def _imply(self, x, y):
        self.graph[x].append(y if y >= 0 else 2 * self.n + y)

    def either(self, x, y):
        """"""either x or y must be True""""""
        self._imply(~x, y)
        self._imply(~y, x)

    def set(self, x):
        """"""x must be True""""""
        self._imply(~x, x)

    def implies(self, x, y):
        self.either(~x, y)

    def solve(self):
        SCC = find_SCC(self.graph)
        order = [0] * (2 * self.n)
        for i, comp in enumerate(SCC):
            for x in comp:
                order[x] = i
        for i in range(self.n):
            if order[i] == order[~i]:
                return False, None
        return True, [+(order[i] > order[~i]) for i in range(self.n)]


class Helper:
    def __init__(self, i: int): self.i = i
    def __ge__(self, x: int): return self.i * (K+1) + x - 1
    def __lt__(self, x: int): return ~(self >= x)
    def __gt__(self, x: int): return self >= x + 1
    def __le__(self, x: int): return self < x + 1


out = []
for _ in range(int(input())):
    N, M, K = map(int, input().split())
    A = [Helper(i) for i in range(N)]
    ts = TwoSat(N*(K+1))

    for i in range(N):
        ts.set(A[i] >= 1)
        ts.set(A[i] <= K)

        for k in range(1, K):
            ts.implies(A[i] < k, A[i] < k+1)

        if i < N-1:
            for k in range(1, K+1):
                ts.implies(A[i] >= k, A[i+1] >= k)

    for _ in range(M):
        type, *args = map(int, input().split())
        if type == 1:
            i, x = args; i -= 1
            ts.either(A[i] < x, A[i] > x)
        else:
            i, j, x = args
            i -= 1; j -= 1

            if type == 2:
                for y in range(1, K+1):
                    if 1 <= x - y <= K:
                        ts.implies(A[i] >= y, A[j] <= x - y)
                        ts.implies(A[j] >= y, A[i] <= x - y)

                if x <= K:
                    ts.set(A[i] < x)
                    ts.set(A[j] < x)

            elif type == 3:
                for y in range(1, K+1):
                    if 1 <= x - y <= K:
                        ts.implies(A[i] <= y, A[j] >= x - y)
                        ts.implies(A[j] <= y, A[i] >= x - y)

                if x > K:
                    ts.set(A[i] >= x - K)
                    ts.set(A[j] >= x - K)

    ok, sol = ts.solve()
    if not ok:
        out.append(""-1"")
    else:
        ans = []
        for i in range(N):
            for k in range(K, 0, -1):
                if sol[A[i] >= k]:
                    ans.append(str(k))
                    break
            else:
                assert False

        out.append("" "".join(ans))

print(""\n"".join(out))
","['constructive algorithms', 'graphs', 'implementation', 'other']"
4806,"In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system. nan m = {}
for k in range(26):
    m[chr(65+k)] = 1+k

for abcdd in range(int(raw_input())):
    a = raw_input()
    for k in range(len(a)):
        if a[k].isdigit():
            a, b = a[:k], a[k:]
            break
    if b.isdigit():
        n = 0
        for k in a:
            n = n * 26 + m[k]
        print 'R' + b + 'C' + str(n)
    else:
        c, b = b.split('C')
        a = ''
        b = int(b)
        while b:
            a = chr(65+(b-1)%26) + a
            b = int((b-1) / 26)
        print a + c","['implementation', 'math']"
800,"Janusz is a businessman. He owns a company ""Januszex"", which produces games for teenagers. Last hit of Januszex was a cool one-person game ""Make it one"". The player is given a sequence of $$$n$$$ integers $$$a_i$$$.It is allowed to select any subset of them, and the score is equal to the greatest common divisor of selected elements. The goal is to take as little elements as it is possible, getting the score $$$1$$$. Now Janusz wonders, for given sequence, how much elements should the player choose? NoteIn the first example, selecting a subset of all numbers gives a gcd of $$$1$$$ and for all smaller subsets the gcd is greater than $$$1$$$.In the second example, for all subsets of numbers the gcd is at least $$$2$$$.  mod = int(1e9+7)
N = int(3e5+7)
fact = [0]*(N)
invfact = [0]*(N)
cnt = [0]*N
def ncr(n, r): 
    r = min(r, n-r)
    if n<r or r<0:
        return 0
    return ((fact[n] * invfact[r]) % mod * invfact[n-r]) % mod
fact[0] = 1
for i in range(1,N):
    fact[i] = (fact[i - 1] * i) % mod;
invfact[N-1] = pow(fact[N-1],mod-2,mod)
for i in range(N-1,0,-1):
    invfact[i-1] = (invfact[i]*i)%mod
n = int(raw_input(''))
a = map(int,raw_input().strip('\n').split(' '))
for i in a:
	cnt[i] += 1
for i in range(1,N):
	for j in range(i+i,N,i):
		cnt[i]+=cnt[j]
ans = -1
for i in range(1,10):
	dp = [0]*N
	for j in range(N-1,0,-1):
		dp[j]=ncr(cnt[j],i)
		for k in range(j+j,N,j):
			dp[j] = (dp[j]-dp[k])%mod
	if dp[1]>0:
		ans = i
		break
print ans","['bitmasks', 'combinatorics', 'dp', 'math', 'number theory', 'shortest paths']"
3399,"There are n parliamentarians in Berland. They are numbered with integers from 1 to n. It happened that all parliamentarians with odd indices are Democrats and all parliamentarians with even indices are Republicans.New parliament assembly hall is a rectangle consisting of a × b chairs — a rows of b chairs each. Two chairs are considered neighbouring if they share as side. For example, chair number 5 in row number 2 is neighbouring to chairs number 4 and 6 in this row and chairs with number 5 in rows 1 and 3. Thus, chairs have four neighbours in general, except for the chairs on the border of the hallWe know that if two parliamentarians from one political party (that is two Democrats or two Republicans) seat nearby they spent all time discussing internal party issues.Write the program that given the number of parliamentarians and the sizes of the hall determine if there is a way to find a seat for any parliamentarian, such that no two members of the same party share neighbouring seats. NoteIn the first sample there are many other possible solutions. For example, 3 20 1and 2 13 0The following assignment 3 21 0is incorrect, because parliamentarians 1 and 3 are both from Democrats party but will occupy neighbouring seats. n, a, b = map(int, input().split())
if a * b < n:
    print(-1)
else:
    for i in range(a):
        if b % 2 == 1 or i % 2 == 0:
            for j in range(1, b + 1):
                k = b* i + j
                if k > n:
                    k = 0
                print(k, end = ' ')
            print(' ')
        else:
            for j in range(b, 0, -1):
                k = b* i + j
                if k > n:
                    k = 0
                print(k, end = ' ')
            print(' ')
            
","['constructive algorithms', 'other']"
4343,"Molly Hooper has n different kinds of chemicals arranged in a line. Each of the chemicals has an affection value, The i-th of them has affection value ai.Molly wants Sherlock to fall in love with her. She intends to do this by mixing a contiguous segment of chemicals together to make a love potion with total affection value as a non-negative integer power of k. Total affection value of a continuous segment of chemicals is the sum of affection values of each chemical in that segment.Help her to do so in finding the total number of such segments. NoteDo keep in mind that k0 = 1.In the first sample, Molly can get following different affection values:  2: segments [1, 1], [2, 2], [3, 3], [4, 4]; 4: segments [1, 2], [2, 3], [3, 4]; 6: segments [1, 3], [2, 4]; 8: segments [1, 4]. Out of these, 2, 4 and 8 are powers of k = 2. Therefore, the answer is 8.In the second sample, Molly can choose segments [1, 2], [3, 3], [3, 4]. from sys import stdin
from collections import *


def arr_sum(arr):
    tem = [0]
    for i in range(len(arr)):
        tem.append(tem[i] + arr[i])
    return tem


rints = lambda: [int(x) for x in stdin.readline().split()]
mi, ma = -10 ** 14, 10 ** 14

n, k = rints()
a = rints()
mem, ans, lst, val = arr_sum(a), 0, 0, 1
c = Counter(mem)

for j in mem[:-1]:
    c[j] -= 1
    val = 1
    for i in range(48):
        if k == -1 and i == 2 or k == 1 and i == 1 or val > ma or val < mi:
            break

        ans += c[val + j]
        val *= k

print(ans)
","['binary search', 'brute force', 'data structures', 'implementation', 'math']"
4760,"You have a permutation: an array $$$a = [a_1, a_2, \ldots, a_n]$$$ of distinct integers from $$$1$$$ to $$$n$$$. The length of the permutation $$$n$$$ is odd.You need to sort the permutation in increasing order.In one step, you can choose any prefix of the permutation with an odd length and reverse it. Formally, if $$$a = [a_1, a_2, \ldots, a_n]$$$, you can choose any odd integer $$$p$$$ between $$$1$$$ and $$$n$$$, inclusive, and set $$$a$$$ to $$$[a_p, a_{p-1}, \ldots, a_1, a_{p+1}, a_{p+2}, \ldots, a_n]$$$.Find a way to sort $$$a$$$ using no more than $$$\frac{5n}{2}$$$ reversals of the above kind, or determine that such a way doesn't exist. The number of reversals doesn't have to be minimized. NoteIn the first test case, the permutation is already sorted. Any even number of reversals of the length $$$3$$$ prefix doesn't change that fact.In the second test case, after reversing the prefix of length $$$3$$$ the permutation will change to $$$[5, 4, 3, 2, 1]$$$, and then after reversing the prefix of length $$$5$$$ the permutation will change to $$$[1, 2, 3, 4, 5]$$$.In the third test case, it's impossible to sort the permutation. ''' C. Bottom-Tier Reversals
https://codeforces.com/contest/1558/problem/C
'''

import io, os, sys
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline  # decode().strip() if str
output = sys.stdout.write

def debug(*args):   
    if os.environ.get('debug') in [None, '0']: return
    from inspect import currentframe, getframeinfo
    from re import search
    frame = currentframe().f_back
    s = getframeinfo(frame).code_context[0]
    r = search(r""\((.*)\)"", s).group(1)
    vnames = r.split(', ')
    var_and_vals = [f'{var}={val}' for var, val in zip(vnames, args)]
    prefix = f'{currentframe().f_back.f_lineno:02d}: '
    print(f'{prefix}{"", "".join(var_and_vals)}')

from types import GeneratorType
def bootstrap(f, stack=[]):
    def wrappedfunc(*args, **kwargs):
        if stack: return f(*args, **kwargs)
        to = f(*args, **kwargs)
        while True:
            if type(to) is GeneratorType:
                stack.append(to)
                to = next(to)
            else:
                stack.pop()
                if not stack: break
                to = stack[-1].send(to)
        return to
    return wrappedfunc

class IntKeyDict(dict):
    from random import randrange
    rand = randrange(1 << 62)
    def __setitem__(self, k, v): super().__setitem__(k^self.rand, v)
    def __getitem__(self, k): return super().__getitem__(k^self.rand)
    def __contains__(self, k): return super().__contains__(k^self.rand)
    def __repr__(self): return str({k: v for k, v in self.items()})
    def get(self, k, default=None): return super().get(k^self.rand, default)
    def keys(self): return [k^self.rand for k in super().keys()]
    def items(self): return [(k^self.rand, v) for k, v in super().items()]

INF = float('inf')

# -----------------------------------------

# reversal preserves parity of position
# put pair of (n, n-1), (n-2, n-3), ... in order
#    7 a b 6 c d e
#    b a 7 6 c d e
#    e d c 6 7 a b
#    7 6 c d e a b
#    b a e d c 6 7

def solve(N, A):
    res = []
    for a1 in range(N, 1, -2):
        # put a1 at 0
        for i, a in enumerate(A):
            if a == a1:
                if i & 1: return -1, []
                res.append(i + 1)
                A[:i+1] = A[:i+1][::-1]
                break 

        i0 = -1
        for i, a in enumerate(A):
            if a == a1 - 1: 
                if i & 1 == 0: return -1, []
                i0 = i
                break

        # 7 a b 6 c d e -> b a 7 6 c d e
        res.append(i0)
        A[:i0] = A[:i0][::-1]
        i1 = i0 - 1

        # b a 7 6 c d e -> e d c 6 7 a b
        res.append(a1)
        A[:a1] = A[:a1][::-1]
        i1 = a1 - 1 - i1

        # e d c 6 7 a b -> 7 6 c d e a b
        res.append(i1 + 1)
        A[:i1+1] = A[:i1+1][::-1]

        # 7 6 c d e a b -> b a e d c 6 7
        res.append(a1)
        A[:a1] = A[:a1][::-1]
        
    assert A == list(range(1, N + 1))
    assert all(a & 1 for a in res)
    assert len(res) <= 5 * N // 2
    return len(res), res



def main():
    T = int(input())
    for _ in range(T):
        N = int(input())
        A = list(map(int, input().split()))
        r1, r2 = solve(N, A)
        print(r1)
        if r2: print(*r2)


if __name__ == '__main__':
    main()

","['constructive algorithms', 'greedy']"
1730,"After their adventure with the magic mirror Kay and Gerda have returned home and sometimes give free ice cream to kids in the summer.At the start of the day they have x ice cream packs. Since the ice cream is free, people start standing in the queue before Kay and Gerda's house even in the night. Each person in the queue wants either to take several ice cream packs for himself and his friends or to give several ice cream packs to Kay and Gerda (carriers that bring ice cream have to stand in the same queue).If a carrier with d ice cream packs comes to the house, then Kay and Gerda take all his packs. If a child who wants to take d ice cream packs comes to the house, then Kay and Gerda will give him d packs if they have enough ice cream, otherwise the child will get no ice cream at all and will leave in distress.Kay wants to find the amount of ice cream they will have after all people will leave from the queue, and Gerda wants to find the number of distressed kids. NoteConsider the first sample.  Initially Kay and Gerda have 7 packs of ice cream.  Carrier brings 5 more, so now they have 12 packs.  A kid asks for 10 packs and receives them. There are only 2 packs remaining.  Another kid asks for 20 packs. Kay and Gerda do not have them, so the kid goes away distressed.  Carrier bring 40 packs, now Kay and Gerda have 42 packs.  Kid asks for 20 packs and receives them. There are 22 packs remaining.  # int(input())
# [int(s) for s in input().split()]
# input()


def solve():
    n, x = [int(s) for s in input().split()]
    ans = 0
    for i in range(n):
        s = input().split()
        if s[0] == ""+"":
            x += int(s[1])
        else:
            if x >= int(s[1]):
                x -= int(s[1])
            else:
                ans += 1
    print(x, ans)


if __name__ == ""__main__"":
    solve()","['constructive algorithms', 'implementation']"
1789,"One day, Vogons wanted to build a new hyperspace highway through a distant system with $$$n$$$ planets. The $$$i$$$-th planet is on the orbit $$$a_i$$$, there could be multiple planets on the same orbit. It's a pity that all the planets are on the way and need to be destructed.Vogons have two machines to do that.  The first machine in one operation can destroy any planet at cost of $$$1$$$ Triganic Pu.  The second machine in one operation can destroy all planets on a single orbit in this system at the cost of $$$c$$$ Triganic Pus. Vogons can use each machine as many times as they want.Vogons are very greedy, so they want to destroy all planets with minimum amount of money spent. Can you help them to know the minimum cost of this project? NoteIn the first test case, the cost of using both machines is the same, so you can always use the second one and destroy all planets in orbit $$$1$$$, all planets in orbit $$$2$$$, all planets in orbit $$$4$$$, all planets in orbit $$$5$$$.In the second test case, it is advantageous to use the second machine for $$$2$$$ Triganic Pus to destroy all the planets in orbit $$$2$$$, then destroy the remaining two planets using the first machine.In the third test case, you can use the first machine twice or the second machine once.In the fourth test case, it is advantageous to use the first machine twice. from collections import defaultdict
from collections import Counter

def parse():
    return(int(input()))
    
def parse2():
    return(list(map(int,input().split())))
    
def parsestr():
    return input()
    
def solve():
    n, c = parse2()
    orbs = parse2()
    d = Counter()
    for i, orb in enumerate(orbs):
        d[orb] += 1
    ans = 0
    for v in d.values():
        if v > c:
            ans += c
        else:
            ans += v
    print(ans)
    
if __name__ == '__main__':
    t = parse()
    while t > 0:
        solve()
        t -= 1","['data structures', 'greedy', 'sortings']"
3409,"Kilani and Abd are neighbors for 3000 years, but then the day came and Kilani decided to move to another house. As a farewell gift, Kilani is going to challenge Abd with a problem written by their other neighbor with the same name Abd.  The problem is:You are given a connected tree rooted at node $$$1$$$.You should assign a character a or b to every node in the tree so that the total number of a's is equal to $$$x$$$ and the total number of b's is equal to $$$n - x$$$.Let's define a string for each node $$$v$$$ of the tree as follows:   if $$$v$$$ is root then the string is just one character assigned to $$$v$$$:  otherwise, let's take a string defined for the $$$v$$$'s parent $$$p_v$$$ and add to the end of it a character assigned to $$$v$$$. You should assign every node a character in a way that minimizes the number of distinct strings among the strings of all nodes. NoteThe tree from the sample is shown below:  The tree after assigning characters to every node (according to the output) is the following:  Strings for all nodes are the following:   string of node $$$1$$$ is: a  string of node $$$2$$$ is: aa  string of node $$$3$$$ is: aab  string of node $$$4$$$ is: aab  string of node $$$5$$$ is: aabb  string of node $$$6$$$ is: aabb  string of node $$$7$$$ is: aabb  string of node $$$8$$$ is: aabb  string of node $$$9$$$ is: aa The set of unique strings is $$$\{\text{a}, \text{aa}, \text{aab}, \text{aabb}\}$$$, so the number of distinct strings is $$$4$$$. n, a = map(int, raw_input().split());p = [-1] + [int(x) - 1 for x in raw_input().split()];g = [[] for i in range(n)]
for i in range(1, n):	g[p[i]].append(i)
d = [-1 for i in range(n)];d_all = [[] for i in range(n)];d_lv = [[] for i in range(n)];d_nlv = [[] for i in range(n)];q = [0];d[0] = 0
while len(q) > 0:
	v = q.pop()
	d_all[d[v]].append(v)
	if len(g[v]) == 0:
		d_lv[d[v]].append(v)
	else:
		d_nlv[d[v]].append(v)
	for u in g[v]:
		if d[u] == -1:
			d[u] = d[v] + 1
			q.append(u)
mx = max(d) + 1
mx_lv_pos = -1
for i in range(mx):
	if mx_lv_pos == -1 or len(d_lv[i]) > len(d_lv[mx_lv_pos]):
		mx_lv_pos = i
wg = [len(d_all[i]) if i != mx_lv_pos else 0 for i in range(mx)]

un = sorted(list(set(wg)))[1:]
pos = {}
for i in range(len(un)):
	pos[un[i]] = i
vals = [[] for i in range(len(un))]
for i in range(len(wg)):
	if wg[i] != 0:
		vals[pos[wg[i]]].append(i)

lst = [[-1, -1] for i in range(n + 1)]
dp = [[False for j in range(n + 1)] for i in range(2)]
dp[0][0] = True

l = len(un)
for ii in range(l):
	i = ii & 1
	ni = i ^ 1
	dp[ni] = [False for j in range(n + 1)]
	lst_tk = [-1 for j in range(un[ii])]
	for j in range(n + 1):
		rm = j % un[ii]
		if dp[i][j]:
			lst_tk[rm] = j
			dp[ni][j] = True
		elif lst_tk[rm] >= 0 and (j - lst_tk[rm]) // un[ii] <= len(vals[ii]):
			dp[ni][j] = True
			lst[j] = [lst_tk[rm], ii]
dp = dp[l & 1]
ans = mx
res = -1
if dp[a]:
	res = a
elif a - len(d_all[mx_lv_pos]) >= 0 and dp[a - len(d_all[mx_lv_pos])]:
	res = a - len(d_all[mx_lv_pos])
else:
	for i in range(a + 1):
		if dp[i] and ((len(d_nlv[mx_lv_pos]) <= a - i <= len(d_all[mx_lv_pos])) or (0 <= a - i <= len(d_lv[mx_lv_pos]))):
			res = i
			break
	ans += 1
cur = res
fin = set()
while cur > 0:
	p = lst[cur][0]
	x = lst[cur][1]
	while cur > p:
		fin.add(vals[x].pop())
		cur -= un[x]
s = [1 for i in range(n)]
a -= res

for i in range(mx + 1):
	if i in fin:
		for v in d_all[i]:
			s[v] = 0
	if i == mx_lv_pos:
		if a == len(d_all[i]):
			for v in d_all[i]:
				s[v] = 0
			a -= len(d_nlv[i])
		elif a != 0 and len(d_nlv[i]) <= a <= len(d_all[i]):
			a -= len(d_nlv[i])
			for v in d_nlv[i]:
				s[v] = 0
		for _ in range(a):
			s[d_lv[i].pop()] = 0
print(ans)
print("""".join([""ab""[x] for x in s]))","['dp', 'greedy', 'trees']"
4727,"Vasily the bear has got a sequence of positive integers a1, a2, ..., an. Vasily the Bear wants to write out several numbers on a piece of paper so that the beauty of the numbers he wrote out was maximum. The beauty of the written out numbers b1, b2, ..., bk is such maximum non-negative integer v, that number b1 and b2 and ... and bk is divisible by number 2v without a remainder. If such number v doesn't exist (that is, for any non-negative integer v, number b1 and b2 and ... and bk is divisible by 2v without a remainder), the beauty of the written out numbers equals -1. Tell the bear which numbers he should write out so that the beauty of the written out numbers is maximum. If there are multiple ways to write out the numbers, you need to choose the one where the bear writes out as many numbers as possible.Here expression x and y means applying the bitwise AND operation to numbers x and y. In programming languages C++ and Java this operation is represented by ""&amp;"", in Pascal — by ""and"". nan import functools
n = int(input())

nums = list(map(int, input().split()))

bits = [""{0:b}"".format(num) for num in nums]

def possible(v):
    possible_vals = [
        nums[x]
        for x in range(n)
        if len(bits[x]) > v and bits[x][len(bits[x])-v-1] == '1'
    ]
    if len(possible_vals) == 0:
        return False, []
    res = functools.reduce((lambda x, y: x&y), possible_vals, pow(2, v+1)-1)
    return bool(res & ((1 << (v+1))-1) == (1 << v)), possible_vals

for x in range(30, -1, -1):
    p, vals = possible(x)
    if p:
        print(len(vals))
        print(' '.join(list(map(str, vals))))
        break","['brute force', 'greedy', 'implementation', 'number theory']"
1620,"Bob has a string $$$s$$$ consisting of lowercase English letters. He defines $$$s'$$$ to be the string after removing all ""a"" characters from $$$s$$$ (keeping all other characters in the same order). He then generates a new string $$$t$$$ by concatenating $$$s$$$ and $$$s'$$$. In other words, $$$t=s+s'$$$ (look at notes for an example).You are given a string $$$t$$$. Your task is to find some $$$s$$$ that Bob could have used to generate $$$t$$$. It can be shown that if an answer exists, it will be unique. NoteIn the first example, we have $$$s = $$$ ""aaaaa"", and $$$s' = $$$ """".In the second example, no such $$$s$$$ can work that will generate the given $$$t$$$.In the third example, we have $$$s = $$$ ""ababacac"", and $$$s' = $$$ ""bbcc"", and $$$t = s + s' = $$$ ""ababacacbbcc"". s = input()
import re
r = re.sub('a','',s)
if r == 2*r[:len(r)//2] and (s[-len(r)//2:].count('a')  == 0 or r == ''):
        print(s[:len(s)-len(r)//2])
else: print(':(')","['implementation', 'strings']"
4180,"A triple of points $$$i$$$, $$$j$$$ and $$$k$$$ on a coordinate line is called beautiful if $$$i &lt; j &lt; k$$$ and $$$k - i \le d$$$.You are given a set of points on a coordinate line, initially empty. You have to process queries of three types:  add a point;  remove a point;  calculate the number of beautiful triples consisting of points belonging to the set.  nan 




###############################
class lazy_segtree():
    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])
    def all_apply(self,k,f):
        self.d[k]=self.mapping(f,self.d[k])
        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])
    def push(self,k):
        self.all_apply(2*k,self.lz[k])
        self.all_apply(2*k+1,self.lz[k])
        self.lz[k]=self.identity
    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):
        self.n=len(V)
        self.log=(self.n-1).bit_length()
        self.size=1<<self.log
        self.d=[E for i in range(2*self.size)]
        self.lz=[ID for i in range(self.size)]
        self.e=E
        self.op=OP
        self.mapping=MAPPING
        self.composition=COMPOSITION
        self.identity=ID
        for i in range(self.n):self.d[self.size+i]=V[i]
        for i in range(self.size-1,0,-1):self.update(i)
    def set(self,p,x):
        assert 0<=p and p<self.n
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=x
        for i in range(1,self.log+1):self.update(p>>i)
    def get(self,p):
        assert 0<=p and p<self.n
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        return self.d[p]
    def prod(self,l,r):
        assert 0<=l and l<=r and r<=self.n
        if l==r:return self.e
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push(r>>i)
        sml,smr=self.e,self.e
        while(l<r):
            if l&1:
                sml=self.op(sml,self.d[l])
                l+=1
            if r&1:
                r-=1
                smr=self.op(self.d[r],smr)
            l>>=1
            r>>=1
        return self.op(sml,smr)
    def all_prod(self):return self.d[1]
    def apply_point(self,p,f):
        assert 0<=p and p<self.n
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=self.mapping(f,self.d[p])
        for i in range(1,self.log+1):self.update(p>>i)
    def apply(self,l,r,f):
        assert 0<=l and l<=r and r<=self.n
        if l==r:return
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push((r-1)>>i)
        l2,r2=l,r
        while(l<r):
            if (l&1):
                self.all_apply(l,f)
                l+=1
            if (r&1):
                r-=1
                self.all_apply(r,f)
            l>>=1
            r>>=1
        l,r=l2,r2
        for i in range(1,self.log+1):
            if (((l>>i)<<i)!=l):self.update(l>>i)
            if (((r>>i)<<i)!=r):self.update((r-1)>>i)
    def max_right(self,l,g):
        assert 0<=l and l<=self.n
        assert g(self.e)
        if l==self.n:return self.n
        l+=self.size
        for i in range(self.log,0,-1):self.push(l>>i)
        sm=self.e
        while(1):
            while(i%2==0):l>>=1
            if not(g(self.op(sm,self.d[l]))):
                while(l<self.size):
                    self.push(l)
                    l=(2*l)
                    if (g(self.op(sm,self.d[l]))):
                        sm=self.op(sm,self.d[l])
                        l+=1
                return l-self.size
            sm=self.op(sm,self.d[l])
            l+=1
            if (l&-l)==l:break
        return self.n
    def min_left(self,r,g):
        assert (0<=r and r<=self.n)
        assert g(self.e)
        if r==0:return 0
        r+=self.size
        for i in range(self.log,0,-1):self.push((r-1)>>i)
        sm=self.e
        while(1):
            r-=1
            while(r>1 and (r%2)):r>>=1
            if not(g(self.op(self.d[r],sm))):
                while(r<self.size):
                    self.push(r)
                    r=(2*r+1)
                    if g(self.op(self.d[r],sm)):
                        sm=self.op(self.d[r],sm)
                        r-=1
                return r+1-self.size
            sm=self.op(self.d[r],sm)
            if (r&-r)==r:break
        return 0

###########################

M=2*10**5+10
def to(x):
    num2,num,cnt1=x
    return [num2,num*M+cnt1]
def inv(x):
    num2=x[0]
    y=x[1]
    cnt1=y%M
    num=y//M
    return [num2,num,cnt1]


def op(a,b):
    a=inv(a)
    b=inv(b)
    res=[0,0,0]
    res[0]=a[0]+b[0]
    res[1]=a[1]+b[1]
    res[2]=a[2]+b[2]
    return to(res)

def mapping(f,x):
    x=inv(x)
    num2,num,cnt1=x
    res2,res,rescnt1=0,0,0
    res2=num2+2*f*num+f**2*cnt1
    res=num+f*cnt1
    rescnt1=cnt1
    return to([res2,res,rescnt1])
def compose(f,g):
    return f+g






####################################
class BIT:
    #https://atcoder.jp/contests/abc233/submissions/28159326
    def __init__(self,arg):

        if isinstance(arg,int):
            self.N=arg
            self.dat=[0]*(self.N+1)
        else:
            self.N=len(arg)
            self.dat=[0]+list(arg)
            for i in range(self.N.bit_length()-1):
                for j in range(self.N>>(i+1)):
                    idx=(j<<1|1)<<i

                    nidx=idx+(idx&-idx)
                    if nidx<self.N+1:
                        self.dat[nidx]+=self.dat[idx]


    def add(self,idx,x):
        idx+=1
        while idx<self.N+1:
            self.dat[idx]+=x

            idx+=idx&-idx

    def sum(self,idx):
        if idx<0:return 0
        idx+=1
        sum_=0
        while idx>0:
            sum_+=self.dat[idx]

            idx-=idx&-idx
        return sum_

    def query(self,l,r):
        if l>=r:return 0
        return self.sum(r-1)-self.sum(l-1)

    def get(self,k):
        return self.query(k,k+1)

    def update(self,k,x):
        self.add(k,-self.get(k))
        self.add(k,x)

    def lower_bound(self,x):
        sum_=0
        idx=1<<(self.N.bit_length()-1)
        while True:
            if idx<self.N+1 and sum_+self.dat[idx]<x:
                sum_+=self.dat[idx]
                if idx&-idx==1:
                    break
                idx+=(idx&-idx)>>1
            else:
                if idx&-idx==1:
                    idx-=1
                    break
                idx-=(idx&-idx)>>1
        return idx,sum_

###################################




q,d=map(int,input().split())
x=[0]*(4*10**5+10)
wa=BIT(4*10**5+10)
seg=lazy_segtree([to([0,0,0]) for i in range(2*10**5+10)],op,to([0,0,0]),mapping,compose,0)


a=list(map(int,input().split()))
for i in a:
    if x[i]==1:
        x[i]=0
        wa.add(i,-1)
        seg.set(i,to([0,0,0]))
        left=max(0,i-d)
        right=i
        seg.apply(left,right,-1)
    else:
        x[i]=1
        wa.add(i,1)
        num=wa.query(i+1,i+d+1)
        seg.set(i,to([num**2,num,1]))
        left = max(0, i - d)
        right = i
        seg.apply(left, right, 1)
    ans=inv(seg.prod(1,2*10**5+1))
    num2,num,_=ans
    print((num2-num)//2)








","['combinatorics', 'data structures', 'implementation', 'math', 'other']"
3882,"Vasya has a string $$$s$$$ of length $$$n$$$. He decides to make the following modification to the string:   Pick an integer $$$k$$$, ($$$1 \leq k \leq n$$$).  For $$$i$$$ from $$$1$$$ to $$$n-k+1$$$, reverse the substring $$$s[i:i+k-1]$$$ of $$$s$$$. For example, if string $$$s$$$ is qwer and $$$k = 2$$$, below is the series of transformations the string goes through:   qwer (original string)  wqer (after reversing the first substring of length $$$2$$$)  weqr (after reversing the second substring of length $$$2$$$)  werq (after reversing the last substring of length $$$2$$$)  Hence, the resulting string after modifying $$$s$$$ with $$$k = 2$$$ is werq. Vasya wants to choose a $$$k$$$ such that the string obtained after the above-mentioned modification is lexicographically smallest possible among all choices of $$$k$$$. Among all such $$$k$$$, he wants to choose the smallest one. Since he is busy attending Felicity 2020, he asks for your help.A string $$$a$$$ is lexicographically smaller than a string $$$b$$$ if and only if one of the following holds:   $$$a$$$ is a prefix of $$$b$$$, but $$$a \ne b$$$;  in the first position where $$$a$$$ and $$$b$$$ differ, the string $$$a$$$ has a letter that appears earlier in the alphabet than the corresponding letter in $$$b$$$.  NoteIn the first testcase of the first sample, the string modification results for the sample abab are as follows :   for $$$k = 1$$$ : abab  for $$$k = 2$$$ : baba  for $$$k = 3$$$ : abab  for $$$k = 4$$$ : babaThe lexicographically smallest string achievable through modification is abab for $$$k = 1$$$ and $$$3$$$. Smallest value of $$$k$$$ needed to achieve is hence $$$1$$$.  # cook your dish here
for _ in range(int(input())):
    n=int(input())
    s=input()
    
    ch=s[0]
    for i in range(1,n):
        if ch>s[i]:
            ch=s[i]
            
    ks=[]
    for i in range(n):
        if(s[i]==ch):
            ks.append(i+1)
    
    low=-1        
    for k in ks:
        rev=False
        if (n-k+1)%2==1:
            rev=True
        temp=s[k-1:n]
        str1=s[0:k-1]
        if rev:
            str1=str1[::-1]
        temp=temp+str1
        if (low==-1) or ans>temp:
            low=k
            ans=temp
            
    print(ans)
    print(low)","['brute force', 'constructive algorithms', 'implementation', 'sortings', 'strings']"
4881,"People worry that computers will get too smart and take over the world, but the real problem is that they're too stupid and they've already taken over the world.— Pedro DomingosYou work for a well-known department store that uses leading technologies and employs mechanistic work — that is, robots!The department you work in sells $$$n \cdot k$$$ items. The first item costs $$$1$$$ dollar, the second item costs $$$2$$$ dollars, and so on: $$$i$$$-th item costs $$$i$$$ dollars. The items are situated on shelves. The items form a rectangular grid: there are $$$n$$$ shelves in total, and each shelf contains exactly $$$k$$$ items. We will denote by $$$a_{i,j}$$$ the price of $$$j$$$-th item (counting from the left) on the $$$i$$$-th shelf, $$$1 \le i \le n, 1 \le j \le k$$$.Occasionally robots get curious and ponder on the following question: what is the mean price (arithmetic average) of items $$$a_{i,l}, a_{i,l+1}, \ldots, a_{i,r}$$$ for some shelf $$$i$$$ and indices $$$l \le r$$$? Unfortunately, the old robots can only work with whole numbers. If the mean price turns out not to be an integer, they break down.You care about robots' welfare. You want to arrange the items in such a way that the robots cannot theoretically break. Formally, you want to choose such a two-dimensional array $$$a$$$ that:  Every number from $$$1$$$ to $$$n \cdot k$$$ (inclusively) occurs exactly once.  For each $$$i, l, r$$$, the mean price of items from $$$l$$$ to $$$r$$$ on $$$i$$$-th shelf is an integer. Find out if such an arrangement is possible, and if it is, give any example of such arrangement. nan t = int(input())
for x in range(t):
    n,k = map(int, input().split("" "")) 
    if(k== 1):
        print(""YES"")
        for y in range(n):
            print(y+1)

    elif(n*k % 2 ==0 and n % 2 == 0):
        
        print(""YES"")
        arr = [[0 for i in range(k)] for j in range(n)]
        
        cou = 1
        for q in range(k): 
            for z in range(n):
                arr[z][q] = str(cou) 
                cou+=1
            
            

        
        for b in range(n):
            print("" "".join(arr[b]))


    else: 
        print(""NO"")
",['constructive algorithms']
1536,"A student of z-school found a kind of sorting called z-sort. The array a with n elements are z-sorted if two conditions hold:  ai ≥ ai - 1 for all even i,  ai ≤ ai - 1 for all odd i &gt; 1. For example the arrays [1,2,1,2] and [1,1,1,1] are z-sorted while the array [1,2,3,4] isn’t z-sorted.Can you make the array z-sorted? nan n = int(input())
array = input().split("" "") # поскольку вводится все в строку
# то мы делаем переход к массиву этим методом (просто делим строку на список по пробелам)
MaxArray = [] # массив с максимальными элементами из array

for i in range(n): # цикл, в котором вырываются максимальные эл из array
    # и загоняются в MaxArray (меня интересует только половина таких)
    array[i] = int(array[i])

for i in range(n // 2):
    MaxArray.append(max(array))
    array.remove(max(array))

if n % 2 != 0:
    print(array[0], end = ' ')
    array.remove(array[0])
    for i in range(n // 2):
        print(MaxArray[(n // 2) - 1 - i], array[i], end = ' ')
else:
    for i in range(n // 2):
        print(array[i], MaxArray[(n // 2) - 1 - i], end = ' ')",['sortings']
1405,"Soroush and Keshi each have a labeled and rooted tree on $$$n$$$ vertices. Both of their trees are rooted from vertex $$$1$$$.Soroush and Keshi used to be at war. After endless decades of fighting, they finally became allies to prepare a Codeforces round. To celebrate this fortunate event, they decided to make a memorial graph on $$$n$$$ vertices.They add an edge between vertices $$$u$$$ and $$$v$$$ in the memorial graph if both of the following conditions hold:   One of $$$u$$$ or $$$v$$$ is the ancestor of the other in Soroush's tree.  Neither of $$$u$$$ or $$$v$$$ is the ancestor of the other in Keshi's tree. Here vertex $$$u$$$ is considered ancestor of vertex $$$v$$$, if $$$u$$$ lies on the path from $$$1$$$ (the root) to the $$$v$$$.Popping out of nowhere, Mashtali tried to find the maximum clique in the memorial graph for no reason. He failed because the graph was too big. Help Mashtali by finding the size of the maximum clique in the memorial graph.As a reminder, clique is a subset of vertices of the graph, each two of which are connected by an edge. NoteIn the first and third test cases, you can pick any vertex.In the second test case, one of the maximum cliques is $$$\{2, 3, 4, 5\}$$$.In the fourth test case, one of the maximum cliques is $$$\{3, 4, 6\}$$$. import sys
import os
from io import BytesIO
from operator import getitem

if sys.version_info[0] < 3:
    sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))

f = sys.stdin
if os.environ.get('USER') == ""loic"":
    f = open(""data.in"")

line = lambda: f.readline().strip('\r\n').split()

def write(w):
    sys.stdout.write(w)
    sys.stdout.write(""\n"")

# From https://github.com/cheran-senthil/PyRival/blob/master/pyrival/data_structures/SortedList.py
class SortedList:
    def __init__(self, iterable=[], _load=200):
        """"""Initialize sorted list instance.""""""
        values = sorted(iterable)
        self._len = _len = len(values)
        self._load = _load
        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]
        self._list_lens = [len(_list) for _list in _lists]
        self._mins = [_list[0] for _list in _lists]
        self._fen_tree = []
        self._rebuild = True

    def _fen_build(self):
        """"""Build a fenwick tree instance.""""""
        self._fen_tree[:] = self._list_lens
        _fen_tree = self._fen_tree
        for i in range(len(_fen_tree)):
            if i | i + 1 < len(_fen_tree):
                _fen_tree[i | i + 1] += _fen_tree[i]
        self._rebuild = False

    def _fen_update(self, index, value):
        """"""Update `fen_tree[index] += value`.""""""
        if not self._rebuild:
            _fen_tree = self._fen_tree
            while index < len(_fen_tree):
                _fen_tree[index] += value
                index |= index + 1

    def _fen_query(self, end):
        """"""Return `sum(_fen_tree[:end])`.""""""
        if self._rebuild:
            self._fen_build()

        _fen_tree = self._fen_tree
        x = 0
        while end:
            x += _fen_tree[end - 1]
            end &= end - 1
        return x

    def _fen_findkth(self, k):
        """"""Return a pair of (the largest `idx` such that `sum(_fen_tree[:idx]) <= k`, `k - sum(_fen_tree[:idx])`).""""""
        _list_lens = self._list_lens
        if k < _list_lens[0]:
            return 0, k
        if k >= self._len - _list_lens[-1]:
            return len(_list_lens) - 1, k + _list_lens[-1] - self._len
        if self._rebuild:
            self._fen_build()

        _fen_tree = self._fen_tree
        idx = -1
        for d in reversed(range(len(_fen_tree).bit_length())):
            right_idx = idx + (1 << d)
            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:
                idx = right_idx
                k -= _fen_tree[idx]
        return idx + 1, k

    def _delete(self, pos, idx):
        """"""Delete value at the given `(pos, idx)`.""""""
        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens

        self._len -= 1
        self._fen_update(pos, -1)
        del _lists[pos][idx]
        _list_lens[pos] -= 1

        if _list_lens[pos]:
            _mins[pos] = _lists[pos][0]
        else:
            del _lists[pos]
            del _list_lens[pos]
            del _mins[pos]
            self._rebuild = True

    def _loc_left(self, value):
        """"""Return an index pair that corresponds to the first position of `value` in the sorted list.""""""
        if not self._len:
            return 0, 0

        _lists = self._lists
        _mins = self._mins

        lo, pos = -1, len(_lists) - 1
        while lo + 1 < pos:
            mi = (lo + pos) >> 1
            if value <= _mins[mi]:
                pos = mi
            else:
                lo = mi

        if pos and value <= _lists[pos - 1][-1]:
            pos -= 1

        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value <= _list[mi]:
                idx = mi
            else:
                lo = mi

        return pos, idx

    def _loc_right(self, value):
        """"""Return an index pair that corresponds to the last position of `value` in the sorted list.""""""
        if not self._len:
            return 0, 0

        _lists = self._lists
        _mins = self._mins

        pos, hi = 0, len(_lists)
        while pos + 1 < hi:
            mi = (pos + hi) >> 1
            if value < _mins[mi]:
                hi = mi
            else:
                pos = mi

        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value < _list[mi]:
                idx = mi
            else:
                lo = mi

        return pos, idx

    def add(self, value):
        """"""Add `value` to sorted list.""""""
        _load = self._load
        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens

        self._len += 1
        if _lists:
            pos, idx = self._loc_right(value)
            self._fen_update(pos, 1)
            _list = _lists[pos]
            _list.insert(idx, value)
            _list_lens[pos] += 1
            _mins[pos] = _list[0]
            if _load + _load < len(_list):
                _lists.insert(pos + 1, _list[_load:])
                _list_lens.insert(pos + 1, len(_list) - _load)
                _mins.insert(pos + 1, _list[_load])
                _list_lens[pos] = _load
                del _list[_load:]
                self._rebuild = True
        else:
            _lists.append([value])
            _mins.append(value)
            _list_lens.append(1)
            self._rebuild = True

    def discard(self, value):
        """"""Remove `value` from sorted list if it is a member.""""""
        _lists = self._lists
        if _lists:
            pos, idx = self._loc_right(value)
            if idx and _lists[pos][idx - 1] == value:
                self._delete(pos, idx - 1)

    def remove(self, value):
        """"""Remove `value` from sorted list; `value` must be a member.""""""
        _len = self._len
        self.discard(value)
        if _len == self._len:
            raise ValueError('{0!r} not in list'.format(value))

    def pop(self, index=-1):
        """"""Remove and return value at `index` in sorted list.""""""
        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        value = self._lists[pos][idx]
        self._delete(pos, idx)
        return value

    def bisect_left(self, value):
        """"""Return the first index to insert `value` in the sorted list.""""""
        pos, idx = self._loc_left(value)
        return self._fen_query(pos) + idx

    def bisect_right(self, value):
        """"""Return the last index to insert `value` in the sorted list.""""""
        pos, idx = self._loc_right(value)
        return self._fen_query(pos) + idx

    def count(self, value):
        """"""Return number of occurrences of `value` in the sorted list.""""""
        return self.bisect_right(value) - self.bisect_left(value)

    def __len__(self):
        """"""Return the size of the sorted list.""""""
        return self._len

    def __getitem__(self, index):
        """"""Lookup value at `index` in sorted list.""""""
        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        return self._lists[pos][idx]

    def __delitem__(self, index):
        """"""Remove value at `index` from sorted list.""""""
        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        self._delete(pos, idx)

    def __contains__(self, value):
        """"""Return true if `value` is an element of the sorted list.""""""
        _lists = self._lists
        if _lists:
            pos, idx = self._loc_left(value)
            return idx < len(_lists[pos]) and _lists[pos][idx] == value
        return False

    def __iter__(self):
        """"""Return an iterator over the sorted list.""""""
        return (value for _list in self._lists for value in _list)

    def __reversed__(self):
        """"""Return a reverse iterator over the sorted list.""""""
        return (value for _list in reversed(self._lists) for value in reversed(_list))

    def __repr__(self):
        """"""Return string representation of sorted list.""""""
        return 'SortedList({0})'.format(list(self))


def dfs_time(g, start):
    times_vis = [-1] * len(g)
    
    q = [start]
    times_vis[start] = 0
    
    c = 0
    
    while q:
        n = q[-1]
        
        if times_vis[n] == 1:
            t_out[n] = c
            c += 1
            q.pop()
        else:
            t_in[n] = c
            c += 1
            
            times_vis[n] = 1
            
            for ch in reversed(g[n]):
                times_vis[ch] = 0
                q.append(ch)

def dfs(g, start):
    times_vis = [-1] * len(g)
    
    q = [start]
    times_vis[start] = 0
    
    mx = 0
    data = [(t_in[n],t_out[n],n) for n in range(N)]
    sl = SortedList()
    rep = [None for _ in range(N)]
    
    while q:
        n = q[-1]
        
        if times_vis[n] == 1:
            sl.remove(data[n])
            if rep[n] is not None:
                r = rep[n]
                sl.add(data[r])
            q.pop()
        else:
            idx = sl.bisect_left(data[n])
            if idx > 0:
                itv = getitem(sl, idx-1)
                if itv[1] > t_out[n]:
                    sl.remove(itv)
                    rep[n] = itv[2]
            sl.add(data[n])
            
            mx = max(mx, len(sl))
            
            times_vis[n] = 1
            
            for ch in reversed(g[n]):
                times_vis[ch] = 0
                q.append(ch)
    
    return mx

def solve():
    
    dfs_time(G2, 0)
    res = dfs(G1, 0)
    
    return str(res)

T = int(line()[0])
for test in range(1,T+1):
    N = int(line()[0])
    G1 = [[] for _ in range(N)]
    G2 = [[] for _ in range(N)]
    
    par = list(map(int,line()))
    for i in range(len(par)):
        G1[par[i]-1].append(i+1)  
    
    par = list(map(int,line()))
    for i in range(len(par)):
        G2[par[i]-1].append(i+1)
    
    t_in = [-1]*N
    t_out = [-1]*N
    
    write(solve())
    
f.close()","['data structures', 'dfs and similar', 'greedy', 'trees']"
99,"Let's assume that we are given a matrix b of size x × y, let's determine the operation of mirroring matrix b. The mirroring of matrix b is a 2x × y matrix c which has the following properties:  the upper half of matrix c (rows with numbers from 1 to x) exactly matches b;  the lower half of matrix c (rows with numbers from x + 1 to 2x) is symmetric to the upper one; the symmetry line is the line that separates two halves (the line that goes in the middle, between rows x and x + 1). Sereja has an n × m matrix a. He wants to find such matrix b, that it can be transformed into matrix a, if we'll perform on it several (possibly zero) mirrorings. What minimum number of rows can such matrix contain? NoteIn the first test sample the answer is a 2 × 3 matrix b:001110If we perform a mirroring operation with this matrix, we get the matrix a that is given in the input:001110110001 def check(i, j):
    global a
    while i < j:
        if a[i] != a[j]:
            return False
        i += 1
        j -= 1
    return True
n, m = map(int, input().split())
a = []
for i in range(n):
    a.append(input().strip())
last = n
while last % 2 == 0:
    if check(0, last - 1):
        last //= 2
    else:
        break
print(last)",['implementation']
4619,"This is the hard version of the problem. The only difference is that in this version $$$1 \le q \le 10^5$$$. You can make hacks only if both versions of the problem are solved.There is a process that takes place on arrays $$$a$$$ and $$$b$$$ of length $$$n$$$ and length $$$n-1$$$ respectively. The process is an infinite sequence of operations. Each operation is as follows:   First, choose a random integer $$$i$$$ ($$$1 \le i \le n-1$$$).  Then, simultaneously set $$$a_i = \min\left(a_i, \frac{a_i+a_{i+1}-b_i}{2}\right)$$$ and $$$a_{i+1} = \max\left(a_{i+1}, \frac{a_i+a_{i+1}+b_i}{2}\right)$$$ without any rounding (so values may become non-integer).  See notes for an example of an operation.It can be proven that array $$$a$$$ converges, i. e. for each $$$i$$$ there exists a limit $$$a_i$$$ converges to. Let function $$$F(a, b)$$$ return the value $$$a_1$$$ converges to after a process on $$$a$$$ and $$$b$$$.You are given array $$$b$$$, but not array $$$a$$$. However, you are given a third array $$$c$$$. Array $$$a$$$ is good if it contains only integers and satisfies $$$0 \leq a_i \leq c_i$$$ for $$$1 \leq i \leq n$$$.Your task is to count the number of good arrays $$$a$$$ where $$$F(a, b) \geq x$$$ for $$$q$$$ values of $$$x$$$. Since the number of arrays can be very large, print it modulo $$$10^9+7$$$. NoteThe following explanation assumes $$$b = [2, 1]$$$ and $$$c=[2, 3, 4]$$$ (as in the sample).Examples of arrays $$$a$$$ that are not good:   $$$a = [3, 2, 3]$$$ is not good because $$$a_1 &gt; c_1$$$;  $$$a = [0, -1, 3]$$$ is not good because $$$a_2 &lt; 0$$$. One possible good array $$$a$$$ is $$$[0, 2, 4]$$$. We can show that no operation has any effect on this array, so $$$F(a, b) = a_1 = 0$$$.Another possible good array $$$a$$$ is $$$[0, 1, 4]$$$. In a single operation with $$$i = 1$$$, we set $$$a_1 = \min(\frac{0+1-2}{2}, 0)$$$ and $$$a_2 = \max(\frac{0+1+2}{2}, 1)$$$. So, after a single operation with $$$i = 1$$$, $$$a$$$ becomes equal to $$$[-\frac{1}{2}, \frac{3}{2}, 4]$$$. We can show that no operation has any effect on this array, so $$$F(a, b) = -\frac{1}{2}$$$. def solve():
    MOD = 10**9+7
    n = int(input())
    c = list(map(int, input().split()))
    b = [0] + list(map(int, input().split()))
    q = int(input())
    queries = list(map(int, input().split()))
    maxans = 1
    for c1 in c:
        maxans = maxans * (c1+1) % MOD
    ans = {}
    for i in range(1, n):
        b[i] += b[i-1]
    s = lb = 0
    for i in range(1, n):
        s -= b[i]
        lb = min(lb, s//(i+1))
    s = ub = c[0]
    for i in range(n):
        s += c[i] - b[i]
        ub = min(ub, s//(i+1))
    for x in queries:
        if x <= lb:
            print(maxans)
        elif x > ub:
            print(0)
        elif x in ans:
            print(ans[x])
        else:
            dp0 = [1] * 10002
            dp0[0] = 0
            bd = 0
            for i in range(n):
                dp1 = [0] * 10002
                bd += b[i] + x
                for j in range(max(bd, 0), 10001):
                    dp1[j+1] = (dp1[j] + dp0[j+1] - dp0[max(j-c[i], 0)]) % MOD
                dp0 = dp1[:]
            a = dp0[-1]
            ans[x] = a
            print(a)
 
 
import sys
input = lambda: sys.stdin.readline().rstrip()
solve()","['dp', 'math']"
3339,"Yura is tasked to build a closed fence in shape of an arbitrary non-degenerate simple quadrilateral. He's already got three straight fence segments with known lengths $$$a$$$, $$$b$$$, and $$$c$$$. Now he needs to find out some possible integer length $$$d$$$ of the fourth straight fence segment so that he can build the fence using these four segments. In other words, the fence should have a quadrilateral shape with side lengths equal to $$$a$$$, $$$b$$$, $$$c$$$, and $$$d$$$. Help Yura, find any possible length of the fourth side.A non-degenerate simple quadrilateral is such a quadrilateral that no three of its corners lie on the same line, and it does not cross itself. NoteWe can build a quadrilateral with sides $$$1$$$, $$$2$$$, $$$3$$$, $$$4$$$.We can build a quadrilateral with sides $$$12$$$, $$$34$$$, $$$56$$$, $$$42$$$. for _ in range(int(input())):
    num = list(map(int, input().split()))
    q = 0
    num.sort()
    c = num[0]
    a = num[1]
    b = num[2]
    print(int((((b - c) ** 2 + a ** 2) ** 0.5)))","['geometry', 'math']"
4525,"Little time is left before Berland annual football championship. Therefore the coach of team ""Losewille Rangers"" decided to resume the practice, that were indefinitely interrupted for uncertain reasons. Overall there are n players in ""Losewille Rangers"". Each player on the team has a number — a unique integer from 1 to n. To prepare for the championship, the coach Mr. Floppe decided to spend some number of practices.Mr. Floppe spent some long nights of his holiday planning how to conduct the practices. He came to a very complex practice system. Each practice consists of one game, all n players of the team take part in the game. The players are sorted into two teams in some way. In this case, the teams may have different numbers of players, but each team must have at least one player.The coach wants to be sure that after the series of the practice sessions each pair of players had at least one practice, when they played in different teams. As the players' energy is limited, the coach wants to achieve the goal in the least number of practices.Help him to schedule the practices. nan from math import floor
def divide_group(src, a, b):
    '''
    src, a, b: [(int, int)]
    '''
    for l, r in src:
        if l == r:
            b.append((l,r))
        else:
            p = floor((l+r)/2)
            a.append((l, p))
            b.append((p+1, r))

def size(groups):
    '''
    gr: [(int, int)]
    '''
    return max(list(map(lambda group: group[1]-group[0] + 1, groups)) or [0])

def practice(n):
    '''
    http://codeforces.com/problemset/problem/234/G
    '''
    # a=[(l, r)] b=[(l,r)]
    a = [(1, n)]
    b = []
    solution = []
    while size(a) > 1 or size(b) > 1:
        tmpa, tmpb = [], []
        divide_group(a, tmpa, tmpb)
        divide_group(b, tmpa, tmpb)
        a, b = tmpa, tmpb
        game = []
        for l, r in a:
            # [(int, int)]
            for player in range(l, r + 1):
                game.append(player)
        solution.append(game)
    return solution

n=int(open(""input.txt"").read())
games = practice(n)
# print(len(games))
out = str(len(games)) + '\n'
for game in games:
    out += '{}'.format(len(game))
    for p in game:
        out += ' {}'.format(p)
    out += '\n'

open(""output.txt"",""w"").write(out)
","['constructive algorithms', 'divide and conquer', 'implementation']"
4864,"An array $$$[b_1, b_2, \ldots, b_m]$$$ is a palindrome, if $$$b_i = b_{m+1-i}$$$ for each $$$i$$$ from $$$1$$$ to $$$m$$$. Empty array is also a palindrome.An array is called kalindrome, if the following condition holds: It's possible to select some integer $$$x$$$ and delete some of the elements of the array equal to $$$x$$$, so that the remaining array (after gluing together the remaining parts) is a palindrome. Note that you don't have to delete all elements equal to $$$x$$$, and you don't have to delete at least one element equal to $$$x$$$.For example :   $$$[1, 2, 1]$$$ is kalindrome because you can simply not delete a single element.  $$$[3, 1, 2, 3, 1]$$$ is kalindrome because you can choose $$$x = 3$$$ and delete both elements equal to $$$3$$$, obtaining array $$$[1, 2, 1]$$$, which is a palindrome.  $$$[1, 2, 3]$$$ is not kalindrome. You are given an array $$$[a_1, a_2, \ldots, a_n]$$$. Determine if $$$a$$$ is kalindrome or not. NoteIn the first test case, array $$$[1]$$$ is already a palindrome, so it's a kalindrome as well.In the second test case, we can choose $$$x = 2$$$, delete the second element, and obtain array $$$[1]$$$, which is a palindrome.In the third test case, it's impossible to obtain a palindrome.In the fourth test case, you can choose $$$x = 4$$$ and delete the fifth element, obtaining $$$[1, 4, 4, 1]$$$. You also can choose $$$x = 1$$$, delete the first and the fourth elements, and obtain $$$[4, 4, 4]$$$. import sys
inpu = sys.stdin.readline
prin = sys.stdout.write
for _ in range(int(inpu())) :
    n = int(inpu())
    s = list(map(int, inpu().split(' ')))
    num = -1
    for i in range(n//2) :
        if s[i] != s[n - i - 1]:
            d1 = s[i]
            d2 = s[n - i - 1]
            num = i
            break
    if num == -1:
        prin(""YES\n"")
        continue
    index1 = num
    index2 = n - num - 1
    op = 0
    while 1 :        
        if s[index1] != s[index2] :
            while 1 :
                if s[index1] == d1:
                    index1 += 1
                else:
                    break
            while 1 :
                if s[index2] == d1:
                    index2 -= 1
                else:
                    break
            if s[index1] != s[index2] :
                op = -1
                break
        if abs(index1 - index2) <= 1:
            break
        index1 += 1
        index2 -= 1
    if op != -1 :
        prin(""YES\n"")
        continue
    if d1 == d2 :
        prin(""NO\n"")
        continue
    index1 = num
    index2 = n - num - 1
    op = 0
    while 1 :        
        if s[index1] != s[index2] :
            while 1 :
                if s[index1] == d2:
                    index1 += 1
                else:
                    break
            while 1 :
                if s[index2] == d2:
                    index2 -= 1
                else:
                    break
            if s[index1] != s[index2] :
                op = -1
                break
        if abs(index1 - index2) <= 1:
            break
        index1 += 1
        index2 -= 1
    if op != -1 :
        prin(""YES\n"")
    else:
        prin(""NO\n"")","['greedy', 'two pointers']"
191,"There is a $$$k \times k$$$ grid, where $$$k$$$ is even. The square in row $$$r$$$ and column $$$c$$$ is denoted by $$$(r,c)$$$. Two squares $$$(r_1, c_1)$$$ and $$$(r_2, c_2)$$$ are considered adjacent if $$$\lvert r_1 - r_2 \rvert + \lvert c_1 - c_2 \rvert = 1$$$.An array of adjacent pairs of squares is called strong if it is possible to cut the grid along grid lines into two connected, congruent pieces so that each pair is part of the same piece. Two pieces are congruent if one can be matched with the other by translation, rotation, and reflection, or a combination of these.  The picture above represents the first test case. Arrows indicate pairs of squares, and the thick black line represents the cut. You are given an array $$$a$$$ of $$$n$$$ pairs of adjacent squares. Find the size of the largest strong subsequence of $$$a$$$. An array $$$p$$$ is a subsequence of an array $$$q$$$ if $$$p$$$ can be obtained from $$$q$$$ by deletion of several (possibly, zero or all) elements. NoteIn the first test case, the array $$$a$$$ is not good, but if we take the subsequence $$$[a_1, a_2, a_3, a_4, a_5, a_6, a_8]$$$, then the square can be split as shown in the statement.In the second test case, we can take the subsequence consisting of the last four elements of $$$a$$$ and cut the square with a horizontal line through its center. import io, os
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
from heapq import heappop, heappush
 
for _ in range(int(input())):
    q, n = map(int, input().split())
    graph = [[[] for j in range(n + 1)] for i in range(n + 1)]
    for x in range(n + 1):
        for y in range(n + 1):
            if x - 1 >= 0: graph[x-1][y] += [[x, y, 0]]
            if x + 1 < n: graph[x+1][y] += [[x, y, 0]]
            if y - 1 >= 0: graph[x][y-1] += [[x, y, 0]]
            if y + 1 < n: graph[x][y+1] += [[x, y, 0]]
            
    def update(x1, y1, x2, y2):
        for i in range(len(graph[x1][y1])):
            if (graph[x1][y1][i][0], graph[x1][y1][i][1]) == (x2, y2):
                graph[x1][y1][i][2] += 1
        for i in range(len(graph[x2][y2])):
            if (graph[x2][y2][i][0], graph[x2][y2][i][1]) == (x1, y1):
                graph[x2][y2][i][2] += 1
    
    for i in range(q):
        x1, y1, x2, y2 = map(int, input().split())
        if x1 == x2:
            y1, y2 = min(y1, y2), max(y1, y2)
            update(x1 - 1, y1, x1, y1)
            update(n - (x1 - 1), n - y1, n - x1, n - y1)
        else:
            x1, x2 = min(x1, x2), max(x1, x2)
            update(x1, y1 - 1, x1, y1)
            update(n - x1, n - (y1 - 1), n - x1, n - y1)
    
    dist = [[float(""inf"")] * (n + 1) for __ in range(n + 1)]
    queue = []
    heappush(queue, (0, n // 2, n // 2))
    dist[n // 2][n // 2] = 0
    while queue:
        length, x, y = heappop(queue)
        if x == 0 or y == 0:
            print(q - length)
            break
        if dist[x][y] != length:
            continue
        for x2, y2, w in graph[x][y]:
            if dist[x2][y2] > dist[x][y] + w:
                dist[x2][y2] = dist[x][y] + w
                heappush(queue, (dist[x2][y2], x2, y2))","['geometry', 'graphs', 'greedy', 'implementation', 'shortest paths']"
2236,"Summer is coming! It's time for Iahub and Iahubina to work out, as they both want to look hot at the beach. The gym where they go is a matrix a with n lines and m columns. Let number a[i][j] represents the calories burned by performing workout at the cell of gym in the i-th line and the j-th column.Iahub starts with workout located at line 1 and column 1. He needs to finish with workout a[n][m]. After finishing workout a[i][j], he can go to workout a[i + 1][j] or a[i][j + 1]. Similarly, Iahubina starts with workout a[n][1] and she needs to finish with workout a[1][m]. After finishing workout from cell a[i][j], she goes to either a[i][j + 1] or a[i - 1][j]. There is one additional condition for their training. They have to meet in exactly one cell of gym. At that cell, none of them will work out. They will talk about fast exponentiation (pretty odd small talk) and then both of them will move to the next workout.If a workout was done by either Iahub or Iahubina, it counts as total gain. Please plan a workout for Iahub and Iahubina such as total gain to be as big as possible. Note, that Iahub and Iahubina can perform workouts with different speed, so the number of cells that they use to reach meet cell may differs. NoteIahub will choose exercises a[1][1] → a[1][2] → a[2][2] → a[3][2] → a[3][3]. Iahubina will choose exercises a[3][1] → a[2][1] → a[2][2] → a[2][3] → a[1][3]. n, m = map(int, input().split())
gym = [[0 for i in range(m+1)]]
for row in range(n):
    gym.append([0] + list(map(int, input().split())))

bToMid = [[0 for i in range(m+2)] for j in range(n+2)]
for i in range(1, n+1):
    for j in range(1, m+1):
        bToMid[i][j] = gym[i][j] + max(bToMid[i-1][j], bToMid[i][j-1])
bToEnd = [[0 for i in range(m+2)] for j in range(n+2)]
for i in range(n, 0, -1):
    for j in range(m, 0, -1):
        bToEnd[i][j] = gym[i][j] + max(bToEnd[i+1][j], bToEnd[i][j+1])
aToMid = [[0 for i in range(m+2)] for j in range(n+2)]
for i in range(n, 0, -1):
    for j in range(1, m+1):
        aToMid[i][j] = gym[i][j] + max(aToMid[i+1][j], aToMid[i][j-1])
aToEnd = [[0 for i in range(m+2)] for j in range(n+2)]
for i in range(1, n+1):
    for j in range(m, 0, -1):
        aToEnd[i][j] = gym[i][j] + max(aToEnd[i-1][j], aToEnd[i][j+1])
#print(bToMid[1][2], bToEnd[3][2], aToMid[2][1], aToEnd[2][3])
best = 0
bestIJ = ()
for i in range(2, n):
    for j in range(2, m):
        best = max(best, bToMid[i][j-1]+bToEnd[i][j+1]+aToMid[i+1][j]+aToEnd[i-1][j])
        best = max(best, bToMid[i-1][j]+bToEnd[i+1][j]+aToMid[i][j-1]+aToEnd[i][j+1])
        bestIJ = (i, j)
print(best)
#print(bestIJ)
",['dp']
3365,"Convexity of a set of points on the plane is the size of the largest subset of points that form a convex polygon. Your task is to build a set of n points with the convexity of exactly m. Your set of points should not contain three points that lie on a straight line. nan n, m = map( int, raw_input().split() )

if( ( m == 3 ) and ( n >= 5 ) ):
    print -1
else:
    for i in xrange( m ):
        print i, ( i * i )
    for i in xrange( n - m ):
        print ( i * i + 12345 ), i
","['constructive algorithms', 'geometry']"
1793,"Consider an array $$$a$$$ of $$$n$$$ positive integers.You may perform the following operation:   select two indices $$$l$$$ and $$$r$$$ ($$$1 \leq l \leq r \leq n$$$), then  decrease all elements $$$a_l, a_{l + 1}, \dots, a_r$$$ by $$$1$$$. Let's call $$$f(a)$$$ the minimum number of operations needed to change array $$$a$$$ into an array of $$$n$$$ zeros.Determine if for all permutations$$$^\dagger$$$ $$$b$$$ of $$$a$$$, $$$f(a) \leq f(b)$$$ is true. $$$^\dagger$$$ An array $$$b$$$ is a permutation of an array $$$a$$$ if $$$b$$$ consists of the elements of $$$a$$$ in arbitrary order. For example, $$$[4,2,3,4]$$$ is a permutation of $$$[3,2,4,4]$$$ while $$$[1,2,2]$$$ is not a permutation of $$$[1,2,3]$$$. NoteIn the first test case, we can change all elements to $$$0$$$ in $$$5$$$ operations. It can be shown that no permutation of $$$[2, 3, 5, 4]$$$ requires less than $$$5$$$ operations to change all elements to $$$0$$$.In the third test case, we need $$$5$$$ operations to change all elements to $$$0$$$, while $$$[2, 3, 3, 1]$$$ only needs $$$3$$$ operations. import sys

tc = int(sys.stdin.readline())
for test in range(tc):
    n = int(sys.stdin.readline())
    a = list(map(int,sys.stdin.readline().split()))
    b = a.index(max(a))
    if sorted(a[b:]) == a[b:] or sorted(a[b:],reverse=True) == a[b:]:
        if sorted(a[:b+1]) == a[:b+1] or sorted(a[:b+1],reverse=True) == a[:b+1]:
            print(""YES"")
        else:
            print(""NO"")
    else:
        print(""NO"")","['constructive algorithms', 'sortings']"
879,"Two people are playing a game with a string $$$s$$$, consisting of lowercase latin letters. On a player's turn, he should choose two consecutive equal letters in the string and delete them. For example, if the string is equal to ""xaax"" than there is only one possible turn: delete ""aa"", so the string will become ""xx"". A player not able to make a turn loses.Your task is to determine which player will win if both play optimally. NoteIn the first example the first player is unable to make a turn, so he loses.In the second example first player turns the string into ""q"", then second player is unable to move, so he loses. s = input()
n = len(s)
a = []
a.append(s[0])

ans = 0

for i in range(1, n):
    if a:
        cur = a.pop()
        if cur == s[i]:
            ans += 1
            continue
        else:
            a.append(cur)
            a.append(s[i])
    else:
        a.append(s[i])

if ans % 2:
    print('Yes')
else:
    print('No')","['data structures', 'implementation', 'math']"
1888,"Polycarp found under the Christmas tree an array $$$a$$$ of $$$n$$$ elements and instructions for playing with it:   At first, choose index $$$i$$$ ($$$1 \leq i \leq n$$$) — starting position in the array. Put the chip at the index $$$i$$$ (on the value $$$a_i$$$).  While $$$i \leq n$$$, add $$$a_i$$$ to your score and move the chip $$$a_i$$$ positions to the right (i.e. replace $$$i$$$ with $$$i + a_i$$$).  If $$$i &gt; n$$$, then Polycarp ends the game. For example, if $$$n = 5$$$ and $$$a = [7, 3, 1, 2, 3]$$$, then the following game options are possible:   Polycarp chooses $$$i = 1$$$. Game process: $$$i = 1 \overset{+7}{\longrightarrow} 8$$$. The score of the game is: $$$a_1 = 7$$$.  Polycarp chooses $$$i = 2$$$. Game process: $$$i = 2 \overset{+3}{\longrightarrow} 5 \overset{+3}{\longrightarrow} 8$$$. The score of the game is: $$$a_2 + a_5 = 6$$$.  Polycarp chooses $$$i = 3$$$. Game process: $$$i = 3 \overset{+1}{\longrightarrow} 4 \overset{+2}{\longrightarrow} 6$$$. The score of the game is: $$$a_3 + a_4 = 3$$$.  Polycarp chooses $$$i = 4$$$. Game process: $$$i = 4 \overset{+2}{\longrightarrow} 6$$$. The score of the game is: $$$a_4 = 2$$$.  Polycarp chooses $$$i = 5$$$. Game process: $$$i = 5 \overset{+3}{\longrightarrow} 8$$$. The score of the game is: $$$a_5 = 3$$$. Help Polycarp to find out the maximum score he can get if he chooses the starting index in an optimal way. NoteThe first test case is explained in the statement.In the second test case, the maximum score can be achieved by choosing $$$i = 1$$$.In the third test case, the maximum score can be achieved by choosing $$$i = 2$$$.In the fourth test case, the maximum score can be achieved by choosing $$$i = 1$$$. 
if __name__ == '__main__':
    t = int(input())
    for _ in range(t):
        n = int(input())
        nums = list(map(int, input().split()))
        result, max_found = [], -float('inf')
        for x in nums:
            result.append(x)
            max_found = max(max_found, x) 
        parent = {i:i for i in range(len(nums))}
        for i in range(len(nums)):
            next_idx = i + nums[i]
            while next_idx < len(nums) and parent[next_idx] == next_idx:
                result[i] += nums[next_idx]
                parent[next_idx] = i
                next_idx = next_idx + nums[next_idx]
            max_found = max(max_found, result[i])

        print(max_found)
","['dp', 'graphs']"
2651,"Iahub accidentally discovered a secret lab. He found there n devices ordered in a line, numbered from 1 to n from left to right. Each device i (1 ≤ i ≤ n) can create either ai units of matter or ai units of antimatter. Iahub wants to choose some contiguous subarray of devices in the lab, specify the production mode for each of them (produce matter or antimatter) and finally take a photo of it. However he will be successful only if the amounts of matter and antimatter produced in the selected subarray will be the same (otherwise there would be overflowing matter or antimatter in the photo). You are requested to compute the number of different ways Iahub can successful take a photo. A photo is different than another if it represents another subarray, or if at least one device of the subarray is set to produce matter in one of the photos and antimatter in the other one. NoteThe possible photos are [1+, 2-], [1-, 2+], [2+, 3-], [2-, 3+], [3+, 4-], [3-, 4+], [1+, 2+, 3-, 4-], [1+, 2-, 3+, 4-], [1+, 2-, 3-, 4+], [1-, 2+, 3+, 4-], [1-, 2+, 3-, 4+] and [1-, 2-, 3+, 4+], where ""i+"" means that the i-th element produces matter, and ""i-"" means that the i-th element produces antimatter. from sys import stdin
N = 1000000007
 
def read_input():
    n = int(stdin.readline())
    devices = [int(x) for x in stdin.readline().split()]
 
    return n, devices
 
if __name__ == ""__main__"":
    n, devices = read_input()
    M, r = sum(devices), 0
    res = [[0] * (2 * M + 1) for _ in range(n+1)]
 
    for nb, val in enumerate(devices, 1):
        for i in range(2 * M):
            if i - val >= 0:
                res[nb][i-val] = (res[nb][i-val] + res[nb-1][i]) % N
            if i + val <= 2 * M:
                res[nb][i+val] = (res[nb][i+val] + res[nb-1][i]) % N
 
        res[nb][M+val] += 1
        res[nb][M-val] += 1
 
        r = (r + res[nb][M]) % N
 
    print(r)
",['dp']
2118,"Let $$$\mathsf{AND}$$$ denote the bitwise AND operation, and $$$\mathsf{OR}$$$ denote the bitwise OR operation.You are given an array $$$a$$$ of length $$$n$$$ and a non-negative integer $$$k$$$. You can perform at most $$$k$$$ operations on the array of the following type:  Select an index $$$i$$$ ($$$1 \leq i \leq n$$$) and replace $$$a_i$$$ with $$$a_i$$$ $$$\mathsf{OR}$$$ $$$2^j$$$ where $$$j$$$ is any integer between $$$0$$$ and $$$30$$$ inclusive. In other words, in an operation you can choose an index $$$i$$$ ($$$1 \leq i \leq n$$$) and set the $$$j$$$-th bit of $$$a_i$$$ to $$$1$$$ ($$$0 \leq j \leq 30$$$). Output the maximum possible value of $$$a_1$$$ $$$\mathsf{AND}$$$ $$$a_2$$$ $$$\mathsf{AND}$$$ $$$\dots$$$ $$$\mathsf{AND}$$$ $$$a_n$$$ after performing at most $$$k$$$ operations.  NoteFor the first test case, we can set the bit $$$1$$$ ($$$2^1$$$) of the last $$$2$$$ elements using the $$$2$$$ operations, thus obtaining the array [$$$2$$$, $$$3$$$, $$$3$$$], which has $$$\mathsf{AND}$$$ value equal to $$$2$$$.For the second test case, we can't perform any operations so the answer is just the $$$\mathsf{AND}$$$ of the whole array which is $$$4$$$. #https://codeforces.com/blog/entry/71884
import sys
input = sys.stdin.readline
from math import inf, gcd, log, log2, floor, ceil, sqrt
from collections import Counter, defaultdict, deque
from heapq import heappush, heappop, heapify
from functools import lru_cache
from bisect import bisect_left, bisect_right

############ ---- Input Functions ---- ############
def inp():
    return(int(input()))
def inlt():
    return(list(map(int,input().split())))
def insr():
    s = input()
    return(list(s[:len(s) - 1]))
def invr():
    return(map(int,input().split()))

def solve(n,k,arr):
    t = k
    bits = [0]*31
    for x in arr:
        num = '{:031b}'.format(x)
        for i in range(len(num)):
            if num[i] == ""0"":
                bits[len(num)-i-1] += 1
    ans = 0
    for i in range(len(bits)-1,-1,-1):
        if k >= bits[i]:
            k -= bits[i]
            ans += pow(2,i)

    return ans




 
t = inp()
for k in range(t):
    d = inlt()
    n, k = d[0],d[1]
    arr = inlt()
    print(solve(n,k,arr))
    
","['bitmasks', 'greedy', 'math']"
1807,"Dima has a birthday soon! It's a big day! Saryozha's present to Dima is that Seryozha won't be in the room and won't disturb Dima and Inna as they celebrate the birthday. Inna's present to Dima is a stack, a queue and a deck.Inna wants her present to show Dima how great a programmer he is. For that, she is going to give Dima commands one by one. There are two types of commands:  Add a given number into one of containers. For the queue and the stack, you can add elements only to the end. For the deck, you can add elements to the beginning and to the end.  Extract a number from each of at most three distinct containers. Tell all extracted numbers to Inna and then empty all containers. In the queue container you can extract numbers only from the beginning. In the stack container you can extract numbers only from the end. In the deck number you can extract numbers from the beginning and from the end. You cannot extract numbers from empty containers. Every time Dima makes a command of the second type, Inna kisses Dima some (possibly zero) number of times. Dima knows Inna perfectly well, he is sure that this number equals the sum of numbers he extracts from containers during this operation.As we've said before, Dima knows Inna perfectly well and he knows which commands Inna will give to Dima and the order of the commands. Help Dima find the strategy that lets him give as more kisses as possible for his birthday! nan n = int(raw_input())
pq,q = [],[]
st = [""Queue"",""Stack"",""Front"",""Back""]
for i in xrange(0,n+1):
    a = 0
    if i<n :  a = int(raw_input())
    if a!=0 : 
        pq.append(a)
        q.append(a)
    else :
        sz,mx,f = 0,[1E7,1E7,1E7],[0,0,0]
        pq.sort(reverse=True)
        for val in pq:
            if sz<3 : 
                mx[sz] = val
                sz+=1
            else : break
        for val in q:
            if val==mx[0] and mx[0]!=1E7 and f[0]==0 :
                print ""push"" + st[0]
                f[0] = 1
            elif val==mx[1] and mx[1]!=1E7 and f[1]==0 :
                print ""push"" + st[1]
                f[1] = 1
            elif val==mx[2] and mx[2]!=1E7 and f[2]==0 :
                print ""push"" + st[2]
                f[2] = 1
            else : print ""push"" + st[3]
        pq,q = [],[]
        if i==n : break
        lis = str(sz)
        if sz!=0 : lis+= "" pop"" + "" pop"".join([st[j] for j in xrange(0,sz)]) 
        print lis

","['constructive algorithms', 'greedy', 'implementation']"
2378,"The prison of your city has n prisoners. As the prison can't accommodate all of them, the city mayor has decided to transfer c of the prisoners to a prison located in another city.For this reason, he made the n prisoners to stand in a line, with a number written on their chests. The number is the severity of the crime he/she has committed. The greater the number, the more severe his/her crime was.Then, the mayor told you to choose the c prisoners, who will be transferred to the other prison. He also imposed two conditions. They are,  The chosen c prisoners has to form a contiguous segment of prisoners.  Any of the chosen prisoner's crime level should not be greater then t. Because, that will make the prisoner a severe criminal and the mayor doesn't want to take the risk of his running away during the transfer. Find the number of ways you can choose the c prisoners. nan __author__ = 'cecilia'

c=raw_input().split()
a=raw_input().split()
c=map(int,c)
a=map(int,a)
b=[]
d=[]
for i in range(c[0]):
    if a[i]>c[1]:
        b.append(i)
b.append(c[0])
d.append(b[0])
for i in range(1,len(b)):
    e=b[i]-b[i-1]-1
    if e>=c[2]:
        e = e-(c[2]-1)
        if e>=0:
            d.append(e)
d[0]=d[0]-(c[2]-1)
if d[0]<0:
    d[0]=0
f=sum(d)

print f","['data structures', 'implementation']"
4260,"Students of Winter Informatics School are going to live in a set of houses connected by underground passages. Teachers are also going to live in some of these houses, but they can not be accommodated randomly. For safety reasons, the following must hold:  All passages between two houses will be closed, if there are no teachers in both of them. All other passages will stay open.  It should be possible to travel between any two houses using the underground passages that are open.  Teachers should not live in houses, directly connected by a passage. Please help the organizers to choose the houses where teachers will live to satisfy the safety requirements or determine that it is impossible. NoteThe picture below shows the second example test.    import sys
input=sys.stdin.buffer.readline
t=int(input())
for _ in range(t):
    n,m=map(int,input().split())
    g=[[] for i in range(n+1)]
    for __ in range(m):
        u,v=map(int,input().split())
        g[u].append(v)
        g[v].append(u)
    black=[-1 for i in range(n+1)]
    ans=[]
    path=[1]
    black[0]=2
    black[1]=1
    while path:
        x=path.pop()
        for y in g[x]:
            if black[x]==1:
                if black[y]==-1:
                    path.append(y)
                black[y]=0
            elif black[y]==-1:
                path.append(y)
                black[y]=1
    if -1 in black:
        print('NO')
        continue
    print('YES')
    for i in range(1,n+1):
        if black[i]==1:
            ans.append(i)
    print(len(ans))
    print("" "".join(str(i) for i in ans))

","['constructive algorithms', 'dfs and similar', 'graphs', 'greedy', 'other']"
3254,"n people came to a party. Then those, who had no friends among people at the party, left. Then those, who had exactly 1 friend among those who stayed, left as well. Then those, who had exactly 2, 3, ..., n - 1 friends among those who stayed by the moment of their leaving, did the same.What is the maximum amount of people that could stay at the party in the end?  nan n = input()
for i in range(0,int (n)):
	x = input()
	if int(x)-2 == -1:
		print(0)
	else:
		print(int(x)-2)","['constructive algorithms', 'graphs', 'math']"
3559,"Sereja has got an array, consisting of n integers, a1, a2, ..., an. Sereja is an active boy, so he is now going to complete m operations. Each operation will have one of the three forms:  Make vi-th array element equal to xi. In other words, perform the assignment avi = xi.  Increase each array element by yi. In other words, perform n assignments ai = ai + yi (1 ≤ i ≤ n).  Take a piece of paper and write out the qi-th array element. That is, the element aqi. Help Sereja, complete all his operations. nan def go():
    n, m = (int(i) for i in input().split(' '))
    a = [int(i) for i in input().split(' ')]
    keep = 0
    o = ''
    for i in range(m):
        data = tuple(int(i) for i in input().split(' '))
        if data[0] == 1:
            a[data[1] - 1] = data[2] - keep
        elif data[0] == 2:
            keep += data[1]
        elif data[0] == 3:
            o += '{}\n'.format(a[data[1] - 1] + keep)
    return o

print(go())
",['implementation']
3683,"The city where Mocha lives in is called Zhijiang. There are $$$n+1$$$ villages and $$$2n-1$$$ directed roads in this city. There are two kinds of roads:  $$$n-1$$$ roads are from village $$$i$$$ to village $$$i+1$$$, for all $$$1\leq i \leq n-1$$$.  $$$n$$$ roads can be described by a sequence $$$a_1,\ldots,a_n$$$. If $$$a_i=0$$$, the $$$i$$$-th of these roads goes from village $$$i$$$ to village $$$n+1$$$, otherwise it goes from village $$$n+1$$$ to village $$$i$$$, for all $$$1\leq i\leq n$$$. Mocha plans to go hiking with Taki this weekend. To avoid the trip being boring, they plan to go through every village exactly once. They can start and finish at any villages. Can you help them to draw up a plan?  NoteIn the first test case, the city looks like the following graph:So all possible answers are $$$(1 \to 4 \to 2 \to 3)$$$, $$$(1 \to 2 \to 3 \to 4)$$$.In the second test case, the city looks like the following graph:So all possible answers are $$$(4 \to 1 \to 2 \to 3)$$$, $$$(1 \to 2 \to 3 \to 4)$$$, $$$(3 \to 4 \to 1 \to 2)$$$, $$$(2 \to 3 \to 4 \to 1)$$$. import sys
from os import path
def input():
    return sys.stdin.readline().strip()

def solve(n,array):
    # YOUR CODE HERE
    answer = list(range(1,n+1))
    if array[n-1] == 0:
        answer.append(n+1)
    elif array[0] == 1:
        answer.insert(0,n+1)
    else:
        for index in range(n-1):
            if array[index] == 0 and array[index+1] == 1:
                answer.insert(index+1,n+1)
                break
    
    print(*answer)


def main():
    # testcases = 1 
    
    testcases = int(input()) # multiple testcases
    for _ in range(testcases):
        solve(int(input()),list(map(int,input().split())))


if __name__ == ""__main__"":
    if(path.exists('input.txt')):
        sys.stdin = open(""input.txt"",""r"")
        sys.stdout = open(""output.txt"",""w"")
    main()
        
","['constructive algorithms', 'graphs']"
3783,"Anfisa the monkey learns to type. She is yet unfamiliar with the ""space"" key and can only type in lower-case Latin letters. Having typed for a fairly long line, Anfisa understood that it would be great to divide what she has written into k lines not shorter than a and not longer than b, for the text to resemble human speech more. Help Anfisa. nan #
# Yet I'm feeling like
# 	There is no better place than right by your side
# 		I had a little taste
# 			And I'll only spoil the party anyway
# 				'Cause all the girls are looking fine
# 					But you're the only one on my mind


import sys
import re
# inf = float(""inf"")
#sys.setrecursionlimit(1000000)

# abc='abcdefghijklmnopqrstuvwxyz'
# abd={'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}
# mod,MOD=1000000007,998244353
# vow=['a','e','i','o','u']
# dx,dy=[-1,1,0,0],[0,0,1,-1]

# from cmath import sqrt
# from collections import deque, Counter, OrderedDict,defaultdict
# from heapq import nsmallest, nlargest, heapify,heappop ,heappush, heapreplace
# from math import ceil,floor,log,sqrt,factorial,pow,pi,gcd,log10,atan,tan
# from bisect import bisect_left,bisect_right
# import numpy as np

def get_array(): return list(map(int , sys.stdin.readline().strip().split()))
def get_ints(): return map(int, sys.stdin.readline().strip().split())
def input(): return sys.stdin.readline().strip()

k,a,b=get_ints()
string=input()
length=len(string)
if length<a*k or length>b*k:
    print('No solution')
    exit()
result=[a]*k
remaining=length-k*a
index=k-1
while remaining>0:
    can_add=b-result[index]
    result[index]+=min(can_add,remaining)
    remaining-=min(can_add,remaining)
    index-=1
last=0
answer=[]
for i in range(1,len(result)):
    result[i]+=result[i-1]
for i in result:
    answer.append(string[last:i])
    last=i
for i in answer:
    print i",['dp']
2845,"Once Petya was in such a good mood that he decided to help his mum with the washing-up. There were n dirty bowls in the sink. From the geometrical point of view each bowl looks like a blunted cone. We can disregard the width of the walls and bottom. Petya puts the clean bowls one on another naturally, i. e. so that their vertical axes coincide (see the picture). You will be given the order in which Petya washes the bowls. Determine the height of the construction, i.e. the distance from the bottom of the lowest bowl to the top of the highest one.    nan import sys
from array import array  # noqa: F401


def input1():
    with open('input.txt') as fp:
        return fp.readlines()


def output1(ans: str):
    with open('output.txt', mode='w') as fp:
        fp.write(ans)


def input2():
    return [line.decode('utf-8') for line in sys.stdin.buffer.readlines()]


def output2(ans):
    print(ans)


submit = 1
if submit:
    input = input1
    output = output1
else:
    input = input2
    output = output2


s = input()
n = int(s[0])
bowls = [tuple(map(float, line.split())) for line in s[1:]]
ans = bowls[0][0]
bottom = [0.0] * n
eps = 1e-9

for i in range(1, n):
    hi, ri, Ri = bowls[i]
    res = bottom[i - 1]

    for j in range(i - 1, -1, -1):
        hj, rj, Rj = bowls[j]
        x = 0.0

        if Rj <= ri:
            x = hj
        elif Rj >= Ri:
            x = max((Ri - rj) / (Rj - rj) * hj - hi, (ri - rj) / (Rj - rj) * hj)
        else:
            x = max(hj - (Rj - ri) / (Ri - ri) * hi, (ri - rj) / (Rj - rj) * hj)

        res = max(res, x + bottom[j])

    bottom[i] = res
    ans = max(ans, bottom[i] + hi)

output('{:.10f}'.format(ans))
","['geometry', 'implementation']"
3307,"Amr lives in Lala Land. Lala Land is a very beautiful country that is located on a coordinate line. Lala Land is famous with its apple trees growing everywhere.Lala Land has exactly n apple trees. Tree number i is located in a position xi and has ai apples growing on it. Amr wants to collect apples from the apple trees. Amr currently stands in x = 0 position. At the beginning, he can choose whether to go right or left. He'll continue in his direction until he meets an apple tree he didn't visit before. He'll take all of its apples and then reverse his direction, continue walking in this direction until he meets another apple tree he didn't visit before and so on. In the other words, Amr reverses his direction when visiting each new apple tree. Amr will stop collecting apples when there are no more trees he didn't visit in the direction he is facing.What is the maximum number of apples he can collect? NoteIn the first sample test it doesn't matter if Amr chose at first to go left or right. In both cases he'll get all the apples.In the second sample test the optimal solution is to go left to x =  - 1, collect apples from there, then the direction will be reversed, Amr has to go to x = 1, collect apples from there, then the direction will be reversed and Amr goes to the final tree x =  - 2.In the third sample test the optimal solution is to go right to x = 1, collect apples from there, then the direction will be reversed and Amr will not be able to collect anymore apples because there are no apple trees to his left. def nsum(a):
    res = 0
    for i in range(len(a)):
        res += a[i][1]
    return res

n = int(input())
l, r = [], []
for i in range(n):
    x, t = [int(x) for x in input().split()]
    if x < 0:
        l.append([-x, t])
    else:
        r.append([x, t])
l.sort()
r.sort()
if len(l) == len(r):
    print(nsum(l) + nsum(r))
elif len(l) < len(r):
    print(nsum(r[:len(l)+1]) + nsum(l))
else:
    print(nsum(r) + nsum(l[:len(r)+1]))
","['brute force', 'implementation', 'sortings']"
3192,"The city Valera lives in is going to hold elections to the city Parliament.The city has n districts and n - 1 bidirectional roads. We know that from any district there is a path along the roads to any other district. Let's enumerate all districts in some way by integers from 1 to n, inclusive. Furthermore, for each road the residents decided if it is the problem road or not. A problem road is a road that needs to be repaired.There are n candidates running the elections. Let's enumerate all candidates in some way by integers from 1 to n, inclusive. If the candidate number i will be elected in the city Parliament, he will perform exactly one promise — to repair all problem roads on the way from the i-th district to the district 1, where the city Parliament is located.Help Valera and determine the subset of candidates such that if all candidates from the subset will be elected to the city Parliament, all problem roads in the city will be repaired. If there are several such subsets, you should choose the subset consisting of the minimum number of candidates. nan import sys
from math import sqrt, gcd, ceil, log
# from bisect import bisect, bisect_left
from collections import defaultdict, Counter, deque
# from heapq import heapify, heappush, heappop
input = sys.stdin.readline
read = lambda: list(map(int, input().strip().split()))

sys.setrecursionlimit(200000)


def main(): 
	n = int(input()); 
	adj = defaultdict(list)
	problem = set()
	for i in range(n-1):
		x, y, t = read()
		adj[x].append(y)
		adj[y].append(x)
		if t == 2:problem.add((x, y))


	parent = defaultdict(int)
	order = []
	def dfs():
		stk = [(1, 0)]
		while stk:
			node, par = stk.pop()
			order.append(node); parent[node] = par
			for child in adj[node]:
				if child != par:
					stk.append((child, node))
		# return(order)
		# lis = []
		# for child in adj[node]:
		# 	if child != par:
		# 		tem = dfs(child, node)
		# 		if (node, child) in problem or (child, node) in problem:
		# 			if tem == []:lis.append(child)
		# 			else:lis.extend(tem)
		# 		elif tem:
		# 			lis.extend(tem)
		# return(lis)
	dfs()
	# print(order)
	# print(parent)
	dic = defaultdict(int)
	ans = []
	for i in range(n-1, -1, -1):
		child = order[i]; par = parent[order[i]]
		if dic[child]:
			dic[par] += dic[child]
		elif (child, par) in problem or (par, child) in problem:
			ans.append(child)
			dic[par] += 1
	print(len(ans))
	print(*ans)



			






if __name__ == ""__main__"":
	main()","['dfs and similar', 'graphs', 'trees']"
1041,"You are given an array $$$a$$$ consisting of $$$500000$$$ integers (numbered from $$$1$$$ to $$$500000$$$). Initially all elements of $$$a$$$ are zero.You have to process two types of queries to this array:  $$$1$$$ $$$x$$$ $$$y$$$ — increase $$$a_x$$$ by $$$y$$$;  $$$2$$$ $$$x$$$ $$$y$$$ — compute $$$\sum\limits_{i \in R(x, y)} a_i$$$, where $$$R(x, y)$$$ is the set of all integers from $$$1$$$ to $$$500000$$$ which have remainder $$$y$$$ modulo $$$x$$$. Can you process all the queries? nan import sys
range = xrange
big = 500001
A = [0]*big
small = 500
buckets = [[0]*i for i in range(1, small + 1)]

def add(x,y):
    for i,b in enumerate(buckets):
        b[x%(i+1)] += y

def summa(x,i):
    s = 0
    while i < big:
        s += A[i]
        i += x
    return s

inp = [int(x) for x in sys.stdin.read().split()]
ii = 0

q = inp[ii]
ii += 1
out = []
for _ in range(q):
    c = inp[ii]
    ii += 1
    x = inp[ii]
    ii += 1
    y = inp[ii]
    ii += 1
    if c == 1:
        A[x] += y
        add(x,y)
    else:
        s = buckets[x - 1][y] if x<=small else summa(x,y)
        out.append(s)
print '\n'.join(str(x) for x in out)
","['brute force', 'data structures', 'implementation']"
4633,"Ujan has a lot of numbers in his boxes. He likes order and balance, so he decided to reorder the numbers.There are $$$k$$$ boxes numbered from $$$1$$$ to $$$k$$$. The $$$i$$$-th box contains $$$n_i$$$ integer numbers. The integers can be negative. All of the integers are distinct. Ujan is lazy, so he will do the following reordering of the numbers exactly once. He will pick a single integer from each of the boxes, $$$k$$$ integers in total. Then he will insert the chosen numbers — one integer in each of the boxes, so that the number of integers in each box is the same as in the beginning. Note that he may also insert an integer he picked from a box back into the same box.Ujan will be happy if the sum of the integers in each box is the same. Can he achieve this and make the boxes perfectly balanced, like all things should be? NoteIn the first sample, Ujan can put the number $$$7$$$ in the $$$2$$$nd box, the number $$$2$$$ in the $$$3$$$rd box, the number $$$5$$$ in the $$$1$$$st box and keep the number $$$10$$$ in the same $$$4$$$th box. Then the boxes will contain numbers $$$\{1,5,4\}$$$, $$$\{3, 7\}$$$, $$$\{8,2\}$$$ and $$$\{10\}$$$. The sum in each box then is equal to $$$10$$$.In the second sample, it is not possible to pick and redistribute the numbers in the required way.In the third sample, one can swap the numbers $$$-20$$$ and $$$-10$$$, making the sum in each box equal to $$$-10$$$. import sys
reader = (s.rstrip() for s in sys.stdin)
input = reader.__next__

k = int(input())
d = {}
aa = []
sa = []
for i in range(k):
    ni, *a = map(int, input().split())
    for ai in a:
        d[ai] = i
    aa.append(a)
    sa.append(sum(a))

s = sum(sa)
if s%k != 0:
    print(""No"")
    exit()
s //= k

def calc_next(i, aij):
    bij = s-sa[i]+aij
    if bij not in d:
        return -1, bij
    else:
        return d[bij], bij

def loop_to_num(loop):
    ret = 0
    for i in reversed(range(k)):
        ret <<= 1
        ret += loop[i]
    return ret

loop_dict = {}
used = set()
for i in range(k):
    for aij in aa[i]:
        if aij in used:
            continue

        loop = [0]*k
        num = [float(""Inf"")]*k
        start_i = i
        start_aij = aij
        j = i

        loop[j] = 1
        num[j] = aij
        used.add(aij)

        exist = False
        for _ in range(100):
            j, aij = calc_next(j, aij)
            if j == -1:
                break
            #used.add(aij)
            if loop[j] == 0:
                loop[j] = 1
                num[j] = aij
            else:
                if j == start_i and aij == start_aij:
                    exist = True
                break
        if exist:
            m = loop_to_num(loop)
            loop_dict[m] = tuple(num)
            for numi in num:
                if numi != float(""inf""):
                    used.add(numi)

mask = 1<<k
for state in range(1, mask):
    if state in loop_dict:
        continue
    j = (state-1)&state
    while j:
        i = state^j
        if i in loop_dict and j in loop_dict:
            tp = tuple(min(loop_dict[i][l], loop_dict[j][l]) for l in range(k))
            loop_dict[state] = tp
            break
        j = (j-1)&state

if mask-1 not in loop_dict:
    print(""No"")
else:
    print(""Yes"")
    t = loop_dict[mask-1]
    ns = [sa[i]-t[i] for i in range(k)]
    need = [s - ns[i] for i in range(k)]
    for i in range(k):
        print(t[i], need.index(t[i])+1)","['bitmasks', 'dfs and similar', 'dp', 'graphs', 'implementation']"
3998,"Implication is a function of two logical arguments, its value is false if and only if the value of the first argument is true and the value of the second argument is false. Implication is written by using character '', and the arguments and the result of the implication are written as '0' (false) and '1' (true). According to the definition of the implication:   When a logical expression contains multiple implications, then when there are no brackets, it will be calculated from left to fight. For example,. When there are brackets, we first calculate the expression in brackets. For example,.For the given logical expression  determine if it is possible to place there brackets so that the value of a logical expression is false. If it is possible, your task is to find such an arrangement of brackets. nan def f(a):
    if len(a) == 1:
        if a[0] == 0:
            print(""YES\n0"")
            return
        else:
            print(""NO"")
            return
    if a[-1] == 1:
        print(""NO"")
        return
    if a[-2] == 1:
        print(""YES"")
        print(""->"".join(str(x) for x in a))
        return
    elif len(a) == 2:
        print(""NO"")
        return
    elif len(a) >= 3 and a[-3] == 0:
        a[-3] = '(0'
        a[-2] = '0)'
        print(""YES\n"" + ""->"".join(str(x) for x in a))
        return      
    for i in range(len(a) - 3, -1, -1):
        if a[i] == 0:
            a[i] = '(' + str(a[i])
            a[i+1] = '(' + str(a[i+1])
            a[-2] = '0))'
            print(""YES\n"" + ""->"".join(str(x) for x in a))
            return
    print(""NO"")
    return

n = int(input())
a = list(int(x) for x in input().split())
f(a)","['constructive algorithms', 'greedy', 'implementation', 'math']"
2874,"In a far away kingdom lived the King, the Prince, the Shoemaker, the Dressmaker and many other citizens. They lived happily until great trouble came into the Kingdom. The ACMers settled there.Most damage those strange creatures inflicted upon the kingdom was that they loved high precision numbers. As a result, the Kingdom healers had already had three appointments with the merchants who were asked to sell, say, exactly 0.273549107 beer barrels. To deal with the problem somehow, the King issued an order obliging rounding up all numbers to the closest integer to simplify calculations. Specifically, the order went like this: If a number's integer part does not end with digit 9 and its fractional part is strictly less than 0.5, then the rounded up number coincides with the number’s integer part.  If a number's integer part does not end with digit 9 and its fractional part is not less than 0.5, the rounded up number is obtained if we add 1 to the last digit of the number’s integer part. If the number’s integer part ends with digit 9, to round up the numbers one should go to Vasilisa the Wise. In the whole Kingdom she is the only one who can perform the tricky operation of carrying into the next position. Merchants found the algorithm very sophisticated and they asked you (the ACMers) to help them. Can you write a program that would perform the rounding according to the King’s order? nan import decimal
D=decimal.Decimal
s = input()
place = s.index(""."")
last = s[place-1]
next = s[place+1]
#print(last,int(next)<5)

if last == ""9"": #and int(next)>=5:
        print(""GOTO Vasilisa."")
#elif last==""9"" and int(next)<5:
        #print(""HI"")
        #print(s[:place])
elif last!=""9"" and int(next)>=5:
        #print(""HO"")
        print(s[:place-1]+str((int(s[place-1])+1)))
else:
        #print(""NEATO"")
        print(s[:place])



",['strings']
3901,"Vladik often travels by trains. He remembered some of his trips especially well and I would like to tell you about one of these trips:Vladik is at initial train station, and now n people (including Vladik) want to get on the train. They are already lined up in some order, and for each of them the city code ai is known (the code of the city in which they are going to).Train chief selects some number of disjoint segments of the original sequence of people (covering entire sequence by segments is not necessary). People who are in the same segment will be in the same train carriage. The segments are selected in such way that if at least one person travels to the city x, then all people who are going to city x should be in the same railway carriage. This means that they can’t belong to different segments. Note, that all people who travel to the city x, either go to it and in the same railway carriage, or do not go anywhere at all.Comfort of a train trip with people on segment from position l to position r is equal to XOR of all distinct codes of cities for people on the segment from position l to position r. XOR operation also known as exclusive OR.Total comfort of a train trip is equal to sum of comfort for each segment.Help Vladik to know maximal possible total comfort. NoteIn the first test case best partition into segments is: [4, 4] [2, 5, 2] [3], answer is calculated as follows: 4 + (2 xor 5) + 3 = 4 + 7 + 3 = 14In the second test case best partition into segments is: 5 1 [3] 1 5 [2, 4, 2] 5, answer calculated as follows: 3 + (2 xor 4) = 3 + 6 = 9. n = int(input())
a = list(map(int, input().split()))

dp = [0]*(n + 1)
f,l = {}, {}
for i in range(len(a)):
    x = a[i]
    if x not in f:
        f[x] = i
    l[x] = i
pr = [a[0]]

for i in range(1, len(a) + 1):
    j = i
    mx = 0
    nums = set()
    curxor = 0
    b = i
    while j > 0:
        x = a[j-1]
        if l[x] > i - 1:
            break
        if x not in nums:
            nums.add(x)
            curxor ^= x
        b = min(b, f[x] + 1)
        if b == j:
            mx = max(mx, dp[j-1] + curxor)
        j -= 1
    dp[i] = max(dp[i-1], mx)
print(dp[len(a)])","['dp', 'implementation']"
1615,"You are given three integers $$$a$$$, $$$b$$$, and $$$d$$$. Your task is to find any integer $$$x$$$ which satisfies all of the following conditions, or determine that no such integers exist:  $$$0 \le x \lt 2^{60}$$$;  $$$a|x$$$ is divisible by $$$d$$$;  $$$b|x$$$ is divisible by $$$d$$$. Here, $$$|$$$ denotes the bitwise OR operation. NoteIn the first test case, $$$x=18$$$ is one of the possible solutions, since $$$39|18=55$$$ and $$$12|18=30$$$, both of which are multiples of $$$d=5$$$.In the second test case, $$$x=14$$$ is one of the possible solutions, since $$$8|14=6|14=14$$$, which is a multiple of $$$d=14$$$.In the third and fourth test cases, we can show that there are no solutions. 
""""""**************************************************************\
                   BISMILLAHIR RAHMANIR RAHIM
****************************************************************
               AUTHOR NAME: MD. TAHURUZZOHA TUHIN
\**************************************************************""""""


#!/usr/bin/env python

import os
import sys
from collections import Counter, defaultdict, deque
from heapq import heapify, heappop, heappush
# from math import *
from io import BytesIO, IOBase

if sys.version_info[0] < 3:
    from __builtin__ import xrange as range
    from future_builtins import ascii, filter, hex, map, oct, zip


# Start FASTIO
BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._file = file
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


def print(*args, **kwargs):
    sep, file = kwargs.pop(""sep"", "" ""), kwargs.pop(""file"", sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop(""end"", ""\n""))
    if kwargs.pop(""flush"", False):
        file.flush()


if sys.version_info[0] < 3:
    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)


# def input(): return sys.stdin.readline().rstrip(""\r\n"")


def prod(a, mod=10 ** 9 + 7):
    ans = 1
    for each in a:
        ans = (ans * each) % mod
    return ans


def gcd(x, y):
    while y:
        x, y = y, x % y
    return x


def lcm(a, b): return a * b // gcd(a, b)


def binary(x, length=16):
    y = bin(x)[2:]
    return y if len(y) >= length else ""0"" * (length - len(y)) + y


def check_freq(x):
    freq = {}
    for c in set(x):
        freq[c] = x.count(c)
    return freq


def numToDigit(x):
    box = []
    while(x):
        tmp = x % 10
        x = x//10
        box.append(tmp)
    box.reverse()
    return box


def ii(): return int(input())
def si(): return input()
def mi(): return map(int, input().strip().split("" ""))
def li(): return list(mi())

MAXX = 100000000

'''**************Solution is Here***********'''

def main():

    T=int(input())
    for i in range(T):
        a,b,d=map(int,input().split())
        num=1
        while d%2==0:
            d//=2
            num*=2
        bitOr=a|b
        if bitOr%num!=0:
            
            print(-1)
            continue
        
        shift=(1<<30)%d
        count=(-bitOr*pow(shift,-1,d))%d
        res=(count<<30)+bitOr
        print(res)
            
# End FASTIO
if __name__ == ""__main__"":
    main()

","['bitmasks', 'combinatorics', 'constructive algorithms', 'math', 'number theory', 'other']"
1738,"In a far away land, there are two cities near a river. One day, the cities decide that they have too little space and would like to reclaim some of the river area into land.The river area can be represented by a grid with r rows and exactly two columns — each cell represents a rectangular area. The rows are numbered 1 through r from top to bottom, while the columns are numbered 1 and 2.Initially, all of the cells are occupied by the river. The plan is to turn some of those cells into land one by one, with the cities alternately choosing a cell to reclaim, and continuing until no more cells can be reclaimed.However, the river is also used as a major trade route. The cities need to make sure that ships will still be able to sail from one end of the river to the other. More formally, if a cell (r, c) has been reclaimed, it is not allowed to reclaim any of the cells (r - 1, 3 - c), (r, 3 - c), or (r + 1, 3 - c).The cities are not on friendly terms, and each city wants to be the last city to reclaim a cell (they don't care about how many cells they reclaim, just who reclaims a cell last). The cities have already reclaimed n cells. Your job is to determine which city will be the last to reclaim a cell, assuming both choose cells optimally from current moment. NoteIn the first example, there are 3 possible cells for the first city to reclaim: (2, 1), (3, 1), or (3, 2). The first two possibilities both lose, as they leave exactly one cell for the other city.  However, reclaiming the cell at (3, 2) leaves no more cells that can be reclaimed, and therefore the first city wins.  In the third example, there are no cells that can be reclaimed. r,n = [int(x) for x in input().split()]
cells = [[int(x) for x in input().split()] for i in range(n)]
cells.sort()
#print(cells)
out = False

res = {True:""WIN"",False:""LOSE""}

if len(cells) == 0: print(res[r%2 == 1])
else:
    out = False
    #print(cells[0][0] > 1)
    #print(cells[-1][0] < r)
    for i in range(1,n):
        out ^= ((cells[i][0]-cells[i-1][0]-1)%2) ^ (cells[i][1] != cells[i-1][1])
    dif = abs((cells[0][0]-1)-(r-cells[-1][0]))
    #print(out,dif)
    hi,lo = max(cells[0][0]-1,r-cells[-1][0]),min(cells[0][0]-1,r-cells[-1][0])
    #print(out,dif,lo,hi)
    if lo > 1:
        if dif == 0:
            print(res[out])
        elif dif == 1 and lo % 2 == 0:
            print(res[not out])
        else:
            print(res[True])
    elif lo == 0:
        if hi == 0: print(res[out])
        elif hi == 1:
            print(res[not out])
        else:
            print(res[True])
    elif lo == 1:
        if hi == 1:
            print(res[out])
        else:
            print(res[True])
",['games']
166,"We start with a string $$$s$$$ consisting only of the digits $$$1$$$, $$$2$$$, or $$$3$$$. The length of $$$s$$$ is denoted by $$$|s|$$$. For each $$$i$$$ from $$$1$$$ to $$$|s|$$$, the $$$i$$$-th character of $$$s$$$ is denoted by $$$s_i$$$. There is one cursor. The cursor's location $$$\ell$$$ is denoted by an integer in $$$\{0, \ldots, |s|\}$$$, with the following meaning:   If $$$\ell = 0$$$, then the cursor is located before the first character of $$$s$$$.  If $$$\ell = |s|$$$, then the cursor is located right after the last character of $$$s$$$.  If $$$0 &lt; \ell &lt; |s|$$$, then the cursor is located between $$$s_\ell$$$ and $$$s_{\ell+1}$$$. We denote by $$$s_\text{left}$$$ the string to the left of the cursor and $$$s_\text{right}$$$ the string to the right of the cursor. We also have a string $$$c$$$, which we call our clipboard, which starts out as empty. There are three types of actions:  The Move action. Move the cursor one step to the right. This increments $$$\ell$$$ once.  The Cut action. Set $$$c \leftarrow s_\text{right}$$$, then set $$$s \leftarrow s_\text{left}$$$.  The Paste action. Append the value of $$$c$$$ to the end of the string $$$s$$$. Note that this doesn't modify $$$c$$$. The cursor initially starts at $$$\ell = 0$$$. Then, we perform the following procedure:  Perform the Move action once.  Perform the Cut action once.  Perform the Paste action $$$s_\ell$$$ times.  If $$$\ell = x$$$, stop. Otherwise, return to step 1. You're given the initial string $$$s$$$ and the integer $$$x$$$. What is the length of $$$s$$$ when the procedure stops? Since this value may be very large, only find it modulo $$$10^9 + 7$$$. It is guaranteed that $$$\ell \le |s|$$$ at any time. NoteLet's illustrate what happens with the first test case. Initially, we have $$$s = $$$ 231. Initially, $$$\ell = 0$$$ and $$$c = \varepsilon$$$ (the empty string). The following things happen if we follow the procedure above:  Step 1, Move once: we get $$$\ell = 1$$$.  Step 2, Cut once: we get $$$s = $$$ 2 and $$$c = $$$ 31.  Step 3, Paste $$$s_\ell = $$$ 2 times: we get $$$s = $$$ 23131.  Step 4: $$$\ell = 1 \not= x = 5$$$, so we return to step 1.   Step 1, Move once: we get $$$\ell = 2$$$.  Step 2, Cut once: we get $$$s = $$$ 23 and $$$c = $$$ 131.  Step 3, Paste $$$s_\ell = $$$ 3 times: we get $$$s = $$$ 23131131131.  Step 4: $$$\ell = 2 \not= x = 5$$$, so we return to step 1.   Step 1, Move once: we get $$$\ell = 3$$$.  Step 2, Cut once: we get $$$s = $$$ 231 and $$$c = $$$ 31131131.  Step 3, Paste $$$s_\ell = $$$ 1 time: we get $$$s = $$$ 23131131131.  Step 4: $$$\ell = 3 \not= x = 5$$$, so we return to step 1.   Step 1, Move once: we get $$$\ell = 4$$$.  Step 2, Cut once: we get $$$s = $$$ 2313 and $$$c = $$$ 1131131.  Step 3, Paste $$$s_\ell = $$$ 3 times: we get $$$s = $$$ 2313113113111311311131131.  Step 4: $$$\ell = 4 \not= x = 5$$$, so we return to step 1.   Step 1, Move once: we get $$$\ell = 5$$$.  Step 2, Cut once: we get $$$s = $$$ 23131 and $$$c = $$$ 13113111311311131131.  Step 3, Paste $$$s_\ell = $$$ 1 times: we get $$$s = $$$ 2313113113111311311131131.  Step 4: $$$\ell = 5 = x$$$, so we stop. At the end of the procedure, $$$s$$$ has length $$$25$$$.  for _ in range(int(input())):
	x = int(input())
	sen = list(map(int, input()))
	l = 1
	len_sen = len(sen)
	while(l <= x):
		itr = sen[l-1]
		len_sen = (l + (len_sen - l) * sen[l-1])%(1000000007)
		
		idx = len(sen)
		for _ in range(itr-1):
			if len(sen) < x:
				sen += sen[l:idx]
			else:
				break
		l+=1
	print(len_sen)","['implementation', 'math']"
2457,"You are given an array $$$a_1, a_2, \ldots, a_n$$$ consisting of $$$n$$$ positive integers and a positive integer $$$m$$$.You should divide elements of this array into some arrays. You can order the elements in the new arrays as you want.Let's call an array $$$m$$$-divisible if for each two adjacent numbers in the array (two numbers on the positions $$$i$$$ and $$$i+1$$$ are called adjacent for each $$$i$$$) their sum is divisible by $$$m$$$. An array of one element is $$$m$$$-divisible.Find the smallest number of $$$m$$$-divisible arrays that $$$a_1, a_2, \ldots, a_n$$$ is possible to divide into. NoteIn the first test case we can divide the elements as follows:  $$$[4, 8]$$$. It is a $$$4$$$-divisible array because $$$4+8$$$ is divisible by $$$4$$$.  $$$[2, 6, 2]$$$. It is a $$$4$$$-divisible array because $$$2+6$$$ and $$$6+2$$$ are divisible by $$$4$$$.  $$$[9]$$$. It is a $$$4$$$-divisible array because it consists of one element.  t = int(input())
for p in range(t):
    l = list(map(int, input().rstrip().split()))
    n = l[0]
    m = l[1]
    res = []
    l1 = list(map(int, input().rstrip().split()))
    mydict = {}
    count = 0
    for a in range(m):
        mydict[a] = 0
    for i in l1:
        mydict[i % m] += 1

    for j in range(m):

        if mydict[j] == 0:
            continue
        if j == 0:
            count += 1
        elif mydict[m - j] != 0:
            if mydict[m - j] == mydict[j]:
                count += 1
            elif abs(mydict[j] - mydict[m - j]) >= 1:
                count += abs(mydict[j] - mydict[m - j])
            else:
                count += 1
            mydict[j] = 0
            mydict[m - j] = 0
        else:
            count += mydict[j]
            mydict[j] = 0
    print(count)
","['constructive algorithms', 'greedy', 'math']"
1717,"Leslie and Leon entered a labyrinth. The labyrinth consists of $$$n$$$ halls and $$$m$$$ one-way passages between them. The halls are numbered from $$$1$$$ to $$$n$$$.Leslie and Leon start their journey in the hall $$$s$$$. Right away, they quarrel and decide to explore the labyrinth separately. However, they want to meet again at the end of their journey.To help Leslie and Leon, your task is to find two different paths from the given hall $$$s$$$ to some other hall $$$t$$$, such that these two paths do not share halls other than the staring hall $$$s$$$ and the ending hall $$$t$$$. The hall $$$t$$$ has not been determined yet, so you can choose any of the labyrinth's halls as $$$t$$$ except $$$s$$$.Leslie's and Leon's paths do not have to be the shortest ones, but their paths must be simple, visiting any hall at most once. Also, they cannot visit any common halls except $$$s$$$ and $$$t$$$ during their journey, even at different times. nan import sys

input = sys.stdin.readline


def gen_input():
    while True:
        yield [int(c) for c in input().split()]


def gen_fake1():
    yield [5, 5, 1]
    yield [1, 2]
    yield [2, 3]
    yield [1, 4]
    yield [4, 3]
    yield [3, 5]


def gen_fake():
    yield [3, 3, 2]
    yield [1, 2]
    yield [2, 3]
    yield [3, 1]


def gen_fake3():
    yield [5, 5, 1]
    yield [1, 2]
    yield [2, 3]
    yield [3, 4]
    yield [2, 5]
    yield [5, 4]


def ints(g=gen_input()):
    return next(g)


n, m, s = ints()
s -= 1
v = [[] for _ in range(n)]

for _ in range(m):
    a, b = ints()
    v[a - 1].append(b - 1)


def down(v, s, q):
    """"""nodes reachable from s through q""""""
    n = len(v)
    vis = [False] * n
    vis[s] = True
    back = [-1] * n
    back[q] = s
    op = [q]  # open nodes

    ret = set()
    while op:
        x = op.pop()
        ret.add(x)
        vis[x] = True
        for y in v[x]:
            if not vis[y]:
                op.append(y)
                back[y] = x
    return ret, back


def backtrack(back, start):
    ret = []
    while start != -1:
        ret.append(start)
        start = back[start]
    return list(reversed(ret))


def prune_common(path1, path2):
    for i, node in enumerate(path1):
        if i and node in path2:
            return path1[:i+1], path2[:path2.index(node) + 1]
    return path1, path2


def go(v=v, s=s):
    n = len(v)
    vis = [-1] * n
    vis[s] = s

    back = [-1] * n
    for q in v[s]:
        if vis[q] >= 0:
            return [s, q], backtrack(back, q)
        op = [q]
        back[q] = s
        while op:
            x = op.pop()
            vis[x] = q
            for y in v[x]:
                if vis[y] == -1:
                    op.append(y)
                    back[y] = x
                elif vis[y] != s and vis[y] >= 0 and vis[y] != q:
                    return backtrack(back, y), backtrack(back, x) + [y]


# def go():
#     if len(v[s]) <= 1:
#         return
#     d = [0] * len(v[s])
#     d[0] = down(v, s, v[s][0])[0]
#     vis_total = d[0]
#     for i in range(1, len(d)):
#         d[i] = down(v, s, v[s][i])[0]
#         vis_new = vis_total | d[i]
#         if len(vis_new) < len(vis_total) + len(d[i]):
#             break
#         vis_total = vis_new
#     else:
#         return

#     for j in range(0, i):
#         s12 = d[i] & d[j]
#         if s12:
#             desto = s12.pop()
#             back1 = down(v, s, v[s][i])[1]
#             back2 = down(v, s, v[s][j])[1]

#             path1 = backtrack(back1, desto)
#             path2 = backtrack(back2, desto)
#             #print(path1, path2)
#             path1, path2 = prune_common(path1, path2)
#             path1 = [x+1 for x in path1]
#             path2 = [x+1 for x in path2]
#             return path1, path2

def array_plus1(v):
    for i in range(len(v)):
        v[i] += 1


p12 = go()

if p12:
    print(""Possible"")
    p1, p2 = p12
    array_plus1(p1)
    array_plus1(p2)

    print(len(p1))
    print(*p1)
    print(len(p2))
    print(*p2)
else:
    print(""Impossible"")
","['dfs and similar', 'graphs']"
1469,"Consider an infinite triangle made up of layers. Let's number the layers, starting from one, from the top of the triangle (from top to bottom). The $$$k$$$-th layer of the triangle contains $$$k$$$ points, numbered from left to right. Each point of an infinite triangle is described by a pair of numbers $$$(r, c)$$$ ($$$1 \le c \le r$$$), where $$$r$$$ is the number of the layer, and $$$c$$$ is the number of the point in the layer. From each point $$$(r, c)$$$ there are two directed edges to the points $$$(r+1, c)$$$ and $$$(r+1, c+1)$$$, but only one of the edges is activated. If $$$r + c$$$ is even, then the edge to the point $$$(r+1, c)$$$ is activated, otherwise the edge to the point $$$(r+1, c+1)$$$ is activated. Look at the picture for a better understanding.  Activated edges are colored in black. Non-activated edges are colored in gray. From the point $$$(r_1, c_1)$$$ it is possible to reach the point $$$(r_2, c_2)$$$, if there is a path between them only from activated edges. For example, in the picture above, there is a path from $$$(1, 1)$$$ to $$$(3, 2)$$$, but there is no path from $$$(2, 1)$$$ to $$$(1, 1)$$$.Initially, you are at the point $$$(1, 1)$$$. For each turn, you can:   Replace activated edge for point $$$(r, c)$$$. That is if the edge to the point $$$(r+1, c)$$$ is activated, then instead of it, the edge to the point $$$(r+1, c+1)$$$ becomes activated, otherwise if the edge to the point $$$(r+1, c+1)$$$, then instead if it, the edge to the point $$$(r+1, c)$$$ becomes activated. This action increases the cost of the path by $$$1$$$;  Move from the current point to another by following the activated edge. This action does not increase the cost of the path. You are given a sequence of $$$n$$$ points of an infinite triangle $$$(r_1, c_1), (r_2, c_2), \ldots, (r_n, c_n)$$$. Find the minimum cost path from $$$(1, 1)$$$, passing through all $$$n$$$ points in arbitrary order. nan import sys
input = sys.stdin.buffer.readline

t = int(input())
for _ in range(t):
    n = int(input())
    R = list(map(int, input().split()))
    C = list(map(int, input().split()))

    go = sorted([(1, 1)] + list(zip(R, C)))
    ans = 0
    for i in range(n):
        c1 = go[i][0] - go[i][1] + 1
        c2 = go[i + 1][0] - go[i + 1][1] + 1
        k1 = c1 // 2
        k2 = c2 // 2
        if c1 % 2 == 0 and c2 % 2 == 0:
            ans += k2 - k1
        if c1 % 2 == 0 and c2 % 2 == 1:
            ans += k2 - k1 + 1
        if c1 % 2 == 1 and c2 % 2 == 0:
            ans += k2 - k1 - 1
        if c1 % 2 == 1 and c2 % 2 == 1:
            if k1 == k2:
                ans += go[i + 1][0] - go[i][0]
            else:
                ans += k2 - k1
    
    print(ans)","['constructive algorithms', 'graphs', 'math', 'shortest paths', 'sortings']"
2907,"Petya has an array $$$a$$$ consisting of $$$n$$$ integers. He has learned partial sums recently, and now he can calculate the sum of elements on any segment of the array really fast. The segment is a non-empty sequence of elements standing one next to another in the array.Now he wonders what is the number of segments in his array with the sum less than $$$t$$$. Help Petya to calculate this number.More formally, you are required to calculate the number of pairs $$$l, r$$$ ($$$l \le r$$$) such that $$$a_l + a_{l+1} + \dots + a_{r-1} + a_r &lt; t$$$. NoteIn the first example the following segments have sum less than $$$4$$$:  $$$[2, 2]$$$, sum of elements is $$$-1$$$  $$$[2, 3]$$$, sum of elements is $$$2$$$  $$$[3, 3]$$$, sum of elements is $$$3$$$  $$$[4, 5]$$$, sum of elements is $$$3$$$  $$$[5, 5]$$$, sum of elements is $$$-1$$$  from bisect import bisect_left

sum = [0]*200005
srt = []
n,t = map(int,input().split())
a = list(map(int,input().split()))

tree = [0]*200005

def get(x):
    ans = 0
    while x:
        ans += tree[x]
        x -= x&-x
    return ans

def update(x):

    while x <= 200002:
        tree[x] += 1
        x += x&-x


for i in range(n):
    if i:
        sum[i] = sum[i-1] + a[i]
    else:
        sum[i] = a[i]
    srt.append(sum[i])

if 0 not in srt:
    srt.append(0)

srt.sort()

ans = 0
update(bisect_left(srt,0) + 1)




for i in range(n):
    l = min(len(srt)-1,bisect_left(srt,sum[i] - t))

    if srt[l] <= sum[i] - t:
        l = l+1

    cnt = get(l)
    ans += i + 1 - cnt


    update(bisect_left(srt,sum[i]) + 1)

print(ans)

","['data structures', 'divide and conquer', 'two pointers']"
3749,"There are $$$n$$$ piles of sand where the $$$i$$$-th pile has $$$a_i$$$ blocks of sand. The $$$i$$$-th pile is called too tall if $$$1 &lt; i &lt; n$$$ and $$$a_i &gt; a_{i-1} + a_{i+1}$$$. That is, a pile is too tall if it has more sand than its two neighbours combined. (Note that piles on the ends of the array cannot be too tall.)You are given an integer $$$k$$$. An operation consists of picking $$$k$$$ consecutive piles of sand and adding one unit of sand to them all. Formally, pick $$$1 \leq l,r \leq n$$$ such that $$$r-l+1=k$$$. Then for all $$$l \leq i \leq r$$$, update $$$a_i \gets a_i+1$$$.What is the maximum number of piles that can simultaneously be too tall after some (possibly zero) operations? NoteIn the first test case, we can perform the following three operations:   Add one unit of sand to piles $$$1$$$ and $$$2$$$: $$$[\color{red}{3}, \color{red}{10}, 2, 4, 1]$$$.  Add one unit of sand to piles $$$4$$$ and $$$5$$$: $$$[3, 10, 2, \color{red}{5}, \color{red}{2}]$$$.  Add one unit of sand to piles $$$3$$$ and $$$4$$$: $$$[3, 10, \color{red}{3}, \color{red}{6}, 2]$$$.  Now piles $$$2$$$ and $$$4$$$ are too tall, so in this case the answer is $$$2$$$. It can be shown that it is impossible to make more than $$$2$$$ piles too tall.In the second test case, any operation will increase all piles by $$$1$$$ unit, so the number of too tall piles will always be $$$0$$$.In the third test case, we can increase any pile by $$$1$$$ unit of sand. It can be shown that the maximum number of too tall piles is $$$1$$$. 
q=int(input())
for i in range(q):
    A=input().split()
    n=int(A[0])
    k=int(A[1])
    A=input().split()
    B=[0]*n
    t=0
    for j in range(n):
            B[j]=int(A[j])
    if k==1:
        if n%2==0:
            print(int(n/2-1))
        else:
            print(int((n+1)/2-1))
    else:

        for j in range(1,n-1):
            if B[j]>B[j+1]+B[j-1]:
                t=t+1
        print(t)


        
    
","['constructive algorithms', 'greedy', 'implementation']"
422,"Kristina has two arrays $$$a$$$ and $$$b$$$, each containing $$$n$$$ non-negative integers. She can perform the following operation on array $$$a$$$ any number of times:   apply a decrement to each non-zero element of the array, that is, replace the value of each element $$$a_i$$$ such that $$$a_i &gt; 0$$$ with the value $$$a_i - 1$$$ ($$$1 \le i \le n$$$). If $$$a_i$$$ was $$$0$$$, its value does not change. Determine whether Kristina can get an array $$$b$$$ from an array $$$a$$$ in some number of operations (probably zero). In other words, can she make $$$a_i = b_i$$$ after some number of operations for each $$$1 \le i \le n$$$?For example, let $$$n = 4$$$, $$$a = [3, 5, 4, 1]$$$ and $$$b = [1, 3, 2, 0]$$$. In this case, she can apply the operation twice:   after the first application of the operation she gets $$$a = [2, 4, 3, 0]$$$;  after the second use of the operation she gets $$$a = [1, 3, 2, 0]$$$. Thus, in two operations, she can get an array $$$b$$$ from an array $$$a$$$. NoteThe first test case is analyzed in the statement.In the second test case, it is enough to apply the operation to array $$$a$$$ once.In the third test case, it is impossible to get array $$$b$$$ from array $$$a$$$. noofcases=int(input())
arr1=[]
arr2=[]
for i in range(0,noofcases):
    nooflines=int(input())
    if(nooflines>1000):
        check=True
        arr1=list(map(int, input().split()))
        arr2=list(map(int, input().split()))
        diff=arr1[0]-arr2[0]
        if (nooflines <= 1 and diff > -1):
            print('yes')  
            continue
        elif diff < 0 or (arr2[0] > arr1[0]):
            print('no')  
            continue
        for j in range(1,nooflines):
            if((arr1[j]-diff != arr2[j] and arr1[j]-diff > -1) or arr2[j]>arr1[j]):
                print('no')
                break
        else:
            print('yes')
    else:
        check=True
        arr1=list(map(int, input().split()))
        arr2=list(map(int, input().split()))
        while(arr1.count(0)!=len(arr1)):
            if(arr1==arr2):
                break
            for k in range(0,len(arr1)):
                if(int(arr1[k])>0):
                    arr1[k]=int(arr1[k])-1
            if(arr1==arr2):
                break
        else:
            if(check and arr1==arr2):
                print('yEs')
                check=False
            else:
                print('no')
        if(check and arr1==arr2):
            print('YES')","['greedy', 'implementation']"
95,"Vivek has encountered a problem. He has a maze that can be represented as an $$$n \times m$$$ grid. Each of the grid cells may represent the following:  Empty — '.'  Wall — '#'  Good person  — 'G'  Bad person — 'B' The only escape from the maze is at cell $$$(n, m)$$$.A person can move to a cell only if it shares a side with their current cell and does not contain a wall. Vivek wants to block some of the empty cells by replacing them with walls in such a way, that all the good people are able to escape, while none of the bad people are able to. A cell that initially contains 'G' or 'B' cannot be blocked and can be travelled through.Help him determine if there exists a way to replace some (zero or more) empty cells with walls to satisfy the above conditions.It is guaranteed that the cell $$$(n,m)$$$ is empty. Vivek can also block this cell. NoteFor the first and second test cases, all conditions are already satisfied.For the third test case, there is only one empty cell $$$(2,2)$$$, and if it is replaced with a wall then the good person at $$$(1,2)$$$ will not be able to escape.For the fourth test case, the good person at $$$(1,1)$$$ cannot escape.For the fifth test case, Vivek can block the cells $$$(2,3)$$$ and $$$(2,2)$$$.For the last test case, Vivek can block the destination cell $$$(2, 2)$$$. import sys
input = sys.stdin.buffer.readline

def main():

    t = int(input())
    for _ in range(t):
        n, m = map(int, input().split())
        M = [list(str(input())[2:m+2]) for _ in range(n)]
        M = [['#']*m] + M + [['#']*m]
        M = [['#']+c+['#'] for c in M]
        #print(M)
        B = []
        G = []
        flag1 = True
        for i in range(1, n+1):
            for j in range(1, m+1):
                if M[i][j] == 'B':
                    for di, dj in (-1, 0), (1, 0), (0, -1), (0, 1):
                        ni, nj = i+di, j+dj
                        if 1 <= ni <= n and 1 <= nj <= m:
                            if M[ni][nj] == '.':
                                M[ni][nj] = '#'
                            if M[ni][nj] == 'G':
                                flag1 = False
                                break
                    B.append((i, j))
                if M[i][j] == 'G':
                    G.append((i, j))
        if not flag1:
            print('No')
            continue
        if len(G) > 0 and M[n][m] == '#':
            print('No')
            continue

        s = []
        s.append((n, m))
        visit = [[-1]*(m+2) for _ in range(n+2)]
        visit[n][m] = 0
        while s:
            y, x = s.pop()
            for dy, dx in (-1, 0), (1, 0), (0, -1), (0, 1):
                ny, nx = y+dy, x+dx
                if visit[ny][nx] == -1 and M[ny][nx] != '#':
                    visit[ny][nx] = visit[y][x]+1
                    s.append((ny, nx))
        flag = True
        for sy, sx in G:
            if visit[sy][sx] == -1:
                flag = False
                break
        #print(visit)
        if flag:
            print('Yes')
        else:
            print('No')

if __name__ == '__main__':
    main()
","['constructive algorithms', 'dfs and similar', 'dsu', 'graphs', 'greedy', 'implementation', 'shortest paths']"
2438,"You are given a sequence of n integers a1, a2, ..., an. Determine a real number x such that the weakness of the sequence a1 - x, a2 - x, ..., an - x is as small as possible.The weakness of a sequence is defined as the maximum value of the poorness over all segments (contiguous subsequences) of a sequence.The poorness of a segment is defined as the absolute value of sum of the elements of segment. NoteFor the first case, the optimal value of x is 2 so the sequence becomes  - 1, 0, 1 and the max poorness occurs at the segment ""-1"" or segment ""1"". The poorness value (answer) equals to 1 in this case. For the second sample the optimal value of x is 2.5 so the sequence becomes  - 1.5,  - 0.5, 0.5, 1.5 and the max poorness occurs on segment ""-1.5 -0.5"" or ""0.5 1.5"". The poorness value (answer) equals to 2 in this case. n=input()
a=map(float,raw_input().split())
l,r=-22222.,22222.
for i in xrange(55):
  w=x=p=0
  y=-22222
  z=22222
  mid=(l+r)/2
  for t in a:
    p+=t-mid
    y=max(y,p-w)
    z=min(z,p-x)
    w=min(p,w)
    x=max(p,x)
  if y+z<0:
    r=mid
  else:
    l=mid
print max(y,-z)
",['other']
1261,"A tourist wants to visit country Zeydabad for Zbazi (a local game in Zeydabad).The country Zeydabad is a rectangular table consisting of n rows and m columns. Each cell on the country is either 'z' or '.'.The tourist knows this country is named Zeydabad because there are lots of ''Z-pattern""s in the country. A ''Z-pattern"" is a square which anti-diagonal is completely filled with 'z' and its upper and lower rows are also completely filled with 'z'. All other cells of a square can be arbitrary.  Note that a ''Z-pattern"" can consist of only one cell (see the examples).So he wants to count the number of ''Z-pattern""s in the country (a necessary skill for Zbazi).Now your task is to help tourist with counting number of ''Z-pattern""s.As input/output can reach huge size it is recommended to use fast input/output methods: for example, prefer to use gets/scanf/printf instead of getline/cin/cout in C++, prefer to use BufferedReader/PrintWriter instead of Scanner/System.out in Java. nan #!/usr/bin/env python3

from __future__ import division, print_function

def least_significant_bit(i):
    return ((i) & -(i))

class FenwickTree():
    def __init__(self, n):
        # 1-indexed
        self.n = n + 1 
        self.data = [0,] * self.n
    
    def add(self, index, value):
        # 1-indexed
        i = index + 1
        while i < self.n:
            self.data[i] += value
            i += least_significant_bit(i)
        
    def prefix_sum(self, index):
        # 1-indexed
        i = index + 1
        result = 0
        while i > 0:
            result += self.data[i]
            i -= least_significant_bit(i)
        return result
    
    def range_sum(self, start, end):
        return self.prefix_sum(end) - self.prefix_sum(start-1)

def solver(ifs):
    n, m = list(map(int, ifs.readline().split()))
    grid = [
        [(True if c=='z' else False) for c in ifs.readline()]
        for _ in range(n)]
    ifs.close()
    left = [0, ] * (n * m)
    right = [0, ] * (n * m)
    for i in range(n):
        row = grid[i]
        s = i*m
        left[s+0] = 1 if row[0] else 0
        for j in range(1, m):
            if row[j]:
                left[s+j] = left[s+j-1] + 1
        right[s+m-1] = 1 if row[m-1] else 0
        for j in range(m-2, -1, -1):
            if row[j]:
                right[s+j] = right[s+j+1] + 1
    res = 0
    for i, j in [(0, a) for a in range(m)] + [(b, m-1) for b in range(1, n)]:
        lend = min(n-i, j+1)
        d = [1 if grid[i+pos][j-pos] else 0 for pos in range(lend)]
        for pos in range(lend-2, -1, -1):
            d[pos] = d[pos+1] + 1 if d[pos] else 0
        tbr = [ [] for _ in range(lend + 1)]
        ft = FenwickTree(lend)
        for pos, val in enumerate(d):
            while tbr[pos]:
                ft.add(tbr[pos].pop(), -1)
            c = min(val, left[(i+pos)*m + j-pos])
            if c > 0:
                ft.add(pos, 1)
                tbr[pos + c].append(pos)
            d = right[(i+pos)*m + j-pos]
            if d > 0:
                res += ft.range_sum(max(0,pos-d+1), pos)
    print(res)

def main():
    import sys
    if sys.version_info.major == 3:
        from io import StringIO as StreamIO
    else:
         from io import BytesIO as StreamIO
    
    with StreamIO(sys.stdin.read()) as ifs, StreamIO() as ofs:
        _stdout = sys.stdout
        sys.stdout = ofs
        solver(ifs)
        sys.stdout = _stdout
        sys.stdout.write(ofs.getvalue())
    return 0

if __name__ == '__main__':
    main()
","['data structures', 'implementation']"
2518,"Little Petya learns how to write. The teacher gave pupils the task to write the letter A on the sheet of paper. It is required to check whether Petya really had written the letter A.You are given three segments on the plane. They form the letter A if the following conditions hold:  Two segments have common endpoint (lets call these segments first and second), while the third segment connects two points on the different segments.  The angle between the first and the second segments is greater than 0 and do not exceed 90 degrees.  The third segment divides each of the first two segments in proportion not less than 1 / 4 (i.e. the ratio of the length of the shortest part to the length of the longest part is not less than 1 / 4).  nan __author__ = 'Darren'


def solve():
    t = int(input())
    while t:
        run()
        t -= 1


def run():
    def check_condition_1():
        record = {}
        common, first, second = None, -1, -1
        found = False
        for i in range(3):
            for j in range(2):
                if segments[i][j] in record:
                    if found:
                        return False
                    found = True
                    common = segments[i][j]
                    first, second = record[segments[i][j]], i
                else:
                    record[segments[i][j]] = i
        if not found:
            return False

        segments[0], segments[first] = segments[first], segments[0]
        segments[1], segments[second] = segments[second], segments[1]
        if common != segments[0][0]:
            segments[0][0], segments[0][1] = segments[0][1], segments[0][0]
        if common != segments[1][0]:
            segments[1][0], segments[1][1] = segments[1][1], segments[1][0]

        nonlocal vector1, vector2, vector3, vector4
        vector1 = Vector2D(segments[0][0], segments[0][1])
        vector2 = Vector2D(segments[1][0], segments[1][1])
        vector3 = Vector2D(segments[0][0], segments[2][0])
        vector4 = Vector2D(segments[1][0], segments[2][1])
        if vector1.parallel(vector3):
            return vector2.parallel(vector4)
        else:
            vector3 = Vector2D(segments[0][0], segments[2][1])
            vector4 = Vector2D(segments[1][0], segments[2][0])
            return vector1.parallel(vector3) and vector2.parallel(vector4)

    def check_condition_2():
        return vector1.acute_or_perpendicular(vector2)

    def check_condition_3():
        return (0.2 <= vector1.dot_product(vector3) / vector1.distance_square() <= 0.8 and
                0.2 <= vector2.dot_product(vector4) / vector2.distance_square() <= 0.8)

    segments = []
    for _i in range(3):
        temp = [int(x) for x in input().split()]
        segments.append([Point2D(temp[0], temp[1]), Point2D(temp[2], temp[3])])
    vector1, vector2, vector3, vector4 = None, None, None, None
    if check_condition_1() and check_condition_2() and check_condition_3():
        print('YES')
    else:
        print('NO')


class Point2D:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __eq__(self, other):
        return self.x == other.x and self.y == other.y

    def __ne__(self, other):
        return self.x != other.x or self.y != other.y

    def __hash__(self):
        return self.x + self.y * 31


class Vector2D:
    def __init__(self, p1, p2):
        self.x = p2.x - p1.x
        self.y = p2.y - p1.y

    def distance_square(self):
        return self.x ** 2 + self.y ** 2

    def __sub__(self, other):
        return Vector2D(self.x - other.x, self.y - other.y)

    def dot_product(self, other):
        return self.x * other.x + self.y * other.y

    def cross_product(self, other):
        return self.x * other.y - self.y * other.x

    def parallel(self, other):
        return self.cross_product(other) == 0

    def acute_or_perpendicular(self, other):
        return self.dot_product(other) >= 0 and not self.parallel(other)


if __name__ == '__main__':
    solve()","['geometry', 'implementation']"
2399,"Harry came to know from Dumbledore that Salazar Slytherin's locket is a horcrux. This locket was present earlier at 12 Grimmauld Place, the home of Sirius Black's mother. It was stolen from there and is now present in the Ministry of Magic in the office of Dolorous Umbridge, Harry's former Defense Against the Dark Arts teacher. Harry, Ron and Hermione are infiltrating the Ministry. Upon reaching Umbridge's office, they observed a code lock with a puzzle asking them to calculate count of magic numbers between two integers l and r (both inclusive). Harry remembered from his detention time with Umbridge that she defined a magic number as a number which when converted to a given base b, all the digits from 0 to b - 1 appear even number of times in its representation without any leading zeros.You have to answer q queries to unlock the office. Each query has three integers bi, li and ri, the base and the range for which you have to find the count of magic numbers. NoteIn sample test case 1, for first query, when we convert numbers 4 to 9 into base 2, we get:   4 = 1002,  5 = 1012,  6 = 1102,  7 = 1112,  8 = 10002,  9 = 10012. Out of these, only base 2 representation of 9 has even number of 1 and 0. Thus, the answer is 1. import sys
range = xrange
input = raw_input

def int2base(n, base):
    if n == 0:
        return [0]
    A = []
    while n:
        n,r = divmod(n, base)
        A.append(r)
    return A

big = 10**18
DP =   [[[0]*(1 << b) for _ in range(b>1 and len(int2base(big, b)) + 1)] for b in range(11)]
DP0 =  [[[0]*(1 << b) for _ in range(b>1 and len(int2base(big, b)) + 1)] for b in range(11)]

for b in range(2,11):
    DPb = DP[b]
    DP0b = DP0[b]

    DP0b[0][0] = 1
    
    for l in range(1, len(DPb)):
        for mask in range(1 << b):
            for digit in range(b):
                DP0b[l][mask ^ (1 << digit)] += DP0b[l - 1][mask]
            
            for digit in range(1, b):
                DPb[l][mask ^ (1 << digit)] += DP0b[l - 1][mask]
                
inp = sys.stdin.read().split()
ii = 0

# < upper
def counter(upper, base):
    if upper <= base:
        return 0
    number = int2base(upper, base)
    DPb = DP[base]
    DP0b = DP0[base]

    mask = 0
    n = number.pop()
    ans = 0
    for l in range(len(number) + 1):
        ans += DPb[l][0]
    
    for digit in range(1, n):
        ans += DP0b[len(number)][mask ^ (1 << digit)]
    mask ^= 1 << n
    
    while number:
        n = number.pop()
        for digit in range(n):
            ans += DP0b[len(number)][mask ^ (1 << digit)]
        mask ^= 1 << n
    return ans
            
q = int(inp[ii]); ii += 1

out = []
for _ in range(q):
    b = int(inp[ii]); ii += 1
    l = int(inp[ii]); ii += 1
    r = int(inp[ii]); ii += 1

    out.append(str(counter(r + 1, b) - counter(l, b)))

print '\n'.join(out)","['bitmasks', 'dp']"
2201,"Olya likes milk very much. She drinks k cartons of milk each day if she has at least k and drinks all of them if she doesn't. But there's an issue — expiration dates. Each carton has a date after which you can't drink it (you still can drink it exactly at the date written on the carton). Due to this, if Olya's fridge contains a carton past its expiry date, she throws it away.Olya hates throwing out cartons, so when she drinks a carton, she chooses the one which expires the fastest. It's easy to understand that this strategy minimizes the amount of cartons thrown out and lets her avoid it if it's even possible.    Milk. Best before: 20.02.2017. The main issue Olya has is the one of buying new cartons. Currently, there are n cartons of milk in Olya's fridge, for each one an expiration date is known (how soon does it expire, measured in days). In the shop that Olya visited there are m cartons, and the expiration date is known for each of those cartons as well.Find the maximum number of cartons Olya can buy so that she wouldn't have to throw away any cartons. Assume that Olya drank no cartons today.  NoteIn the first example k = 2 and Olya has three cartons with expiry dates 0, 1 and 1 (they expire today, tomorrow and tomorrow), and the shop has 3 cartons with expiry date 0 and 3 cartons with expiry date 2. Olya can buy three cartons, for example, one with the expiry date 0 and two with expiry date 2.In the second example all three cartons Olya owns expire today and it means she would have to throw packets away regardless of whether she buys an extra one or not.In the third example Olya would drink k = 2 cartons today (one she alreay has in her fridge and one from the shop) and the remaining one tomorrow. import sys, collections

raw_input = sys.stdin.readline
n, m, k = map(int, raw_input().split())
current = map(int, raw_input().split())
store = map(int, raw_input().split())
milk = [0]*(10**7 + 1)
store_indexes = collections.defaultdict(list)
current.sort()
max_index = 10**7 + 1
valid = True
ans = []
count = 0

for i in xrange(m):
    store_indexes[store[i]].append(i+1)

store.sort()
for i in xrange(n-1, -1, -1):
    index = min(current[i], max_index)        
    while milk[index] >= k and index > -1:
        index -= 1

    if index == -1:
        valid = False
        break
    
    max_index = min(max_index, index)
    milk[index] += 1
    #print milk[:3]
    
if not valid:
    print -1
    raise SystemExit
else:
    min_index = 0
    for i in xrange(m):
        stop = store[i]
        index = min(stop, min_index)
        while milk[index] >= k and index <= stop:
            index += 1

        if index <= stop:
            milk[index] += 1
            count += 1
            ans.append(str(store_indexes[stop].pop()))

        min_index = max(min_index, index)
        #print milk[:3], count, stop

print count
print "" "".join(ans)
","['binary search', 'data structures', 'greedy', 'sortings', 'two pointers']"
1699,"An array is sorted if it has no inversionsA Young BoyYou are given an array of $$$n$$$ positive integers $$$a_1,a_2,\ldots,a_n$$$. In one operation you do the following:   Choose any integer $$$x$$$.  For all $$$i$$$ such that $$$a_i = x$$$, do $$$a_i := 0$$$ (assign $$$0$$$ to $$$a_i$$$). Find the minimum number of operations required to sort the array in non-decreasing order. NoteIn the first test case, you can choose $$$x = 3$$$ for the operation, the resulting array is $$$[0, 0, 2]$$$.In the second test case, you can choose $$$x = 1$$$ for the first operation and $$$x = 3$$$ for the second operation, the resulting array is $$$[0, 0, 0, 0]$$$. # -*- coding: utf-8 -*-
""""""
Created on Sat Aug 13 22:42:21 2022

@author: A
""""""

for _ in range(int(input())):
    n=int(input())
    a=[*map(int,input().split())]
    ordered=[]
    w=set()
    for i in a:
      if ordered and (ordered[-1]>i or i in w):
        while ordered:
          w.add(ordered.pop())
      ordered.append(i)
    print(len(w))","['greedy', 'sortings']"
80,"Vus the Cossack has two binary strings, that is, strings that consist only of ""0"" and ""1"". We call these strings $$$a$$$ and $$$b$$$. It is known that $$$|b| \leq |a|$$$, that is, the length of $$$b$$$ is at most the length of $$$a$$$.The Cossack considers every substring of length $$$|b|$$$ in string $$$a$$$. Let's call this substring $$$c$$$. He matches the corresponding characters in $$$b$$$ and $$$c$$$, after which he counts the number of positions where the two strings are different. We call this function $$$f(b, c)$$$.For example, let $$$b = 00110$$$, and $$$c = 11000$$$. In these strings, the first, second, third and fourth positions are different.Vus the Cossack counts the number of such substrings $$$c$$$ such that $$$f(b, c)$$$ is even.For example, let $$$a = 01100010$$$ and $$$b = 00110$$$. $$$a$$$ has four substrings of the length $$$|b|$$$: $$$01100$$$, $$$11000$$$, $$$10001$$$, $$$00010$$$.  $$$f(00110, 01100) = 2$$$; $$$f(00110, 11000) = 4$$$; $$$f(00110, 10001) = 4$$$; $$$f(00110, 00010) = 1$$$. Since in three substrings, $$$f(b, c)$$$ is even, the answer is $$$3$$$.Vus can not find the answer for big strings. That is why he is asking you to help him. NoteThe first example is explained in the legend.In the second example, there are five substrings that satisfy us: $$$1010$$$, $$$0101$$$, $$$1111$$$, $$$1111$$$. a=input()
b=input()

aCount = 0# if a[0]=='1' else 0

for i in range(0,len(b)):
  aCount += (1 if a[i]=='1' else 0)

bCount=0
for i in range(len(b)):
  bCount+= 1 if b[i]=='1' else 0

res=0
#print(ones,bCount)
for i in range(0,len(a)-len(b)):
  #print((ones[i+len(b)-1]-ones[i-1]) %2 , ones[i+len(b)-1],ones[i-1],bCount%2)
  #print(aCount,bCount)
  if( aCount %2 == bCount%2):
    #print(a[i:i+len(b)])
    res+=1
  
  #print(""::"",a[len(b)+i],a[i],""index:"",len(b)+i,i)
  #if coming char ==1 increase count(out of coundary)
  aCount+=(1 if a[len(b)+i]=='1' else 0)
  #print(""after1"",aCount,bCount)
  #if going  char==1 decrease count
  aCount-= 1 if  a[i]=='1' else 0
  #print(1 if  a[i]=='1' else 0)
  #print(""after2"",aCount,bCount)
if( aCount %2 == bCount%2):
    #print(a[i:i+len(b)])
    res+=1

print(res)



","['implementation', 'math']"
803,"Inna loves sleeping very much, so she needs n alarm clocks in total to wake up. Let's suppose that Inna's room is a 100 × 100 square with the lower left corner at point (0, 0) and with the upper right corner at point (100, 100). Then the alarm clocks are points with integer coordinates in this square.The morning has come. All n alarm clocks in Inna's room are ringing, so Inna wants to turn them off. For that Inna has come up with an amusing game:  First Inna chooses a type of segments that she will use throughout the game. The segments can be either vertical or horizontal.  Then Inna makes multiple moves. In a single move, Inna can paint a segment of any length on the plane, she chooses its type at the beginning of the game (either vertical or horizontal), then all alarm clocks that are on this segment switch off. The game ends when all the alarm clocks are switched off. Inna is very sleepy, so she wants to get through the alarm clocks as soon as possible. Help her, find the minimum number of moves in the game that she needs to turn off all the alarm clocks! NoteIn the first sample, Inna first chooses type ""vertical segments"", and then she makes segments with ends at : (0, 0), (0, 2); and, for example, (1, 0), (1, 1). If she paints horizontal segments, she will need at least 3 segments.In the third sample it is important to note that Inna doesn't have the right to change the type of the segments during the game. That's why she will need 3 horizontal or 3 vertical segments to end the game. relojes = int(input())
x = []
y = []
for i in range(relojes):
  ubicacion = list(map(int, (input().split())))
  if ubicacion[1] not in x:
    x += [ubicacion[1]]
  if ubicacion[0] not in y:
    y += [ubicacion[0]]
print(min(len(x), len(y)))",['implementation']
2011,"Dima is a beginner programmer. During his working process, he regularly has to repeat the following operation again and again: to remove every second element from the array. One day he has been bored with easy solutions of this problem, and he has come up with the following extravagant algorithm.Let's consider that initially array contains n numbers from 1 to n and the number i is located in the cell with the index 2i - 1 (Indices are numbered starting from one) and other cells of the array are empty. Each step Dima selects a non-empty array cell with the maximum index and moves the number written in it to the nearest empty cell to the left of the selected one. The process continues until all n numbers will appear in the first n cells of the array. For example if n = 4, the array is changing as follows:  You have to write a program that allows you to determine what number will be in the cell with index x (1 ≤ x ≤ n) after Dima's algorithm finishes. NoteThe first example is shown in the picture.In the second example the final array is [1, 12, 2, 8, 3, 11, 4, 9, 5, 13, 6, 10, 7]. import math
from decimal import Decimal
def na():
	n = int(input())
	b = [int(x) for x in input().split()]
	return n,b
 
 
def nab():
	n = int(input())
	b = [int(x) for x in input().split()]
	c = [int(x) for x in input().split()]
	return n,b,c
 
 
def dv():
	n, m = map(int, input().split())
	return n,m
 
 
def dva():
	n, m = map(int, input().split())
	a = [int(x) for x in input().split()]
	b = [int(x) for x in input().split()]
	return n,m,b
 
 
def eratosthenes(n): 
	sieve = list(range(n + 1))
	for i in sieve:
		if i > 1:
			for j in range(i + i, len(sieve), i):
				sieve[j] = 0
	return sorted(set(sieve))
 
 
 
def nm():
	n = int(input())
	b = [int(x) for x in input().split()]
	m = int(input())
	c = [int(x) for x in input().split()]
	return n,b,m,c
 
 
def dvs():
	n = int(input())
	m = int(input())
	return n, m
 


n, q = map(int, input().split())
ans = []
for i in range(q):
	x = int(input())
	ans.append(x)
for i in ans:
	d = 2 * n - i
	while d % 2 == 0:
		d //= 2
	print(n - d // 2)
","['constructive algorithms', 'math']"
4535,"The spring is coming and it means that a lot of fruits appear on the counters. One sunny day little boy Valera decided to go shopping. He made a list of m fruits he wanted to buy. If Valera want to buy more than one fruit of some kind, he includes it into the list several times. When he came to the fruit stall of Ashot, he saw that the seller hadn't distributed price tags to the goods, but put all price tags on the counter. Later Ashot will attach every price tag to some kind of fruits, and Valera will be able to count the total price of all fruits from his list. But Valera wants to know now what can be the smallest total price (in case of the most «lucky» for him distribution of price tags) and the largest total price (in case of the most «unlucky» for him distribution of price tags). nan t, f = [int(x) for x in raw_input().split()]
prices1 = sorted([int(x) for x in raw_input().split()])
prices2 = prices1[::-1]
fruit = {}
for n in xrange(f):
    s = raw_input()
    if s in fruit:
        fruit[s] += 1
    else:
        fruit[s] = 1
l = []
for k in fruit:
    l.append(fruit[k])
l = sorted(l)[::-1]
low = 0
high = 0
for i, li in enumerate(l):
    low += li * prices1[i]
    high += li * prices2[i]
print low, high","['greedy', 'implementation', 'sortings']"
3405,"Anton is playing a very interesting computer game, but now he is stuck at one of the levels. To pass to the next level he has to prepare n potions.Anton has a special kettle, that can prepare one potions in x seconds. Also, he knows spells of two types that can faster the process of preparing potions.  Spells of this type speed up the preparation time of one potion. There are m spells of this type, the i-th of them costs bi manapoints and changes the preparation time of each potion to ai instead of x.  Spells of this type immediately prepare some number of potions. There are k such spells, the i-th of them costs di manapoints and instantly create ci potions. Anton can use no more than one spell of the first type and no more than one spell of the second type, and the total number of manapoints spent should not exceed s. Consider that all spells are used instantly and right before Anton starts to prepare potions.Anton wants to get to the next level as fast as possible, so he is interested in the minimum number of time he needs to spent in order to prepare at least n potions. NoteIn the first sample, the optimum answer is to use the second spell of the first type that costs 10 manapoints. Thus, the preparation time of each potion changes to 4 seconds. Also, Anton should use the second spell of the second type to instantly prepare 15 potions spending 80 manapoints. The total number of manapoints used is 10 + 80 = 90, and the preparation time is 4·5 = 20 seconds (15 potions were prepared instantly, and the remaining 5 will take 4 seconds each).In the second sample, Anton can't use any of the spells, so he just prepares 20 potions, spending 10 seconds on each of them and the answer is 20·10 = 200. import bisect
n, m, k = map(int, input().split())
x, s = map(int, input().split())
a1 = [int(x) for x in input().split()]
a2 = [int(x) for x in input().split()]
b1 = [int(x) for x in input().split()]
b2 = [int(x) for x in input().split()]
a1.append(x)
a2.append(0)
ans = n*x
for i in range(m+1):
    if a2[i] > s:
        continue
    if s - a2[i] < b2[0]:
        ans = min(ans, n*a1[i])
        continue
    t = bisect.bisect_right(b2, s - a2[i]) - 1
    ans = min(ans, a1[i]*(n-b1[t]))
print(ans)
","['binary search', 'dp', 'greedy', 'two pointers']"
3536,"You've got array A, consisting of n integers and a positive integer k. Array A is indexed by integers from 1 to n.You need to permute the array elements so that value  became minimal possible. In particular, it is allowed not to change order of elements at all. NoteIn the first test one of the optimal permutations is 1 4 2. In the second test the initial order is optimal. In the third test one of the optimal permutations is 2 3 4 4 3 5. f = lambda: map(int, input().split())
n, k = f()
p = sorted(f())

m, d = n // k, n % k
u, v = d + 1, k - d + 1
g = [0] * u * v

i = 0
for a in range(u):
    j = a * m + a - 1
    for b in range(v):
        x = g[i - 1] + p[j] - p[j - m + 1] if b else 9e9
        y = g[i - v] + p[j] - p[j - m] if a else 9e9
        if i: g[i] = min(x, y)
        i += 1
        j += m
print(g[-1])
","['dp', 'greedy', 'sortings']"
1397,"One day Masha was walking in the park and found a graph under a tree... Surprised? Did you think that this problem would have some logical and reasoned story? No way! So, the problem...Masha has an oriented graph which $$$i$$$-th vertex contains some positive integer $$$a_i$$$. Initially Masha can put a coin at some vertex. In one operation she can move a coin placed in some vertex $$$u$$$ to any other vertex $$$v$$$ such that there is an oriented edge $$$u \to v$$$ in the graph. Each time when the coin is placed in some vertex $$$i$$$, Masha write down an integer $$$a_i$$$ in her notebook (in particular, when Masha initially puts a coin at some vertex, she writes an integer written at this vertex in her notebook). Masha wants to make exactly $$$k - 1$$$ operations in such way that the maximum number written in her notebook is as small as possible. NoteGraph described in the first and the second examples is illustrated below.  In the first example Masha can initially put a coin at vertex $$$1$$$. After that she can perform three operations: $$$1 \to 3$$$, $$$3 \to 4$$$ and $$$4 \to 5$$$. Integers $$$1, 2, 3$$$ and $$$4$$$ will be written in the notepad.In the second example Masha can initially put a coin at vertex $$$2$$$. After that she can perform $$$99$$$ operations: $$$2 \to 5$$$, $$$5 \to 6$$$, $$$6 \to 2$$$, $$$2 \to 5$$$, and so on. Integers $$$10, 4, 5, 10, 4, 5, \ldots, 10, 4, 5, 10$$$ will be written in the notepad.In the third example Masha won't be able to perform $$$4$$$ operations. import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

from collections import defaultdict, deque

def memoize(function):
    cache = {}
    def decorated_function(*args):
        try:
            return cache[args]
        except KeyError:
            val = function(*args)
            cache[args] = val
            return val
    return decorated_function

@memoize
def can(limit, k):
    G = defaultdict(list)
 
    D = [0] * n

    vcount = 0
    for s, e in E:
        if A[s] <= limit and A[e] <= limit:
            G[s].append(e)
            D[e] += 1
            if D[e] == 1:
                vcount += 1
        else:
            break

    Q = deque()
    for i, a in As:
        if a <= limit:
            if D[i] == 0:
                Q.append((i, k - 1))
                vcount += 1
        else:
            break

    while Q:
        s, d = Q.popleft()
        if d == 0:
            return True

        vcount -= 1

        if s in G:
            for e in G[s]:
                D[e] -= 1
                if D[e] == 0:
                    Q.append((e, d - 1))


    return vcount >= 2
                    


n, m, k = map(int, input().split())
A = list(map(int, input().split()))

As = list(enumerate(A))
As.sort(lambda e: e[1])

E = []
for _ in range(m):
    s, e = map(int, input().split())
    E.append((s - 1, e - 1))
E.sort(lambda e: max(A[e[0]], A[e[1]]))


l, r = 0, n
while l + 1 < r:
    v = (l + r)//2
    if can(As[v][1], k):
        r = v
    else:
        l = v

if (can(As[l][1], k) if l < n else False):
    print(As[l][1])
elif (can(As[r][1], k) if r < n else False):
    print(As[r][1])
else:
    print(""-1"")
","['binary search', 'dfs and similar', 'dp', 'graphs']"
3790,"The Smart Beaver from ABBYY has once again surprised us! He has developed a new calculating device, which he called the ""Beaver's Calculator 1.0"". It is very peculiar and it is planned to be used in a variety of scientific problems.To test it, the Smart Beaver invited n scientists, numbered from 1 to n. The i-th scientist brought ki calculating problems for the device developed by the Smart Beaver from ABBYY. The problems of the i-th scientist are numbered from 1 to ki, and they must be calculated sequentially in the described order, since calculating each problem heavily depends on the results of calculating of the previous ones.Each problem of each of the n scientists is described by one integer ai, j, where i (1 ≤ i ≤ n) is the number of the scientist, j (1 ≤ j ≤ ki) is the number of the problem, and ai, j is the number of resource units the calculating device needs to solve this problem.The calculating device that is developed by the Smart Beaver is pretty unusual. It solves problems sequentially, one after another. After some problem is solved and before the next one is considered, the calculating device allocates or frees resources.The most expensive operation for the calculating device is freeing resources, which works much slower than allocating them. It is therefore desirable that each next problem for the calculating device requires no less resources than the previous one.You are given the information about the problems the scientists offered for the testing. You need to arrange these problems in such an order that the number of adjacent ""bad"" pairs of problems in this list is minimum possible. We will call two consecutive problems in this list a ""bad pair"" if the problem that is performed first requires more resources than the one that goes after it. Do not forget that the problems of the same scientist must be solved in a fixed order. NoteIn the first sample n = 2, k1 = 2, a1, 1 = 1, a1, 2 = 2, k2 = 2, a2, 1 = 3, a2, 2 = 4. We've got two scientists, each of them has two calculating problems. The problems of the first scientist require 1 and 2 resource units, the problems of the second one require 3 and 4 resource units. Let's list all possible variants of the calculating order (each problem is characterized only by the number of resource units it requires): (1, 2, 3, 4), (1, 3, 2, 4), (3, 1, 2, 4), (1, 3, 4, 2), (3, 4, 1, 2), (3, 1, 4, 2).Sequence of problems (1, 3, 2, 4) has one ""bad"" pair (3 and 2), (3, 1, 4, 2) has two ""bad"" pairs (3 and 1, 4 and 2), and (1, 2, 3, 4) has no ""bad"" pairs. import sys

n = int(sys.stdin.readline())

k1, a11, x1, y1, m1 = map(int, sys.stdin.readline().split())
k2, a21, x2, y2, m2 = map(int, sys.stdin.readline().split())

# generate
a1vec = [0]*k1
a2vec = [0]*k2

a1vec[0] = a11
a2vec[0] = a21

for i in range(1, k1):
  a1vec[i] = (a1vec[i-1]*x1 + y1)%m1

for i in range(1, k2):
  a2vec[i] = (a2vec[i-1]*x2 + y2)%m2

i1 = 0
i2 = 0

last = -1

numBreaks = 0

resultStr = """"

while i1 < len(a1vec) and i2 < len(a2vec):
  # if both are valid, increment the least
  curr1 = a1vec[i1]
  curr2 = a2vec[i2]

  if curr1 >= last and curr2 >= last:
    if curr1 > curr2:
      last = curr2
      i2 += 1
      resultStr += (str(curr2) + "" 2\n"")
    else:
      last = curr1
      i1 += 1
      resultStr += (str(curr1) + "" 1\n"")
  elif curr1 >= last:
    last = curr1
    i1 += 1
    resultStr += (str(curr1) + "" 1\n"")
  elif curr2 >= last:
    last = curr2
    i2 += 1
    resultStr += (str(curr2) + "" 2\n"")  
  else:
    numBreaks += 1
    if curr1 > curr2:
      last = curr2
      i2 += 1
      resultStr += (str(curr2) + "" 2\n"")
    else:
      last = curr1
      i1 += 1
      resultStr += (str(curr1) + "" 1\n"")

# CONTINUE TO THE END IF ONE IS DONE
while i1 < len(a1vec):
  curr1 = a1vec[i1]
  i1 += 1
  resultStr += (str(curr1) + "" 1\n"")
  if curr1 < last:
    numBreaks +=1
  last = curr1

while i2 < len(a2vec):
  curr2 = a2vec[i2]
  i2 += 1
  resultStr += (str(curr2) + "" 2\n"")
  if curr2 < last:
    numBreaks +=1
  last = curr2
  
  

    
print(numBreaks)
print(resultStr)


# one of them may still have some left

  ",['greedy']
1052,"Vasya, like many others, likes to participate in a variety of sweepstakes and lotteries. Now he collects wrappings from a famous chocolate bar ""Jupiter"". According to the sweepstake rules, each wrapping has an integer written on it — the number of points that the participant adds to his score as he buys the bar. After a participant earns a certain number of points, he can come to the prize distribution center and exchange the points for prizes. When somebody takes a prize, the prize's cost is simply subtracted from the number of his points.Vasya didn't only bought the bars, he also kept a record of how many points each wrapping cost. Also, he remembers that he always stucks to the greedy strategy — as soon as he could take at least one prize, he went to the prize distribution centre and exchanged the points for prizes. Moreover, if he could choose between multiple prizes, he chose the most expensive one. If after an exchange Vasya had enough points left to get at least one more prize, then he continued to exchange points.The sweepstake has the following prizes (the prizes are sorted by increasing of their cost):   a mug (costs a points),  a towel (costs b points),  a bag (costs c points),  a bicycle (costs d points),  a car (costs e points). Now Vasya wants to recollect what prizes he has received. You know sequence p1, p2, ..., pn, where pi is the number of points Vasya got for the i-th bar. The sequence of points is given in the chronological order. You also know numbers a, b, c, d, e. Your task is to find, how many prizes Vasya received, what prizes they are and how many points he's got left after all operations are completed. NoteIn the first sample Vasya gets 3 points after eating the first chocolate bar. Then he exchanges 2 points and gets a mug. Vasya wins a bag after eating the second chocolate bar. Then he wins a towel after eating the third chocolate bar. After all chocolate bars 3 - 2 + 10 - 10 + 4 - 4 = 1 points remains. n = int(raw_input())
pts = [int(i) for i in raw_input().split()]
goods = [int(i) for i in raw_input().split()]

left = 0
gets = [0]*5
for p in pts:
    left += p
    for i in xrange(4, -1, -1):
        gets[i] += left/goods[i]
        left %= goods[i]
print gets[0], gets[1], gets[2], gets[3], gets[4]
print left
",['implementation']
2899,"You are planning to buy an apartment in a $$$n$$$-floor building. The floors are numbered from $$$1$$$ to $$$n$$$ from the bottom to the top. At first for each floor you want to know the minimum total time to reach it from the first (the bottom) floor.Let:  $$$a_i$$$ for all $$$i$$$ from $$$1$$$ to $$$n-1$$$ be the time required to go from the $$$i$$$-th floor to the $$$(i+1)$$$-th one (and from the $$$(i+1)$$$-th to the $$$i$$$-th as well) using the stairs;  $$$b_i$$$ for all $$$i$$$ from $$$1$$$ to $$$n-1$$$ be the time required to go from the $$$i$$$-th floor to the $$$(i+1)$$$-th one (and from the $$$(i+1)$$$-th to the $$$i$$$-th as well) using the elevator, also there is a value $$$c$$$ — time overhead for elevator usage (you need to wait for it, the elevator doors are too slow!). In one move, you can go from the floor you are staying at $$$x$$$ to any floor $$$y$$$ ($$$x \ne y$$$) in two different ways:  If you are using the stairs, just sum up the corresponding values of $$$a_i$$$. Formally, it will take $$$\sum\limits_{i=min(x, y)}^{max(x, y) - 1} a_i$$$ time units.  If you are using the elevator, just sum up $$$c$$$ and the corresponding values of $$$b_i$$$. Formally, it will take $$$c + \sum\limits_{i=min(x, y)}^{max(x, y) - 1} b_i$$$ time units. You can perform as many moves as you want (possibly zero).So your task is for each $$$i$$$ to determine the minimum total time it takes to reach the $$$i$$$-th floor from the $$$1$$$-st (bottom) floor. nan n, c = [int(i) for i in input().split()]
b = [int(i) for i in input().split()]
a = [int(i) for i in input().split()]
dp = [[0,0] for i in range(n+1)]
dp[1][0] = 50000000
dp[1][1] = 0
for i in range(2, n+1):
    dp[i][0] = min(dp[i-1][0] + a[i-2], dp[i-1][1] + c  + a[i-2])
    dp[i][1] = min(dp[i-1][0] + b[i-2], dp[i-1][1] + b[i-2])
[print(min(dp[i]), end=' ') for i in range(1, n+1)]
print()


","['dp', 'shortest paths']"
3172,"You've got a list of program warning logs. Each record of a log stream is a string in this format:  ""2012-MM-DD HH:MM:SS:MESSAGE"" (without the quotes). String ""MESSAGE"" consists of spaces, uppercase and lowercase English letters and characters ""!"", ""."", "","", ""?"". String ""2012-MM-DD"" determines a correct date in the year of 2012. String ""HH:MM:SS"" determines a correct time in the 24 hour format.The described record of a log stream means that at a certain time the record has got some program warning (string ""MESSAGE"" contains the warning's description).Your task is to print the first moment of time, when the number of warnings for the last n seconds was not less than m. nan import sys,time,re
n,m=map(int,raw_input().split())
t=[]
i=j=0
for s in sys.stdin:
  t+=[time.mktime(map(int,re.split('[-: ]',s[:19]))+[0]*3)]
  while j<i and t[j]<=t[i]-n:j+=1
  i+=1
  if i-j>=m:
    print s[:19]
    exit()
print -1
","['binary search', 'brute force', 'implementation', 'strings']"
152,"  While performing complex market analysis William encountered the following problem:For a given array $$$a$$$ of size $$$n$$$ and a natural number $$$e$$$, calculate the number of pairs of natural numbers $$$(i, k)$$$ which satisfy the following conditions:   $$$1 \le i, k$$$  $$$i + e \cdot k \le n$$$.  Product $$$a_i \cdot a_{i + e} \cdot a_{i + 2 \cdot e} \cdot \ldots \cdot a_{i + k \cdot e} $$$ is a prime number. A prime number (or a prime) is a natural number greater than 1 that is not a product of two smaller natural numbers. NoteIn the first example test case two pairs satisfy the conditions:   $$$i = 2, k = 1$$$, for which the product is: $$$a_{2} \cdot a_{5} = 2$$$ which is a prime number.  $$$i = 3, k = 1$$$, for which the product is: $$$a_{3} \cdot a_{6} = 19$$$ which is a prime number. In the second example test case there are no pairs that satisfy the conditions.In the third example test case four pairs satisfy the conditions:   $$$i = 1, k = 1$$$, for which the product is: $$$a_{1} \cdot a_{4} = 2$$$ which is a prime number.  $$$i = 1, k = 2$$$, for which the product is: $$$a_{1} \cdot a_{4} \cdot a_{7} = 2$$$ which is a prime number.  $$$i = 3, k = 1$$$, for which the product is: $$$a_{3} \cdot a_{6} = 2$$$ which is a prime number.  $$$i = 6, k = 1$$$, for which the product is: $$$a_{6} \cdot a_{9} = 2$$$ which is a prime number. In the fourth example test case there are no pairs that satisfy the conditions.In the fifth example test case five pairs satisfy the conditions:   $$$i = 1, k = 1$$$, for which the product is: $$$a_{1} \cdot a_{2} = 2$$$ which is a prime number.  $$$i = 1, k = 2$$$, for which the product is: $$$a_{1} \cdot a_{2} \cdot a_{3} = 2$$$ which is a prime number.  $$$i = 1, k = 3$$$, for which the product is: $$$a_{1} \cdot a_{2} \cdot a_{3} \cdot a_{4} = 2$$$ which is a prime number.  $$$i = 2, k = 1$$$, for which the product is: $$$a_{2} \cdot a_{3} = 2$$$ which is a prime number.  $$$i = 2, k = 2$$$, for which the product is: $$$a_{2} \cdot a_{3} \cdot a_{4} = 2$$$ which is a prime number. In the sixth example test case there are no pairs that satisfy the conditions. # 16:34-
import sys
input = lambda: sys.stdin.readline().rstrip()

from functools import lru_cache
@lru_cache(maxsize=None)
def is_prime(a):
	if a==1:return False
	for i in range(2,int(a**0.5)+1):
		if a%i==0:
			return False
	return True

def cal(B):
	ans = 0
	for i,b in enumerate(B):
		if b==2:
			l,r = i,i
			for j in range(i-1,-1,-1):
				if B[j]==1:
					l=j
				else:
					break
			for j in range(i+1,len(B)):
				if B[j]==1:
					r=j
				else:
					break
			ans += (r-i)+(i-l)+(r-i)*(i-l)
	return ans

for _ in range(int(input())):
	N,E = map(int, input().split())
	A = list(map(int, input().split()))
	B = [[] for _ in range(E)]
	for i in range(E):
		for j in range(i,N,E):
			B[i].append(A[j])

	ans = 0
	for b in B:
		for i,d in enumerate(b):
			if d==1:continue
			if is_prime(d):
				b[i] = 2
			else:
				b[i] = 0
		ans += cal(b)
	print(ans)

","['binary search', 'dp', 'implementation', 'number theory', 'other', 'two pointers']"
